/*! For license information please see model-viewer.79105f7c.js.LICENSE.txt */
'use strict';
(self.webpackChunkweb3pass = self.webpackChunkweb3pass || []).push([
    [751],
    {
        17160: (t, e, n) => {
            n.r(e), n.d(e, { ModelViewerElement: () => Uy });
            const i =
                    'undefined' != typeof window &&
                    null != window.customElements &&
                    void 0 !== window.customElements.polyfillWrapFlushCallback,
                r = (t, e, n = null) => {
                    for (; e !== n; ) {
                        const n = e.nextSibling;
                        t.removeChild(e), (e = n);
                    }
                },
                s = `{{lit-${String(Math.random()).slice(2)}}}`,
                a = `\x3c!--${s}--\x3e`,
                o = new RegExp(`${s}|${a}`);
            class l {
                constructor(t, e) {
                    (this.parts = []), (this.element = e);
                    const n = [],
                        i = [],
                        r = document.createTreeWalker(e.content, 133, null, !1);
                    let a = 0,
                        l = -1,
                        h = 0;
                    const {
                        strings: p,
                        values: { length: m },
                    } = t;
                    for (; h < m; ) {
                        const t = r.nextNode();
                        if (null !== t) {
                            if ((l++, 1 === t.nodeType)) {
                                if (t.hasAttributes()) {
                                    const e = t.attributes,
                                        { length: n } = e;
                                    let i = 0;
                                    for (let t = 0; t < n; t++) c(e[t].name, '$lit$') && i++;
                                    for (; i-- > 0; ) {
                                        const e = p[h],
                                            n = d.exec(e)[2],
                                            i = n.toLowerCase() + '$lit$',
                                            r = t.getAttribute(i);
                                        t.removeAttribute(i);
                                        const s = r.split(o);
                                        this.parts.push({ type: 'attribute', index: l, name: n, strings: s }),
                                            (h += s.length - 1);
                                    }
                                }
                                'TEMPLATE' === t.tagName && (i.push(t), (r.currentNode = t.content));
                            } else if (3 === t.nodeType) {
                                const e = t.data;
                                if (e.indexOf(s) >= 0) {
                                    const i = t.parentNode,
                                        r = e.split(o),
                                        s = r.length - 1;
                                    for (let e = 0; e < s; e++) {
                                        let n,
                                            s = r[e];
                                        if ('' === s) n = u();
                                        else {
                                            const t = d.exec(s);
                                            null !== t &&
                                                c(t[2], '$lit$') &&
                                                (s =
                                                    s.slice(0, t.index) + t[1] + t[2].slice(0, -'$lit$'.length) + t[3]),
                                                (n = document.createTextNode(s));
                                        }
                                        i.insertBefore(n, t), this.parts.push({ type: 'node', index: ++l });
                                    }
                                    '' === r[s] ? (i.insertBefore(u(), t), n.push(t)) : (t.data = r[s]), (h += s);
                                }
                            } else if (8 === t.nodeType)
                                if (t.data === s) {
                                    const e = t.parentNode;
                                    (null !== t.previousSibling && l !== a) || (l++, e.insertBefore(u(), t)),
                                        (a = l),
                                        this.parts.push({ type: 'node', index: l }),
                                        null === t.nextSibling ? (t.data = '') : (n.push(t), l--),
                                        h++;
                                } else {
                                    let e = -1;
                                    for (; -1 !== (e = t.data.indexOf(s, e + 1)); )
                                        this.parts.push({ type: 'node', index: -1 }), h++;
                                }
                        } else r.currentNode = i.pop();
                    }
                    for (const t of n) t.parentNode.removeChild(t);
                }
            }
            const c = (t, e) => {
                    const n = t.length - e.length;
                    return n >= 0 && t.slice(n) === e;
                },
                h = (t) => -1 !== t.index,
                u = () => document.createComment(''),
                d =
                    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
            function p(t, e) {
                const {
                        element: { content: n },
                        parts: i,
                    } = t,
                    r = document.createTreeWalker(n, 133, null, !1);
                let s = f(i),
                    a = i[s],
                    o = -1,
                    l = 0;
                const c = [];
                let h = null;
                for (; r.nextNode(); ) {
                    o++;
                    const t = r.currentNode;
                    for (
                        t.previousSibling === h && (h = null),
                            e.has(t) && (c.push(t), null === h && (h = t)),
                            null !== h && l++;
                        void 0 !== a && a.index === o;

                    )
                        (a.index = null !== h ? -1 : a.index - l), (s = f(i, s)), (a = i[s]);
                }
                c.forEach((t) => t.parentNode.removeChild(t));
            }
            const m = (t) => {
                    let e = 11 === t.nodeType ? 0 : 1;
                    const n = document.createTreeWalker(t, 133, null, !1);
                    for (; n.nextNode(); ) e++;
                    return e;
                },
                f = (t, e = -1) => {
                    for (let n = e + 1; n < t.length; n++) {
                        const e = t[n];
                        if (h(e)) return n;
                    }
                    return -1;
                },
                g = new WeakMap(),
                v = (t) => 'function' == typeof t && g.has(t),
                y = {},
                x = {};
            class b {
                constructor(t, e, n) {
                    (this.__parts = []), (this.template = t), (this.processor = e), (this.options = n);
                }
                update(t) {
                    let e = 0;
                    for (const n of this.__parts) void 0 !== n && n.setValue(t[e]), e++;
                    for (const t of this.__parts) void 0 !== t && t.commit();
                }
                _clone() {
                    const t = i
                            ? this.template.element.content.cloneNode(!0)
                            : document.importNode(this.template.element.content, !0),
                        e = [],
                        n = this.template.parts,
                        r = document.createTreeWalker(t, 133, null, !1);
                    let s,
                        a = 0,
                        o = 0,
                        l = r.nextNode();
                    for (; a < n.length; )
                        if (((s = n[a]), h(s))) {
                            for (; o < s.index; )
                                o++,
                                    'TEMPLATE' === l.nodeName && (e.push(l), (r.currentNode = l.content)),
                                    null === (l = r.nextNode()) && ((r.currentNode = e.pop()), (l = r.nextNode()));
                            if ('node' === s.type) {
                                const t = this.processor.handleTextExpression(this.options);
                                t.insertAfterNode(l.previousSibling), this.__parts.push(t);
                            } else
                                this.__parts.push(
                                    ...this.processor.handleAttributeExpressions(l, s.name, s.strings, this.options),
                                );
                            a++;
                        } else this.__parts.push(void 0), a++;
                    return i && (document.adoptNode(t), customElements.upgrade(t)), t;
                }
            }
            const w = window.trustedTypes && trustedTypes.createPolicy('lit-html', { createHTML: (t) => t }),
                _ = ` ${s} `;
            class M {
                constructor(t, e, n, i) {
                    (this.strings = t), (this.values = e), (this.type = n), (this.processor = i);
                }
                getHTML() {
                    const t = this.strings.length - 1;
                    let e = '',
                        n = !1;
                    for (let i = 0; i < t; i++) {
                        const t = this.strings[i],
                            r = t.lastIndexOf('\x3c!--');
                        n = (r > -1 || n) && -1 === t.indexOf('--\x3e', r + 1);
                        const o = d.exec(t);
                        e += null === o ? t + (n ? _ : a) : t.substr(0, o.index) + o[1] + o[2] + '$lit$' + o[3] + s;
                    }
                    return (e += this.strings[t]), e;
                }
                getTemplateElement() {
                    const t = document.createElement('template');
                    let e = this.getHTML();
                    return void 0 !== w && (e = w.createHTML(e)), (t.innerHTML = e), t;
                }
            }
            const S = (t) => null === t || !('object' == typeof t || 'function' == typeof t),
                T = (t) => Array.isArray(t) || !(!t || !t[Symbol.iterator]);
            class E {
                constructor(t, e, n) {
                    (this.dirty = !0), (this.element = t), (this.name = e), (this.strings = n), (this.parts = []);
                    for (let t = 0; t < n.length - 1; t++) this.parts[t] = this._createPart();
                }
                _createPart() {
                    return new A(this);
                }
                _getValue() {
                    const t = this.strings,
                        e = t.length - 1,
                        n = this.parts;
                    if (1 === e && '' === t[0] && '' === t[1]) {
                        const t = n[0].value;
                        if ('symbol' == typeof t) return String(t);
                        if ('string' == typeof t || !T(t)) return t;
                    }
                    let i = '';
                    for (let r = 0; r < e; r++) {
                        i += t[r];
                        const e = n[r];
                        if (void 0 !== e) {
                            const t = e.value;
                            if (S(t) || !T(t)) i += 'string' == typeof t ? t : String(t);
                            else for (const e of t) i += 'string' == typeof e ? e : String(e);
                        }
                    }
                    return (i += t[e]), i;
                }
                commit() {
                    this.dirty && ((this.dirty = !1), this.element.setAttribute(this.name, this._getValue()));
                }
            }
            class A {
                constructor(t) {
                    (this.value = void 0), (this.committer = t);
                }
                setValue(t) {
                    t === y || (S(t) && t === this.value) || ((this.value = t), v(t) || (this.committer.dirty = !0));
                }
                commit() {
                    for (; v(this.value); ) {
                        const t = this.value;
                        (this.value = y), t(this);
                    }
                    this.value !== y && this.committer.commit();
                }
            }
            class L {
                constructor(t) {
                    (this.value = void 0), (this.__pendingValue = void 0), (this.options = t);
                }
                appendInto(t) {
                    (this.startNode = t.appendChild(u())), (this.endNode = t.appendChild(u()));
                }
                insertAfterNode(t) {
                    (this.startNode = t), (this.endNode = t.nextSibling);
                }
                appendIntoPart(t) {
                    t.__insert((this.startNode = u())), t.__insert((this.endNode = u()));
                }
                insertAfterPart(t) {
                    t.__insert((this.startNode = u())), (this.endNode = t.endNode), (t.endNode = this.startNode);
                }
                setValue(t) {
                    this.__pendingValue = t;
                }
                commit() {
                    if (null === this.startNode.parentNode) return;
                    for (; v(this.__pendingValue); ) {
                        const t = this.__pendingValue;
                        (this.__pendingValue = y), t(this);
                    }
                    const t = this.__pendingValue;
                    t !== y &&
                        (S(t)
                            ? t !== this.value && this.__commitText(t)
                            : t instanceof M
                            ? this.__commitTemplateResult(t)
                            : t instanceof Node
                            ? this.__commitNode(t)
                            : T(t)
                            ? this.__commitIterable(t)
                            : t === x
                            ? ((this.value = x), this.clear())
                            : this.__commitText(t));
                }
                __insert(t) {
                    this.endNode.parentNode.insertBefore(t, this.endNode);
                }
                __commitNode(t) {
                    this.value !== t && (this.clear(), this.__insert(t), (this.value = t));
                }
                __commitText(t) {
                    const e = this.startNode.nextSibling,
                        n = 'string' == typeof (t = null == t ? '' : t) ? t : String(t);
                    e === this.endNode.previousSibling && 3 === e.nodeType
                        ? (e.data = n)
                        : this.__commitNode(document.createTextNode(n)),
                        (this.value = t);
                }
                __commitTemplateResult(t) {
                    const e = this.options.templateFactory(t);
                    if (this.value instanceof b && this.value.template === e) this.value.update(t.values);
                    else {
                        const n = new b(e, t.processor, this.options),
                            i = n._clone();
                        n.update(t.values), this.__commitNode(i), (this.value = n);
                    }
                }
                __commitIterable(t) {
                    Array.isArray(this.value) || ((this.value = []), this.clear());
                    const e = this.value;
                    let n,
                        i = 0;
                    for (const r of t)
                        (n = e[i]),
                            void 0 === n &&
                                ((n = new L(this.options)),
                                e.push(n),
                                0 === i ? n.appendIntoPart(this) : n.insertAfterPart(e[i - 1])),
                            n.setValue(r),
                            n.commit(),
                            i++;
                    i < e.length && ((e.length = i), this.clear(n && n.endNode));
                }
                clear(t = this.startNode) {
                    r(this.startNode.parentNode, t.nextSibling, this.endNode);
                }
            }
            class R {
                constructor(t, e, n) {
                    if (
                        ((this.value = void 0),
                        (this.__pendingValue = void 0),
                        2 !== n.length || '' !== n[0] || '' !== n[1])
                    )
                        throw new Error('Boolean attributes can only contain a single expression');
                    (this.element = t), (this.name = e), (this.strings = n);
                }
                setValue(t) {
                    this.__pendingValue = t;
                }
                commit() {
                    for (; v(this.__pendingValue); ) {
                        const t = this.__pendingValue;
                        (this.__pendingValue = y), t(this);
                    }
                    if (this.__pendingValue === y) return;
                    const t = !!this.__pendingValue;
                    this.value !== t &&
                        (t ? this.element.setAttribute(this.name, '') : this.element.removeAttribute(this.name),
                        (this.value = t)),
                        (this.__pendingValue = y);
                }
            }
            class C extends E {
                constructor(t, e, n) {
                    super(t, e, n), (this.single = 2 === n.length && '' === n[0] && '' === n[1]);
                }
                _createPart() {
                    return new P(this);
                }
                _getValue() {
                    return this.single ? this.parts[0].value : super._getValue();
                }
                commit() {
                    this.dirty && ((this.dirty = !1), (this.element[this.name] = this._getValue()));
                }
            }
            class P extends A {}
            let I = !1;
            (() => {
                try {
                    const t = {
                        get capture() {
                            return (I = !0), !1;
                        },
                    };
                    window.addEventListener('test', t, t), window.removeEventListener('test', t, t);
                } catch (t) {}
            })();
            class D {
                constructor(t, e, n) {
                    (this.value = void 0),
                        (this.__pendingValue = void 0),
                        (this.element = t),
                        (this.eventName = e),
                        (this.eventContext = n),
                        (this.__boundHandleEvent = (t) => this.handleEvent(t));
                }
                setValue(t) {
                    this.__pendingValue = t;
                }
                commit() {
                    for (; v(this.__pendingValue); ) {
                        const t = this.__pendingValue;
                        (this.__pendingValue = y), t(this);
                    }
                    if (this.__pendingValue === y) return;
                    const t = this.__pendingValue,
                        e = this.value,
                        n =
                            null == t ||
                            (null != e && (t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive)),
                        i = null != t && (null == e || n);
                    n && this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options),
                        i &&
                            ((this.__options = N(t)),
                            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options)),
                        (this.value = t),
                        (this.__pendingValue = y);
                }
                handleEvent(t) {
                    'function' == typeof this.value
                        ? this.value.call(this.eventContext || this.element, t)
                        : this.value.handleEvent(t);
                }
            }
            const N = (t) => t && (I ? { capture: t.capture, passive: t.passive, once: t.once } : t.capture);
            function F(t) {
                let e = O.get(t.type);
                void 0 === e && ((e = { stringsArray: new WeakMap(), keyString: new Map() }), O.set(t.type, e));
                let n = e.stringsArray.get(t.strings);
                if (void 0 !== n) return n;
                const i = t.strings.join(s);
                return (
                    (n = e.keyString.get(i)),
                    void 0 === n && ((n = new l(t, t.getTemplateElement())), e.keyString.set(i, n)),
                    e.stringsArray.set(t.strings, n),
                    n
                );
            }
            const O = new Map(),
                U = new WeakMap(),
                k = (t, e, n) => {
                    let i = U.get(e);
                    void 0 === i &&
                        (r(e, e.firstChild),
                        U.set(e, (i = new L(Object.assign({ templateFactory: F }, n)))),
                        i.appendInto(e)),
                        i.setValue(t),
                        i.commit();
                },
                z = new (class {
                    handleAttributeExpressions(t, e, n, i) {
                        const r = e[0];
                        return '.' === r
                            ? new C(t, e.slice(1), n).parts
                            : '@' === r
                            ? [new D(t, e.slice(1), i.eventContext)]
                            : '?' === r
                            ? [new R(t, e.slice(1), n)]
                            : new E(t, e, n).parts;
                    }
                    handleTextExpression(t) {
                        return new L(t);
                    }
                })();
            'undefined' != typeof window && (window.litHtmlVersions || (window.litHtmlVersions = [])).push('1.4.1');
            const B = (t, ...e) => new M(t, e, 'html', z),
                H = (t, e) => `${t}--${e}`;
            let G = !0;
            void 0 === window.ShadyCSS
                ? (G = !1)
                : void 0 === window.ShadyCSS.prepareTemplateDom &&
                  (console.warn(
                      'Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.',
                  ),
                  (G = !1));
            const V = (t) => (e) => {
                    const n = H(e.type, t);
                    let i = O.get(n);
                    void 0 === i && ((i = { stringsArray: new WeakMap(), keyString: new Map() }), O.set(n, i));
                    let r = i.stringsArray.get(e.strings);
                    if (void 0 !== r) return r;
                    const a = e.strings.join(s);
                    if (((r = i.keyString.get(a)), void 0 === r)) {
                        const n = e.getTemplateElement();
                        G && window.ShadyCSS.prepareTemplateDom(n, t), (r = new l(e, n)), i.keyString.set(a, r);
                    }
                    return i.stringsArray.set(e.strings, r), r;
                },
                W = ['html', 'svg'],
                j = new Set();
            window.JSCompiler_renameProperty = (t, e) => t;
            const q = {
                    toAttribute(t, e) {
                        switch (e) {
                            case Boolean:
                                return t ? '' : null;
                            case Object:
                            case Array:
                                return null == t ? t : JSON.stringify(t);
                        }
                        return t;
                    },
                    fromAttribute(t, e) {
                        switch (e) {
                            case Boolean:
                                return null !== t;
                            case Number:
                                return null === t ? null : Number(t);
                            case Object:
                            case Array:
                                return JSON.parse(t);
                        }
                        return t;
                    },
                },
                X = (t, e) => e !== t && (e == e || t == t),
                Y = { attribute: !0, type: String, converter: q, reflect: !1, hasChanged: X };
            class Z extends HTMLElement {
                constructor() {
                    super(), this.initialize();
                }
                static get observedAttributes() {
                    this.finalize();
                    const t = [];
                    return (
                        this._classProperties.forEach((e, n) => {
                            const i = this._attributeNameForProperty(n, e);
                            void 0 !== i && (this._attributeToPropertyMap.set(i, n), t.push(i));
                        }),
                        t
                    );
                }
                static _ensureClassProperties() {
                    if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
                        this._classProperties = new Map();
                        const t = Object.getPrototypeOf(this)._classProperties;
                        void 0 !== t && t.forEach((t, e) => this._classProperties.set(e, t));
                    }
                }
                static createProperty(t, e = Y) {
                    if (
                        (this._ensureClassProperties(),
                        this._classProperties.set(t, e),
                        e.noAccessor || this.prototype.hasOwnProperty(t))
                    )
                        return;
                    const n = 'symbol' == typeof t ? Symbol() : `__${t}`,
                        i = this.getPropertyDescriptor(t, n, e);
                    void 0 !== i && Object.defineProperty(this.prototype, t, i);
                }
                static getPropertyDescriptor(t, e, n) {
                    return {
                        get() {
                            return this[e];
                        },
                        set(i) {
                            const r = this[t];
                            (this[e] = i), this.requestUpdateInternal(t, r, n);
                        },
                        configurable: !0,
                        enumerable: !0,
                    };
                }
                static getPropertyOptions(t) {
                    return (this._classProperties && this._classProperties.get(t)) || Y;
                }
                static finalize() {
                    const t = Object.getPrototypeOf(this);
                    if (
                        (t.hasOwnProperty('finalized') || t.finalize(),
                        (this.finalized = !0),
                        this._ensureClassProperties(),
                        (this._attributeToPropertyMap = new Map()),
                        this.hasOwnProperty(JSCompiler_renameProperty('properties', this)))
                    ) {
                        const t = this.properties,
                            e = [
                                ...Object.getOwnPropertyNames(t),
                                ...('function' == typeof Object.getOwnPropertySymbols
                                    ? Object.getOwnPropertySymbols(t)
                                    : []),
                            ];
                        for (const n of e) this.createProperty(n, t[n]);
                    }
                }
                static _attributeNameForProperty(t, e) {
                    const n = e.attribute;
                    return !1 === n
                        ? void 0
                        : 'string' == typeof n
                        ? n
                        : 'string' == typeof t
                        ? t.toLowerCase()
                        : void 0;
                }
                static _valueHasChanged(t, e, n = X) {
                    return n(t, e);
                }
                static _propertyValueFromAttribute(t, e) {
                    const n = e.type,
                        i = e.converter || q,
                        r = 'function' == typeof i ? i : i.fromAttribute;
                    return r ? r(t, n) : t;
                }
                static _propertyValueToAttribute(t, e) {
                    if (void 0 === e.reflect) return;
                    const n = e.type,
                        i = e.converter;
                    return ((i && i.toAttribute) || q.toAttribute)(t, n);
                }
                initialize() {
                    (this._updateState = 0),
                        (this._updatePromise = new Promise((t) => (this._enableUpdatingResolver = t))),
                        (this._changedProperties = new Map()),
                        this._saveInstanceProperties(),
                        this.requestUpdateInternal();
                }
                _saveInstanceProperties() {
                    this.constructor._classProperties.forEach((t, e) => {
                        if (this.hasOwnProperty(e)) {
                            const t = this[e];
                            delete this[e],
                                this._instanceProperties || (this._instanceProperties = new Map()),
                                this._instanceProperties.set(e, t);
                        }
                    });
                }
                _applyInstanceProperties() {
                    this._instanceProperties.forEach((t, e) => (this[e] = t)), (this._instanceProperties = void 0);
                }
                connectedCallback() {
                    this.enableUpdating();
                }
                enableUpdating() {
                    void 0 !== this._enableUpdatingResolver &&
                        (this._enableUpdatingResolver(), (this._enableUpdatingResolver = void 0));
                }
                disconnectedCallback() {}
                attributeChangedCallback(t, e, n) {
                    e !== n && this._attributeToProperty(t, n);
                }
                _propertyToAttribute(t, e, n = Y) {
                    const i = this.constructor,
                        r = i._attributeNameForProperty(t, n);
                    if (void 0 !== r) {
                        const t = i._propertyValueToAttribute(e, n);
                        if (void 0 === t) return;
                        (this._updateState = 8 | this._updateState),
                            null == t ? this.removeAttribute(r) : this.setAttribute(r, t),
                            (this._updateState = -9 & this._updateState);
                    }
                }
                _attributeToProperty(t, e) {
                    if (8 & this._updateState) return;
                    const n = this.constructor,
                        i = n._attributeToPropertyMap.get(t);
                    if (void 0 !== i) {
                        const t = n.getPropertyOptions(i);
                        (this._updateState = 16 | this._updateState),
                            (this[i] = n._propertyValueFromAttribute(e, t)),
                            (this._updateState = -17 & this._updateState);
                    }
                }
                requestUpdateInternal(t, e, n) {
                    let i = !0;
                    if (void 0 !== t) {
                        const r = this.constructor;
                        (n = n || r.getPropertyOptions(t)),
                            r._valueHasChanged(this[t], e, n.hasChanged)
                                ? (this._changedProperties.has(t) || this._changedProperties.set(t, e),
                                  !0 !== n.reflect ||
                                      16 & this._updateState ||
                                      (void 0 === this._reflectingProperties &&
                                          (this._reflectingProperties = new Map()),
                                      this._reflectingProperties.set(t, n)))
                                : (i = !1);
                    }
                    !this._hasRequestedUpdate && i && (this._updatePromise = this._enqueueUpdate());
                }
                requestUpdate(t, e) {
                    return this.requestUpdateInternal(t, e), this.updateComplete;
                }
                async _enqueueUpdate() {
                    this._updateState = 4 | this._updateState;
                    try {
                        await this._updatePromise;
                    } catch (t) {}
                    const t = this.performUpdate();
                    return null != t && (await t), !this._hasRequestedUpdate;
                }
                get _hasRequestedUpdate() {
                    return 4 & this._updateState;
                }
                get hasUpdated() {
                    return 1 & this._updateState;
                }
                performUpdate() {
                    if (!this._hasRequestedUpdate) return;
                    this._instanceProperties && this._applyInstanceProperties();
                    let t = !1;
                    const e = this._changedProperties;
                    try {
                        (t = this.shouldUpdate(e)), t ? this.update(e) : this._markUpdated();
                    } catch (e) {
                        throw ((t = !1), this._markUpdated(), e);
                    }
                    t &&
                        (1 & this._updateState || ((this._updateState = 1 | this._updateState), this.firstUpdated(e)),
                        this.updated(e));
                }
                _markUpdated() {
                    (this._changedProperties = new Map()), (this._updateState = -5 & this._updateState);
                }
                get updateComplete() {
                    return this._getUpdateComplete();
                }
                _getUpdateComplete() {
                    return this.getUpdateComplete();
                }
                getUpdateComplete() {
                    return this._updatePromise;
                }
                shouldUpdate(t) {
                    return !0;
                }
                update(t) {
                    void 0 !== this._reflectingProperties &&
                        this._reflectingProperties.size > 0 &&
                        (this._reflectingProperties.forEach((t, e) => this._propertyToAttribute(e, this[e], t)),
                        (this._reflectingProperties = void 0)),
                        this._markUpdated();
                }
                updated(t) {}
                firstUpdated(t) {}
            }
            Z.finalized = !0;
            const J = (t, e) =>
                'method' === e.kind && e.descriptor && !('value' in e.descriptor)
                    ? Object.assign(Object.assign({}, e), {
                          finisher(n) {
                              n.createProperty(e.key, t);
                          },
                      })
                    : {
                          kind: 'field',
                          key: Symbol(),
                          placement: 'own',
                          descriptor: {},
                          initializer() {
                              'function' == typeof e.initializer && (this[e.key] = e.initializer.call(this));
                          },
                          finisher(n) {
                              n.createProperty(e.key, t);
                          },
                      };
            function $(t) {
                return (e, n) =>
                    void 0 !== n
                        ? ((t, e, n) => {
                              e.constructor.createProperty(n, t);
                          })(t, e, n)
                        : J(t, e);
            }
            const K =
                    window.ShadowRoot &&
                    (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) &&
                    'adoptedStyleSheets' in Document.prototype &&
                    'replace' in CSSStyleSheet.prototype,
                Q = Symbol();
            class tt {
                constructor(t, e) {
                    if (e !== Q) throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
                    this.cssText = t;
                }
                get styleSheet() {
                    return (
                        void 0 === this._styleSheet &&
                            (K
                                ? ((this._styleSheet = new CSSStyleSheet()), this._styleSheet.replaceSync(this.cssText))
                                : (this._styleSheet = null)),
                        this._styleSheet
                    );
                }
                toString() {
                    return this.cssText;
                }
            }
            (window.litElementVersions || (window.litElementVersions = [])).push('2.5.1');
            const et = {};
            class nt extends Z {
                static getStyles() {
                    return this.styles;
                }
                static _getUniqueStyles() {
                    if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) return;
                    const t = this.getStyles();
                    if (Array.isArray(t)) {
                        const e = (t, n) => t.reduceRight((t, n) => (Array.isArray(n) ? e(n, t) : (t.add(n), t)), n),
                            n = e(t, new Set()),
                            i = [];
                        n.forEach((t) => i.unshift(t)), (this._styles = i);
                    } else this._styles = void 0 === t ? [] : [t];
                    this._styles = this._styles.map((t) => {
                        if (t instanceof CSSStyleSheet && !K) {
                            const e = Array.prototype.slice.call(t.cssRules).reduce((t, e) => t + e.cssText, '');
                            return new tt(String(e), Q);
                        }
                        return t;
                    });
                }
                initialize() {
                    super.initialize(),
                        this.constructor._getUniqueStyles(),
                        (this.renderRoot = this.createRenderRoot()),
                        window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles();
                }
                createRenderRoot() {
                    return this.attachShadow(this.constructor.shadowRootOptions);
                }
                adoptStyles() {
                    const t = this.constructor._styles;
                    0 !== t.length &&
                        (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow
                            ? K
                                ? (this.renderRoot.adoptedStyleSheets = t.map((t) =>
                                      t instanceof CSSStyleSheet ? t : t.styleSheet,
                                  ))
                                : (this._needsShimAdoptedStyleSheets = !0)
                            : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(
                                  t.map((t) => t.cssText),
                                  this.localName,
                              ));
                }
                connectedCallback() {
                    super.connectedCallback(),
                        this.hasUpdated && void 0 !== window.ShadyCSS && window.ShadyCSS.styleElement(this);
                }
                update(t) {
                    const e = this.render();
                    super.update(t),
                        e !== et &&
                            this.constructor.render(e, this.renderRoot, {
                                scopeName: this.localName,
                                eventContext: this,
                            }),
                        this._needsShimAdoptedStyleSheets &&
                            ((this._needsShimAdoptedStyleSheets = !1),
                            this.constructor._styles.forEach((t) => {
                                const e = document.createElement('style');
                                (e.textContent = t.cssText), this.renderRoot.appendChild(e);
                            }));
                }
                render() {
                    return et;
                }
            }
            (nt.finalized = !0),
                (nt.render = (t, e, n) => {
                    if (!n || 'object' != typeof n || !n.scopeName)
                        throw new Error('The `scopeName` option is required.');
                    const i = n.scopeName,
                        s = U.has(e),
                        a = G && 11 === e.nodeType && !!e.host,
                        o = a && !j.has(i),
                        l = o ? document.createDocumentFragment() : e;
                    if ((k(t, l, Object.assign({ templateFactory: V(i) }, n)), o)) {
                        const t = U.get(l);
                        U.delete(l),
                            ((t, e, n) => {
                                j.add(t);
                                const i = n ? n.element : document.createElement('template'),
                                    r = e.querySelectorAll('style'),
                                    { length: s } = r;
                                if (0 === s) return void window.ShadyCSS.prepareTemplateStyles(i, t);
                                const a = document.createElement('style');
                                for (let t = 0; t < s; t++) {
                                    const e = r[t];
                                    e.parentNode.removeChild(e), (a.textContent += e.textContent);
                                }
                                ((t) => {
                                    W.forEach((e) => {
                                        const n = O.get(H(e, t));
                                        void 0 !== n &&
                                            n.keyString.forEach((t) => {
                                                const {
                                                        element: { content: e },
                                                    } = t,
                                                    n = new Set();
                                                Array.from(e.querySelectorAll('style')).forEach((t) => {
                                                    n.add(t);
                                                }),
                                                    p(t, n);
                                            });
                                    });
                                })(t);
                                const o = i.content;
                                n
                                    ? (function (t, e, n = null) {
                                          const {
                                              element: { content: i },
                                              parts: r,
                                          } = t;
                                          if (null == n) return void i.appendChild(e);
                                          const s = document.createTreeWalker(i, 133, null, !1);
                                          let a = f(r),
                                              o = 0,
                                              l = -1;
                                          for (; s.nextNode(); )
                                              for (
                                                  l++,
                                                      s.currentNode === n &&
                                                          ((o = m(e)), n.parentNode.insertBefore(e, n));
                                                  -1 !== a && r[a].index === l;

                                              ) {
                                                  if (o > 0) {
                                                      for (; -1 !== a; ) (r[a].index += o), (a = f(r, a));
                                                      return;
                                                  }
                                                  a = f(r, a);
                                              }
                                      })(n, a, o.firstChild)
                                    : o.insertBefore(a, o.firstChild),
                                    window.ShadyCSS.prepareTemplateStyles(i, t);
                                const l = o.querySelector('style');
                                if (window.ShadyCSS.nativeShadow && null !== l)
                                    e.insertBefore(l.cloneNode(!0), e.firstChild);
                                else if (n) {
                                    o.insertBefore(a, o.firstChild);
                                    const t = new Set();
                                    t.add(a), p(n, t);
                                }
                            })(i, l, t.value instanceof b ? t.value.template : void 0),
                            r(e, e.firstChild),
                            e.appendChild(l),
                            U.set(e, t);
                    }
                    !s && a && window.ShadyCSS.styleElement(e.host);
                }),
                (nt.shadowRootOptions = { mode: 'open' });
            const it = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported,
                rt = it && self.XRSession.prototype.requestHitTestSource,
                st = null != self.ResizeObserver,
                at = null != self.IntersectionObserver,
                ot = rt;
            (() => {
                const t = navigator.userAgent || navigator.vendor || self.opera;
                /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                    t,
                ) ||
                    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                        t.substr(0, 4),
                    );
            })(),
                /\bCrOS\b/.test(navigator.userAgent);
            const lt = /android/i.test(navigator.userAgent),
                ct =
                    (/iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream) ||
                    ('MacIntel' === navigator.platform && navigator.maxTouchPoints > 1),
                ht = (() => {
                    const t = document.createElement('a');
                    return Boolean(t.relList && t.relList.supports && t.relList.supports('ar'));
                })();
            /Safari\//.test(navigator.userAgent);
            const ut = /firefox/i.test(navigator.userAgent),
                dt = /OculusBrowser/.test(navigator.userAgent);
            ct && /CriOS\//.test(navigator.userAgent);
            const pt = lt && !ut && !dt,
                mt = B`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

/* NOTE: This ruleset is our integration surface area with the
 * :focus-visible polyfill.
 *
 * @see https://github.com/WICG/focus-visible/pull/196 */
:host([data-js-focus-visible]:focus:not(.focus-visible)),
:host([data-js-focus-visible]) :focus:not(.focus-visible) {
  outline: none;
}

.container {
  position: relative;
}

.userInput {
  width: 100%;
  height: 100%;
  display: block;
  position: relative;
  overflow: hidden;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

canvas.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  opacity: 0;
  transition: opacity 0.3s 0.3s;
  background-color: inherit;
}

.slot.poster.show {
  opacity: 1;
  transition: none;
}

.slot.poster.quick {
  transition: none;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: var(--poster-color, #fff);
  background-image: var(--poster-image, none);
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--progress-mask, #fff);
  transition: opacity 0.3s;
  opacity: 0.2;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  align-items: center;
  justify-content: center;

  opacity: 0;
  will-change: opacity;
  overflow: hidden;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.slot.interaction-prompt > .animated-container {
  will-change: transform, opacity;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 16px;
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="A depiction of a 3D model"
      aria-live="polite">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>
  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          aria-label="View this 3D model up close">
        ${B`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`}
      </a>
    </slot>
  </div>

  <div class="slot interaction-prompt">
    <div class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${B`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`}
      </slot>
    </div>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="mask" part="default-progress-mask"></div>
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>
    
    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${B`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`}
        </a>
      </slot>
    </div>
  </div>
</div>`;
            class ft {
                addEventListener(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
                }
                hasEventListener(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e);
                }
                removeEventListener(t, e) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners[t];
                    if (void 0 !== n) {
                        const t = n.indexOf(e);
                        -1 !== t && n.splice(t, 1);
                    }
                }
                dispatchEvent(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        const n = e.slice(0);
                        for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                        t.target = null;
                    }
                }
            }
            let gt = 1234567;
            const vt = Math.PI / 180,
                yt = 180 / Math.PI,
                xt = [];
            for (let t = 0; t < 256; t++) xt[t] = (t < 16 ? '0' : '') + t.toString(16);
            const bt = 'undefined' != typeof crypto && 'randomUUID' in crypto;
            function wt() {
                if (bt) return crypto.randomUUID().toUpperCase();
                const t = (4294967295 * Math.random()) | 0,
                    e = (4294967295 * Math.random()) | 0,
                    n = (4294967295 * Math.random()) | 0,
                    i = (4294967295 * Math.random()) | 0;
                return (
                    xt[255 & t] +
                    xt[(t >> 8) & 255] +
                    xt[(t >> 16) & 255] +
                    xt[(t >> 24) & 255] +
                    '-' +
                    xt[255 & e] +
                    xt[(e >> 8) & 255] +
                    '-' +
                    xt[((e >> 16) & 15) | 64] +
                    xt[(e >> 24) & 255] +
                    '-' +
                    xt[(63 & n) | 128] +
                    xt[(n >> 8) & 255] +
                    '-' +
                    xt[(n >> 16) & 255] +
                    xt[(n >> 24) & 255] +
                    xt[255 & i] +
                    xt[(i >> 8) & 255] +
                    xt[(i >> 16) & 255] +
                    xt[(i >> 24) & 255]
                ).toUpperCase();
            }
            function _t(t, e, n) {
                return Math.max(e, Math.min(n, t));
            }
            function Mt(t, e) {
                return ((t % e) + e) % e;
            }
            function St(t, e, n) {
                return (1 - n) * t + n * e;
            }
            function Tt(t) {
                return 0 == (t & (t - 1)) && 0 !== t;
            }
            function Et(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
            }
            function At(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
            }
            var Lt = Object.freeze({
                __proto__: null,
                DEG2RAD: vt,
                RAD2DEG: yt,
                generateUUID: wt,
                clamp: _t,
                euclideanModulo: Mt,
                mapLinear: function (t, e, n, i, r) {
                    return i + ((t - e) * (r - i)) / (n - e);
                },
                inverseLerp: function (t, e, n) {
                    return t !== e ? (n - t) / (e - t) : 0;
                },
                lerp: St,
                damp: function (t, e, n, i) {
                    return St(t, e, 1 - Math.exp(-n * i));
                },
                pingpong: function (t, e = 1) {
                    return e - Math.abs(Mt(t, 2 * e) - e);
                },
                smoothstep: function (t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
                },
                smootherstep: function (t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
                },
                randInt: function (t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1));
                },
                randFloat: function (t, e) {
                    return t + Math.random() * (e - t);
                },
                randFloatSpread: function (t) {
                    return t * (0.5 - Math.random());
                },
                seededRandom: function (t) {
                    return (
                        void 0 !== t && (gt = t % 2147483647), (gt = (16807 * gt) % 2147483647), (gt - 1) / 2147483646
                    );
                },
                degToRad: function (t) {
                    return t * vt;
                },
                radToDeg: function (t) {
                    return t * yt;
                },
                isPowerOfTwo: Tt,
                ceilPowerOfTwo: Et,
                floorPowerOfTwo: At,
                setQuaternionFromProperEuler: function (t, e, n, i, r) {
                    const s = Math.cos,
                        a = Math.sin,
                        o = s(n / 2),
                        l = a(n / 2),
                        c = s((e + i) / 2),
                        h = a((e + i) / 2),
                        u = s((e - i) / 2),
                        d = a((e - i) / 2),
                        p = s((i - e) / 2),
                        m = a((i - e) / 2);
                    switch (r) {
                        case 'XYX':
                            t.set(o * h, l * u, l * d, o * c);
                            break;
                        case 'YZY':
                            t.set(l * d, o * h, l * u, o * c);
                            break;
                        case 'ZXZ':
                            t.set(l * u, l * d, o * h, o * c);
                            break;
                        case 'XZX':
                            t.set(o * h, l * m, l * p, o * c);
                            break;
                        case 'YXY':
                            t.set(l * p, o * h, l * m, o * c);
                            break;
                        case 'ZYZ':
                            t.set(l * m, l * p, o * h, o * c);
                            break;
                        default:
                            console.warn(
                                'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + r,
                            );
                    }
                },
            });
            class Rt {
                constructor(t = 0, e = 0) {
                    (this.x = t), (this.y = e);
                }
                get width() {
                    return this.x;
                }
                set width(t) {
                    this.x = t;
                }
                get height() {
                    return this.y;
                }
                set height(t) {
                    this.y = t;
                }
                set(t, e) {
                    return (this.x = t), (this.y = e), this;
                }
                setScalar(t) {
                    return (this.x = t), (this.y = t), this;
                }
                setX(t) {
                    return (this.x = t), this;
                }
                setY(t) {
                    return (this.y = t), this;
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error('index is out of range: ' + t);
                    }
                    return this;
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error('index is out of range: ' + t);
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y);
                }
                copy(t) {
                    return (this.x = t.x), (this.y = t.y), this;
                }
                add(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                          ),
                          this.addVectors(t, e))
                        : ((this.x += t.x), (this.y += t.y), this);
                }
                addScalar(t) {
                    return (this.x += t), (this.y += t), this;
                }
                addVectors(t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
                }
                addScaledVector(t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), this;
                }
                sub(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                          ),
                          this.subVectors(t, e))
                        : ((this.x -= t.x), (this.y -= t.y), this);
                }
                subScalar(t) {
                    return (this.x -= t), (this.y -= t), this;
                }
                subVectors(t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
                }
                multiply(t) {
                    return (this.x *= t.x), (this.y *= t.y), this;
                }
                multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), this;
                }
                divide(t) {
                    return (this.x /= t.x), (this.y /= t.y), this;
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        i = t.elements;
                    return (this.x = i[0] * e + i[3] * n + i[6]), (this.y = i[1] * e + i[4] * n + i[7]), this;
                }
                min(t) {
                    return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this;
                }
                max(t) {
                    return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this;
                }
                clamp(t, e) {
                    return (
                        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                        this
                    );
                }
                clampScalar(t, e) {
                    return (
                        (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), this
                    );
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
                }
                floor() {
                    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
                }
                ceil() {
                    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
                }
                round() {
                    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
                }
                roundToZero() {
                    return (
                        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                        this
                    );
                }
                negate() {
                    return (this.x = -this.x), (this.y = -this.y), this;
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y;
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x;
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y);
                }
                normalize() {
                    return this.divideScalar(this.length() || 1);
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI;
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t));
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n;
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t);
                }
                lerp(t, e) {
                    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
                }
                lerpVectors(t, e, n) {
                    return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this;
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y;
                }
                fromArray(t, e = 0) {
                    return (this.x = t[e]), (this.y = t[e + 1]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.x), (t[e + 1] = this.y), t;
                }
                fromBufferAttribute(t, e, n) {
                    return (
                        void 0 !== n &&
                            console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().'),
                        (this.x = t.getX(e)),
                        (this.y = t.getY(e)),
                        this
                    );
                }
                rotateAround(t, e) {
                    const n = Math.cos(e),
                        i = Math.sin(e),
                        r = this.x - t.x,
                        s = this.y - t.y;
                    return (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this;
                }
                random() {
                    return (this.x = Math.random()), (this.y = Math.random()), this;
                }
                *[Symbol.iterator]() {
                    yield this.x, yield this.y;
                }
            }
            Rt.prototype.isVector2 = !0;
            class Ct {
                constructor() {
                    (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                        arguments.length > 0 &&
                            console.error(
                                'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',
                            );
                }
                set(t, e, n, i, r, s, a, o, l) {
                    const c = this.elements;
                    return (
                        (c[0] = t),
                        (c[1] = i),
                        (c[2] = a),
                        (c[3] = e),
                        (c[4] = r),
                        (c[5] = o),
                        (c[6] = n),
                        (c[7] = s),
                        (c[8] = l),
                        this
                    );
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return (
                        (e[0] = n[0]),
                        (e[1] = n[1]),
                        (e[2] = n[2]),
                        (e[3] = n[3]),
                        (e[4] = n[4]),
                        (e[5] = n[5]),
                        (e[6] = n[6]),
                        (e[7] = n[7]),
                        (e[8] = n[8]),
                        this
                    );
                }
                extractBasis(t, e, n) {
                    return (
                        t.setFromMatrix3Column(this, 0),
                        e.setFromMatrix3Column(this, 1),
                        n.setFromMatrix3Column(this, 2),
                        this
                    );
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t);
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this);
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        s = n[0],
                        a = n[3],
                        o = n[6],
                        l = n[1],
                        c = n[4],
                        h = n[7],
                        u = n[2],
                        d = n[5],
                        p = n[8],
                        m = i[0],
                        f = i[3],
                        g = i[6],
                        v = i[1],
                        y = i[4],
                        x = i[7],
                        b = i[2],
                        w = i[5],
                        _ = i[8];
                    return (
                        (r[0] = s * m + a * v + o * b),
                        (r[3] = s * f + a * y + o * w),
                        (r[6] = s * g + a * x + o * _),
                        (r[1] = l * m + c * v + h * b),
                        (r[4] = l * f + c * y + h * w),
                        (r[7] = l * g + c * x + h * _),
                        (r[2] = u * m + d * v + p * b),
                        (r[5] = u * f + d * y + p * w),
                        (r[8] = u * g + d * x + p * _),
                        this
                    );
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return (
                        (e[0] *= t),
                        (e[3] *= t),
                        (e[6] *= t),
                        (e[1] *= t),
                        (e[4] *= t),
                        (e[7] *= t),
                        (e[2] *= t),
                        (e[5] *= t),
                        (e[8] *= t),
                        this
                    );
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        c = t[8];
                    return e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o;
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        c = t[8],
                        h = c * s - a * l,
                        u = a * o - c * r,
                        d = l * r - s * o,
                        p = e * h + n * u + i * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const m = 1 / p;
                    return (
                        (t[0] = h * m),
                        (t[1] = (i * l - c * n) * m),
                        (t[2] = (a * n - i * s) * m),
                        (t[3] = u * m),
                        (t[4] = (c * e - i * o) * m),
                        (t[5] = (i * r - a * e) * m),
                        (t[6] = d * m),
                        (t[7] = (n * o - l * e) * m),
                        (t[8] = (s * e - n * r) * m),
                        this
                    );
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return (
                        (t = e[1]),
                        (e[1] = e[3]),
                        (e[3] = t),
                        (t = e[2]),
                        (e[2] = e[6]),
                        (e[6] = t),
                        (t = e[5]),
                        (e[5] = e[7]),
                        (e[7] = t),
                        this
                    );
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose();
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return (
                        (t[0] = e[0]),
                        (t[1] = e[3]),
                        (t[2] = e[6]),
                        (t[3] = e[1]),
                        (t[4] = e[4]),
                        (t[5] = e[7]),
                        (t[6] = e[2]),
                        (t[7] = e[5]),
                        (t[8] = e[8]),
                        this
                    );
                }
                setUvTransform(t, e, n, i, r, s, a) {
                    const o = Math.cos(r),
                        l = Math.sin(r);
                    return (
                        this.set(
                            n * o,
                            n * l,
                            -n * (o * s + l * a) + s + t,
                            -i * l,
                            i * o,
                            -i * (-l * s + o * a) + a + e,
                            0,
                            0,
                            1,
                        ),
                        this
                    );
                }
                scale(t, e) {
                    const n = this.elements;
                    return (n[0] *= t), (n[3] *= t), (n[6] *= t), (n[1] *= e), (n[4] *= e), (n[7] *= e), this;
                }
                rotate(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t),
                        i = this.elements,
                        r = i[0],
                        s = i[3],
                        a = i[6],
                        o = i[1],
                        l = i[4],
                        c = i[7];
                    return (
                        (i[0] = e * r + n * o),
                        (i[3] = e * s + n * l),
                        (i[6] = e * a + n * c),
                        (i[1] = -n * r + e * o),
                        (i[4] = -n * s + e * l),
                        (i[7] = -n * a + e * c),
                        this
                    );
                }
                translate(t, e) {
                    const n = this.elements;
                    return (
                        (n[0] += t * n[2]),
                        (n[3] += t * n[5]),
                        (n[6] += t * n[8]),
                        (n[1] += e * n[2]),
                        (n[4] += e * n[5]),
                        (n[7] += e * n[8]),
                        this
                    );
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
                    return !0;
                }
                fromArray(t, e = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this;
                }
                toArray(t = [], e = 0) {
                    const n = this.elements;
                    return (
                        (t[e] = n[0]),
                        (t[e + 1] = n[1]),
                        (t[e + 2] = n[2]),
                        (t[e + 3] = n[3]),
                        (t[e + 4] = n[4]),
                        (t[e + 5] = n[5]),
                        (t[e + 6] = n[6]),
                        (t[e + 7] = n[7]),
                        (t[e + 8] = n[8]),
                        t
                    );
                }
                clone() {
                    return new this.constructor().fromArray(this.elements);
                }
            }
            function Pt(t) {
                if (0 === t.length) return -1 / 0;
                let e = t[0];
                for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                return e;
            }
            function It(t) {
                return document.createElementNS('http://www.w3.org/1999/xhtml', t);
            }
            let Dt;
            Ct.prototype.isMatrix3 = !0;
            class Nt {
                static getDataURL(t) {
                    if (/^data:/i.test(t.src)) return t.src;
                    if ('undefined' == typeof HTMLCanvasElement) return t.src;
                    let e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                        void 0 === Dt && (Dt = It('canvas')), (Dt.width = t.width), (Dt.height = t.height);
                        const n = Dt.getContext('2d');
                        t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                            (e = Dt);
                    }
                    return e.width > 2048 || e.height > 2048
                        ? (console.warn(
                              'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
                              t,
                          ),
                          e.toDataURL('image/jpeg', 0.6))
                        : e.toDataURL('image/png');
                }
            }
            let Ft = 0;
            class Ot extends ft {
                constructor(
                    t = Ot.DEFAULT_IMAGE,
                    e = Ot.DEFAULT_MAPPING,
                    n = 1001,
                    i = 1001,
                    r = 1006,
                    s = 1008,
                    a = 1023,
                    o = 1009,
                    l = 1,
                    c = 3e3,
                ) {
                    super(),
                        Object.defineProperty(this, 'id', { value: Ft++ }),
                        (this.uuid = wt()),
                        (this.name = ''),
                        (this.image = t),
                        (this.mipmaps = []),
                        (this.mapping = e),
                        (this.wrapS = n),
                        (this.wrapT = i),
                        (this.magFilter = r),
                        (this.minFilter = s),
                        (this.anisotropy = l),
                        (this.format = a),
                        (this.internalFormat = null),
                        (this.type = o),
                        (this.offset = new Rt(0, 0)),
                        (this.repeat = new Rt(1, 1)),
                        (this.center = new Rt(0, 0)),
                        (this.rotation = 0),
                        (this.matrixAutoUpdate = !0),
                        (this.matrix = new Ct()),
                        (this.generateMipmaps = !0),
                        (this.premultiplyAlpha = !1),
                        (this.flipY = !0),
                        (this.unpackAlignment = 4),
                        (this.encoding = c),
                        (this.version = 0),
                        (this.onUpdate = null),
                        (this.isRenderTargetTexture = !1);
                }
                updateMatrix() {
                    this.matrix.setUvTransform(
                        this.offset.x,
                        this.offset.y,
                        this.repeat.x,
                        this.repeat.y,
                        this.rotation,
                        this.center.x,
                        this.center.y,
                    );
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return (
                        (this.name = t.name),
                        (this.image = t.image),
                        (this.mipmaps = t.mipmaps.slice(0)),
                        (this.mapping = t.mapping),
                        (this.wrapS = t.wrapS),
                        (this.wrapT = t.wrapT),
                        (this.magFilter = t.magFilter),
                        (this.minFilter = t.minFilter),
                        (this.anisotropy = t.anisotropy),
                        (this.format = t.format),
                        (this.internalFormat = t.internalFormat),
                        (this.type = t.type),
                        this.offset.copy(t.offset),
                        this.repeat.copy(t.repeat),
                        this.center.copy(t.center),
                        (this.rotation = t.rotation),
                        (this.matrixAutoUpdate = t.matrixAutoUpdate),
                        this.matrix.copy(t.matrix),
                        (this.generateMipmaps = t.generateMipmaps),
                        (this.premultiplyAlpha = t.premultiplyAlpha),
                        (this.flipY = t.flipY),
                        (this.unpackAlignment = t.unpackAlignment),
                        (this.encoding = t.encoding),
                        this
                    );
                }
                toJSON(t) {
                    const e = void 0 === t || 'string' == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    const n = {
                        metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment,
                    };
                    if (void 0 !== this.image) {
                        const i = this.image;
                        if ((void 0 === i.uuid && (i.uuid = wt()), !e && void 0 === t.images[i.uuid])) {
                            let e;
                            if (Array.isArray(i)) {
                                e = [];
                                for (let t = 0, n = i.length; t < n; t++)
                                    i[t].isDataTexture ? e.push(Ut(i[t].image)) : e.push(Ut(i[t]));
                            } else e = Ut(i);
                            t.images[i.uuid] = { uuid: i.uuid, url: e };
                        }
                        n.image = i.uuid;
                    }
                    return e || (t.textures[this.uuid] = n), n;
                }
                dispose() {
                    this.dispatchEvent({ type: 'dispose' });
                }
                transformUv(t) {
                    if (300 !== this.mapping) return t;
                    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                        switch (this.wrapS) {
                            case 1e3:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case 1001:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case 1002:
                                1 === Math.abs(Math.floor(t.x) % 2)
                                    ? (t.x = Math.ceil(t.x) - t.x)
                                    : (t.x = t.x - Math.floor(t.x));
                        }
                    if (t.y < 0 || t.y > 1)
                        switch (this.wrapT) {
                            case 1e3:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case 1001:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case 1002:
                                1 === Math.abs(Math.floor(t.y) % 2)
                                    ? (t.y = Math.ceil(t.y) - t.y)
                                    : (t.y = t.y - Math.floor(t.y));
                        }
                    return this.flipY && (t.y = 1 - t.y), t;
                }
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
            }
            function Ut(t) {
                return ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                    ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                    ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
                    ? Nt.getDataURL(t)
                    : t.data
                    ? {
                          data: Array.prototype.slice.call(t.data),
                          width: t.width,
                          height: t.height,
                          type: t.data.constructor.name,
                      }
                    : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
            }
            (Ot.DEFAULT_IMAGE = void 0), (Ot.DEFAULT_MAPPING = 300), (Ot.prototype.isTexture = !0);
            class kt {
                constructor(t = 0, e = 0, n = 0, i = 1) {
                    (this.x = t), (this.y = e), (this.z = n), (this.w = i);
                }
                get width() {
                    return this.z;
                }
                set width(t) {
                    this.z = t;
                }
                get height() {
                    return this.w;
                }
                set height(t) {
                    this.w = t;
                }
                set(t, e, n, i) {
                    return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
                }
                setScalar(t) {
                    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
                }
                setX(t) {
                    return (this.x = t), this;
                }
                setY(t) {
                    return (this.y = t), this;
                }
                setZ(t) {
                    return (this.z = t), this;
                }
                setW(t) {
                    return (this.w = t), this;
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error('index is out of range: ' + t);
                    }
                    return this;
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error('index is out of range: ' + t);
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w);
                }
                copy(t) {
                    return (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = void 0 !== t.w ? t.w : 1), this;
                }
                add(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                          ),
                          this.addVectors(t, e))
                        : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this);
                }
                addScalar(t) {
                    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
                }
                addVectors(t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this;
                }
                addScaledVector(t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this;
                }
                sub(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                          ),
                          this.subVectors(t, e))
                        : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this);
                }
                subScalar(t) {
                    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
                }
                subVectors(t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this;
                }
                multiply(t) {
                    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this;
                }
                multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        s = t.elements;
                    return (
                        (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
                        (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
                        (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
                        (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
                        this
                    );
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return (
                        e < 1e-4
                            ? ((this.x = 1), (this.y = 0), (this.z = 0))
                            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
                        this
                    );
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, n, i, r;
                    const s = 0.01,
                        a = 0.1,
                        o = t.elements,
                        l = o[0],
                        c = o[4],
                        h = o[8],
                        u = o[1],
                        d = o[5],
                        p = o[9],
                        m = o[2],
                        f = o[6],
                        g = o[10];
                    if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
                        if (
                            Math.abs(c + u) < a &&
                            Math.abs(h + m) < a &&
                            Math.abs(p + f) < a &&
                            Math.abs(l + d + g - 3) < a
                        )
                            return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (l + 1) / 2,
                            o = (d + 1) / 2,
                            v = (g + 1) / 2,
                            y = (c + u) / 4,
                            x = (h + m) / 4,
                            b = (p + f) / 4;
                        return (
                            t > o && t > v
                                ? t < s
                                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                                    : ((n = Math.sqrt(t)), (i = y / n), (r = x / n))
                                : o > v
                                ? o < s
                                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                                    : ((i = Math.sqrt(o)), (n = y / i), (r = b / i))
                                : v < s
                                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                                : ((r = Math.sqrt(v)), (n = x / r), (i = b / r)),
                            this.set(n, i, r, e),
                            this
                        );
                    }
                    let v = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
                    return (
                        Math.abs(v) < 0.001 && (v = 1),
                        (this.x = (f - p) / v),
                        (this.y = (h - m) / v),
                        (this.z = (u - c) / v),
                        (this.w = Math.acos((l + d + g - 1) / 2)),
                        this
                    );
                }
                min(t) {
                    return (
                        (this.x = Math.min(this.x, t.x)),
                        (this.y = Math.min(this.y, t.y)),
                        (this.z = Math.min(this.z, t.z)),
                        (this.w = Math.min(this.w, t.w)),
                        this
                    );
                }
                max(t) {
                    return (
                        (this.x = Math.max(this.x, t.x)),
                        (this.y = Math.max(this.y, t.y)),
                        (this.z = Math.max(this.z, t.z)),
                        (this.w = Math.max(this.w, t.w)),
                        this
                    );
                }
                clamp(t, e) {
                    return (
                        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                        (this.w = Math.max(t.w, Math.min(e.w, this.w))),
                        this
                    );
                }
                clampScalar(t, e) {
                    return (
                        (this.x = Math.max(t, Math.min(e, this.x))),
                        (this.y = Math.max(t, Math.min(e, this.y))),
                        (this.z = Math.max(t, Math.min(e, this.z))),
                        (this.w = Math.max(t, Math.min(e, this.w))),
                        this
                    );
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
                }
                floor() {
                    return (
                        (this.x = Math.floor(this.x)),
                        (this.y = Math.floor(this.y)),
                        (this.z = Math.floor(this.z)),
                        (this.w = Math.floor(this.w)),
                        this
                    );
                }
                ceil() {
                    return (
                        (this.x = Math.ceil(this.x)),
                        (this.y = Math.ceil(this.y)),
                        (this.z = Math.ceil(this.z)),
                        (this.w = Math.ceil(this.w)),
                        this
                    );
                }
                round() {
                    return (
                        (this.x = Math.round(this.x)),
                        (this.y = Math.round(this.y)),
                        (this.z = Math.round(this.z)),
                        (this.w = Math.round(this.w)),
                        this
                    );
                }
                roundToZero() {
                    return (
                        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
                        this
                    );
                }
                negate() {
                    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
                }
                normalize() {
                    return this.divideScalar(this.length() || 1);
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t);
                }
                lerp(t, e) {
                    return (
                        (this.x += (t.x - this.x) * e),
                        (this.y += (t.y - this.y) * e),
                        (this.z += (t.z - this.z) * e),
                        (this.w += (t.w - this.w) * e),
                        this
                    );
                }
                lerpVectors(t, e, n) {
                    return (
                        (this.x = t.x + (e.x - t.x) * n),
                        (this.y = t.y + (e.y - t.y) * n),
                        (this.z = t.z + (e.z - t.z) * n),
                        (this.w = t.w + (e.w - t.w) * n),
                        this
                    );
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
                }
                fromArray(t, e = 0) {
                    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t;
                }
                fromBufferAttribute(t, e, n) {
                    return (
                        void 0 !== n &&
                            console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().'),
                        (this.x = t.getX(e)),
                        (this.y = t.getY(e)),
                        (this.z = t.getZ(e)),
                        (this.w = t.getW(e)),
                        this
                    );
                }
                random() {
                    return (
                        (this.x = Math.random()),
                        (this.y = Math.random()),
                        (this.z = Math.random()),
                        (this.w = Math.random()),
                        this
                    );
                }
                *[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w;
                }
            }
            kt.prototype.isVector4 = !0;
            class zt extends ft {
                constructor(t, e, n = {}) {
                    super(),
                        (this.width = t),
                        (this.height = e),
                        (this.depth = 1),
                        (this.scissor = new kt(0, 0, t, e)),
                        (this.scissorTest = !1),
                        (this.viewport = new kt(0, 0, t, e)),
                        (this.texture = new Ot(
                            void 0,
                            n.mapping,
                            n.wrapS,
                            n.wrapT,
                            n.magFilter,
                            n.minFilter,
                            n.format,
                            n.type,
                            n.anisotropy,
                            n.encoding,
                        )),
                        (this.texture.isRenderTargetTexture = !0),
                        (this.texture.image = { width: t, height: e, depth: 1 }),
                        (this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps),
                        (this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null),
                        (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
                        (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
                        (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
                        (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
                }
                setTexture(t) {
                    (t.image = { width: this.width, height: this.height, depth: this.depth }), (this.texture = t);
                }
                setSize(t, e, n = 1) {
                    (this.width === t && this.height === e && this.depth === n) ||
                        ((this.width = t),
                        (this.height = e),
                        (this.depth = n),
                        (this.texture.image.width = t),
                        (this.texture.image.height = e),
                        (this.texture.image.depth = n),
                        this.dispose()),
                        this.viewport.set(0, 0, t, e),
                        this.scissor.set(0, 0, t, e);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return (
                        (this.width = t.width),
                        (this.height = t.height),
                        (this.depth = t.depth),
                        this.viewport.copy(t.viewport),
                        (this.texture = t.texture.clone()),
                        (this.texture.image = { ...this.texture.image }),
                        (this.depthBuffer = t.depthBuffer),
                        (this.stencilBuffer = t.stencilBuffer),
                        (this.depthTexture = t.depthTexture),
                        this
                    );
                }
                dispose() {
                    this.dispatchEvent({ type: 'dispose' });
                }
            }
            (zt.prototype.isWebGLRenderTarget = !0),
                (class extends zt {
                    constructor(t, e, n) {
                        super(t, e);
                        const i = this.texture;
                        this.texture = [];
                        for (let t = 0; t < n; t++) this.texture[t] = i.clone();
                    }
                    setSize(t, e, n = 1) {
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            (this.width = t), (this.height = e), (this.depth = n);
                            for (let i = 0, r = this.texture.length; i < r; i++)
                                (this.texture[i].image.width = t),
                                    (this.texture[i].image.height = e),
                                    (this.texture[i].image.depth = n);
                            this.dispose();
                        }
                        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this;
                    }
                    copy(t) {
                        this.dispose(),
                            (this.width = t.width),
                            (this.height = t.height),
                            (this.depth = t.depth),
                            this.viewport.set(0, 0, this.width, this.height),
                            this.scissor.set(0, 0, this.width, this.height),
                            (this.depthBuffer = t.depthBuffer),
                            (this.stencilBuffer = t.stencilBuffer),
                            (this.depthTexture = t.depthTexture),
                            (this.texture.length = 0);
                        for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                        return this;
                    }
                }.prototype.isWebGLMultipleRenderTargets = !0);
            class Bt extends zt {
                constructor(t, e, n) {
                    super(t, e, n), (this.samples = 4);
                }
                copy(t) {
                    return super.copy.call(this, t), (this.samples = t.samples), this;
                }
            }
            Bt.prototype.isWebGLMultisampleRenderTarget = !0;
            class Ht {
                constructor(t = 0, e = 0, n = 0, i = 1) {
                    (this._x = t), (this._y = e), (this._z = n), (this._w = i);
                }
                static slerp(t, e, n, i) {
                    return (
                        console.warn(
                            'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.',
                        ),
                        n.slerpQuaternions(t, e, i)
                    );
                }
                static slerpFlat(t, e, n, i, r, s, a) {
                    let o = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        h = n[i + 3];
                    const u = r[s + 0],
                        d = r[s + 1],
                        p = r[s + 2],
                        m = r[s + 3];
                    if (0 === a) return (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h);
                    if (1 === a) return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = m);
                    if (h !== m || o !== u || l !== d || c !== p) {
                        let t = 1 - a;
                        const e = o * u + l * d + c * p + h * m,
                            n = e >= 0 ? 1 : -1,
                            i = 1 - e * e;
                        if (i > Number.EPSILON) {
                            const r = Math.sqrt(i),
                                s = Math.atan2(r, e * n);
                            (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
                        }
                        const r = a * n;
                        if (
                            ((o = o * t + u * r),
                            (l = l * t + d * r),
                            (c = c * t + p * r),
                            (h = h * t + m * r),
                            t === 1 - a)
                        ) {
                            const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                            (o *= t), (l *= t), (c *= t), (h *= t);
                        }
                    }
                    (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
                }
                static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                    const a = n[i],
                        o = n[i + 1],
                        l = n[i + 2],
                        c = n[i + 3],
                        h = r[s],
                        u = r[s + 1],
                        d = r[s + 2],
                        p = r[s + 3];
                    return (
                        (t[e] = a * p + c * h + o * d - l * u),
                        (t[e + 1] = o * p + c * u + l * h - a * d),
                        (t[e + 2] = l * p + c * d + a * u - o * h),
                        (t[e + 3] = c * p - a * h - o * u - l * d),
                        t
                    );
                }
                get x() {
                    return this._x;
                }
                set x(t) {
                    (this._x = t), this._onChangeCallback();
                }
                get y() {
                    return this._y;
                }
                set y(t) {
                    (this._y = t), this._onChangeCallback();
                }
                get z() {
                    return this._z;
                }
                set z(t) {
                    (this._z = t), this._onChangeCallback();
                }
                get w() {
                    return this._w;
                }
                set w(t) {
                    (this._w = t), this._onChangeCallback();
                }
                set(t, e, n, i) {
                    return (this._x = t), (this._y = e), (this._z = n), (this._w = i), this._onChangeCallback(), this;
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w);
                }
                copy(t) {
                    return (
                        (this._x = t.x),
                        (this._y = t.y),
                        (this._z = t.z),
                        (this._w = t.w),
                        this._onChangeCallback(),
                        this
                    );
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler)
                        throw new Error(
                            'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
                        );
                    const n = t._x,
                        i = t._y,
                        r = t._z,
                        s = t._order,
                        a = Math.cos,
                        o = Math.sin,
                        l = a(n / 2),
                        c = a(i / 2),
                        h = a(r / 2),
                        u = o(n / 2),
                        d = o(i / 2),
                        p = o(r / 2);
                    switch (s) {
                        case 'XYZ':
                            (this._x = u * c * h + l * d * p),
                                (this._y = l * d * h - u * c * p),
                                (this._z = l * c * p + u * d * h),
                                (this._w = l * c * h - u * d * p);
                            break;
                        case 'YXZ':
                            (this._x = u * c * h + l * d * p),
                                (this._y = l * d * h - u * c * p),
                                (this._z = l * c * p - u * d * h),
                                (this._w = l * c * h + u * d * p);
                            break;
                        case 'ZXY':
                            (this._x = u * c * h - l * d * p),
                                (this._y = l * d * h + u * c * p),
                                (this._z = l * c * p + u * d * h),
                                (this._w = l * c * h - u * d * p);
                            break;
                        case 'ZYX':
                            (this._x = u * c * h - l * d * p),
                                (this._y = l * d * h + u * c * p),
                                (this._z = l * c * p - u * d * h),
                                (this._w = l * c * h + u * d * p);
                            break;
                        case 'YZX':
                            (this._x = u * c * h + l * d * p),
                                (this._y = l * d * h + u * c * p),
                                (this._z = l * c * p - u * d * h),
                                (this._w = l * c * h - u * d * p);
                            break;
                        case 'XZY':
                            (this._x = u * c * h - l * d * p),
                                (this._y = l * d * h - u * c * p),
                                (this._z = l * c * p + u * d * h),
                                (this._w = l * c * h + u * d * p);
                            break;
                        default:
                            console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + s);
                    }
                    return !1 !== e && this._onChangeCallback(), this;
                }
                setFromAxisAngle(t, e) {
                    const n = e / 2,
                        i = Math.sin(n);
                    return (
                        (this._x = t.x * i),
                        (this._y = t.y * i),
                        (this._z = t.z * i),
                        (this._w = Math.cos(n)),
                        this._onChangeCallback(),
                        this
                    );
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        n = e[0],
                        i = e[4],
                        r = e[8],
                        s = e[1],
                        a = e[5],
                        o = e[9],
                        l = e[2],
                        c = e[6],
                        h = e[10],
                        u = n + a + h;
                    if (u > 0) {
                        const t = 0.5 / Math.sqrt(u + 1);
                        (this._w = 0.25 / t), (this._x = (c - o) * t), (this._y = (r - l) * t), (this._z = (s - i) * t);
                    } else if (n > a && n > h) {
                        const t = 2 * Math.sqrt(1 + n - a - h);
                        (this._w = (c - o) / t), (this._x = 0.25 * t), (this._y = (i + s) / t), (this._z = (r + l) / t);
                    } else if (a > h) {
                        const t = 2 * Math.sqrt(1 + a - n - h);
                        (this._w = (r - l) / t), (this._x = (i + s) / t), (this._y = 0.25 * t), (this._z = (o + c) / t);
                    } else {
                        const t = 2 * Math.sqrt(1 + h - n - a);
                        (this._w = (s - i) / t), (this._x = (r + l) / t), (this._y = (o + c) / t), (this._z = 0.25 * t);
                    }
                    return this._onChangeCallback(), this;
                }
                setFromUnitVectors(t, e) {
                    let n = t.dot(e) + 1;
                    return (
                        n < Number.EPSILON
                            ? ((n = 0),
                              Math.abs(t.x) > Math.abs(t.z)
                                  ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
                                  : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
                            : ((this._x = t.y * e.z - t.z * e.y),
                              (this._y = t.z * e.x - t.x * e.z),
                              (this._z = t.x * e.y - t.y * e.x),
                              (this._w = n)),
                        this.normalize()
                    );
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(_t(this.dot(t), -1, 1)));
                }
                rotateTowards(t, e) {
                    const n = this.angleTo(t);
                    if (0 === n) return this;
                    const i = Math.min(1, e / n);
                    return this.slerp(t, i), this;
                }
                identity() {
                    return this.set(0, 0, 0, 1);
                }
                invert() {
                    return this.conjugate();
                }
                conjugate() {
                    return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
                }
                normalize() {
                    let t = this.length();
                    return (
                        0 === t
                            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                            : ((t = 1 / t),
                              (this._x = this._x * t),
                              (this._y = this._y * t),
                              (this._z = this._z * t),
                              (this._w = this._w * t)),
                        this._onChangeCallback(),
                        this
                    );
                }
                multiply(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',
                          ),
                          this.multiplyQuaternions(t, e))
                        : this.multiplyQuaternions(this, t);
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this);
                }
                multiplyQuaternions(t, e) {
                    const n = t._x,
                        i = t._y,
                        r = t._z,
                        s = t._w,
                        a = e._x,
                        o = e._y,
                        l = e._z,
                        c = e._w;
                    return (
                        (this._x = n * c + s * a + i * l - r * o),
                        (this._y = i * c + s * o + r * a - n * l),
                        (this._z = r * c + s * l + n * o - i * a),
                        (this._w = s * c - n * a - i * o - r * l),
                        this._onChangeCallback(),
                        this
                    );
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const n = this._x,
                        i = this._y,
                        r = this._z,
                        s = this._w;
                    let a = s * t._w + n * t._x + i * t._y + r * t._z;
                    if (
                        (a < 0
                            ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (a = -a))
                            : this.copy(t),
                        a >= 1)
                    )
                        return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
                    const o = 1 - a * a;
                    if (o <= Number.EPSILON) {
                        const t = 1 - e;
                        return (
                            (this._w = t * s + e * this._w),
                            (this._x = t * n + e * this._x),
                            (this._y = t * i + e * this._y),
                            (this._z = t * r + e * this._z),
                            this.normalize(),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    const l = Math.sqrt(o),
                        c = Math.atan2(l, a),
                        h = Math.sin((1 - e) * c) / l,
                        u = Math.sin(e * c) / l;
                    return (
                        (this._w = s * h + this._w * u),
                        (this._x = n * h + this._x * u),
                        (this._y = i * h + this._y * u),
                        (this._z = r * h + this._z * u),
                        this._onChangeCallback(),
                        this
                    );
                }
                slerpQuaternions(t, e, n) {
                    this.copy(t).slerp(e, n);
                }
                random() {
                    const t = Math.random(),
                        e = Math.sqrt(1 - t),
                        n = Math.sqrt(t),
                        i = 2 * Math.PI * Math.random(),
                        r = 2 * Math.PI * Math.random();
                    return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i));
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
                }
                fromArray(t, e = 0) {
                    return (
                        (this._x = t[e]),
                        (this._y = t[e + 1]),
                        (this._z = t[e + 2]),
                        (this._w = t[e + 3]),
                        this._onChangeCallback(),
                        this
                    );
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t;
                }
                fromBufferAttribute(t, e) {
                    return (
                        (this._x = t.getX(e)), (this._y = t.getY(e)), (this._z = t.getZ(e)), (this._w = t.getW(e)), this
                    );
                }
                _onChange(t) {
                    return (this._onChangeCallback = t), this;
                }
                _onChangeCallback() {}
            }
            Ht.prototype.isQuaternion = !0;
            class Gt {
                constructor(t = 0, e = 0, n = 0) {
                    (this.x = t), (this.y = e), (this.z = n);
                }
                set(t, e, n) {
                    return void 0 === n && (n = this.z), (this.x = t), (this.y = e), (this.z = n), this;
                }
                setScalar(t) {
                    return (this.x = t), (this.y = t), (this.z = t), this;
                }
                setX(t) {
                    return (this.x = t), this;
                }
                setY(t) {
                    return (this.y = t), this;
                }
                setZ(t) {
                    return (this.z = t), this;
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error('index is out of range: ' + t);
                    }
                    return this;
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error('index is out of range: ' + t);
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z);
                }
                copy(t) {
                    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
                }
                add(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                          ),
                          this.addVectors(t, e))
                        : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
                }
                addScalar(t) {
                    return (this.x += t), (this.y += t), (this.z += t), this;
                }
                addVectors(t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this;
                }
                addScaledVector(t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
                }
                sub(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                          ),
                          this.subVectors(t, e))
                        : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
                }
                subScalar(t) {
                    return (this.x -= t), (this.y -= t), (this.z -= t), this;
                }
                subVectors(t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this;
                }
                multiply(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',
                          ),
                          this.multiplyVectors(t, e))
                        : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
                }
                multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), (this.z *= t), this;
                }
                multiplyVectors(t, e) {
                    return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this;
                }
                applyEuler(t) {
                    return (
                        (t && t.isEuler) ||
                            console.error(
                                'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
                            ),
                        this.applyQuaternion(Wt.setFromEuler(t))
                    );
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(Wt.setFromAxisAngle(t, e));
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return (
                        (this.x = r[0] * e + r[3] * n + r[6] * i),
                        (this.y = r[1] * e + r[4] * n + r[7] * i),
                        (this.z = r[2] * e + r[5] * n + r[8] * i),
                        this
                    );
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize();
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements,
                        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                    return (
                        (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
                        (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
                        (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
                        this
                    );
                }
                applyQuaternion(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.x,
                        s = t.y,
                        a = t.z,
                        o = t.w,
                        l = o * e + s * i - a * n,
                        c = o * n + a * e - r * i,
                        h = o * i + r * n - s * e,
                        u = -r * e - s * n - a * i;
                    return (
                        (this.x = l * o + u * -r + c * -a - h * -s),
                        (this.y = c * o + u * -s + h * -r - l * -a),
                        (this.z = h * o + u * -a + l * -s - c * -r),
                        this
                    );
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
                }
                transformDirection(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return (
                        (this.x = r[0] * e + r[4] * n + r[8] * i),
                        (this.y = r[1] * e + r[5] * n + r[9] * i),
                        (this.z = r[2] * e + r[6] * n + r[10] * i),
                        this.normalize()
                    );
                }
                divide(t) {
                    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                }
                min(t) {
                    return (
                        (this.x = Math.min(this.x, t.x)),
                        (this.y = Math.min(this.y, t.y)),
                        (this.z = Math.min(this.z, t.z)),
                        this
                    );
                }
                max(t) {
                    return (
                        (this.x = Math.max(this.x, t.x)),
                        (this.y = Math.max(this.y, t.y)),
                        (this.z = Math.max(this.z, t.z)),
                        this
                    );
                }
                clamp(t, e) {
                    return (
                        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                        this
                    );
                }
                clampScalar(t, e) {
                    return (
                        (this.x = Math.max(t, Math.min(e, this.x))),
                        (this.y = Math.max(t, Math.min(e, this.y))),
                        (this.z = Math.max(t, Math.min(e, this.z))),
                        this
                    );
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
                }
                floor() {
                    return (
                        (this.x = Math.floor(this.x)),
                        (this.y = Math.floor(this.y)),
                        (this.z = Math.floor(this.z)),
                        this
                    );
                }
                ceil() {
                    return (
                        (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this
                    );
                }
                round() {
                    return (
                        (this.x = Math.round(this.x)),
                        (this.y = Math.round(this.y)),
                        (this.z = Math.round(this.z)),
                        this
                    );
                }
                roundToZero() {
                    return (
                        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                        this
                    );
                }
                negate() {
                    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z;
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                }
                normalize() {
                    return this.divideScalar(this.length() || 1);
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t);
                }
                lerp(t, e) {
                    return (
                        (this.x += (t.x - this.x) * e),
                        (this.y += (t.y - this.y) * e),
                        (this.z += (t.z - this.z) * e),
                        this
                    );
                }
                lerpVectors(t, e, n) {
                    return (
                        (this.x = t.x + (e.x - t.x) * n),
                        (this.y = t.y + (e.y - t.y) * n),
                        (this.z = t.z + (e.z - t.z) * n),
                        this
                    );
                }
                cross(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',
                          ),
                          this.crossVectors(t, e))
                        : this.crossVectors(this, t);
                }
                crossVectors(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = e.x,
                        a = e.y,
                        o = e.z;
                    return (this.x = i * o - r * a), (this.y = r * s - n * o), (this.z = n * a - i * s), this;
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const n = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(n);
                }
                projectOnPlane(t) {
                    return Vt.copy(this).projectOnVector(t), this.sub(Vt);
                }
                reflect(t) {
                    return this.sub(Vt.copy(t).multiplyScalar(2 * this.dot(t)));
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const n = this.dot(t) / e;
                    return Math.acos(_t(n, -1, 1));
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t));
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return e * e + n * n + i * i;
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
                }
                setFromSphericalCoords(t, e, n) {
                    const i = Math.sin(e) * t;
                    return (this.x = i * Math.sin(n)), (this.y = Math.cos(e) * t), (this.z = i * Math.cos(n)), this;
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
                }
                setFromCylindricalCoords(t, e, n) {
                    return (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this;
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        i = this.setFromMatrixColumn(t, 2).length();
                    return (this.x = e), (this.y = n), (this.z = i), this;
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e);
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e);
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z;
                }
                fromArray(t, e = 0) {
                    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
                }
                fromBufferAttribute(t, e, n) {
                    return (
                        void 0 !== n &&
                            console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().'),
                        (this.x = t.getX(e)),
                        (this.y = t.getY(e)),
                        (this.z = t.getZ(e)),
                        this
                    );
                }
                random() {
                    return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
                }
                randomDirection() {
                    const t = 2 * (Math.random() - 0.5),
                        e = Math.random() * Math.PI * 2,
                        n = Math.sqrt(1 - t ** 2);
                    return (this.x = n * Math.cos(e)), (this.y = n * Math.sin(e)), (this.z = t), this;
                }
                *[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z;
                }
            }
            Gt.prototype.isVector3 = !0;
            const Vt = new Gt(),
                Wt = new Ht();
            class jt {
                constructor(t = new Gt(1 / 0, 1 / 0, 1 / 0), e = new Gt(-1 / 0, -1 / 0, -1 / 0)) {
                    (this.min = t), (this.max = e);
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this;
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.length; o < l; o += 3) {
                        const l = t[o],
                            c = t[o + 1],
                            h = t[o + 2];
                        l < e && (e = l),
                            c < n && (n = c),
                            h < i && (i = h),
                            l > r && (r = l),
                            c > s && (s = c),
                            h > a && (a = h);
                    }
                    return this.min.set(e, n, i), this.max.set(r, s, a), this;
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.count; o < l; o++) {
                        const l = t.getX(o),
                            c = t.getY(o),
                            h = t.getZ(o);
                        l < e && (e = l),
                            c < n && (n = c),
                            h < i && (i = h),
                            l > r && (r = l),
                            c > s && (s = c),
                            h > a && (a = h);
                    }
                    return this.min.set(e, n, i), this.max.set(r, s, a), this;
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this;
                }
                setFromCenterAndSize(t, e) {
                    const n = Xt.copy(e).multiplyScalar(0.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
                }
                setFromObject(t) {
                    return this.makeEmpty(), this.expandByObject(t);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this;
                }
                makeEmpty() {
                    return (
                        (this.min.x = this.min.y = this.min.z = 1 / 0),
                        (this.max.x = this.max.y = this.max.z = -1 / 0),
                        this
                    );
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this;
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this;
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this;
                }
                expandByObject(t) {
                    t.updateWorldMatrix(!1, !1);
                    const e = t.geometry;
                    void 0 !== e &&
                        (null === e.boundingBox && e.computeBoundingBox(),
                        Yt.copy(e.boundingBox),
                        Yt.applyMatrix4(t.matrixWorld),
                        this.union(Yt));
                    const n = t.children;
                    for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                    return this;
                }
                containsPoint(t) {
                    return !(
                        t.x < this.min.x ||
                        t.x > this.max.x ||
                        t.y < this.min.y ||
                        t.y > this.max.y ||
                        t.z < this.min.z ||
                        t.z > this.max.z
                    );
                }
                containsBox(t) {
                    return (
                        this.min.x <= t.min.x &&
                        t.max.x <= this.max.x &&
                        this.min.y <= t.min.y &&
                        t.max.y <= this.max.y &&
                        this.min.z <= t.min.z &&
                        t.max.z <= this.max.z
                    );
                }
                getParameter(t, e) {
                    return e.set(
                        (t.x - this.min.x) / (this.max.x - this.min.x),
                        (t.y - this.min.y) / (this.max.y - this.min.y),
                        (t.z - this.min.z) / (this.max.z - this.min.z),
                    );
                }
                intersectsBox(t) {
                    return !(
                        t.max.x < this.min.x ||
                        t.min.x > this.max.x ||
                        t.max.y < this.min.y ||
                        t.min.y > this.max.y ||
                        t.max.z < this.min.z ||
                        t.min.z > this.max.z
                    );
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, Xt), Xt.distanceToSquared(t.center) <= t.radius * t.radius;
                }
                intersectsPlane(t) {
                    let e, n;
                    return (
                        t.normal.x > 0
                            ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                            : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
                        t.normal.y > 0
                            ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
                            : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
                        t.normal.z > 0
                            ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
                            : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
                        e <= -t.constant && n >= -t.constant
                    );
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(ee),
                        ne.subVectors(this.max, ee),
                        Zt.subVectors(t.a, ee),
                        Jt.subVectors(t.b, ee),
                        $t.subVectors(t.c, ee),
                        Kt.subVectors(Jt, Zt),
                        Qt.subVectors($t, Jt),
                        te.subVectors(Zt, $t);
                    let e = [
                        0,
                        -Kt.z,
                        Kt.y,
                        0,
                        -Qt.z,
                        Qt.y,
                        0,
                        -te.z,
                        te.y,
                        Kt.z,
                        0,
                        -Kt.x,
                        Qt.z,
                        0,
                        -Qt.x,
                        te.z,
                        0,
                        -te.x,
                        -Kt.y,
                        Kt.x,
                        0,
                        -Qt.y,
                        Qt.x,
                        0,
                        -te.y,
                        te.x,
                        0,
                    ];
                    return (
                        !!se(e, Zt, Jt, $t, ne) &&
                        ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                        !!se(e, Zt, Jt, $t, ne) &&
                            (ie.crossVectors(Kt, Qt), (e = [ie.x, ie.y, ie.z]), se(e, Zt, Jt, $t, ne)))
                    );
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max);
                }
                distanceToPoint(t) {
                    return Xt.copy(t).clamp(this.min, this.max).sub(t).length();
                }
                getBoundingSphere(t) {
                    return this.getCenter(t.center), (t.radius = 0.5 * this.getSize(Xt).length()), t;
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this;
                }
                applyMatrix4(t) {
                    return (
                        this.isEmpty() ||
                            (qt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                            qt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                            qt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                            qt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                            qt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                            qt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                            qt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                            qt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                            this.setFromPoints(qt)),
                        this
                    );
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this;
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max);
                }
            }
            jt.prototype.isBox3 = !0;
            const qt = [new Gt(), new Gt(), new Gt(), new Gt(), new Gt(), new Gt(), new Gt(), new Gt()],
                Xt = new Gt(),
                Yt = new jt(),
                Zt = new Gt(),
                Jt = new Gt(),
                $t = new Gt(),
                Kt = new Gt(),
                Qt = new Gt(),
                te = new Gt(),
                ee = new Gt(),
                ne = new Gt(),
                ie = new Gt(),
                re = new Gt();
            function se(t, e, n, i, r) {
                for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                    re.fromArray(t, s);
                    const a = r.x * Math.abs(re.x) + r.y * Math.abs(re.y) + r.z * Math.abs(re.z),
                        o = e.dot(re),
                        l = n.dot(re),
                        c = i.dot(re);
                    if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
                }
                return !0;
            }
            const ae = new jt(),
                oe = new Gt(),
                le = new Gt(),
                ce = new Gt();
            class he {
                constructor(t = new Gt(), e = -1) {
                    (this.center = t), (this.radius = e);
                }
                set(t, e) {
                    return this.center.copy(t), (this.radius = e), this;
                }
                setFromPoints(t, e) {
                    const n = this.center;
                    void 0 !== e ? n.copy(e) : ae.setFromPoints(t).getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                    return (this.radius = Math.sqrt(i)), this;
                }
                copy(t) {
                    return this.center.copy(t.center), (this.radius = t.radius), this;
                }
                isEmpty() {
                    return this.radius < 0;
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), (this.radius = -1), this;
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius;
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius;
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e;
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this);
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
                }
                clampPoint(t, e) {
                    const n = this.center.distanceToSquared(t);
                    return (
                        e.copy(t),
                        n > this.radius * this.radius &&
                            (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
                        e
                    );
                }
                getBoundingBox(t) {
                    return this.isEmpty()
                        ? (t.makeEmpty(), t)
                        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this;
                }
                translate(t) {
                    return this.center.add(t), this;
                }
                expandByPoint(t) {
                    ce.subVectors(t, this.center);
                    const e = ce.lengthSq();
                    if (e > this.radius * this.radius) {
                        const t = Math.sqrt(e),
                            n = 0.5 * (t - this.radius);
                        this.center.add(ce.multiplyScalar(n / t)), (this.radius += n);
                    }
                    return this;
                }
                union(t) {
                    return (
                        le.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
                        this.expandByPoint(oe.copy(t.center).add(le)),
                        this.expandByPoint(oe.copy(t.center).sub(le)),
                        this
                    );
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            const ue = new Gt(),
                de = new Gt(),
                pe = new Gt(),
                me = new Gt(),
                fe = new Gt(),
                ge = new Gt(),
                ve = new Gt();
            class ye {
                constructor(t = new Gt(), e = new Gt(0, 0, -1)) {
                    (this.origin = t), (this.direction = e);
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this;
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
                }
                at(t, e) {
                    return e.copy(this.direction).multiplyScalar(t).add(this.origin);
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this;
                }
                recast(t) {
                    return this.origin.copy(this.at(t, ue)), this;
                }
                closestPointToPoint(t, e) {
                    e.subVectors(t, this.origin);
                    const n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t));
                }
                distanceSqToPoint(t) {
                    const e = ue.subVectors(t, this.origin).dot(this.direction);
                    return e < 0
                        ? this.origin.distanceToSquared(t)
                        : (ue.copy(this.direction).multiplyScalar(e).add(this.origin), ue.distanceToSquared(t));
                }
                distanceSqToSegment(t, e, n, i) {
                    de.copy(t).add(e).multiplyScalar(0.5), pe.copy(e).sub(t).normalize(), me.copy(this.origin).sub(de);
                    const r = 0.5 * t.distanceTo(e),
                        s = -this.direction.dot(pe),
                        a = me.dot(this.direction),
                        o = -me.dot(pe),
                        l = me.lengthSq(),
                        c = Math.abs(1 - s * s);
                    let h, u, d, p;
                    if (c > 0)
                        if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
                            if (u >= -p)
                                if (u <= p) {
                                    const t = 1 / c;
                                    (h *= t), (u *= t), (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
                                } else (u = r), (h = Math.max(0, -(s * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                            else (u = -r), (h = Math.max(0, -(s * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                        else
                            u <= -p
                                ? ((h = Math.max(0, -(-s * r + a))),
                                  (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                                  (d = -h * h + u * (u + 2 * o) + l))
                                : u <= p
                                ? ((h = 0), (u = Math.min(Math.max(-r, -o), r)), (d = u * (u + 2 * o) + l))
                                : ((h = Math.max(0, -(s * r + a))),
                                  (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
                                  (d = -h * h + u * (u + 2 * o) + l));
                    else (u = s > 0 ? -r : r), (h = Math.max(0, -(s * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                    return (
                        n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
                        i && i.copy(pe).multiplyScalar(u).add(de),
                        d
                    );
                }
                intersectSphere(t, e) {
                    ue.subVectors(t.center, this.origin);
                    const n = ue.dot(this.direction),
                        i = ue.dot(ue) - n * n,
                        r = t.radius * t.radius;
                    if (i > r) return null;
                    const s = Math.sqrt(r - i),
                        a = n - s,
                        o = n + s;
                    return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null;
                }
                intersectPlane(t, e) {
                    const n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e);
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0;
                }
                intersectBox(t, e) {
                    let n, i, r, s, a, o;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return (
                        l >= 0
                            ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
                            : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
                        c >= 0
                            ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
                            : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
                        n > s || r > i
                            ? null
                            : ((r > n || n != n) && (n = r),
                              (s < i || i != i) && (i = s),
                              h >= 0
                                  ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
                                  : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
                              n > o || a > i
                                  ? null
                                  : ((a > n || n != n) && (n = a),
                                    (o < i || i != i) && (i = o),
                                    i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                    );
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, ue);
                }
                intersectTriangle(t, e, n, i, r) {
                    fe.subVectors(e, t), ge.subVectors(n, t), ve.crossVectors(fe, ge);
                    let s,
                        a = this.direction.dot(ve);
                    if (a > 0) {
                        if (i) return null;
                        s = 1;
                    } else {
                        if (!(a < 0)) return null;
                        (s = -1), (a = -a);
                    }
                    me.subVectors(this.origin, t);
                    const o = s * this.direction.dot(ge.crossVectors(me, ge));
                    if (o < 0) return null;
                    const l = s * this.direction.dot(fe.cross(me));
                    if (l < 0) return null;
                    if (o + l > a) return null;
                    const c = -s * me.dot(ve);
                    return c < 0 ? null : this.at(c / a, r);
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            class xe {
                constructor() {
                    (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
                        arguments.length > 0 &&
                            console.error(
                                'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',
                            );
                }
                set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
                    const g = this.elements;
                    return (
                        (g[0] = t),
                        (g[4] = e),
                        (g[8] = n),
                        (g[12] = i),
                        (g[1] = r),
                        (g[5] = s),
                        (g[9] = a),
                        (g[13] = o),
                        (g[2] = l),
                        (g[6] = c),
                        (g[10] = h),
                        (g[14] = u),
                        (g[3] = d),
                        (g[7] = p),
                        (g[11] = m),
                        (g[15] = f),
                        this
                    );
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                }
                clone() {
                    return new xe().fromArray(this.elements);
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return (
                        (e[0] = n[0]),
                        (e[1] = n[1]),
                        (e[2] = n[2]),
                        (e[3] = n[3]),
                        (e[4] = n[4]),
                        (e[5] = n[5]),
                        (e[6] = n[6]),
                        (e[7] = n[7]),
                        (e[8] = n[8]),
                        (e[9] = n[9]),
                        (e[10] = n[10]),
                        (e[11] = n[11]),
                        (e[12] = n[12]),
                        (e[13] = n[13]),
                        (e[14] = n[14]),
                        (e[15] = n[15]),
                        this
                    );
                }
                copyPosition(t) {
                    const e = this.elements,
                        n = t.elements;
                    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
                }
                setFromMatrix3(t) {
                    const e = t.elements;
                    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
                }
                extractBasis(t, e, n) {
                    return (
                        t.setFromMatrixColumn(this, 0),
                        e.setFromMatrixColumn(this, 1),
                        n.setFromMatrixColumn(this, 2),
                        this
                    );
                }
                makeBasis(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
                }
                extractRotation(t) {
                    const e = this.elements,
                        n = t.elements,
                        i = 1 / be.setFromMatrixColumn(t, 0).length(),
                        r = 1 / be.setFromMatrixColumn(t, 1).length(),
                        s = 1 / be.setFromMatrixColumn(t, 2).length();
                    return (
                        (e[0] = n[0] * i),
                        (e[1] = n[1] * i),
                        (e[2] = n[2] * i),
                        (e[3] = 0),
                        (e[4] = n[4] * r),
                        (e[5] = n[5] * r),
                        (e[6] = n[6] * r),
                        (e[7] = 0),
                        (e[8] = n[8] * s),
                        (e[9] = n[9] * s),
                        (e[10] = n[10] * s),
                        (e[11] = 0),
                        (e[12] = 0),
                        (e[13] = 0),
                        (e[14] = 0),
                        (e[15] = 1),
                        this
                    );
                }
                makeRotationFromEuler(t) {
                    (t && t.isEuler) ||
                        console.error(
                            'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',
                        );
                    const e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z,
                        s = Math.cos(n),
                        a = Math.sin(n),
                        o = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        h = Math.sin(r);
                    if ('XYZ' === t.order) {
                        const t = s * c,
                            n = s * h,
                            i = a * c,
                            r = a * h;
                        (e[0] = o * c),
                            (e[4] = -o * h),
                            (e[8] = l),
                            (e[1] = n + i * l),
                            (e[5] = t - r * l),
                            (e[9] = -a * o),
                            (e[2] = r - t * l),
                            (e[6] = i + n * l),
                            (e[10] = s * o);
                    } else if ('YXZ' === t.order) {
                        const t = o * c,
                            n = o * h,
                            i = l * c,
                            r = l * h;
                        (e[0] = t + r * a),
                            (e[4] = i * a - n),
                            (e[8] = s * l),
                            (e[1] = s * h),
                            (e[5] = s * c),
                            (e[9] = -a),
                            (e[2] = n * a - i),
                            (e[6] = r + t * a),
                            (e[10] = s * o);
                    } else if ('ZXY' === t.order) {
                        const t = o * c,
                            n = o * h,
                            i = l * c,
                            r = l * h;
                        (e[0] = t - r * a),
                            (e[4] = -s * h),
                            (e[8] = i + n * a),
                            (e[1] = n + i * a),
                            (e[5] = s * c),
                            (e[9] = r - t * a),
                            (e[2] = -s * l),
                            (e[6] = a),
                            (e[10] = s * o);
                    } else if ('ZYX' === t.order) {
                        const t = s * c,
                            n = s * h,
                            i = a * c,
                            r = a * h;
                        (e[0] = o * c),
                            (e[4] = i * l - n),
                            (e[8] = t * l + r),
                            (e[1] = o * h),
                            (e[5] = r * l + t),
                            (e[9] = n * l - i),
                            (e[2] = -l),
                            (e[6] = a * o),
                            (e[10] = s * o);
                    } else if ('YZX' === t.order) {
                        const t = s * o,
                            n = s * l,
                            i = a * o,
                            r = a * l;
                        (e[0] = o * c),
                            (e[4] = r - t * h),
                            (e[8] = i * h + n),
                            (e[1] = h),
                            (e[5] = s * c),
                            (e[9] = -a * c),
                            (e[2] = -l * c),
                            (e[6] = n * h + i),
                            (e[10] = t - r * h);
                    } else if ('XZY' === t.order) {
                        const t = s * o,
                            n = s * l,
                            i = a * o,
                            r = a * l;
                        (e[0] = o * c),
                            (e[4] = -h),
                            (e[8] = l * c),
                            (e[1] = t * h + r),
                            (e[5] = s * c),
                            (e[9] = n * h - i),
                            (e[2] = i * h - n),
                            (e[6] = a * c),
                            (e[10] = r * h + t);
                    }
                    return (
                        (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this
                    );
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(_e, t, Me);
                }
                lookAt(t, e, n) {
                    const i = this.elements;
                    return (
                        Ee.subVectors(t, e),
                        0 === Ee.lengthSq() && (Ee.z = 1),
                        Ee.normalize(),
                        Se.crossVectors(n, Ee),
                        0 === Se.lengthSq() &&
                            (1 === Math.abs(n.z) ? (Ee.x += 1e-4) : (Ee.z += 1e-4),
                            Ee.normalize(),
                            Se.crossVectors(n, Ee)),
                        Se.normalize(),
                        Te.crossVectors(Ee, Se),
                        (i[0] = Se.x),
                        (i[4] = Te.x),
                        (i[8] = Ee.x),
                        (i[1] = Se.y),
                        (i[5] = Te.y),
                        (i[9] = Ee.y),
                        (i[2] = Se.z),
                        (i[6] = Te.z),
                        (i[10] = Ee.z),
                        this
                    );
                }
                multiply(t, e) {
                    return void 0 !== e
                        ? (console.warn(
                              'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',
                          ),
                          this.multiplyMatrices(t, e))
                        : this.multiplyMatrices(this, t);
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this);
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        s = n[0],
                        a = n[4],
                        o = n[8],
                        l = n[12],
                        c = n[1],
                        h = n[5],
                        u = n[9],
                        d = n[13],
                        p = n[2],
                        m = n[6],
                        f = n[10],
                        g = n[14],
                        v = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        w = i[0],
                        _ = i[4],
                        M = i[8],
                        S = i[12],
                        T = i[1],
                        E = i[5],
                        A = i[9],
                        L = i[13],
                        R = i[2],
                        C = i[6],
                        P = i[10],
                        I = i[14],
                        D = i[3],
                        N = i[7],
                        F = i[11],
                        O = i[15];
                    return (
                        (r[0] = s * w + a * T + o * R + l * D),
                        (r[4] = s * _ + a * E + o * C + l * N),
                        (r[8] = s * M + a * A + o * P + l * F),
                        (r[12] = s * S + a * L + o * I + l * O),
                        (r[1] = c * w + h * T + u * R + d * D),
                        (r[5] = c * _ + h * E + u * C + d * N),
                        (r[9] = c * M + h * A + u * P + d * F),
                        (r[13] = c * S + h * L + u * I + d * O),
                        (r[2] = p * w + m * T + f * R + g * D),
                        (r[6] = p * _ + m * E + f * C + g * N),
                        (r[10] = p * M + m * A + f * P + g * F),
                        (r[14] = p * S + m * L + f * I + g * O),
                        (r[3] = v * w + y * T + x * R + b * D),
                        (r[7] = v * _ + y * E + x * C + b * N),
                        (r[11] = v * M + y * A + x * P + b * F),
                        (r[15] = v * S + y * L + x * I + b * O),
                        this
                    );
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return (
                        (e[0] *= t),
                        (e[4] *= t),
                        (e[8] *= t),
                        (e[12] *= t),
                        (e[1] *= t),
                        (e[5] *= t),
                        (e[9] *= t),
                        (e[13] *= t),
                        (e[2] *= t),
                        (e[6] *= t),
                        (e[10] *= t),
                        (e[14] *= t),
                        (e[3] *= t),
                        (e[7] *= t),
                        (e[11] *= t),
                        (e[15] *= t),
                        this
                    );
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[4],
                        i = t[8],
                        r = t[12],
                        s = t[1],
                        a = t[5],
                        o = t[9],
                        l = t[13],
                        c = t[2],
                        h = t[6],
                        u = t[10],
                        d = t[14];
                    return (
                        t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) +
                        t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) +
                        t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) +
                        t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c)
                    );
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return (
                        (e = t[1]),
                        (t[1] = t[4]),
                        (t[4] = e),
                        (e = t[2]),
                        (t[2] = t[8]),
                        (t[8] = e),
                        (e = t[6]),
                        (t[6] = t[9]),
                        (t[9] = e),
                        (e = t[3]),
                        (t[3] = t[12]),
                        (t[12] = e),
                        (e = t[7]),
                        (t[7] = t[13]),
                        (t[13] = e),
                        (e = t[11]),
                        (t[11] = t[14]),
                        (t[14] = e),
                        this
                    );
                }
                setPosition(t, e, n) {
                    const i = this.elements;
                    return (
                        t.isVector3
                            ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                            : ((i[12] = t), (i[13] = e), (i[14] = n)),
                        this
                    );
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        s = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        c = t[8],
                        h = t[9],
                        u = t[10],
                        d = t[11],
                        p = t[12],
                        m = t[13],
                        f = t[14],
                        g = t[15],
                        v = h * f * l - m * u * l + m * o * d - a * f * d - h * o * g + a * u * g,
                        y = p * u * l - c * f * l - p * o * d + s * f * d + c * o * g - s * u * g,
                        x = c * m * l - p * h * l + p * a * d - s * m * d - c * a * g + s * h * g,
                        b = p * h * o - c * m * o - p * a * u + s * m * u + c * a * f - s * h * f,
                        w = e * v + n * y + i * x + r * b;
                    if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const _ = 1 / w;
                    return (
                        (t[0] = v * _),
                        (t[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * _),
                        (t[2] = (a * f * r - m * o * r + m * i * l - n * f * l - a * i * g + n * o * g) * _),
                        (t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * _),
                        (t[4] = y * _),
                        (t[5] = (c * f * r - p * u * r + p * i * d - e * f * d - c * i * g + e * u * g) * _),
                        (t[6] = (p * o * r - s * f * r - p * i * l + e * f * l + s * i * g - e * o * g) * _),
                        (t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * _),
                        (t[8] = x * _),
                        (t[9] = (p * h * r - c * m * r - p * n * d + e * m * d + c * n * g - e * h * g) * _),
                        (t[10] = (s * m * r - p * a * r + p * n * l - e * m * l - s * n * g + e * a * g) * _),
                        (t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * _),
                        (t[12] = b * _),
                        (t[13] = (c * m * i - p * h * i + p * n * u - e * m * u - c * n * f + e * h * f) * _),
                        (t[14] = (p * a * i - s * m * i - p * n * o + e * m * o + s * n * f - e * a * f) * _),
                        (t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * _),
                        this
                    );
                }
                scale(t) {
                    const e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z;
                    return (
                        (e[0] *= n),
                        (e[4] *= i),
                        (e[8] *= r),
                        (e[1] *= n),
                        (e[5] *= i),
                        (e[9] *= r),
                        (e[2] *= n),
                        (e[6] *= i),
                        (e[10] *= r),
                        (e[3] *= n),
                        (e[7] *= i),
                        (e[11] *= r),
                        this
                    );
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, i));
                }
                makeTranslation(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                }
                makeRotationAxis(t, e) {
                    const n = Math.cos(e),
                        i = Math.sin(e),
                        r = 1 - n,
                        s = t.x,
                        a = t.y,
                        o = t.z,
                        l = r * s,
                        c = r * a;
                    return (
                        this.set(
                            l * s + n,
                            l * a - i * o,
                            l * o + i * a,
                            0,
                            l * a + i * o,
                            c * a + n,
                            c * o - i * s,
                            0,
                            l * o - i * a,
                            c * o + i * s,
                            r * o * o + n,
                            0,
                            0,
                            0,
                            0,
                            1,
                        ),
                        this
                    );
                }
                makeScale(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
                }
                makeShear(t, e, n, i, r, s) {
                    return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
                }
                compose(t, e, n) {
                    const i = this.elements,
                        r = e._x,
                        s = e._y,
                        a = e._z,
                        o = e._w,
                        l = r + r,
                        c = s + s,
                        h = a + a,
                        u = r * l,
                        d = r * c,
                        p = r * h,
                        m = s * c,
                        f = s * h,
                        g = a * h,
                        v = o * l,
                        y = o * c,
                        x = o * h,
                        b = n.x,
                        w = n.y,
                        _ = n.z;
                    return (
                        (i[0] = (1 - (m + g)) * b),
                        (i[1] = (d + x) * b),
                        (i[2] = (p - y) * b),
                        (i[3] = 0),
                        (i[4] = (d - x) * w),
                        (i[5] = (1 - (u + g)) * w),
                        (i[6] = (f + v) * w),
                        (i[7] = 0),
                        (i[8] = (p + y) * _),
                        (i[9] = (f - v) * _),
                        (i[10] = (1 - (u + m)) * _),
                        (i[11] = 0),
                        (i[12] = t.x),
                        (i[13] = t.y),
                        (i[14] = t.z),
                        (i[15] = 1),
                        this
                    );
                }
                decompose(t, e, n) {
                    const i = this.elements;
                    let r = be.set(i[0], i[1], i[2]).length();
                    const s = be.set(i[4], i[5], i[6]).length(),
                        a = be.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r), (t.x = i[12]), (t.y = i[13]), (t.z = i[14]), we.copy(this);
                    const o = 1 / r,
                        l = 1 / s,
                        c = 1 / a;
                    return (
                        (we.elements[0] *= o),
                        (we.elements[1] *= o),
                        (we.elements[2] *= o),
                        (we.elements[4] *= l),
                        (we.elements[5] *= l),
                        (we.elements[6] *= l),
                        (we.elements[8] *= c),
                        (we.elements[9] *= c),
                        (we.elements[10] *= c),
                        e.setFromRotationMatrix(we),
                        (n.x = r),
                        (n.y = s),
                        (n.z = a),
                        this
                    );
                }
                makePerspective(t, e, n, i, r, s) {
                    void 0 === s &&
                        console.warn(
                            'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',
                        );
                    const a = this.elements,
                        o = (2 * r) / (e - t),
                        l = (2 * r) / (n - i),
                        c = (e + t) / (e - t),
                        h = (n + i) / (n - i),
                        u = -(s + r) / (s - r),
                        d = (-2 * s * r) / (s - r);
                    return (
                        (a[0] = o),
                        (a[4] = 0),
                        (a[8] = c),
                        (a[12] = 0),
                        (a[1] = 0),
                        (a[5] = l),
                        (a[9] = h),
                        (a[13] = 0),
                        (a[2] = 0),
                        (a[6] = 0),
                        (a[10] = u),
                        (a[14] = d),
                        (a[3] = 0),
                        (a[7] = 0),
                        (a[11] = -1),
                        (a[15] = 0),
                        this
                    );
                }
                makeOrthographic(t, e, n, i, r, s) {
                    const a = this.elements,
                        o = 1 / (e - t),
                        l = 1 / (n - i),
                        c = 1 / (s - r),
                        h = (e + t) * o,
                        u = (n + i) * l,
                        d = (s + r) * c;
                    return (
                        (a[0] = 2 * o),
                        (a[4] = 0),
                        (a[8] = 0),
                        (a[12] = -h),
                        (a[1] = 0),
                        (a[5] = 2 * l),
                        (a[9] = 0),
                        (a[13] = -u),
                        (a[2] = 0),
                        (a[6] = 0),
                        (a[10] = -2 * c),
                        (a[14] = -d),
                        (a[3] = 0),
                        (a[7] = 0),
                        (a[11] = 0),
                        (a[15] = 1),
                        this
                    );
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
                    return !0;
                }
                fromArray(t, e = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this;
                }
                toArray(t = [], e = 0) {
                    const n = this.elements;
                    return (
                        (t[e] = n[0]),
                        (t[e + 1] = n[1]),
                        (t[e + 2] = n[2]),
                        (t[e + 3] = n[3]),
                        (t[e + 4] = n[4]),
                        (t[e + 5] = n[5]),
                        (t[e + 6] = n[6]),
                        (t[e + 7] = n[7]),
                        (t[e + 8] = n[8]),
                        (t[e + 9] = n[9]),
                        (t[e + 10] = n[10]),
                        (t[e + 11] = n[11]),
                        (t[e + 12] = n[12]),
                        (t[e + 13] = n[13]),
                        (t[e + 14] = n[14]),
                        (t[e + 15] = n[15]),
                        t
                    );
                }
            }
            xe.prototype.isMatrix4 = !0;
            const be = new Gt(),
                we = new xe(),
                _e = new Gt(0, 0, 0),
                Me = new Gt(1, 1, 1),
                Se = new Gt(),
                Te = new Gt(),
                Ee = new Gt(),
                Ae = new xe(),
                Le = new Ht();
            class Re {
                constructor(t = 0, e = 0, n = 0, i = Re.DefaultOrder) {
                    (this._x = t), (this._y = e), (this._z = n), (this._order = i);
                }
                get x() {
                    return this._x;
                }
                set x(t) {
                    (this._x = t), this._onChangeCallback();
                }
                get y() {
                    return this._y;
                }
                set y(t) {
                    (this._y = t), this._onChangeCallback();
                }
                get z() {
                    return this._z;
                }
                set z(t) {
                    (this._z = t), this._onChangeCallback();
                }
                get order() {
                    return this._order;
                }
                set order(t) {
                    (this._order = t), this._onChangeCallback();
                }
                set(t, e, n, i = this._order) {
                    return (
                        (this._x = t), (this._y = e), (this._z = n), (this._order = i), this._onChangeCallback(), this
                    );
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order);
                }
                copy(t) {
                    return (
                        (this._x = t._x),
                        (this._y = t._y),
                        (this._z = t._z),
                        (this._order = t._order),
                        this._onChangeCallback(),
                        this
                    );
                }
                setFromRotationMatrix(t, e = this._order, n = !0) {
                    const i = t.elements,
                        r = i[0],
                        s = i[4],
                        a = i[8],
                        o = i[1],
                        l = i[5],
                        c = i[9],
                        h = i[2],
                        u = i[6],
                        d = i[10];
                    switch (e) {
                        case 'XYZ':
                            (this._y = Math.asin(_t(a, -1, 1))),
                                Math.abs(a) < 0.9999999
                                    ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
                                    : ((this._x = Math.atan2(u, l)), (this._z = 0));
                            break;
                        case 'YXZ':
                            (this._x = Math.asin(-_t(c, -1, 1))),
                                Math.abs(c) < 0.9999999
                                    ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                                    : ((this._y = Math.atan2(-h, r)), (this._z = 0));
                            break;
                        case 'ZXY':
                            (this._x = Math.asin(_t(u, -1, 1))),
                                Math.abs(u) < 0.9999999
                                    ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))
                                    : ((this._y = 0), (this._z = Math.atan2(o, r)));
                            break;
                        case 'ZYX':
                            (this._y = Math.asin(-_t(h, -1, 1))),
                                Math.abs(h) < 0.9999999
                                    ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
                                    : ((this._x = 0), (this._z = Math.atan2(-s, l)));
                            break;
                        case 'YZX':
                            (this._z = Math.asin(_t(o, -1, 1))),
                                Math.abs(o) < 0.9999999
                                    ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))
                                    : ((this._x = 0), (this._y = Math.atan2(a, d)));
                            break;
                        case 'XZY':
                            (this._z = Math.asin(-_t(s, -1, 1))),
                                Math.abs(s) < 0.9999999
                                    ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
                                    : ((this._x = Math.atan2(-c, d)), (this._y = 0));
                            break;
                        default:
                            console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + e);
                    }
                    return (this._order = e), !0 === n && this._onChangeCallback(), this;
                }
                setFromQuaternion(t, e, n) {
                    return Ae.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ae, e, n);
                }
                setFromVector3(t, e = this._order) {
                    return this.set(t.x, t.y, t.z, e);
                }
                reorder(t) {
                    return Le.setFromEuler(this), this.setFromQuaternion(Le, t);
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
                }
                fromArray(t) {
                    return (
                        (this._x = t[0]),
                        (this._y = t[1]),
                        (this._z = t[2]),
                        void 0 !== t[3] && (this._order = t[3]),
                        this._onChangeCallback(),
                        this
                    );
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._order), t;
                }
                toVector3(t) {
                    return t ? t.set(this._x, this._y, this._z) : new Gt(this._x, this._y, this._z);
                }
                _onChange(t) {
                    return (this._onChangeCallback = t), this;
                }
                _onChangeCallback() {}
            }
            (Re.prototype.isEuler = !0),
                (Re.DefaultOrder = 'XYZ'),
                (Re.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']);
            class Ce {
                constructor() {
                    this.mask = 1;
                }
                set(t) {
                    this.mask = (1 << t) | 0;
                }
                enable(t) {
                    this.mask |= (1 << t) | 0;
                }
                enableAll() {
                    this.mask = -1;
                }
                toggle(t) {
                    this.mask ^= (1 << t) | 0;
                }
                disable(t) {
                    this.mask &= ~((1 << t) | 0);
                }
                disableAll() {
                    this.mask = 0;
                }
                test(t) {
                    return 0 != (this.mask & t.mask);
                }
            }
            let Pe = 0;
            const Ie = new Gt(),
                De = new Ht(),
                Ne = new xe(),
                Fe = new Gt(),
                Oe = new Gt(),
                Ue = new Gt(),
                ke = new Ht(),
                ze = new Gt(1, 0, 0),
                Be = new Gt(0, 1, 0),
                He = new Gt(0, 0, 1),
                Ge = { type: 'added' },
                Ve = { type: 'removed' };
            class We extends ft {
                constructor() {
                    super(),
                        Object.defineProperty(this, 'id', { value: Pe++ }),
                        (this.uuid = wt()),
                        (this.name = ''),
                        (this.type = 'Object3D'),
                        (this.parent = null),
                        (this.children = []),
                        (this.up = We.DefaultUp.clone());
                    const t = new Gt(),
                        e = new Re(),
                        n = new Ht(),
                        i = new Gt(1, 1, 1);
                    e._onChange(function () {
                        n.setFromEuler(e, !1);
                    }),
                        n._onChange(function () {
                            e.setFromQuaternion(n, void 0, !1);
                        }),
                        Object.defineProperties(this, {
                            position: { configurable: !0, enumerable: !0, value: t },
                            rotation: { configurable: !0, enumerable: !0, value: e },
                            quaternion: { configurable: !0, enumerable: !0, value: n },
                            scale: { configurable: !0, enumerable: !0, value: i },
                            modelViewMatrix: { value: new xe() },
                            normalMatrix: { value: new Ct() },
                        }),
                        (this.matrix = new xe()),
                        (this.matrixWorld = new xe()),
                        (this.matrixAutoUpdate = We.DefaultMatrixAutoUpdate),
                        (this.matrixWorldNeedsUpdate = !1),
                        (this.layers = new Ce()),
                        (this.visible = !0),
                        (this.castShadow = !1),
                        (this.receiveShadow = !1),
                        (this.frustumCulled = !0),
                        (this.renderOrder = 0),
                        (this.animations = []),
                        (this.userData = {});
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrix.premultiply(t),
                        this.matrix.decompose(this.position, this.quaternion, this.scale);
                }
                applyQuaternion(t) {
                    return this.quaternion.premultiply(t), this;
                }
                setRotationFromAxisAngle(t, e) {
                    this.quaternion.setFromAxisAngle(t, e);
                }
                setRotationFromEuler(t) {
                    this.quaternion.setFromEuler(t, !0);
                }
                setRotationFromMatrix(t) {
                    this.quaternion.setFromRotationMatrix(t);
                }
                setRotationFromQuaternion(t) {
                    this.quaternion.copy(t);
                }
                rotateOnAxis(t, e) {
                    return De.setFromAxisAngle(t, e), this.quaternion.multiply(De), this;
                }
                rotateOnWorldAxis(t, e) {
                    return De.setFromAxisAngle(t, e), this.quaternion.premultiply(De), this;
                }
                rotateX(t) {
                    return this.rotateOnAxis(ze, t);
                }
                rotateY(t) {
                    return this.rotateOnAxis(Be, t);
                }
                rotateZ(t) {
                    return this.rotateOnAxis(He, t);
                }
                translateOnAxis(t, e) {
                    return Ie.copy(t).applyQuaternion(this.quaternion), this.position.add(Ie.multiplyScalar(e)), this;
                }
                translateX(t) {
                    return this.translateOnAxis(ze, t);
                }
                translateY(t) {
                    return this.translateOnAxis(Be, t);
                }
                translateZ(t) {
                    return this.translateOnAxis(He, t);
                }
                localToWorld(t) {
                    return t.applyMatrix4(this.matrixWorld);
                }
                worldToLocal(t) {
                    return t.applyMatrix4(Ne.copy(this.matrixWorld).invert());
                }
                lookAt(t, e, n) {
                    t.isVector3 ? Fe.copy(t) : Fe.set(t, e, n);
                    const i = this.parent;
                    this.updateWorldMatrix(!0, !1),
                        Oe.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? Ne.lookAt(Oe, Fe, this.up) : Ne.lookAt(Fe, Oe, this.up),
                        this.quaternion.setFromRotationMatrix(Ne),
                        i &&
                            (Ne.extractRotation(i.matrixWorld),
                            De.setFromRotationMatrix(Ne),
                            this.quaternion.premultiply(De.invert()));
                }
                add(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this;
                    }
                    return t === this
                        ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this)
                        : (t && t.isObject3D
                              ? (null !== t.parent && t.parent.remove(t),
                                (t.parent = this),
                                this.children.push(t),
                                t.dispatchEvent(Ge))
                              : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', t),
                          this);
                }
                remove(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this;
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(Ve)), this;
                }
                removeFromParent() {
                    const t = this.parent;
                    return null !== t && t.remove(this), this;
                }
                clear() {
                    for (let t = 0; t < this.children.length; t++) {
                        const e = this.children[t];
                        (e.parent = null), e.dispatchEvent(Ve);
                    }
                    return (this.children.length = 0), this;
                }
                attach(t) {
                    return (
                        this.updateWorldMatrix(!0, !1),
                        Ne.copy(this.matrixWorld).invert(),
                        null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ne.multiply(t.parent.matrixWorld)),
                        t.applyMatrix4(Ne),
                        this.add(t),
                        t.updateWorldMatrix(!1, !0),
                        this
                    );
                }
                getObjectById(t) {
                    return this.getObjectByProperty('id', t);
                }
                getObjectByName(t) {
                    return this.getObjectByProperty('name', t);
                }
                getObjectByProperty(t, e) {
                    if (this[t] === e) return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n].getObjectByProperty(t, e);
                        if (void 0 !== i) return i;
                    }
                }
                getWorldPosition(t) {
                    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
                }
                getWorldQuaternion(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Oe, t, Ue), t;
                }
                getWorldScale(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Oe, ke, t), t;
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize();
                }
                raycast() {}
                traverse(t) {
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
                }
                traverseVisible(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
                }
                traverseAncestors(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t));
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
                }
                updateMatrixWorld(t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                        (this.matrixWorldNeedsUpdate || t) &&
                            (null === this.parent
                                ? this.matrixWorld.copy(this.matrix)
                                : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                            (this.matrixWorldNeedsUpdate = !1),
                            (t = !0));
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
                }
                updateWorldMatrix(t, e) {
                    const n = this.parent;
                    if (
                        (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                        this.matrixAutoUpdate && this.updateMatrix(),
                        null === this.parent
                            ? this.matrixWorld.copy(this.matrix)
                            : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                        !0 === e)
                    ) {
                        const t = this.children;
                        for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0);
                    }
                }
                toJSON(t) {
                    const e = void 0 === t || 'string' == typeof t,
                        n = {};
                    e &&
                        ((t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {},
                        }),
                        (n.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }));
                    const i = {};
                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
                    }
                    if (
                        ((i.uuid = this.uuid),
                        (i.type = this.type),
                        '' !== this.name && (i.name = this.name),
                        !0 === this.castShadow && (i.castShadow = !0),
                        !0 === this.receiveShadow && (i.receiveShadow = !0),
                        !1 === this.visible && (i.visible = !1),
                        !1 === this.frustumCulled && (i.frustumCulled = !1),
                        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                        '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData),
                        (i.layers = this.layers.mask),
                        (i.matrix = this.matrix.toArray()),
                        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                        this.isInstancedMesh &&
                            ((i.type = 'InstancedMesh'),
                            (i.count = this.count),
                            (i.instanceMatrix = this.instanceMatrix.toJSON()),
                            null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                        this.isScene)
                    )
                        this.background &&
                            (this.background.isColor
                                ? (i.background = this.background.toJSON())
                                : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
                            this.environment &&
                                this.environment.isTexture &&
                                (i.environment = this.environment.toJSON(t).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const n = e.shapes;
                            if (Array.isArray(n))
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = n[e];
                                    r(t.shapes, i);
                                }
                            else r(t.shapes, n);
                        }
                    }
                    if (
                        (this.isSkinnedMesh &&
                            ((i.bindMode = this.bindMode),
                            (i.bindMatrix = this.bindMatrix.toArray()),
                            void 0 !== this.skeleton &&
                                (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
                        void 0 !== this.material)
                    )
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let n = 0, i = this.material.length; n < i; n++)
                                e.push(r(t.materials, this.material[n]));
                            i.material = e;
                        } else i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let e = 0; e < this.children.length; e++)
                            i.children.push(this.children[e].toJSON(t).object);
                    }
                    if (this.animations.length > 0) {
                        i.animations = [];
                        for (let e = 0; e < this.animations.length; e++) {
                            const n = this.animations[e];
                            i.animations.push(r(t.animations, n));
                        }
                    }
                    if (e) {
                        const e = s(t.geometries),
                            i = s(t.materials),
                            r = s(t.textures),
                            a = s(t.images),
                            o = s(t.shapes),
                            l = s(t.skeletons),
                            c = s(t.animations);
                        e.length > 0 && (n.geometries = e),
                            i.length > 0 && (n.materials = i),
                            r.length > 0 && (n.textures = r),
                            a.length > 0 && (n.images = a),
                            o.length > 0 && (n.shapes = o),
                            l.length > 0 && (n.skeletons = l),
                            c.length > 0 && (n.animations = c);
                    }
                    return (n.object = i), n;
                    function s(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            delete i.metadata, e.push(i);
                        }
                        return e;
                    }
                }
                clone(t) {
                    return new this.constructor().copy(this, t);
                }
                copy(t, e = !0) {
                    if (
                        ((this.name = t.name),
                        this.up.copy(t.up),
                        this.position.copy(t.position),
                        (this.rotation.order = t.rotation.order),
                        this.quaternion.copy(t.quaternion),
                        this.scale.copy(t.scale),
                        this.matrix.copy(t.matrix),
                        this.matrixWorld.copy(t.matrixWorld),
                        (this.matrixAutoUpdate = t.matrixAutoUpdate),
                        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
                        (this.layers.mask = t.layers.mask),
                        (this.visible = t.visible),
                        (this.castShadow = t.castShadow),
                        (this.receiveShadow = t.receiveShadow),
                        (this.frustumCulled = t.frustumCulled),
                        (this.renderOrder = t.renderOrder),
                        (this.userData = JSON.parse(JSON.stringify(t.userData))),
                        !0 === e)
                    )
                        for (let e = 0; e < t.children.length; e++) {
                            const n = t.children[e];
                            this.add(n.clone());
                        }
                    return this;
                }
            }
            (We.DefaultUp = new Gt(0, 1, 0)), (We.DefaultMatrixAutoUpdate = !0), (We.prototype.isObject3D = !0);
            const je = new Gt(),
                qe = new Gt(),
                Xe = new Gt(),
                Ye = new Gt(),
                Ze = new Gt(),
                Je = new Gt(),
                $e = new Gt(),
                Ke = new Gt(),
                Qe = new Gt(),
                tn = new Gt();
            class en {
                constructor(t = new Gt(), e = new Gt(), n = new Gt()) {
                    (this.a = t), (this.b = e), (this.c = n);
                }
                static getNormal(t, e, n, i) {
                    i.subVectors(n, e), je.subVectors(t, e), i.cross(je);
                    const r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
                }
                static getBarycoord(t, e, n, i, r) {
                    je.subVectors(i, e), qe.subVectors(n, e), Xe.subVectors(t, e);
                    const s = je.dot(je),
                        a = je.dot(qe),
                        o = je.dot(Xe),
                        l = qe.dot(qe),
                        c = qe.dot(Xe),
                        h = s * l - a * a;
                    if (0 === h) return r.set(-2, -1, -1);
                    const u = 1 / h,
                        d = (l * o - a * c) * u,
                        p = (s * c - a * o) * u;
                    return r.set(1 - d - p, p, d);
                }
                static containsPoint(t, e, n, i) {
                    return this.getBarycoord(t, e, n, i, Ye), Ye.x >= 0 && Ye.y >= 0 && Ye.x + Ye.y <= 1;
                }
                static getUV(t, e, n, i, r, s, a, o) {
                    return (
                        this.getBarycoord(t, e, n, i, Ye),
                        o.set(0, 0),
                        o.addScaledVector(r, Ye.x),
                        o.addScaledVector(s, Ye.y),
                        o.addScaledVector(a, Ye.z),
                        o
                    );
                }
                static isFrontFacing(t, e, n, i) {
                    return je.subVectors(n, e), qe.subVectors(t, e), je.cross(qe).dot(i) < 0;
                }
                set(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
                }
                setFromPointsAndIndices(t, e, n, i) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
                }
                setFromAttributeAndIndices(t, e, n, i) {
                    return (
                        this.a.fromBufferAttribute(t, e),
                        this.b.fromBufferAttribute(t, n),
                        this.c.fromBufferAttribute(t, i),
                        this
                    );
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
                }
                getArea() {
                    return je.subVectors(this.c, this.b), qe.subVectors(this.a, this.b), 0.5 * je.cross(qe).length();
                }
                getMidpoint(t) {
                    return t
                        .addVectors(this.a, this.b)
                        .add(this.c)
                        .multiplyScalar(1 / 3);
                }
                getNormal(t) {
                    return en.getNormal(this.a, this.b, this.c, t);
                }
                getPlane(t) {
                    return t.setFromCoplanarPoints(this.a, this.b, this.c);
                }
                getBarycoord(t, e) {
                    return en.getBarycoord(t, this.a, this.b, this.c, e);
                }
                getUV(t, e, n, i, r) {
                    return en.getUV(t, this.a, this.b, this.c, e, n, i, r);
                }
                containsPoint(t) {
                    return en.containsPoint(t, this.a, this.b, this.c);
                }
                isFrontFacing(t) {
                    return en.isFrontFacing(this.a, this.b, this.c, t);
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this);
                }
                closestPointToPoint(t, e) {
                    const n = this.a,
                        i = this.b,
                        r = this.c;
                    let s, a;
                    Ze.subVectors(i, n), Je.subVectors(r, n), Ke.subVectors(t, n);
                    const o = Ze.dot(Ke),
                        l = Je.dot(Ke);
                    if (o <= 0 && l <= 0) return e.copy(n);
                    Qe.subVectors(t, i);
                    const c = Ze.dot(Qe),
                        h = Je.dot(Qe);
                    if (c >= 0 && h <= c) return e.copy(i);
                    const u = o * h - c * l;
                    if (u <= 0 && o >= 0 && c <= 0) return (s = o / (o - c)), e.copy(n).addScaledVector(Ze, s);
                    tn.subVectors(t, r);
                    const d = Ze.dot(tn),
                        p = Je.dot(tn);
                    if (p >= 0 && d <= p) return e.copy(r);
                    const m = d * l - o * p;
                    if (m <= 0 && l >= 0 && p <= 0) return (a = l / (l - p)), e.copy(n).addScaledVector(Je, a);
                    const f = c * p - d * h;
                    if (f <= 0 && h - c >= 0 && d - p >= 0)
                        return $e.subVectors(r, i), (a = (h - c) / (h - c + (d - p))), e.copy(i).addScaledVector($e, a);
                    const g = 1 / (f + m + u);
                    return (s = m * g), (a = u * g), e.copy(n).addScaledVector(Ze, s).addScaledVector(Je, a);
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
                }
            }
            let nn = 0;
            class rn extends ft {
                constructor() {
                    super(),
                        Object.defineProperty(this, 'id', { value: nn++ }),
                        (this.uuid = wt()),
                        (this.name = ''),
                        (this.type = 'Material'),
                        (this.fog = !0),
                        (this.blending = 1),
                        (this.side = 0),
                        (this.vertexColors = !1),
                        (this.opacity = 1),
                        (this.format = 1023),
                        (this.transparent = !1),
                        (this.blendSrc = 204),
                        (this.blendDst = 205),
                        (this.blendEquation = 100),
                        (this.blendSrcAlpha = null),
                        (this.blendDstAlpha = null),
                        (this.blendEquationAlpha = null),
                        (this.depthFunc = 3),
                        (this.depthTest = !0),
                        (this.depthWrite = !0),
                        (this.stencilWriteMask = 255),
                        (this.stencilFunc = 519),
                        (this.stencilRef = 0),
                        (this.stencilFuncMask = 255),
                        (this.stencilFail = 7680),
                        (this.stencilZFail = 7680),
                        (this.stencilZPass = 7680),
                        (this.stencilWrite = !1),
                        (this.clippingPlanes = null),
                        (this.clipIntersection = !1),
                        (this.clipShadows = !1),
                        (this.shadowSide = null),
                        (this.colorWrite = !0),
                        (this.precision = null),
                        (this.polygonOffset = !1),
                        (this.polygonOffsetFactor = 0),
                        (this.polygonOffsetUnits = 0),
                        (this.dithering = !1),
                        (this.alphaToCoverage = !1),
                        (this.premultipliedAlpha = !1),
                        (this.visible = !0),
                        (this.toneMapped = !0),
                        (this.userData = {}),
                        (this.version = 0),
                        (this._alphaTest = 0);
                }
                get alphaTest() {
                    return this._alphaTest;
                }
                set alphaTest(t) {
                    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString();
                }
                setValues(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const n = t[e];
                            if (void 0 === n) {
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                continue;
                            }
                            if ('shading' === e) {
                                console.warn(
                                    'THREE.' +
                                        this.type +
                                        ': .shading has been removed. Use the boolean .flatShading instead.',
                                ),
                                    (this.flatShading = 1 === n);
                                continue;
                            }
                            const i = this[e];
                            void 0 !== i
                                ? i && i.isColor
                                    ? i.set(n)
                                    : i && i.isVector3 && n && n.isVector3
                                    ? i.copy(n)
                                    : (this[e] = n)
                                : console.warn(
                                      'THREE.' + this.type + ": '" + e + "' is not a property of this material.",
                                  );
                        }
                }
                toJSON(t) {
                    const e = void 0 === t || 'string' == typeof t;
                    e && (t = { textures: {}, images: {} });
                    const n = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } };
                    function i(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            delete i.metadata, e.push(i);
                        }
                        return e;
                    }
                    if (
                        ((n.uuid = this.uuid),
                        (n.type = this.type),
                        '' !== this.name && (n.name = this.name),
                        this.color && this.color.isColor && (n.color = this.color.getHex()),
                        void 0 !== this.roughness && (n.roughness = this.roughness),
                        void 0 !== this.metalness && (n.metalness = this.metalness),
                        void 0 !== this.sheen && (n.sheen = this.sheen),
                        this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()),
                        void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                        this.emissiveIntensity &&
                            1 !== this.emissiveIntensity &&
                            (n.emissiveIntensity = this.emissiveIntensity),
                        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                        void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                        this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()),
                        void 0 !== this.shininess && (n.shininess = this.shininess),
                        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                        void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                        this.clearcoatMap &&
                            this.clearcoatMap.isTexture &&
                            (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                        this.clearcoatRoughnessMap &&
                            this.clearcoatRoughnessMap.isTexture &&
                            (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                        this.clearcoatNormalMap &&
                            this.clearcoatNormalMap.isTexture &&
                            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
                            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
                        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                        this.lightMap &&
                            this.lightMap.isTexture &&
                            ((n.lightMap = this.lightMap.toJSON(t).uuid),
                            (n.lightMapIntensity = this.lightMapIntensity)),
                        this.aoMap &&
                            this.aoMap.isTexture &&
                            ((n.aoMap = this.aoMap.toJSON(t).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
                        this.bumpMap &&
                            this.bumpMap.isTexture &&
                            ((n.bumpMap = this.bumpMap.toJSON(t).uuid), (n.bumpScale = this.bumpScale)),
                        this.normalMap &&
                            this.normalMap.isTexture &&
                            ((n.normalMap = this.normalMap.toJSON(t).uuid),
                            (n.normalMapType = this.normalMapType),
                            (n.normalScale = this.normalScale.toArray())),
                        this.displacementMap &&
                            this.displacementMap.isTexture &&
                            ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                            (n.displacementScale = this.displacementScale),
                            (n.displacementBias = this.displacementBias)),
                        this.roughnessMap &&
                            this.roughnessMap.isTexture &&
                            (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                        this.metalnessMap &&
                            this.metalnessMap.isTexture &&
                            (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                        this.emissiveMap &&
                            this.emissiveMap.isTexture &&
                            (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                        this.specularMap &&
                            this.specularMap.isTexture &&
                            (n.specularMap = this.specularMap.toJSON(t).uuid),
                        this.specularIntensityMap &&
                            this.specularIntensityMap.isTexture &&
                            (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
                        this.specularTintMap &&
                            this.specularTintMap.isTexture &&
                            (n.specularTintMap = this.specularTintMap.toJSON(t).uuid),
                        this.envMap &&
                            this.envMap.isTexture &&
                            ((n.envMap = this.envMap.toJSON(t).uuid),
                            void 0 !== this.combine && (n.combine = this.combine)),
                        void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                        void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                        void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                        this.gradientMap &&
                            this.gradientMap.isTexture &&
                            (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                        void 0 !== this.transmission && (n.transmission = this.transmission),
                        this.transmissionMap &&
                            this.transmissionMap.isTexture &&
                            (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                        void 0 !== this.thickness && (n.thickness = this.thickness),
                        this.thicknessMap &&
                            this.thicknessMap.isTexture &&
                            (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                        void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance),
                        void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()),
                        void 0 !== this.size && (n.size = this.size),
                        null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                        void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                        1 !== this.blending && (n.blending = this.blending),
                        0 !== this.side && (n.side = this.side),
                        this.vertexColors && (n.vertexColors = !0),
                        this.opacity < 1 && (n.opacity = this.opacity),
                        1023 !== this.format && (n.format = this.format),
                        !0 === this.transparent && (n.transparent = this.transparent),
                        (n.depthFunc = this.depthFunc),
                        (n.depthTest = this.depthTest),
                        (n.depthWrite = this.depthWrite),
                        (n.colorWrite = this.colorWrite),
                        (n.stencilWrite = this.stencilWrite),
                        (n.stencilWriteMask = this.stencilWriteMask),
                        (n.stencilFunc = this.stencilFunc),
                        (n.stencilRef = this.stencilRef),
                        (n.stencilFuncMask = this.stencilFuncMask),
                        (n.stencilFail = this.stencilFail),
                        (n.stencilZFail = this.stencilZFail),
                        (n.stencilZPass = this.stencilZPass),
                        this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                        !0 === this.polygonOffset && (n.polygonOffset = !0),
                        0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                        0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                        this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                        void 0 !== this.scale && (n.scale = this.scale),
                        !0 === this.dithering && (n.dithering = !0),
                        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                        !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
                        !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
                        !0 === this.wireframe && (n.wireframe = this.wireframe),
                        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                        'round' !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                        'round' !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                        !0 === this.flatShading && (n.flatShading = this.flatShading),
                        !1 === this.visible && (n.visible = !1),
                        !1 === this.toneMapped && (n.toneMapped = !1),
                        '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
                        e)
                    ) {
                        const e = i(t.textures),
                            r = i(t.images);
                        e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
                    }
                    return n;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    (this.name = t.name),
                        (this.fog = t.fog),
                        (this.blending = t.blending),
                        (this.side = t.side),
                        (this.vertexColors = t.vertexColors),
                        (this.opacity = t.opacity),
                        (this.format = t.format),
                        (this.transparent = t.transparent),
                        (this.blendSrc = t.blendSrc),
                        (this.blendDst = t.blendDst),
                        (this.blendEquation = t.blendEquation),
                        (this.blendSrcAlpha = t.blendSrcAlpha),
                        (this.blendDstAlpha = t.blendDstAlpha),
                        (this.blendEquationAlpha = t.blendEquationAlpha),
                        (this.depthFunc = t.depthFunc),
                        (this.depthTest = t.depthTest),
                        (this.depthWrite = t.depthWrite),
                        (this.stencilWriteMask = t.stencilWriteMask),
                        (this.stencilFunc = t.stencilFunc),
                        (this.stencilRef = t.stencilRef),
                        (this.stencilFuncMask = t.stencilFuncMask),
                        (this.stencilFail = t.stencilFail),
                        (this.stencilZFail = t.stencilZFail),
                        (this.stencilZPass = t.stencilZPass),
                        (this.stencilWrite = t.stencilWrite);
                    const e = t.clippingPlanes;
                    let n = null;
                    if (null !== e) {
                        const t = e.length;
                        n = new Array(t);
                        for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
                    }
                    return (
                        (this.clippingPlanes = n),
                        (this.clipIntersection = t.clipIntersection),
                        (this.clipShadows = t.clipShadows),
                        (this.shadowSide = t.shadowSide),
                        (this.colorWrite = t.colorWrite),
                        (this.precision = t.precision),
                        (this.polygonOffset = t.polygonOffset),
                        (this.polygonOffsetFactor = t.polygonOffsetFactor),
                        (this.polygonOffsetUnits = t.polygonOffsetUnits),
                        (this.dithering = t.dithering),
                        (this.alphaTest = t.alphaTest),
                        (this.alphaToCoverage = t.alphaToCoverage),
                        (this.premultipliedAlpha = t.premultipliedAlpha),
                        (this.visible = t.visible),
                        (this.toneMapped = t.toneMapped),
                        (this.userData = JSON.parse(JSON.stringify(t.userData))),
                        this
                    );
                }
                dispose() {
                    this.dispatchEvent({ type: 'dispose' });
                }
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
            }
            rn.prototype.isMaterial = !0;
            const sn = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074,
                },
                an = { h: 0, s: 0, l: 0 },
                on = { h: 0, s: 0, l: 0 };
            function ln(t, e, n) {
                return (
                    n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6 ? t + 6 * (e - t) * n : n < 0.5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                );
            }
            function cn(t) {
                return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
            }
            function hn(t) {
                return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
            }
            class un {
                constructor(t, e, n) {
                    return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
                }
                set(t) {
                    return (
                        t && t.isColor
                            ? this.copy(t)
                            : 'number' == typeof t
                            ? this.setHex(t)
                            : 'string' == typeof t && this.setStyle(t),
                        this
                    );
                }
                setScalar(t) {
                    return (this.r = t), (this.g = t), (this.b = t), this;
                }
                setHex(t) {
                    return (
                        (t = Math.floor(t)),
                        (this.r = ((t >> 16) & 255) / 255),
                        (this.g = ((t >> 8) & 255) / 255),
                        (this.b = (255 & t) / 255),
                        this
                    );
                }
                setRGB(t, e, n) {
                    return (this.r = t), (this.g = e), (this.b = n), this;
                }
                setHSL(t, e, n) {
                    if (((t = Mt(t, 1)), (e = _t(e, 0, 1)), (n = _t(n, 0, 1)), 0 === e)) this.r = this.g = this.b = n;
                    else {
                        const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                            r = 2 * n - i;
                        (this.r = ln(r, i, t + 1 / 3)), (this.g = ln(r, i, t)), (this.b = ln(r, i, t - 1 / 3));
                    }
                    return this;
                }
                setStyle(t) {
                    function e(e) {
                        void 0 !== e &&
                            parseFloat(e) < 1 &&
                            console.warn('THREE.Color: Alpha component of ' + t + ' will be ignored.');
                    }
                    let n;
                    if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
                        let t;
                        const i = n[1],
                            r = n[2];
                        switch (i) {
                            case 'rgb':
                            case 'rgba':
                                if ((t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)))
                                    return (
                                        (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                                        (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                                        (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                                        e(t[4]),
                                        this
                                    );
                                if ((t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)))
                                    return (
                                        (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                                        (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                                        (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                                        e(t[4]),
                                        this
                                    );
                                break;
                            case 'hsl':
                            case 'hsla':
                                if (
                                    (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                        r,
                                    ))
                                ) {
                                    const n = parseFloat(t[1]) / 360,
                                        i = parseInt(t[2], 10) / 100,
                                        r = parseInt(t[3], 10) / 100;
                                    return e(t[4]), this.setHSL(n, i, r);
                                }
                        }
                    } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
                        const t = n[1],
                            e = t.length;
                        if (3 === e)
                            return (
                                (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                                (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                                (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                                this
                            );
                        if (6 === e)
                            return (
                                (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                                (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                                (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                                this
                            );
                    }
                    return t && t.length > 0 ? this.setColorName(t) : this;
                }
                setColorName(t) {
                    const e = sn[t.toLowerCase()];
                    return void 0 !== e ? this.setHex(e) : console.warn('THREE.Color: Unknown color ' + t), this;
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b);
                }
                copy(t) {
                    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
                }
                copyGammaToLinear(t, e = 2) {
                    return (this.r = Math.pow(t.r, e)), (this.g = Math.pow(t.g, e)), (this.b = Math.pow(t.b, e)), this;
                }
                copyLinearToGamma(t, e = 2) {
                    const n = e > 0 ? 1 / e : 1;
                    return (this.r = Math.pow(t.r, n)), (this.g = Math.pow(t.g, n)), (this.b = Math.pow(t.b, n)), this;
                }
                convertGammaToLinear(t) {
                    return this.copyGammaToLinear(this, t), this;
                }
                convertLinearToGamma(t) {
                    return this.copyLinearToGamma(this, t), this;
                }
                copySRGBToLinear(t) {
                    return (this.r = cn(t.r)), (this.g = cn(t.g)), (this.b = cn(t.b)), this;
                }
                copyLinearToSRGB(t) {
                    return (this.r = hn(t.r)), (this.g = hn(t.g)), (this.b = hn(t.b)), this;
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this;
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this;
                }
                getHex() {
                    return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0);
                }
                getHexString() {
                    return ('000000' + this.getHex().toString(16)).slice(-6);
                }
                getHSL(t) {
                    const e = this.r,
                        n = this.g,
                        i = this.b,
                        r = Math.max(e, n, i),
                        s = Math.min(e, n, i);
                    let a, o;
                    const l = (s + r) / 2;
                    if (s === r) (a = 0), (o = 0);
                    else {
                        const t = r - s;
                        switch (((o = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {
                            case e:
                                a = (n - i) / t + (n < i ? 6 : 0);
                                break;
                            case n:
                                a = (i - e) / t + 2;
                                break;
                            case i:
                                a = (e - n) / t + 4;
                        }
                        a /= 6;
                    }
                    return (t.h = a), (t.s = o), (t.l = l), t;
                }
                getStyle() {
                    return (
                        'rgb(' + ((255 * this.r) | 0) + ',' + ((255 * this.g) | 0) + ',' + ((255 * this.b) | 0) + ')'
                    );
                }
                offsetHSL(t, e, n) {
                    return this.getHSL(an), (an.h += t), (an.s += e), (an.l += n), this.setHSL(an.h, an.s, an.l), this;
                }
                add(t) {
                    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
                }
                addColors(t, e) {
                    return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this;
                }
                addScalar(t) {
                    return (this.r += t), (this.g += t), (this.b += t), this;
                }
                sub(t) {
                    return (
                        (this.r = Math.max(0, this.r - t.r)),
                        (this.g = Math.max(0, this.g - t.g)),
                        (this.b = Math.max(0, this.b - t.b)),
                        this
                    );
                }
                multiply(t) {
                    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
                }
                multiplyScalar(t) {
                    return (this.r *= t), (this.g *= t), (this.b *= t), this;
                }
                lerp(t, e) {
                    return (
                        (this.r += (t.r - this.r) * e),
                        (this.g += (t.g - this.g) * e),
                        (this.b += (t.b - this.b) * e),
                        this
                    );
                }
                lerpColors(t, e, n) {
                    return (
                        (this.r = t.r + (e.r - t.r) * n),
                        (this.g = t.g + (e.g - t.g) * n),
                        (this.b = t.b + (e.b - t.b) * n),
                        this
                    );
                }
                lerpHSL(t, e) {
                    this.getHSL(an), t.getHSL(on);
                    const n = St(an.h, on.h, e),
                        i = St(an.s, on.s, e),
                        r = St(an.l, on.l, e);
                    return this.setHSL(n, i, r), this;
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b;
                }
                fromArray(t, e = 0) {
                    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
                }
                fromBufferAttribute(t, e) {
                    return (
                        (this.r = t.getX(e)),
                        (this.g = t.getY(e)),
                        (this.b = t.getZ(e)),
                        !0 === t.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
                        this
                    );
                }
                toJSON() {
                    return this.getHex();
                }
            }
            (un.NAMES = sn),
                (un.prototype.isColor = !0),
                (un.prototype.r = 1),
                (un.prototype.g = 1),
                (un.prototype.b = 1);
            class dn extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'MeshBasicMaterial'),
                        (this.color = new un(16777215)),
                        (this.map = null),
                        (this.lightMap = null),
                        (this.lightMapIntensity = 1),
                        (this.aoMap = null),
                        (this.aoMapIntensity = 1),
                        (this.specularMap = null),
                        (this.alphaMap = null),
                        (this.envMap = null),
                        (this.combine = 0),
                        (this.reflectivity = 1),
                        (this.refractionRatio = 0.98),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.wireframeLinecap = 'round'),
                        (this.wireframeLinejoin = 'round'),
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.color.copy(t.color),
                        (this.map = t.map),
                        (this.lightMap = t.lightMap),
                        (this.lightMapIntensity = t.lightMapIntensity),
                        (this.aoMap = t.aoMap),
                        (this.aoMapIntensity = t.aoMapIntensity),
                        (this.specularMap = t.specularMap),
                        (this.alphaMap = t.alphaMap),
                        (this.envMap = t.envMap),
                        (this.combine = t.combine),
                        (this.reflectivity = t.reflectivity),
                        (this.refractionRatio = t.refractionRatio),
                        (this.wireframe = t.wireframe),
                        (this.wireframeLinewidth = t.wireframeLinewidth),
                        (this.wireframeLinecap = t.wireframeLinecap),
                        (this.wireframeLinejoin = t.wireframeLinejoin),
                        this
                    );
                }
            }
            dn.prototype.isMeshBasicMaterial = !0;
            const pn = new Gt(),
                mn = new Rt();
            class fn {
                constructor(t, e, n) {
                    if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
                    (this.name = ''),
                        (this.array = t),
                        (this.itemSize = e),
                        (this.count = void 0 !== t ? t.length / e : 0),
                        (this.normalized = !0 === n),
                        (this.usage = 35044),
                        (this.updateRange = { offset: 0, count: -1 }),
                        (this.version = 0);
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
                setUsage(t) {
                    return (this.usage = t), this;
                }
                copy(t) {
                    return (
                        (this.name = t.name),
                        (this.array = new t.array.constructor(t.array)),
                        (this.itemSize = t.itemSize),
                        (this.count = t.count),
                        (this.normalized = t.normalized),
                        (this.usage = t.usage),
                        this
                    );
                }
                copyAt(t, e, n) {
                    (t *= this.itemSize), (n *= e.itemSize);
                    for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this;
                }
                copyArray(t) {
                    return this.array.set(t), this;
                }
                copyColorsArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r &&
                            (console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i),
                            (r = new un())),
                            (e[n++] = r.r),
                            (e[n++] = r.g),
                            (e[n++] = r.b);
                    }
                    return this;
                }
                copyVector2sArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r &&
                            (console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i),
                            (r = new Rt())),
                            (e[n++] = r.x),
                            (e[n++] = r.y);
                    }
                    return this;
                }
                copyVector3sArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r &&
                            (console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i),
                            (r = new Gt())),
                            (e[n++] = r.x),
                            (e[n++] = r.y),
                            (e[n++] = r.z);
                    }
                    return this;
                }
                copyVector4sArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r &&
                            (console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i),
                            (r = new kt())),
                            (e[n++] = r.x),
                            (e[n++] = r.y),
                            (e[n++] = r.z),
                            (e[n++] = r.w);
                    }
                    return this;
                }
                applyMatrix3(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++)
                            mn.fromBufferAttribute(this, e), mn.applyMatrix3(t), this.setXY(e, mn.x, mn.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++)
                            pn.fromBufferAttribute(this, e), pn.applyMatrix3(t), this.setXYZ(e, pn.x, pn.y, pn.z);
                    return this;
                }
                applyMatrix4(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        (pn.x = this.getX(e)),
                            (pn.y = this.getY(e)),
                            (pn.z = this.getZ(e)),
                            pn.applyMatrix4(t),
                            this.setXYZ(e, pn.x, pn.y, pn.z);
                    return this;
                }
                applyNormalMatrix(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        (pn.x = this.getX(e)),
                            (pn.y = this.getY(e)),
                            (pn.z = this.getZ(e)),
                            pn.applyNormalMatrix(t),
                            this.setXYZ(e, pn.x, pn.y, pn.z);
                    return this;
                }
                transformDirection(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        (pn.x = this.getX(e)),
                            (pn.y = this.getY(e)),
                            (pn.z = this.getZ(e)),
                            pn.transformDirection(t),
                            this.setXYZ(e, pn.x, pn.y, pn.z);
                    return this;
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this;
                }
                getX(t) {
                    return this.array[t * this.itemSize];
                }
                setX(t, e) {
                    return (this.array[t * this.itemSize] = e), this;
                }
                getY(t) {
                    return this.array[t * this.itemSize + 1];
                }
                setY(t, e) {
                    return (this.array[t * this.itemSize + 1] = e), this;
                }
                getZ(t) {
                    return this.array[t * this.itemSize + 2];
                }
                setZ(t, e) {
                    return (this.array[t * this.itemSize + 2] = e), this;
                }
                getW(t) {
                    return this.array[t * this.itemSize + 3];
                }
                setW(t, e) {
                    return (this.array[t * this.itemSize + 3] = e), this;
                }
                setXY(t, e, n) {
                    return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = n), this;
                }
                setXYZ(t, e, n, i) {
                    return (
                        (t *= this.itemSize),
                        (this.array[t + 0] = e),
                        (this.array[t + 1] = n),
                        (this.array[t + 2] = i),
                        this
                    );
                }
                setXYZW(t, e, n, i, r) {
                    return (
                        (t *= this.itemSize),
                        (this.array[t + 0] = e),
                        (this.array[t + 1] = n),
                        (this.array[t + 2] = i),
                        (this.array[t + 3] = r),
                        this
                    );
                }
                onUpload(t) {
                    return (this.onUploadCallback = t), this;
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this);
                }
                toJSON() {
                    const t = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized,
                    };
                    return (
                        '' !== this.name && (t.name = this.name),
                        35044 !== this.usage && (t.usage = this.usage),
                        (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
                            (t.updateRange = this.updateRange),
                        t
                    );
                }
            }
            fn.prototype.isBufferAttribute = !0;
            class gn extends fn {
                constructor(t, e, n) {
                    super(new Uint16Array(t), e, n);
                }
            }
            class vn extends fn {
                constructor(t, e, n) {
                    super(new Uint32Array(t), e, n);
                }
            }
            (class extends fn {
                constructor(t, e, n) {
                    super(new Uint16Array(t), e, n);
                }
            }.prototype.isFloat16BufferAttribute = !0);
            class yn extends fn {
                constructor(t, e, n) {
                    super(new Float32Array(t), e, n);
                }
            }
            let xn = 0;
            const bn = new xe(),
                wn = new We(),
                _n = new Gt(),
                Mn = new jt(),
                Sn = new jt(),
                Tn = new Gt();
            class En extends ft {
                constructor() {
                    super(),
                        Object.defineProperty(this, 'id', { value: xn++ }),
                        (this.uuid = wt()),
                        (this.name = ''),
                        (this.type = 'BufferGeometry'),
                        (this.index = null),
                        (this.attributes = {}),
                        (this.morphAttributes = {}),
                        (this.morphTargetsRelative = !1),
                        (this.groups = []),
                        (this.boundingBox = null),
                        (this.boundingSphere = null),
                        (this.drawRange = { start: 0, count: 1 / 0 }),
                        (this.userData = {});
                }
                getIndex() {
                    return this.index;
                }
                setIndex(t) {
                    return (
                        Array.isArray(t) ? (this.index = new (Pt(t) > 65535 ? vn : gn)(t, 1)) : (this.index = t), this
                    );
                }
                getAttribute(t) {
                    return this.attributes[t];
                }
                setAttribute(t, e) {
                    return (this.attributes[t] = e), this;
                }
                deleteAttribute(t) {
                    return delete this.attributes[t], this;
                }
                hasAttribute(t) {
                    return void 0 !== this.attributes[t];
                }
                addGroup(t, e, n = 0) {
                    this.groups.push({ start: t, count: e, materialIndex: n });
                }
                clearGroups() {
                    this.groups = [];
                }
                setDrawRange(t, e) {
                    (this.drawRange.start = t), (this.drawRange.count = e);
                }
                applyMatrix4(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const e = new Ct().getNormalMatrix(t);
                        n.applyNormalMatrix(e), (n.needsUpdate = !0);
                    }
                    const i = this.attributes.tangent;
                    return (
                        void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
                        null !== this.boundingBox && this.computeBoundingBox(),
                        null !== this.boundingSphere && this.computeBoundingSphere(),
                        this
                    );
                }
                applyQuaternion(t) {
                    return bn.makeRotationFromQuaternion(t), this.applyMatrix4(bn), this;
                }
                rotateX(t) {
                    return bn.makeRotationX(t), this.applyMatrix4(bn), this;
                }
                rotateY(t) {
                    return bn.makeRotationY(t), this.applyMatrix4(bn), this;
                }
                rotateZ(t) {
                    return bn.makeRotationZ(t), this.applyMatrix4(bn), this;
                }
                translate(t, e, n) {
                    return bn.makeTranslation(t, e, n), this.applyMatrix4(bn), this;
                }
                scale(t, e, n) {
                    return bn.makeScale(t, e, n), this.applyMatrix4(bn), this;
                }
                lookAt(t) {
                    return wn.lookAt(t), wn.updateMatrix(), this.applyMatrix4(wn.matrix), this;
                }
                center() {
                    return (
                        this.computeBoundingBox(),
                        this.boundingBox.getCenter(_n).negate(),
                        this.translate(_n.x, _n.y, _n.z),
                        this
                    );
                }
                setFromPoints(t) {
                    const e = [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.push(i.x, i.y, i.z || 0);
                    }
                    return this.setAttribute('position', new yn(e, 3)), this;
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new jt());
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute)
                        return (
                            console.error(
                                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                                this,
                            ),
                            void this.boundingBox.set(new Gt(-1 / 0, -1 / 0, -1 / 0), new Gt(1 / 0, 1 / 0, 1 / 0))
                        );
                    if (void 0 !== t) {
                        if ((this.boundingBox.setFromBufferAttribute(t), e))
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                Mn.setFromBufferAttribute(n),
                                    this.morphTargetsRelative
                                        ? (Tn.addVectors(this.boundingBox.min, Mn.min),
                                          this.boundingBox.expandByPoint(Tn),
                                          Tn.addVectors(this.boundingBox.max, Mn.max),
                                          this.boundingBox.expandByPoint(Tn))
                                        : (this.boundingBox.expandByPoint(Mn.min),
                                          this.boundingBox.expandByPoint(Mn.max));
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
                        console.error(
                            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                            this,
                        );
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new he());
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute)
                        return (
                            console.error(
                                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                                this,
                            ),
                            void this.boundingSphere.set(new Gt(), 1 / 0)
                        );
                    if (t) {
                        const n = this.boundingSphere.center;
                        if ((Mn.setFromBufferAttribute(t), e))
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                Sn.setFromBufferAttribute(n),
                                    this.morphTargetsRelative
                                        ? (Tn.addVectors(Mn.min, Sn.min),
                                          Mn.expandByPoint(Tn),
                                          Tn.addVectors(Mn.max, Sn.max),
                                          Mn.expandByPoint(Tn))
                                        : (Mn.expandByPoint(Sn.min), Mn.expandByPoint(Sn.max));
                            }
                        Mn.getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.count; e < r; e++)
                            Tn.fromBufferAttribute(t, e), (i = Math.max(i, n.distanceToSquared(Tn)));
                        if (e)
                            for (let r = 0, s = e.length; r < s; r++) {
                                const s = e[r],
                                    a = this.morphTargetsRelative;
                                for (let e = 0, r = s.count; e < r; e++)
                                    Tn.fromBufferAttribute(s, e),
                                        a && (_n.fromBufferAttribute(t, e), Tn.add(_n)),
                                        (i = Math.max(i, n.distanceToSquared(Tn)));
                            }
                        (this.boundingSphere.radius = Math.sqrt(i)),
                            isNaN(this.boundingSphere.radius) &&
                                console.error(
                                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                                    this,
                                );
                    }
                }
                computeTangents() {
                    const t = this.index,
                        e = this.attributes;
                    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                        return void console.error(
                            'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
                        );
                    const n = t.array,
                        i = e.position.array,
                        r = e.normal.array,
                        s = e.uv.array,
                        a = i.length / 3;
                    void 0 === e.tangent && this.setAttribute('tangent', new fn(new Float32Array(4 * a), 4));
                    const o = e.tangent.array,
                        l = [],
                        c = [];
                    for (let t = 0; t < a; t++) (l[t] = new Gt()), (c[t] = new Gt());
                    const h = new Gt(),
                        u = new Gt(),
                        d = new Gt(),
                        p = new Rt(),
                        m = new Rt(),
                        f = new Rt(),
                        g = new Gt(),
                        v = new Gt();
                    function y(t, e, n) {
                        h.fromArray(i, 3 * t),
                            u.fromArray(i, 3 * e),
                            d.fromArray(i, 3 * n),
                            p.fromArray(s, 2 * t),
                            m.fromArray(s, 2 * e),
                            f.fromArray(s, 2 * n),
                            u.sub(h),
                            d.sub(h),
                            m.sub(p),
                            f.sub(p);
                        const r = 1 / (m.x * f.y - f.x * m.y);
                        isFinite(r) &&
                            (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r),
                            v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r),
                            l[t].add(g),
                            l[e].add(g),
                            l[n].add(g),
                            c[t].add(v),
                            c[e].add(v),
                            c[n].add(v));
                    }
                    let x = this.groups;
                    0 === x.length && (x = [{ start: 0, count: n.length }]);
                    for (let t = 0, e = x.length; t < e; ++t) {
                        const e = x[t],
                            i = e.start;
                        for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2]);
                    }
                    const b = new Gt(),
                        w = new Gt(),
                        _ = new Gt(),
                        M = new Gt();
                    function S(t) {
                        _.fromArray(r, 3 * t), M.copy(_);
                        const e = l[t];
                        b.copy(e), b.sub(_.multiplyScalar(_.dot(e))).normalize(), w.crossVectors(M, e);
                        const n = w.dot(c[t]) < 0 ? -1 : 1;
                        (o[4 * t] = b.x), (o[4 * t + 1] = b.y), (o[4 * t + 2] = b.z), (o[4 * t + 3] = n);
                    }
                    for (let t = 0, e = x.length; t < e; ++t) {
                        const e = x[t],
                            i = e.start;
                        for (let t = i, r = i + e.count; t < r; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);
                    }
                }
                computeVertexNormals() {
                    const t = this.index,
                        e = this.getAttribute('position');
                    if (void 0 !== e) {
                        let n = this.getAttribute('normal');
                        if (void 0 === n)
                            (n = new fn(new Float32Array(3 * e.count), 3)), this.setAttribute('normal', n);
                        else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                        const i = new Gt(),
                            r = new Gt(),
                            s = new Gt(),
                            a = new Gt(),
                            o = new Gt(),
                            l = new Gt(),
                            c = new Gt(),
                            h = new Gt();
                        if (t)
                            for (let u = 0, d = t.count; u < d; u += 3) {
                                const d = t.getX(u + 0),
                                    p = t.getX(u + 1),
                                    m = t.getX(u + 2);
                                i.fromBufferAttribute(e, d),
                                    r.fromBufferAttribute(e, p),
                                    s.fromBufferAttribute(e, m),
                                    c.subVectors(s, r),
                                    h.subVectors(i, r),
                                    c.cross(h),
                                    a.fromBufferAttribute(n, d),
                                    o.fromBufferAttribute(n, p),
                                    l.fromBufferAttribute(n, m),
                                    a.add(c),
                                    o.add(c),
                                    l.add(c),
                                    n.setXYZ(d, a.x, a.y, a.z),
                                    n.setXYZ(p, o.x, o.y, o.z),
                                    n.setXYZ(m, l.x, l.y, l.z);
                            }
                        else
                            for (let t = 0, a = e.count; t < a; t += 3)
                                i.fromBufferAttribute(e, t + 0),
                                    r.fromBufferAttribute(e, t + 1),
                                    s.fromBufferAttribute(e, t + 2),
                                    c.subVectors(s, r),
                                    h.subVectors(i, r),
                                    c.cross(h),
                                    n.setXYZ(t + 0, c.x, c.y, c.z),
                                    n.setXYZ(t + 1, c.x, c.y, c.z),
                                    n.setXYZ(t + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), (n.needsUpdate = !0);
                    }
                }
                merge(t, e) {
                    if (!t || !t.isBufferGeometry)
                        return void console.error(
                            'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
                            t,
                        );
                    void 0 === e &&
                        ((e = 0),
                        console.warn(
                            'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
                        ));
                    const n = this.attributes;
                    for (const i in n) {
                        if (void 0 === t.attributes[i]) continue;
                        const r = n[i].array,
                            s = t.attributes[i],
                            a = s.array,
                            o = s.itemSize * e,
                            l = Math.min(a.length, r.length - o);
                        for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t];
                    }
                    return this;
                }
                normalizeNormals() {
                    const t = this.attributes.normal;
                    for (let e = 0, n = t.count; e < n; e++)
                        Tn.fromBufferAttribute(t, e), Tn.normalize(), t.setXYZ(e, Tn.x, Tn.y, Tn.z);
                }
                toNonIndexed() {
                    function t(t, e) {
                        const n = t.array,
                            i = t.itemSize,
                            r = t.normalized,
                            s = new n.constructor(e.length * i);
                        let a = 0,
                            o = 0;
                        for (let r = 0, l = e.length; r < l; r++) {
                            a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                            for (let t = 0; t < i; t++) s[o++] = n[a++];
                        }
                        return new fn(s, i, r);
                    }
                    if (null === this.index)
                        return (
                            console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'),
                            this
                        );
                    const e = new En(),
                        n = this.index.array,
                        i = this.attributes;
                    for (const r in i) {
                        const s = t(i[r], n);
                        e.setAttribute(r, s);
                    }
                    const r = this.morphAttributes;
                    for (const i in r) {
                        const s = [],
                            a = r[i];
                        for (let e = 0, i = a.length; e < i; e++) {
                            const i = t(a[e], n);
                            s.push(i);
                        }
                        e.morphAttributes[i] = s;
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let t = 0, n = s.length; t < n; t++) {
                        const n = s[t];
                        e.addGroup(n.start, n.count, n.materialIndex);
                    }
                    return e;
                }
                toJSON() {
                    const t = {
                        metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' },
                    };
                    if (
                        ((t.uuid = this.uuid),
                        (t.type = this.type),
                        '' !== this.name && (t.name = this.name),
                        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                        void 0 !== this.parameters)
                    ) {
                        const e = this.parameters;
                        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t;
                    }
                    t.data = { attributes: {} };
                    const e = this.index;
                    null !== e &&
                        (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
                    const n = this.attributes;
                    for (const e in n) {
                        const i = n[e];
                        t.data.attributes[e] = i.toJSON(t.data);
                    }
                    const i = {};
                    let r = !1;
                    for (const e in this.morphAttributes) {
                        const n = this.morphAttributes[e],
                            s = [];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            s.push(i.toJSON(t.data));
                        }
                        s.length > 0 && ((i[e] = s), (r = !0));
                    }
                    r && ((t.data.morphAttributes = i), (t.data.morphTargetsRelative = this.morphTargetsRelative));
                    const s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    const a = this.boundingSphere;
                    return null !== a && (t.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), t;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    (this.index = null),
                        (this.attributes = {}),
                        (this.morphAttributes = {}),
                        (this.groups = []),
                        (this.boundingBox = null),
                        (this.boundingSphere = null);
                    const e = {};
                    this.name = t.name;
                    const n = t.index;
                    null !== n && this.setIndex(n.clone(e));
                    const i = t.attributes;
                    for (const t in i) {
                        const n = i[t];
                        this.setAttribute(t, n.clone(e));
                    }
                    const r = t.morphAttributes;
                    for (const t in r) {
                        const n = [],
                            i = r[t];
                        for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                        this.morphAttributes[t] = n;
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const s = t.groups;
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t];
                        this.addGroup(e.start, e.count, e.materialIndex);
                    }
                    const a = t.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    const o = t.boundingSphere;
                    return (
                        null !== o && (this.boundingSphere = o.clone()),
                        (this.drawRange.start = t.drawRange.start),
                        (this.drawRange.count = t.drawRange.count),
                        (this.userData = t.userData),
                        void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)),
                        this
                    );
                }
                dispose() {
                    this.dispatchEvent({ type: 'dispose' });
                }
            }
            En.prototype.isBufferGeometry = !0;
            const An = new xe(),
                Ln = new ye(),
                Rn = new he(),
                Cn = new Gt(),
                Pn = new Gt(),
                In = new Gt(),
                Dn = new Gt(),
                Nn = new Gt(),
                Fn = new Gt(),
                On = new Gt(),
                Un = new Gt(),
                kn = new Gt(),
                zn = new Rt(),
                Bn = new Rt(),
                Hn = new Rt(),
                Gn = new Gt(),
                Vn = new Gt();
            class Wn extends We {
                constructor(t = new En(), e = new dn()) {
                    super(), (this.type = 'Mesh'), (this.geometry = t), (this.material = e), this.updateMorphTargets();
                }
                copy(t) {
                    return (
                        super.copy(t),
                        void 0 !== t.morphTargetInfluences &&
                            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                        void 0 !== t.morphTargetDictionary &&
                            (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                        (this.material = t.material),
                        (this.geometry = t.geometry),
                        this
                    );
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e &&
                            e.length > 0 &&
                            console.error(
                                'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                            );
                    }
                }
                raycast(t, e) {
                    const n = this.geometry,
                        i = this.material,
                        r = this.matrixWorld;
                    if (void 0 === i) return;
                    if (
                        (null === n.boundingSphere && n.computeBoundingSphere(),
                        Rn.copy(n.boundingSphere),
                        Rn.applyMatrix4(r),
                        !1 === t.ray.intersectsSphere(Rn))
                    )
                        return;
                    if (
                        (An.copy(r).invert(),
                        Ln.copy(t.ray).applyMatrix4(An),
                        null !== n.boundingBox && !1 === Ln.intersectsBox(n.boundingBox))
                    )
                        return;
                    let s;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            a = n.attributes.position,
                            o = n.morphAttributes.position,
                            l = n.morphTargetsRelative,
                            c = n.attributes.uv,
                            h = n.attributes.uv2,
                            u = n.groups,
                            d = n.drawRange;
                        if (null !== r)
                            if (Array.isArray(i))
                                for (let n = 0, p = u.length; n < p; n++) {
                                    const p = u[n],
                                        m = i[p.materialIndex];
                                    for (
                                        let n = Math.max(p.start, d.start),
                                            i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count));
                                        n < i;
                                        n += 3
                                    ) {
                                        const i = r.getX(n),
                                            u = r.getX(n + 1),
                                            d = r.getX(n + 2);
                                        (s = jn(this, m, t, Ln, a, o, l, c, h, i, u, d)),
                                            s &&
                                                ((s.faceIndex = Math.floor(n / 3)),
                                                (s.face.materialIndex = p.materialIndex),
                                                e.push(s));
                                    }
                                }
                            else
                                for (
                                    let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count);
                                    n < u;
                                    n += 3
                                ) {
                                    const u = r.getX(n),
                                        d = r.getX(n + 1),
                                        p = r.getX(n + 2);
                                    (s = jn(this, i, t, Ln, a, o, l, c, h, u, d, p)),
                                        s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
                                }
                        else if (void 0 !== a)
                            if (Array.isArray(i))
                                for (let n = 0, r = u.length; n < r; n++) {
                                    const r = u[n],
                                        p = i[r.materialIndex];
                                    for (
                                        let n = Math.max(r.start, d.start),
                                            i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count));
                                        n < i;
                                        n += 3
                                    )
                                        (s = jn(this, p, t, Ln, a, o, l, c, h, n, n + 1, n + 2)),
                                            s &&
                                                ((s.faceIndex = Math.floor(n / 3)),
                                                (s.face.materialIndex = r.materialIndex),
                                                e.push(s));
                                }
                            else
                                for (
                                    let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count);
                                    n < r;
                                    n += 3
                                )
                                    (s = jn(this, i, t, Ln, a, o, l, c, h, n, n + 1, n + 2)),
                                        s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
                    } else
                        n.isGeometry &&
                            console.error(
                                'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                            );
                }
            }
            function jn(t, e, n, i, r, s, a, o, l, c, h, u) {
                Cn.fromBufferAttribute(r, c), Pn.fromBufferAttribute(r, h), In.fromBufferAttribute(r, u);
                const d = t.morphTargetInfluences;
                if (s && d) {
                    On.set(0, 0, 0), Un.set(0, 0, 0), kn.set(0, 0, 0);
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = d[t],
                            n = s[t];
                        0 !== e &&
                            (Dn.fromBufferAttribute(n, c),
                            Nn.fromBufferAttribute(n, h),
                            Fn.fromBufferAttribute(n, u),
                            a
                                ? (On.addScaledVector(Dn, e), Un.addScaledVector(Nn, e), kn.addScaledVector(Fn, e))
                                : (On.addScaledVector(Dn.sub(Cn), e),
                                  Un.addScaledVector(Nn.sub(Pn), e),
                                  kn.addScaledVector(Fn.sub(In), e)));
                    }
                    Cn.add(On), Pn.add(Un), In.add(kn);
                }
                t.isSkinnedMesh && (t.boneTransform(c, Cn), t.boneTransform(h, Pn), t.boneTransform(u, In));
                const p = (function (t, e, n, i, r, s, a, o) {
                    let l;
                    if (
                        ((l =
                            1 === e.side
                                ? i.intersectTriangle(a, s, r, !0, o)
                                : i.intersectTriangle(r, s, a, 2 !== e.side, o)),
                        null === l)
                    )
                        return null;
                    Vn.copy(o), Vn.applyMatrix4(t.matrixWorld);
                    const c = n.ray.origin.distanceTo(Vn);
                    return c < n.near || c > n.far ? null : { distance: c, point: Vn.clone(), object: t };
                })(t, e, n, i, Cn, Pn, In, Gn);
                if (p) {
                    o &&
                        (zn.fromBufferAttribute(o, c),
                        Bn.fromBufferAttribute(o, h),
                        Hn.fromBufferAttribute(o, u),
                        (p.uv = en.getUV(Gn, Cn, Pn, In, zn, Bn, Hn, new Rt()))),
                        l &&
                            (zn.fromBufferAttribute(l, c),
                            Bn.fromBufferAttribute(l, h),
                            Hn.fromBufferAttribute(l, u),
                            (p.uv2 = en.getUV(Gn, Cn, Pn, In, zn, Bn, Hn, new Rt())));
                    const t = { a: c, b: h, c: u, normal: new Gt(), materialIndex: 0 };
                    en.getNormal(Cn, Pn, In, t.normal), (p.face = t);
                }
                return p;
            }
            Wn.prototype.isMesh = !0;
            class qn extends En {
                constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                    super(),
                        (this.type = 'BoxGeometry'),
                        (this.parameters = {
                            width: t,
                            height: e,
                            depth: n,
                            widthSegments: i,
                            heightSegments: r,
                            depthSegments: s,
                        });
                    const a = this;
                    (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
                    const o = [],
                        l = [],
                        c = [],
                        h = [];
                    let u = 0,
                        d = 0;
                    function p(t, e, n, i, r, s, p, m, f, g, v) {
                        const y = s / f,
                            x = p / g,
                            b = s / 2,
                            w = p / 2,
                            _ = m / 2,
                            M = f + 1,
                            S = g + 1;
                        let T = 0,
                            E = 0;
                        const A = new Gt();
                        for (let s = 0; s < S; s++) {
                            const a = s * x - w;
                            for (let o = 0; o < M; o++) {
                                const u = o * y - b;
                                (A[t] = u * i),
                                    (A[e] = a * r),
                                    (A[n] = _),
                                    l.push(A.x, A.y, A.z),
                                    (A[t] = 0),
                                    (A[e] = 0),
                                    (A[n] = m > 0 ? 1 : -1),
                                    c.push(A.x, A.y, A.z),
                                    h.push(o / f),
                                    h.push(1 - s / g),
                                    (T += 1);
                            }
                        }
                        for (let t = 0; t < g; t++)
                            for (let e = 0; e < f; e++) {
                                const n = u + e + M * t,
                                    i = u + e + M * (t + 1),
                                    r = u + (e + 1) + M * (t + 1),
                                    s = u + (e + 1) + M * t;
                                o.push(n, i, s), o.push(i, r, s), (E += 6);
                            }
                        a.addGroup(d, E, v), (d += E), (u += T);
                    }
                    p('z', 'y', 'x', -1, -1, n, e, t, s, r, 0),
                        p('z', 'y', 'x', 1, -1, n, e, -t, s, r, 1),
                        p('x', 'z', 'y', 1, 1, t, n, e, i, s, 2),
                        p('x', 'z', 'y', 1, -1, t, n, -e, i, s, 3),
                        p('x', 'y', 'z', 1, -1, t, e, n, i, r, 4),
                        p('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5),
                        this.setIndex(o),
                        this.setAttribute('position', new yn(l, 3)),
                        this.setAttribute('normal', new yn(c, 3)),
                        this.setAttribute('uv', new yn(h, 2));
                }
                static fromJSON(t) {
                    return new qn(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
                }
            }
            function Xn(t) {
                const e = {};
                for (const n in t) {
                    e[n] = {};
                    for (const i in t[n]) {
                        const r = t[n][i];
                        r &&
                        (r.isColor ||
                            r.isMatrix3 ||
                            r.isMatrix4 ||
                            r.isVector2 ||
                            r.isVector3 ||
                            r.isVector4 ||
                            r.isTexture ||
                            r.isQuaternion)
                            ? (e[n][i] = r.clone())
                            : Array.isArray(r)
                            ? (e[n][i] = r.slice())
                            : (e[n][i] = r);
                    }
                }
                return e;
            }
            function Yn(t) {
                const e = {};
                for (let n = 0; n < t.length; n++) {
                    const i = Xn(t[n]);
                    for (const t in i) e[t] = i[t];
                }
                return e;
            }
            const Zn = { clone: Xn, merge: Yn };
            class Jn extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'ShaderMaterial'),
                        (this.defines = {}),
                        (this.uniforms = {}),
                        (this.vertexShader =
                            'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
                        (this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
                        (this.linewidth = 1),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.fog = !1),
                        (this.lights = !1),
                        (this.clipping = !1),
                        (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
                        (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
                        (this.index0AttributeName = void 0),
                        (this.uniformsNeedUpdate = !1),
                        (this.glslVersion = null),
                        void 0 !== t &&
                            (void 0 !== t.attributes &&
                                console.error(
                                    'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',
                                ),
                            this.setValues(t));
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.fragmentShader = t.fragmentShader),
                        (this.vertexShader = t.vertexShader),
                        (this.uniforms = Xn(t.uniforms)),
                        (this.defines = Object.assign({}, t.defines)),
                        (this.wireframe = t.wireframe),
                        (this.wireframeLinewidth = t.wireframeLinewidth),
                        (this.lights = t.lights),
                        (this.clipping = t.clipping),
                        (this.extensions = Object.assign({}, t.extensions)),
                        (this.glslVersion = t.glslVersion),
                        this
                    );
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    (e.glslVersion = this.glslVersion), (e.uniforms = {});
                    for (const n in this.uniforms) {
                        const i = this.uniforms[n].value;
                        i && i.isTexture
                            ? (e.uniforms[n] = { type: 't', value: i.toJSON(t).uuid })
                            : i && i.isColor
                            ? (e.uniforms[n] = { type: 'c', value: i.getHex() })
                            : i && i.isVector2
                            ? (e.uniforms[n] = { type: 'v2', value: i.toArray() })
                            : i && i.isVector3
                            ? (e.uniforms[n] = { type: 'v3', value: i.toArray() })
                            : i && i.isVector4
                            ? (e.uniforms[n] = { type: 'v4', value: i.toArray() })
                            : i && i.isMatrix3
                            ? (e.uniforms[n] = { type: 'm3', value: i.toArray() })
                            : i && i.isMatrix4
                            ? (e.uniforms[n] = { type: 'm4', value: i.toArray() })
                            : (e.uniforms[n] = { value: i });
                    }
                    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                        (e.vertexShader = this.vertexShader),
                        (e.fragmentShader = this.fragmentShader);
                    const n = {};
                    for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                    return Object.keys(n).length > 0 && (e.extensions = n), e;
                }
            }
            Jn.prototype.isShaderMaterial = !0;
            class $n extends We {
                constructor() {
                    super(),
                        (this.type = 'Camera'),
                        (this.matrixWorldInverse = new xe()),
                        (this.projectionMatrix = new xe()),
                        (this.projectionMatrixInverse = new xe());
                }
                copy(t, e) {
                    return (
                        super.copy(t, e),
                        this.matrixWorldInverse.copy(t.matrixWorldInverse),
                        this.projectionMatrix.copy(t.projectionMatrix),
                        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                        this
                    );
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize();
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
                updateWorldMatrix(t, e) {
                    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            $n.prototype.isCamera = !0;
            class Kn extends $n {
                constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
                    super(),
                        (this.type = 'PerspectiveCamera'),
                        (this.fov = t),
                        (this.zoom = 1),
                        (this.near = n),
                        (this.far = i),
                        (this.focus = 10),
                        (this.aspect = e),
                        (this.view = null),
                        (this.filmGauge = 35),
                        (this.filmOffset = 0),
                        this.updateProjectionMatrix();
                }
                copy(t, e) {
                    return (
                        super.copy(t, e),
                        (this.fov = t.fov),
                        (this.zoom = t.zoom),
                        (this.near = t.near),
                        (this.far = t.far),
                        (this.focus = t.focus),
                        (this.aspect = t.aspect),
                        (this.view = null === t.view ? null : Object.assign({}, t.view)),
                        (this.filmGauge = t.filmGauge),
                        (this.filmOffset = t.filmOffset),
                        this
                    );
                }
                setFocalLength(t) {
                    const e = (0.5 * this.getFilmHeight()) / t;
                    (this.fov = 2 * yt * Math.atan(e)), this.updateProjectionMatrix();
                }
                getFocalLength() {
                    const t = Math.tan(0.5 * vt * this.fov);
                    return (0.5 * this.getFilmHeight()) / t;
                }
                getEffectiveFOV() {
                    return 2 * yt * Math.atan(Math.tan(0.5 * vt * this.fov) / this.zoom);
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1);
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1);
                }
                setViewOffset(t, e, n, i, r, s) {
                    (this.aspect = t / e),
                        null === this.view &&
                            (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1,
                            }),
                        (this.view.enabled = !0),
                        (this.view.fullWidth = t),
                        (this.view.fullHeight = e),
                        (this.view.offsetX = n),
                        (this.view.offsetY = i),
                        (this.view.width = r),
                        (this.view.height = s),
                        this.updateProjectionMatrix();
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
                }
                updateProjectionMatrix() {
                    const t = this.near;
                    let e = (t * Math.tan(0.5 * vt * this.fov)) / this.zoom,
                        n = 2 * e,
                        i = this.aspect * n,
                        r = -0.5 * i;
                    const s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = s.fullWidth,
                            a = s.fullHeight;
                        (r += (s.offsetX * i) / t), (e -= (s.offsetY * n) / a), (i *= s.width / t), (n *= s.height / a);
                    }
                    const a = this.filmOffset;
                    0 !== a && (r += (t * a) / this.getFilmWidth()),
                        this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                        (e.object.fov = this.fov),
                        (e.object.zoom = this.zoom),
                        (e.object.near = this.near),
                        (e.object.far = this.far),
                        (e.object.focus = this.focus),
                        (e.object.aspect = this.aspect),
                        null !== this.view && (e.object.view = Object.assign({}, this.view)),
                        (e.object.filmGauge = this.filmGauge),
                        (e.object.filmOffset = this.filmOffset),
                        e
                    );
                }
            }
            Kn.prototype.isPerspectiveCamera = !0;
            class Qn extends We {
                constructor(t, e, n) {
                    if ((super(), (this.type = 'CubeCamera'), !0 !== n.isWebGLCubeRenderTarget))
                        return void console.error(
                            'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.',
                        );
                    this.renderTarget = n;
                    const i = new Kn(90, 1, t, e);
                    (i.layers = this.layers), i.up.set(0, -1, 0), i.lookAt(new Gt(1, 0, 0)), this.add(i);
                    const r = new Kn(90, 1, t, e);
                    (r.layers = this.layers), r.up.set(0, -1, 0), r.lookAt(new Gt(-1, 0, 0)), this.add(r);
                    const s = new Kn(90, 1, t, e);
                    (s.layers = this.layers), s.up.set(0, 0, 1), s.lookAt(new Gt(0, 1, 0)), this.add(s);
                    const a = new Kn(90, 1, t, e);
                    (a.layers = this.layers), a.up.set(0, 0, -1), a.lookAt(new Gt(0, -1, 0)), this.add(a);
                    const o = new Kn(90, 1, t, e);
                    (o.layers = this.layers), o.up.set(0, -1, 0), o.lookAt(new Gt(0, 0, 1)), this.add(o);
                    const l = new Kn(90, 1, t, e);
                    (l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new Gt(0, 0, -1)), this.add(l);
                }
                update(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const n = this.renderTarget,
                        [i, r, s, a, o, l] = this.children,
                        c = t.xr.enabled,
                        h = t.getRenderTarget();
                    t.xr.enabled = !1;
                    const u = n.texture.generateMipmaps;
                    (n.texture.generateMipmaps = !1),
                        t.setRenderTarget(n, 0),
                        t.render(e, i),
                        t.setRenderTarget(n, 1),
                        t.render(e, r),
                        t.setRenderTarget(n, 2),
                        t.render(e, s),
                        t.setRenderTarget(n, 3),
                        t.render(e, a),
                        t.setRenderTarget(n, 4),
                        t.render(e, o),
                        (n.texture.generateMipmaps = u),
                        t.setRenderTarget(n, 5),
                        t.render(e, l),
                        t.setRenderTarget(h),
                        (t.xr.enabled = c);
                }
            }
            class ti extends Ot {
                constructor(t, e, n, i, r, s, a, o, l, c) {
                    super((t = void 0 !== t ? t : []), (e = void 0 !== e ? e : 301), n, i, r, s, a, o, l, c),
                        (this.flipY = !1);
                }
                get images() {
                    return this.image;
                }
                set images(t) {
                    this.image = t;
                }
            }
            ti.prototype.isCubeTexture = !0;
            class ei extends zt {
                constructor(t, e, n) {
                    Number.isInteger(e) &&
                        (console.warn(
                            'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )',
                        ),
                        (e = n)),
                        super(t, t, e),
                        (e = e || {}),
                        (this.texture = new ti(
                            void 0,
                            e.mapping,
                            e.wrapS,
                            e.wrapT,
                            e.magFilter,
                            e.minFilter,
                            e.format,
                            e.type,
                            e.anisotropy,
                            e.encoding,
                        )),
                        (this.texture.isRenderTargetTexture = !0),
                        (this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
                        (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006),
                        (this.texture._needsFlipEnvMap = !1);
                }
                fromEquirectangularTexture(t, e) {
                    (this.texture.type = e.type),
                        (this.texture.format = 1023),
                        (this.texture.encoding = e.encoding),
                        (this.texture.generateMipmaps = e.generateMipmaps),
                        (this.texture.minFilter = e.minFilter),
                        (this.texture.magFilter = e.magFilter);
                    const n = new qn(5, 5, 5),
                        i = new Jn({
                            name: 'CubemapFromEquirect',
                            uniforms: Xn({ tEquirect: { value: null } }),
                            vertexShader:
                                '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
                            fragmentShader:
                                '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t',
                            side: 1,
                            blending: 0,
                        });
                    i.uniforms.tEquirect.value = e;
                    const r = new Wn(n, i),
                        s = e.minFilter;
                    return (
                        1008 === e.minFilter && (e.minFilter = 1006),
                        new Qn(1, 10, this).update(t, r),
                        (e.minFilter = s),
                        r.geometry.dispose(),
                        r.material.dispose(),
                        this
                    );
                }
                clear(t, e, n, i) {
                    const r = t.getRenderTarget();
                    for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                    t.setRenderTarget(r);
                }
            }
            ei.prototype.isWebGLCubeRenderTarget = !0;
            const ni = new Gt(),
                ii = new Gt(),
                ri = new Ct();
            class si {
                constructor(t = new Gt(1, 0, 0), e = 0) {
                    (this.normal = t), (this.constant = e);
                }
                set(t, e) {
                    return this.normal.copy(t), (this.constant = e), this;
                }
                setComponents(t, e, n, i) {
                    return this.normal.set(t, e, n), (this.constant = i), this;
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
                }
                setFromCoplanarPoints(t, e, n) {
                    const i = ni.subVectors(n, e).cross(ii.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, t), this;
                }
                copy(t) {
                    return this.normal.copy(t.normal), (this.constant = t.constant), this;
                }
                normalize() {
                    const t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), (this.constant *= t), this;
                }
                negate() {
                    return (this.constant *= -1), this.normal.negate(), this;
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant;
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius;
                }
                projectPoint(t, e) {
                    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
                }
                intersectLine(t, e) {
                    const n = t.delta(ni),
                        i = this.normal.dot(n);
                    if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                    const r = -(t.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start);
                }
                intersectsLine(t) {
                    const e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return (e < 0 && n > 0) || (n < 0 && e > 0);
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this);
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this);
                }
                coplanarPoint(t) {
                    return t.copy(this.normal).multiplyScalar(-this.constant);
                }
                applyMatrix4(t, e) {
                    const n = e || ri.getNormalMatrix(t),
                        i = this.coplanarPoint(ni).applyMatrix4(t),
                        r = this.normal.applyMatrix3(n).normalize();
                    return (this.constant = -i.dot(r)), this;
                }
                translate(t) {
                    return (this.constant -= t.dot(this.normal)), this;
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            si.prototype.isPlane = !0;
            const ai = new he(),
                oi = new Gt();
            class li {
                constructor(t = new si(), e = new si(), n = new si(), i = new si(), r = new si(), s = new si()) {
                    this.planes = [t, e, n, i, r, s];
                }
                set(t, e, n, i, r, s) {
                    const a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this;
                }
                copy(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this;
                }
                setFromProjectionMatrix(t) {
                    const e = this.planes,
                        n = t.elements,
                        i = n[0],
                        r = n[1],
                        s = n[2],
                        a = n[3],
                        o = n[4],
                        l = n[5],
                        c = n[6],
                        h = n[7],
                        u = n[8],
                        d = n[9],
                        p = n[10],
                        m = n[11],
                        f = n[12],
                        g = n[13],
                        v = n[14],
                        y = n[15];
                    return (
                        e[0].setComponents(a - i, h - o, m - u, y - f).normalize(),
                        e[1].setComponents(a + i, h + o, m + u, y + f).normalize(),
                        e[2].setComponents(a + r, h + l, m + d, y + g).normalize(),
                        e[3].setComponents(a - r, h - l, m - d, y - g).normalize(),
                        e[4].setComponents(a - s, h - c, m - p, y - v).normalize(),
                        e[5].setComponents(a + s, h + c, m + p, y + v).normalize(),
                        this
                    );
                }
                intersectsObject(t) {
                    const e = t.geometry;
                    return (
                        null === e.boundingSphere && e.computeBoundingSphere(),
                        ai.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                        this.intersectsSphere(ai)
                    );
                }
                intersectsSprite(t) {
                    return (
                        ai.center.set(0, 0, 0),
                        (ai.radius = 0.7071067811865476),
                        ai.applyMatrix4(t.matrixWorld),
                        this.intersectsSphere(ai)
                    );
                }
                intersectsSphere(t) {
                    const e = this.planes,
                        n = t.center,
                        i = -t.radius;
                    for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1;
                    return !0;
                }
                intersectsBox(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const i = e[n];
                        if (
                            ((oi.x = i.normal.x > 0 ? t.max.x : t.min.x),
                            (oi.y = i.normal.y > 0 ? t.max.y : t.min.y),
                            (oi.z = i.normal.z > 0 ? t.max.z : t.min.z),
                            i.distanceToPoint(oi) < 0)
                        )
                            return !1;
                    }
                    return !0;
                }
                containsPoint(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            function ci() {
                let t = null,
                    e = !1,
                    n = null,
                    i = null;
                function r(e, s) {
                    n(e, s), (i = t.requestAnimationFrame(r));
                }
                return {
                    start: function () {
                        !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
                    },
                    stop: function () {
                        t.cancelAnimationFrame(i), (e = !1);
                    },
                    setAnimationLoop: function (t) {
                        n = t;
                    },
                    setContext: function (e) {
                        t = e;
                    },
                };
            }
            function hi(t, e) {
                const n = e.isWebGL2,
                    i = new WeakMap();
                return {
                    get: function (t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
                    },
                    remove: function (e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const n = i.get(e);
                        n && (t.deleteBuffer(n.buffer), i.delete(e));
                    },
                    update: function (e, r) {
                        if (e.isGLBufferAttribute) {
                            const t = i.get(e);
                            return void (
                                (!t || t.version < e.version) &&
                                i.set(e, {
                                    buffer: e.buffer,
                                    type: e.type,
                                    bytesPerElement: e.elementSize,
                                    version: e.version,
                                })
                            );
                        }
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const s = i.get(e);
                        void 0 === s
                            ? i.set(
                                  e,
                                  (function (e, i) {
                                      const r = e.array,
                                          s = e.usage,
                                          a = t.createBuffer();
                                      t.bindBuffer(i, a), t.bufferData(i, r, s), e.onUploadCallback();
                                      let o = 5126;
                                      return (
                                          r instanceof Float32Array
                                              ? (o = 5126)
                                              : r instanceof Float64Array
                                              ? console.warn(
                                                    'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.',
                                                )
                                              : r instanceof Uint16Array
                                              ? e.isFloat16BufferAttribute
                                                  ? n
                                                      ? (o = 5131)
                                                      : console.warn(
                                                            'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.',
                                                        )
                                                  : (o = 5123)
                                              : r instanceof Int16Array
                                              ? (o = 5122)
                                              : r instanceof Uint32Array
                                              ? (o = 5125)
                                              : r instanceof Int32Array
                                              ? (o = 5124)
                                              : r instanceof Int8Array
                                              ? (o = 5120)
                                              : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) &&
                                                (o = 5121),
                                          {
                                              buffer: a,
                                              type: o,
                                              bytesPerElement: r.BYTES_PER_ELEMENT,
                                              version: e.version,
                                          }
                                      );
                                  })(e, r),
                              )
                            : s.version < e.version &&
                              ((function (e, i, r) {
                                  const s = i.array,
                                      a = i.updateRange;
                                  t.bindBuffer(r, e),
                                      -1 === a.count
                                          ? t.bufferSubData(r, 0, s)
                                          : (n
                                                ? t.bufferSubData(
                                                      r,
                                                      a.offset * s.BYTES_PER_ELEMENT,
                                                      s,
                                                      a.offset,
                                                      a.count,
                                                  )
                                                : t.bufferSubData(
                                                      r,
                                                      a.offset * s.BYTES_PER_ELEMENT,
                                                      s.subarray(a.offset, a.offset + a.count),
                                                  ),
                                            (a.count = -1));
                              })(s.buffer, e, r),
                              (s.version = e.version));
                    },
                };
            }
            class ui extends En {
                constructor(t = 1, e = 1, n = 1, i = 1) {
                    super(),
                        (this.type = 'PlaneGeometry'),
                        (this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i });
                    const r = t / 2,
                        s = e / 2,
                        a = Math.floor(n),
                        o = Math.floor(i),
                        l = a + 1,
                        c = o + 1,
                        h = t / a,
                        u = e / o,
                        d = [],
                        p = [],
                        m = [],
                        f = [];
                    for (let t = 0; t < c; t++) {
                        const e = t * u - s;
                        for (let n = 0; n < l; n++) {
                            const i = n * h - r;
                            p.push(i, -e, 0), m.push(0, 0, 1), f.push(n / a), f.push(1 - t / o);
                        }
                    }
                    for (let t = 0; t < o; t++)
                        for (let e = 0; e < a; e++) {
                            const n = e + l * t,
                                i = e + l * (t + 1),
                                r = e + 1 + l * (t + 1),
                                s = e + 1 + l * t;
                            d.push(n, i, s), d.push(i, r, s);
                        }
                    this.setIndex(d),
                        this.setAttribute('position', new yn(p, 3)),
                        this.setAttribute('normal', new yn(m, 3)),
                        this.setAttribute('uv', new yn(f, 2));
                }
                static fromJSON(t) {
                    return new ui(t.width, t.height, t.widthSegments, t.heightSegments);
                }
            }
            const di = {
                    alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
                    alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                    alphatest_fragment: '#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif',
                    alphatest_pars_fragment: '#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif',
                    aomap_fragment:
                        '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif',
                    aomap_pars_fragment:
                        '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
                    begin_vertex: 'vec3 transformed = vec3( position );',
                    beginnormal_vertex:
                        'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
                    bsdfs: 'vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenTint * ( D * V );\n}\n#endif',
                    bumpmap_pars_fragment:
                        '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
                    clipping_planes_fragment:
                        '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
                    clipping_planes_pars_fragment:
                        '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
                    clipping_planes_pars_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
                    clipping_planes_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
                    color_fragment:
                        '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
                    color_pars_fragment:
                        '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
                    color_pars_vertex:
                        '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
                    color_vertex:
                        '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
                    common: '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
                    cube_uv_reflection_fragment:
                        '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
                    defaultnormal_vertex:
                        'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
                    displacementmap_pars_vertex:
                        '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
                    displacementmap_vertex:
                        '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
                    emissivemap_fragment:
                        '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
                    emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
                    encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
                    encodings_pars_fragment:
                        '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
                    envmap_fragment:
                        '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
                    envmap_common_pars_fragment:
                        '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
                    envmap_pars_fragment:
                        '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
                    envmap_pars_vertex:
                        '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
                    envmap_physical_pars_fragment:
                        '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif',
                    envmap_vertex:
                        '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
                    fog_vertex: '#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif',
                    fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif',
                    fog_fragment:
                        '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
                    fog_pars_fragment:
                        '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
                    gradientmap_pars_fragment:
                        '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
                    lightmap_fragment:
                        '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif',
                    lightmap_pars_fragment:
                        '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
                    lights_lambert_vertex:
                        'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
                    lights_pars_begin:
                        'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif',
                    lights_toon_fragment: 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
                    lights_toon_pars_fragment:
                        'varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
                    lights_phong_fragment:
                        'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
                    lights_phong_pars_fragment:
                        'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
                    lights_physical_fragment:
                        'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif',
                    lights_physical_pars_fragment:
                        'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
                    lights_fragment_begin:
                        '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
                    lights_fragment_maps:
                        '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif',
                    lights_fragment_end:
                        '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
                    logdepthbuf_fragment:
                        '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
                    logdepthbuf_pars_fragment:
                        '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
                    logdepthbuf_pars_vertex:
                        '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
                    logdepthbuf_vertex:
                        '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
                    map_fragment:
                        '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
                    map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
                    map_particle_fragment:
                        '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
                    map_particle_pars_fragment:
                        '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                    metalnessmap_fragment:
                        'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
                    metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
                    morphnormal_vertex:
                        '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif',
                    morphtarget_pars_vertex:
                        '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif',
                    morphtarget_vertex:
                        '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif',
                    normal_fragment_begin:
                        'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
                    normal_fragment_maps:
                        '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
                    normal_pars_fragment:
                        '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
                    normal_pars_vertex:
                        '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
                    normal_vertex:
                        '#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif',
                    normalmap_pars_fragment:
                        '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif',
                    clearcoat_normal_fragment_begin:
                        '#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
                    clearcoat_normal_fragment_maps:
                        '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif',
                    clearcoat_pars_fragment:
                        '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
                    output_fragment:
                        '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
                    packing:
                        'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
                    premultiplied_alpha_fragment:
                        '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
                    project_vertex:
                        'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
                    dithering_fragment: '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
                    dithering_pars_fragment:
                        '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
                    roughnessmap_fragment:
                        'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
                    roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
                    shadowmap_pars_fragment:
                        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
                    shadowmap_pars_vertex:
                        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
                    shadowmap_vertex:
                        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
                    shadowmask_pars_fragment:
                        'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
                    skinbase_vertex:
                        '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
                    skinning_pars_vertex:
                        '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
                    skinning_vertex:
                        '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
                    skinnormal_vertex:
                        '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
                    specularmap_fragment:
                        'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
                    specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
                    tonemapping_fragment:
                        '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
                    tonemapping_pars_fragment:
                        '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
                    transmission_fragment:
                        '#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif',
                    transmission_pars_fragment:
                        '#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif',
                    uv_pars_fragment:
                        '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
                    uv_pars_vertex:
                        '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
                    uv_vertex: '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
                    uv2_pars_fragment:
                        '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
                    uv2_pars_vertex:
                        '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
                    uv2_vertex:
                        '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
                    worldpos_vertex:
                        '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
                    background_vert:
                        'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
                    background_frag:
                        'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                    cube_vert:
                        'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
                    cube_frag:
                        '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                    depth_vert:
                        '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
                    depth_frag:
                        '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
                    distanceRGBA_vert:
                        '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
                    distanceRGBA_frag:
                        '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
                    equirect_vert:
                        'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
                    equirect_frag:
                        'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                    linedashed_vert:
                        'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                    linedashed_frag:
                        'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                    meshbasic_vert:
                        '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
                    meshbasic_frag:
                        'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                    meshlambert_vert:
                        '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                    meshlambert_frag:
                        'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                    meshmatcap_vert:
                        '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
                    meshmatcap_frag:
                        '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                    meshnormal_vert:
                        '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
                    meshnormal_frag:
                        '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
                    meshphong_vert:
                        '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                    meshphong_frag:
                        '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                    meshphysical_vert:
                        '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}',
                    meshphysical_frag:
                        '#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n\tuniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                    meshtoon_vert:
                        '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                    meshtoon_frag:
                        '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                    points_vert:
                        'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
                    points_frag:
                        'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                    shadow_vert:
                        '#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                    shadow_frag:
                        'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
                    sprite_vert:
                        'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                    sprite_frag:
                        'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
                },
                pi = {
                    common: {
                        diffuse: { value: new un(16777215) },
                        opacity: { value: 1 },
                        map: { value: null },
                        uvTransform: { value: new Ct() },
                        uv2Transform: { value: new Ct() },
                        alphaMap: { value: null },
                        alphaTest: { value: 0 },
                    },
                    specularmap: { specularMap: { value: null } },
                    envmap: {
                        envMap: { value: null },
                        flipEnvMap: { value: -1 },
                        reflectivity: { value: 1 },
                        ior: { value: 1.5 },
                        refractionRatio: { value: 0.98 },
                        maxMipLevel: { value: 0 },
                    },
                    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
                    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
                    emissivemap: { emissiveMap: { value: null } },
                    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
                    normalmap: { normalMap: { value: null }, normalScale: { value: new Rt(1, 1) } },
                    displacementmap: {
                        displacementMap: { value: null },
                        displacementScale: { value: 1 },
                        displacementBias: { value: 0 },
                    },
                    roughnessmap: { roughnessMap: { value: null } },
                    metalnessmap: { metalnessMap: { value: null } },
                    gradientmap: { gradientMap: { value: null } },
                    fog: {
                        fogDensity: { value: 25e-5 },
                        fogNear: { value: 1 },
                        fogFar: { value: 2e3 },
                        fogColor: { value: new un(16777215) },
                    },
                    lights: {
                        ambientLightColor: { value: [] },
                        lightProbe: { value: [] },
                        directionalLights: { value: [], properties: { direction: {}, color: {} } },
                        directionalLightShadows: {
                            value: [],
                            properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
                        },
                        directionalShadowMap: { value: [] },
                        directionalShadowMatrix: { value: [] },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                            },
                        },
                        spotLightShadows: {
                            value: [],
                            properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
                        },
                        spotShadowMap: { value: [] },
                        spotShadowMatrix: { value: [] },
                        pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {},
                            },
                        },
                        pointShadowMap: { value: [] },
                        pointShadowMatrix: { value: [] },
                        hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
                        rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
                        ltc_1: { value: null },
                        ltc_2: { value: null },
                    },
                    points: {
                        diffuse: { value: new un(16777215) },
                        opacity: { value: 1 },
                        size: { value: 1 },
                        scale: { value: 1 },
                        map: { value: null },
                        alphaMap: { value: null },
                        alphaTest: { value: 0 },
                        uvTransform: { value: new Ct() },
                    },
                    sprite: {
                        diffuse: { value: new un(16777215) },
                        opacity: { value: 1 },
                        center: { value: new Rt(0.5, 0.5) },
                        rotation: { value: 0 },
                        map: { value: null },
                        alphaMap: { value: null },
                        alphaTest: { value: 0 },
                        uvTransform: { value: new Ct() },
                    },
                },
                mi = {
                    basic: {
                        uniforms: Yn([pi.common, pi.specularmap, pi.envmap, pi.aomap, pi.lightmap, pi.fog]),
                        vertexShader: di.meshbasic_vert,
                        fragmentShader: di.meshbasic_frag,
                    },
                    lambert: {
                        uniforms: Yn([
                            pi.common,
                            pi.specularmap,
                            pi.envmap,
                            pi.aomap,
                            pi.lightmap,
                            pi.emissivemap,
                            pi.fog,
                            pi.lights,
                            { emissive: { value: new un(0) } },
                        ]),
                        vertexShader: di.meshlambert_vert,
                        fragmentShader: di.meshlambert_frag,
                    },
                    phong: {
                        uniforms: Yn([
                            pi.common,
                            pi.specularmap,
                            pi.envmap,
                            pi.aomap,
                            pi.lightmap,
                            pi.emissivemap,
                            pi.bumpmap,
                            pi.normalmap,
                            pi.displacementmap,
                            pi.fog,
                            pi.lights,
                            {
                                emissive: { value: new un(0) },
                                specular: { value: new un(1118481) },
                                shininess: { value: 30 },
                            },
                        ]),
                        vertexShader: di.meshphong_vert,
                        fragmentShader: di.meshphong_frag,
                    },
                    standard: {
                        uniforms: Yn([
                            pi.common,
                            pi.envmap,
                            pi.aomap,
                            pi.lightmap,
                            pi.emissivemap,
                            pi.bumpmap,
                            pi.normalmap,
                            pi.displacementmap,
                            pi.roughnessmap,
                            pi.metalnessmap,
                            pi.fog,
                            pi.lights,
                            {
                                emissive: { value: new un(0) },
                                roughness: { value: 1 },
                                metalness: { value: 0 },
                                envMapIntensity: { value: 1 },
                            },
                        ]),
                        vertexShader: di.meshphysical_vert,
                        fragmentShader: di.meshphysical_frag,
                    },
                    toon: {
                        uniforms: Yn([
                            pi.common,
                            pi.aomap,
                            pi.lightmap,
                            pi.emissivemap,
                            pi.bumpmap,
                            pi.normalmap,
                            pi.displacementmap,
                            pi.gradientmap,
                            pi.fog,
                            pi.lights,
                            { emissive: { value: new un(0) } },
                        ]),
                        vertexShader: di.meshtoon_vert,
                        fragmentShader: di.meshtoon_frag,
                    },
                    matcap: {
                        uniforms: Yn([
                            pi.common,
                            pi.bumpmap,
                            pi.normalmap,
                            pi.displacementmap,
                            pi.fog,
                            { matcap: { value: null } },
                        ]),
                        vertexShader: di.meshmatcap_vert,
                        fragmentShader: di.meshmatcap_frag,
                    },
                    points: {
                        uniforms: Yn([pi.points, pi.fog]),
                        vertexShader: di.points_vert,
                        fragmentShader: di.points_frag,
                    },
                    dashed: {
                        uniforms: Yn([
                            pi.common,
                            pi.fog,
                            { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
                        ]),
                        vertexShader: di.linedashed_vert,
                        fragmentShader: di.linedashed_frag,
                    },
                    depth: {
                        uniforms: Yn([pi.common, pi.displacementmap]),
                        vertexShader: di.depth_vert,
                        fragmentShader: di.depth_frag,
                    },
                    normal: {
                        uniforms: Yn([
                            pi.common,
                            pi.bumpmap,
                            pi.normalmap,
                            pi.displacementmap,
                            { opacity: { value: 1 } },
                        ]),
                        vertexShader: di.meshnormal_vert,
                        fragmentShader: di.meshnormal_frag,
                    },
                    sprite: {
                        uniforms: Yn([pi.sprite, pi.fog]),
                        vertexShader: di.sprite_vert,
                        fragmentShader: di.sprite_frag,
                    },
                    background: {
                        uniforms: { uvTransform: { value: new Ct() }, t2D: { value: null } },
                        vertexShader: di.background_vert,
                        fragmentShader: di.background_frag,
                    },
                    cube: {
                        uniforms: Yn([pi.envmap, { opacity: { value: 1 } }]),
                        vertexShader: di.cube_vert,
                        fragmentShader: di.cube_frag,
                    },
                    equirect: {
                        uniforms: { tEquirect: { value: null } },
                        vertexShader: di.equirect_vert,
                        fragmentShader: di.equirect_frag,
                    },
                    distanceRGBA: {
                        uniforms: Yn([
                            pi.common,
                            pi.displacementmap,
                            {
                                referencePosition: { value: new Gt() },
                                nearDistance: { value: 1 },
                                farDistance: { value: 1e3 },
                            },
                        ]),
                        vertexShader: di.distanceRGBA_vert,
                        fragmentShader: di.distanceRGBA_frag,
                    },
                    shadow: {
                        uniforms: Yn([pi.lights, pi.fog, { color: { value: new un(0) }, opacity: { value: 1 } }]),
                        vertexShader: di.shadow_vert,
                        fragmentShader: di.shadow_frag,
                    },
                };
            function fi(t, e, n, i, r) {
                const s = new un(0);
                let a,
                    o,
                    l = 0,
                    c = null,
                    h = 0,
                    u = null;
                function d(t, e) {
                    n.buffers.color.setClear(t.r, t.g, t.b, e, r);
                }
                return {
                    getClearColor: function () {
                        return s;
                    },
                    setClearColor: function (t, e = 1) {
                        s.set(t), (l = e), d(s, l);
                    },
                    getClearAlpha: function () {
                        return l;
                    },
                    setClearAlpha: function (t) {
                        (l = t), d(s, l);
                    },
                    render: function (n, r) {
                        let p = !1,
                            m = !0 === r.isScene ? r.background : null;
                        m && m.isTexture && (m = e.get(m));
                        const f = t.xr,
                            g = f.getSession && f.getSession();
                        g && 'additive' === g.environmentBlendMode && (m = null),
                            null === m ? d(s, l) : m && m.isColor && (d(m, 1), (p = !0)),
                            (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                            m && (m.isCubeTexture || 306 === m.mapping)
                                ? (void 0 === o &&
                                      ((o = new Wn(
                                          new qn(1, 1, 1),
                                          new Jn({
                                              name: 'BackgroundCubeMaterial',
                                              uniforms: Xn(mi.cube.uniforms),
                                              vertexShader: mi.cube.vertexShader,
                                              fragmentShader: mi.cube.fragmentShader,
                                              side: 1,
                                              depthTest: !1,
                                              depthWrite: !1,
                                              fog: !1,
                                          }),
                                      )),
                                      o.geometry.deleteAttribute('normal'),
                                      o.geometry.deleteAttribute('uv'),
                                      (o.onBeforeRender = function (t, e, n) {
                                          this.matrixWorld.copyPosition(n.matrixWorld);
                                      }),
                                      Object.defineProperty(o.material, 'envMap', {
                                          get: function () {
                                              return this.uniforms.envMap.value;
                                          },
                                      }),
                                      i.update(o)),
                                  (o.material.uniforms.envMap.value = m),
                                  (o.material.uniforms.flipEnvMap.value =
                                      m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1),
                                  (c === m && h === m.version && u === t.toneMapping) ||
                                      ((o.material.needsUpdate = !0), (c = m), (h = m.version), (u = t.toneMapping)),
                                  n.unshift(o, o.geometry, o.material, 0, 0, null))
                                : m &&
                                  m.isTexture &&
                                  (void 0 === a &&
                                      ((a = new Wn(
                                          new ui(2, 2),
                                          new Jn({
                                              name: 'BackgroundMaterial',
                                              uniforms: Xn(mi.background.uniforms),
                                              vertexShader: mi.background.vertexShader,
                                              fragmentShader: mi.background.fragmentShader,
                                              side: 0,
                                              depthTest: !1,
                                              depthWrite: !1,
                                              fog: !1,
                                          }),
                                      )),
                                      a.geometry.deleteAttribute('normal'),
                                      Object.defineProperty(a.material, 'map', {
                                          get: function () {
                                              return this.uniforms.t2D.value;
                                          },
                                      }),
                                      i.update(a)),
                                  (a.material.uniforms.t2D.value = m),
                                  !0 === m.matrixAutoUpdate && m.updateMatrix(),
                                  a.material.uniforms.uvTransform.value.copy(m.matrix),
                                  (c === m && h === m.version && u === t.toneMapping) ||
                                      ((a.material.needsUpdate = !0), (c = m), (h = m.version), (u = t.toneMapping)),
                                  n.unshift(a, a.geometry, a.material, 0, 0, null));
                    },
                };
            }
            function gi(t, e, n, i) {
                const r = t.getParameter(34921),
                    s = i.isWebGL2 ? null : e.get('OES_vertex_array_object'),
                    a = i.isWebGL2 || null !== s,
                    o = {},
                    l = d(null);
                let c = l;
                function h(e) {
                    return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
                }
                function u(e) {
                    return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
                }
                function d(t) {
                    const e = [],
                        n = [],
                        i = [];
                    for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: e,
                        enabledAttributes: n,
                        attributeDivisors: i,
                        object: t,
                        attributes: {},
                        index: null,
                    };
                }
                function p() {
                    const t = c.newAttributes;
                    for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
                }
                function m(t) {
                    f(t, 0);
                }
                function f(n, r) {
                    const s = c.newAttributes,
                        a = c.enabledAttributes,
                        o = c.attributeDivisors;
                    (s[n] = 1),
                        0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),
                        o[n] !== r &&
                            ((i.isWebGL2 ? t : e.get('ANGLE_instanced_arrays'))[
                                i.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
                            ](n, r),
                            (o[n] = r));
                }
                function g() {
                    const e = c.newAttributes,
                        n = c.enabledAttributes;
                    for (let i = 0, r = n.length; i < r; i++)
                        n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
                }
                function v(e, n, r, s, a, o) {
                    !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
                        ? t.vertexAttribPointer(e, n, r, s, a, o)
                        : t.vertexAttribIPointer(e, n, r, a, o);
                }
                function y() {
                    x(), c !== l && ((c = l), h(c.object));
                }
                function x() {
                    (l.geometry = null), (l.program = null), (l.wireframe = !1);
                }
                return {
                    setup: function (r, l, u, y, x) {
                        let b = !1;
                        if (a) {
                            const e = (function (e, n, r) {
                                const a = !0 === r.wireframe;
                                let l = o[e.id];
                                void 0 === l && ((l = {}), (o[e.id] = l));
                                let c = l[n.id];
                                void 0 === c && ((c = {}), (l[n.id] = c));
                                let h = c[a];
                                return (
                                    void 0 === h &&
                                        ((h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES())),
                                        (c[a] = h)),
                                    h
                                );
                            })(y, u, l);
                            c !== e && ((c = e), h(c.object)),
                                (b = (function (t, e) {
                                    const n = c.attributes,
                                        i = t.attributes;
                                    let r = 0;
                                    for (const t in i) {
                                        const e = n[t],
                                            s = i[t];
                                        if (void 0 === e) return !0;
                                        if (e.attribute !== s) return !0;
                                        if (e.data !== s.data) return !0;
                                        r++;
                                    }
                                    return c.attributesNum !== r || c.index !== e;
                                })(y, x)),
                                b &&
                                    (function (t, e) {
                                        const n = {},
                                            i = t.attributes;
                                        let r = 0;
                                        for (const t in i) {
                                            const e = i[t],
                                                s = {};
                                            (s.attribute = e), e.data && (s.data = e.data), (n[t] = s), r++;
                                        }
                                        (c.attributes = n), (c.attributesNum = r), (c.index = e);
                                    })(y, x);
                        } else {
                            const t = !0 === l.wireframe;
                            (c.geometry === y.id && c.program === u.id && c.wireframe === t) ||
                                ((c.geometry = y.id), (c.program = u.id), (c.wireframe = t), (b = !0));
                        }
                        !0 === r.isInstancedMesh && (b = !0),
                            null !== x && n.update(x, 34963),
                            b &&
                                ((function (r, s, a, o) {
                                    if (
                                        !1 === i.isWebGL2 &&
                                        (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                                        null === e.get('ANGLE_instanced_arrays')
                                    )
                                        return;
                                    p();
                                    const l = o.attributes,
                                        c = a.getAttributes(),
                                        h = s.defaultAttributeValues;
                                    for (const e in c) {
                                        const i = c[e];
                                        if (i.location >= 0) {
                                            let s = l[e];
                                            if (
                                                (void 0 === s &&
                                                    ('instanceMatrix' === e &&
                                                        r.instanceMatrix &&
                                                        (s = r.instanceMatrix),
                                                    'instanceColor' === e && r.instanceColor && (s = r.instanceColor)),
                                                void 0 !== s)
                                            ) {
                                                const e = s.normalized,
                                                    a = s.itemSize,
                                                    l = n.get(s);
                                                if (void 0 === l) continue;
                                                const c = l.buffer,
                                                    h = l.type,
                                                    u = l.bytesPerElement;
                                                if (s.isInterleavedBufferAttribute) {
                                                    const n = s.data,
                                                        l = n.stride,
                                                        d = s.offset;
                                                    if (n && n.isInstancedInterleavedBuffer) {
                                                        for (let t = 0; t < i.locationSize; t++)
                                                            f(i.location + t, n.meshPerAttribute);
                                                        !0 !== r.isInstancedMesh &&
                                                            void 0 === o._maxInstanceCount &&
                                                            (o._maxInstanceCount = n.meshPerAttribute * n.count);
                                                    } else for (let t = 0; t < i.locationSize; t++) m(i.location + t);
                                                    t.bindBuffer(34962, c);
                                                    for (let t = 0; t < i.locationSize; t++)
                                                        v(
                                                            i.location + t,
                                                            a / i.locationSize,
                                                            h,
                                                            e,
                                                            l * u,
                                                            (d + (a / i.locationSize) * t) * u,
                                                        );
                                                } else {
                                                    if (s.isInstancedBufferAttribute) {
                                                        for (let t = 0; t < i.locationSize; t++)
                                                            f(i.location + t, s.meshPerAttribute);
                                                        !0 !== r.isInstancedMesh &&
                                                            void 0 === o._maxInstanceCount &&
                                                            (o._maxInstanceCount = s.meshPerAttribute * s.count);
                                                    } else for (let t = 0; t < i.locationSize; t++) m(i.location + t);
                                                    t.bindBuffer(34962, c);
                                                    for (let t = 0; t < i.locationSize; t++)
                                                        v(
                                                            i.location + t,
                                                            a / i.locationSize,
                                                            h,
                                                            e,
                                                            a * u,
                                                            (a / i.locationSize) * t * u,
                                                        );
                                                }
                                            } else if (void 0 !== h) {
                                                const n = h[e];
                                                if (void 0 !== n)
                                                    switch (n.length) {
                                                        case 2:
                                                            t.vertexAttrib2fv(i.location, n);
                                                            break;
                                                        case 3:
                                                            t.vertexAttrib3fv(i.location, n);
                                                            break;
                                                        case 4:
                                                            t.vertexAttrib4fv(i.location, n);
                                                            break;
                                                        default:
                                                            t.vertexAttrib1fv(i.location, n);
                                                    }
                                            }
                                        }
                                    }
                                    g();
                                })(r, l, u, y),
                                null !== x && t.bindBuffer(34963, n.get(x).buffer));
                    },
                    reset: y,
                    resetDefaultState: x,
                    dispose: function () {
                        y();
                        for (const t in o) {
                            const e = o[t];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) u(n[t].object), delete n[t];
                                delete e[t];
                            }
                            delete o[t];
                        }
                    },
                    releaseStatesOfGeometry: function (t) {
                        if (void 0 === o[t.id]) return;
                        const e = o[t.id];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) u(n[t].object), delete n[t];
                            delete e[t];
                        }
                        delete o[t.id];
                    },
                    releaseStatesOfProgram: function (t) {
                        for (const e in o) {
                            const n = o[e];
                            if (void 0 === n[t.id]) continue;
                            const i = n[t.id];
                            for (const t in i) u(i[t].object), delete i[t];
                            delete n[t.id];
                        }
                    },
                    initAttributes: p,
                    enableAttribute: m,
                    disableUnusedAttributes: g,
                };
            }
            function vi(t, e, n, i) {
                const r = i.isWebGL2;
                let s;
                (this.setMode = function (t) {
                    s = t;
                }),
                    (this.render = function (e, i) {
                        t.drawArrays(s, e, i), n.update(i, s, 1);
                    }),
                    (this.renderInstances = function (i, a, o) {
                        if (0 === o) return;
                        let l, c;
                        if (r) (l = t), (c = 'drawArraysInstanced');
                        else if (((l = e.get('ANGLE_instanced_arrays')), (c = 'drawArraysInstancedANGLE'), null === l))
                            return void console.error(
                                'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
                            );
                        l[c](s, i, a, o), n.update(a, s, o);
                    });
            }
            function yi(t, e, n) {
                let i;
                function r(e) {
                    if ('highp' === e) {
                        if (
                            t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                            t.getShaderPrecisionFormat(35632, 36338).precision > 0
                        )
                            return 'highp';
                        e = 'mediump';
                    }
                    return 'mediump' === e &&
                        t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
                        t.getShaderPrecisionFormat(35632, 36337).precision > 0
                        ? 'mediump'
                        : 'lowp';
                }
                const s =
                    ('undefined' != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext) ||
                    ('undefined' != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext);
                let a = void 0 !== n.precision ? n.precision : 'highp';
                const o = r(a);
                o !== a && (console.warn('THREE.WebGLRenderer:', a, 'not supported, using', o, 'instead.'), (a = o));
                const l = s || e.has('WEBGL_draw_buffers'),
                    c = !0 === n.logarithmicDepthBuffer,
                    h = t.getParameter(34930),
                    u = t.getParameter(35660),
                    d = t.getParameter(3379),
                    p = t.getParameter(34076),
                    m = t.getParameter(34921),
                    f = t.getParameter(36347),
                    g = t.getParameter(36348),
                    v = t.getParameter(36349),
                    y = u > 0,
                    x = s || e.has('OES_texture_float');
                return {
                    isWebGL2: s,
                    drawBuffers: l,
                    getMaxAnisotropy: function () {
                        if (void 0 !== i) return i;
                        if (!0 === e.has('EXT_texture_filter_anisotropic')) {
                            const n = e.get('EXT_texture_filter_anisotropic');
                            i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                        } else i = 0;
                        return i;
                    },
                    getMaxPrecision: r,
                    precision: a,
                    logarithmicDepthBuffer: c,
                    maxTextures: h,
                    maxVertexTextures: u,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: m,
                    maxVertexUniforms: f,
                    maxVaryings: g,
                    maxFragmentUniforms: v,
                    vertexTextures: y,
                    floatFragmentTextures: x,
                    floatVertexTextures: y && x,
                    maxSamples: s ? t.getParameter(36183) : 0,
                };
            }
            function xi(t) {
                const e = this;
                let n = null,
                    i = 0,
                    r = !1,
                    s = !1;
                const a = new si(),
                    o = new Ct(),
                    l = { value: null, needsUpdate: !1 };
                function c() {
                    l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
                        (e.numPlanes = i),
                        (e.numIntersection = 0);
                }
                function h(t, n, i, r) {
                    const s = null !== t ? t.length : 0;
                    let c = null;
                    if (0 !== s) {
                        if (((c = l.value), !0 !== r || null === c)) {
                            const e = i + 4 * s,
                                r = n.matrixWorldInverse;
                            o.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                            for (let e = 0, n = i; e !== s; ++e, n += 4)
                                a.copy(t[e]).applyMatrix4(r, o), a.normal.toArray(c, n), (c[n + 3] = a.constant);
                        }
                        (l.value = c), (l.needsUpdate = !0);
                    }
                    return (e.numPlanes = s), (e.numIntersection = 0), c;
                }
                (this.uniform = l),
                    (this.numPlanes = 0),
                    (this.numIntersection = 0),
                    (this.init = function (t, e, s) {
                        const a = 0 !== t.length || e || 0 !== i || r;
                        return (r = e), (n = h(t, s, 0)), (i = t.length), a;
                    }),
                    (this.beginShadows = function () {
                        (s = !0), h(null);
                    }),
                    (this.endShadows = function () {
                        (s = !1), c();
                    }),
                    (this.setState = function (e, a, o) {
                        const u = e.clippingPlanes,
                            d = e.clipIntersection,
                            p = e.clipShadows,
                            m = t.get(e);
                        if (!r || null === u || 0 === u.length || (s && !p)) s ? h(null) : c();
                        else {
                            const t = s ? 0 : i,
                                e = 4 * t;
                            let r = m.clippingState || null;
                            (l.value = r), (r = h(u, a, e, o));
                            for (let t = 0; t !== e; ++t) r[t] = n[t];
                            (m.clippingState = r),
                                (this.numIntersection = d ? this.numPlanes : 0),
                                (this.numPlanes += t);
                        }
                    });
            }
            function bi(t) {
                let e = new WeakMap();
                function n(t, e) {
                    return 303 === e ? (t.mapping = 301) : 304 === e && (t.mapping = 302), t;
                }
                function i(t) {
                    const n = t.target;
                    n.removeEventListener('dispose', i);
                    const r = e.get(n);
                    void 0 !== r && (e.delete(n), r.dispose());
                }
                return {
                    get: function (r) {
                        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                            const s = r.mapping;
                            if (303 === s || 304 === s) {
                                if (e.has(r)) return n(e.get(r).texture, r.mapping);
                                {
                                    const s = r.image;
                                    if (s && s.height > 0) {
                                        const a = t.getRenderTarget(),
                                            o = new ei(s.height / 2);
                                        return (
                                            o.fromEquirectangularTexture(t, r),
                                            e.set(r, o),
                                            t.setRenderTarget(a),
                                            r.addEventListener('dispose', i),
                                            n(o.texture, r.mapping)
                                        );
                                    }
                                    return null;
                                }
                            }
                        }
                        return r;
                    },
                    dispose: function () {
                        e = new WeakMap();
                    },
                };
            }
            mi.physical = {
                uniforms: Yn([
                    mi.standard.uniforms,
                    {
                        clearcoat: { value: 0 },
                        clearcoatMap: { value: null },
                        clearcoatRoughness: { value: 0 },
                        clearcoatRoughnessMap: { value: null },
                        clearcoatNormalScale: { value: new Rt(1, 1) },
                        clearcoatNormalMap: { value: null },
                        sheen: { value: 0 },
                        sheenTint: { value: new un(0) },
                        sheenRoughness: { value: 0 },
                        transmission: { value: 0 },
                        transmissionMap: { value: null },
                        transmissionSamplerSize: { value: new Rt() },
                        transmissionSamplerMap: { value: null },
                        thickness: { value: 0 },
                        thicknessMap: { value: null },
                        attenuationDistance: { value: 0 },
                        attenuationTint: { value: new un(0) },
                        specularIntensity: { value: 0 },
                        specularIntensityMap: { value: null },
                        specularTint: { value: new un(1, 1, 1) },
                        specularTintMap: { value: null },
                    },
                ]),
                vertexShader: di.meshphysical_vert,
                fragmentShader: di.meshphysical_frag,
            };
            class wi extends $n {
                constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
                    super(),
                        (this.type = 'OrthographicCamera'),
                        (this.zoom = 1),
                        (this.view = null),
                        (this.left = t),
                        (this.right = e),
                        (this.top = n),
                        (this.bottom = i),
                        (this.near = r),
                        (this.far = s),
                        this.updateProjectionMatrix();
                }
                copy(t, e) {
                    return (
                        super.copy(t, e),
                        (this.left = t.left),
                        (this.right = t.right),
                        (this.top = t.top),
                        (this.bottom = t.bottom),
                        (this.near = t.near),
                        (this.far = t.far),
                        (this.zoom = t.zoom),
                        (this.view = null === t.view ? null : Object.assign({}, t.view)),
                        this
                    );
                }
                setViewOffset(t, e, n, i, r, s) {
                    null === this.view &&
                        (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1,
                        }),
                        (this.view.enabled = !0),
                        (this.view.fullWidth = t),
                        (this.view.fullHeight = e),
                        (this.view.offsetX = n),
                        (this.view.offsetY = i),
                        (this.view.width = r),
                        (this.view.height = s),
                        this.updateProjectionMatrix();
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
                }
                updateProjectionMatrix() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2;
                    let r = n - t,
                        s = n + t,
                        a = i + e,
                        o = i - e;
                    if (null !== this.view && this.view.enabled) {
                        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        (r += t * this.view.offsetX),
                            (s = r + t * this.view.width),
                            (a -= e * this.view.offsetY),
                            (o = a - e * this.view.height);
                    }
                    this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                        (e.object.zoom = this.zoom),
                        (e.object.left = this.left),
                        (e.object.right = this.right),
                        (e.object.top = this.top),
                        (e.object.bottom = this.bottom),
                        (e.object.near = this.near),
                        (e.object.far = this.far),
                        null !== this.view && (e.object.view = Object.assign({}, this.view)),
                        e
                    );
                }
            }
            wi.prototype.isOrthographicCamera = !0;
            class _i extends Jn {
                constructor(t) {
                    super(t), (this.type = 'RawShaderMaterial');
                }
            }
            _i.prototype.isRawShaderMaterial = !0;
            const Mi = Math.pow(2, 8),
                Si = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                Ti = 5 + Si.length,
                Ei = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
                Ai = new wi(),
                {
                    _lodPlanes: Li,
                    _sizeLods: Ri,
                    _sigmas: Ci,
                } = (function () {
                    const t = [],
                        e = [],
                        n = [];
                    let i = 8;
                    for (let r = 0; r < Ti; r++) {
                        const s = Math.pow(2, i);
                        e.push(s);
                        let a = 1 / s;
                        r > 4 ? (a = Si[r - 8 + 4 - 1]) : 0 == r && (a = 0), n.push(a);
                        const o = 1 / (s - 1),
                            l = -o / 2,
                            c = 1 + o / 2,
                            h = [l, l, c, l, c, c, l, l, c, c, l, c],
                            u = 6,
                            d = 6,
                            p = 3,
                            m = 2,
                            f = 1,
                            g = new Float32Array(p * d * u),
                            v = new Float32Array(m * d * u),
                            y = new Float32Array(f * d * u);
                        for (let t = 0; t < u; t++) {
                            const e = ((t % 3) * 2) / 3 - 1,
                                n = t > 2 ? 0 : -1,
                                i = [
                                    e,
                                    n,
                                    0,
                                    e + 2 / 3,
                                    n,
                                    0,
                                    e + 2 / 3,
                                    n + 1,
                                    0,
                                    e,
                                    n,
                                    0,
                                    e + 2 / 3,
                                    n + 1,
                                    0,
                                    e,
                                    n + 1,
                                    0,
                                ];
                            g.set(i, p * d * t), v.set(h, m * d * t);
                            const r = [t, t, t, t, t, t];
                            y.set(r, f * d * t);
                        }
                        const x = new En();
                        x.setAttribute('position', new fn(g, p)),
                            x.setAttribute('uv', new fn(v, m)),
                            x.setAttribute('faceIndex', new fn(y, f)),
                            t.push(x),
                            i > 4 && i--;
                    }
                    return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
                })(),
                Pi = new un();
            let Ii = null;
            const Di = (1 + Math.sqrt(5)) / 2,
                Ni = 1 / Di,
                Fi = [
                    new Gt(1, 1, 1),
                    new Gt(-1, 1, 1),
                    new Gt(1, 1, -1),
                    new Gt(-1, 1, -1),
                    new Gt(0, Di, Ni),
                    new Gt(0, Di, -Ni),
                    new Gt(Ni, 0, Di),
                    new Gt(-Ni, 0, Di),
                    new Gt(Di, Ni, 0),
                    new Gt(-Di, Ni, 0),
                ];
            class Oi {
                constructor(t) {
                    (this._renderer = t),
                        (this._pingPongRenderTarget = null),
                        (this._blurMaterial = (function (t) {
                            const e = new Float32Array(20),
                                n = new Gt(0, 1, 0);
                            return new _i({
                                name: 'SphericalGaussianBlur',
                                defines: { n: 20 },
                                uniforms: {
                                    envMap: { value: null },
                                    samples: { value: 1 },
                                    weights: { value: e },
                                    latitudinal: { value: !1 },
                                    dTheta: { value: 0 },
                                    mipInt: { value: 0 },
                                    poleAxis: { value: n },
                                    inputEncoding: { value: Ei[3e3] },
                                    outputEncoding: { value: Ei[3e3] },
                                },
                                vertexShader:
                                    '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                                fragmentShader:
                                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1,
                            });
                        })()),
                        (this._equirectShader = null),
                        (this._cubemapShader = null),
                        this._compileMaterial(this._blurMaterial);
                }
                fromScene(t, e = 0, n = 0.1, i = 100) {
                    Ii = this._renderer.getRenderTarget();
                    const r = this._allocateTargets();
                    return (
                        this._sceneToCubeUV(t, n, i, r),
                        e > 0 && this._blur(r, 0, 0, e),
                        this._applyPMREM(r),
                        this._cleanup(r),
                        r
                    );
                }
                fromEquirectangular(t) {
                    return this._fromTexture(t);
                }
                fromCubemap(t) {
                    return this._fromTexture(t);
                }
                compileCubemapShader() {
                    null === this._cubemapShader &&
                        ((this._cubemapShader = Hi()), this._compileMaterial(this._cubemapShader));
                }
                compileEquirectangularShader() {
                    null === this._equirectShader &&
                        ((this._equirectShader = Bi()), this._compileMaterial(this._equirectShader));
                }
                dispose() {
                    this._blurMaterial.dispose(),
                        null !== this._cubemapShader && this._cubemapShader.dispose(),
                        null !== this._equirectShader && this._equirectShader.dispose();
                    for (let t = 0; t < Li.length; t++) Li[t].dispose();
                }
                _cleanup(t) {
                    this._pingPongRenderTarget.dispose(),
                        this._renderer.setRenderTarget(Ii),
                        (t.scissorTest = !1),
                        zi(t, 0, 0, t.width, t.height);
                }
                _fromTexture(t) {
                    Ii = this._renderer.getRenderTarget();
                    const e = this._allocateTargets(t);
                    return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
                }
                _allocateTargets(t) {
                    const e = {
                            magFilter: 1003,
                            minFilter: 1003,
                            generateMipmaps: !1,
                            type: 1009,
                            format: 1023,
                            encoding: Ui(t) ? t.encoding : 3002,
                            depthBuffer: !1,
                        },
                        n = ki(e);
                    return (n.depthBuffer = !t), (this._pingPongRenderTarget = ki(e)), n;
                }
                _compileMaterial(t) {
                    const e = new Wn(Li[0], t);
                    this._renderer.compile(e, Ai);
                }
                _sceneToCubeUV(t, e, n, i) {
                    const r = new Kn(90, 1, e, n),
                        s = [1, -1, 1, 1, 1, 1],
                        a = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        l = o.autoClear,
                        c = o.outputEncoding,
                        h = o.toneMapping;
                    o.getClearColor(Pi), (o.toneMapping = 0), (o.outputEncoding = 3e3), (o.autoClear = !1);
                    const u = new dn({ name: 'PMREM.Background', side: 1, depthWrite: !1, depthTest: !1 }),
                        d = new Wn(new qn(), u);
                    let p = !1;
                    const m = t.background;
                    m ? m.isColor && (u.color.copy(m), (t.background = null), (p = !0)) : (u.color.copy(Pi), (p = !0));
                    for (let e = 0; e < 6; e++) {
                        const n = e % 3;
                        0 == n
                            ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))
                            : 1 == n
                            ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))
                            : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])),
                            zi(i, n * Mi, e > 2 ? Mi : 0, Mi, Mi),
                            o.setRenderTarget(i),
                            p && o.render(d, r),
                            o.render(t, r);
                    }
                    d.geometry.dispose(),
                        d.material.dispose(),
                        (o.toneMapping = h),
                        (o.outputEncoding = c),
                        (o.autoClear = l),
                        (t.background = m);
                }
                _setEncoding(t, e) {
                    !0 === this._renderer.capabilities.isWebGL2 &&
                    1023 === e.format &&
                    1009 === e.type &&
                    3001 === e.encoding
                        ? (t.value = Ei[3e3])
                        : (t.value = Ei[e.encoding]);
                }
                _textureToCubeUV(t, e) {
                    const n = this._renderer;
                    t.isCubeTexture
                        ? null == this._cubemapShader && (this._cubemapShader = Hi())
                        : null == this._equirectShader && (this._equirectShader = Bi());
                    const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                        r = new Wn(Li[0], i),
                        s = i.uniforms;
                    (s.envMap.value = t),
                        t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
                        this._setEncoding(s.inputEncoding, t),
                        this._setEncoding(s.outputEncoding, e.texture),
                        zi(e, 0, 0, 3 * Mi, 2 * Mi),
                        n.setRenderTarget(e),
                        n.render(r, Ai);
                }
                _applyPMREM(t) {
                    const e = this._renderer,
                        n = e.autoClear;
                    e.autoClear = !1;
                    for (let e = 1; e < Ti; e++) {
                        const n = Math.sqrt(Ci[e] * Ci[e] - Ci[e - 1] * Ci[e - 1]),
                            i = Fi[(e - 1) % Fi.length];
                        this._blur(t, e - 1, e, n, i);
                    }
                    e.autoClear = n;
                }
                _blur(t, e, n, i, r) {
                    const s = this._pingPongRenderTarget;
                    this._halfBlur(t, s, e, n, i, 'latitudinal', r), this._halfBlur(s, t, n, n, i, 'longitudinal', r);
                }
                _halfBlur(t, e, n, i, r, s, a) {
                    const o = this._renderer,
                        l = this._blurMaterial;
                    'latitudinal' !== s &&
                        'longitudinal' !== s &&
                        console.error('blur direction must be either latitudinal or longitudinal!');
                    const c = new Wn(Li[i], l),
                        h = l.uniforms,
                        u = Ri[n] - 1,
                        d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
                        p = r / d,
                        m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                    m > 20 &&
                        console.warn(
                            `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`,
                        );
                    const f = [];
                    let g = 0;
                    for (let t = 0; t < 20; ++t) {
                        const e = t / p,
                            n = Math.exp((-e * e) / 2);
                        f.push(n), 0 == t ? (g += n) : t < m && (g += 2 * n);
                    }
                    for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
                    (h.envMap.value = t.texture),
                        (h.samples.value = m),
                        (h.weights.value = f),
                        (h.latitudinal.value = 'latitudinal' === s),
                        a && (h.poleAxis.value = a),
                        (h.dTheta.value = d),
                        (h.mipInt.value = 8 - n),
                        this._setEncoding(h.inputEncoding, t.texture),
                        this._setEncoding(h.outputEncoding, t.texture);
                    const v = Ri[i];
                    zi(
                        e,
                        3 * Math.max(0, Mi - 2 * v),
                        (0 === i ? 0 : 2 * Mi) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
                        3 * v,
                        2 * v,
                    ),
                        o.setRenderTarget(e),
                        o.render(c, Ai);
                }
            }
            function Ui(t) {
                return (
                    void 0 !== t &&
                    1009 === t.type &&
                    (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding)
                );
            }
            function ki(t) {
                const e = new zt(3 * Mi, 3 * Mi, t);
                return (e.texture.mapping = 306), (e.texture.name = 'PMREM.cubeUv'), (e.scissorTest = !0), e;
            }
            function zi(t, e, n, i, r) {
                t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
            }
            function Bi() {
                const t = new Rt(1, 1);
                return new _i({
                    name: 'EquirectangularToCubeUV',
                    uniforms: {
                        envMap: { value: null },
                        texelSize: { value: t },
                        inputEncoding: { value: Ei[3e3] },
                        outputEncoding: { value: Ei[3e3] },
                    },
                    vertexShader:
                        '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                    fragmentShader:
                        '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                });
            }
            function Hi() {
                return new _i({
                    name: 'CubemapToCubeUV',
                    uniforms: {
                        envMap: { value: null },
                        inputEncoding: { value: Ei[3e3] },
                        outputEncoding: { value: Ei[3e3] },
                    },
                    vertexShader:
                        '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                    fragmentShader:
                        '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                });
            }
            function Gi(t) {
                let e = new WeakMap(),
                    n = null;
                function i(t) {
                    const n = t.target;
                    n.removeEventListener('dispose', i);
                    const r = e.get(n);
                    void 0 !== r && (e.delete(n), r.dispose());
                }
                return {
                    get: function (r) {
                        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                            const s = r.mapping,
                                a = 303 === s || 304 === s,
                                o = 301 === s || 302 === s;
                            if (a || o) {
                                if (e.has(r)) return e.get(r).texture;
                                {
                                    const s = r.image;
                                    if (
                                        (a && s && s.height > 0) ||
                                        (o &&
                                            s &&
                                            (function (t) {
                                                let e = 0;
                                                for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                                return 6 === e;
                                            })(s))
                                    ) {
                                        const s = t.getRenderTarget();
                                        null === n && (n = new Oi(t));
                                        const o = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                        return (
                                            e.set(r, o),
                                            t.setRenderTarget(s),
                                            r.addEventListener('dispose', i),
                                            o.texture
                                        );
                                    }
                                    return null;
                                }
                            }
                        }
                        return r;
                    },
                    dispose: function () {
                        (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
                    },
                };
            }
            function Vi(t) {
                const e = {};
                function n(n) {
                    if (void 0 !== e[n]) return e[n];
                    let i;
                    switch (n) {
                        case 'WEBGL_depth_texture':
                            i =
                                t.getExtension('WEBGL_depth_texture') ||
                                t.getExtension('MOZ_WEBGL_depth_texture') ||
                                t.getExtension('WEBKIT_WEBGL_depth_texture');
                            break;
                        case 'EXT_texture_filter_anisotropic':
                            i =
                                t.getExtension('EXT_texture_filter_anisotropic') ||
                                t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                                t.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                            break;
                        case 'WEBGL_compressed_texture_s3tc':
                            i =
                                t.getExtension('WEBGL_compressed_texture_s3tc') ||
                                t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                                t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                            break;
                        case 'WEBGL_compressed_texture_pvrtc':
                            i =
                                t.getExtension('WEBGL_compressed_texture_pvrtc') ||
                                t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                            break;
                        default:
                            i = t.getExtension(n);
                    }
                    return (e[n] = i), i;
                }
                return {
                    has: function (t) {
                        return null !== n(t);
                    },
                    init: function (t) {
                        t.isWebGL2
                            ? n('EXT_color_buffer_float')
                            : (n('WEBGL_depth_texture'),
                              n('OES_texture_float'),
                              n('OES_texture_half_float'),
                              n('OES_texture_half_float_linear'),
                              n('OES_standard_derivatives'),
                              n('OES_element_index_uint'),
                              n('OES_vertex_array_object'),
                              n('ANGLE_instanced_arrays')),
                            n('OES_texture_float_linear'),
                            n('EXT_color_buffer_half_float');
                    },
                    get: function (t) {
                        const e = n(t);
                        return null === e && console.warn('THREE.WebGLRenderer: ' + t + ' extension not supported.'), e;
                    },
                };
            }
            function Wi(t, e, n, i) {
                const r = {},
                    s = new WeakMap();
                function a(t) {
                    const o = t.target;
                    null !== o.index && e.remove(o.index);
                    for (const t in o.attributes) e.remove(o.attributes[t]);
                    o.removeEventListener('dispose', a), delete r[o.id];
                    const l = s.get(o);
                    l && (e.remove(l), s.delete(o)),
                        i.releaseStatesOfGeometry(o),
                        !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                        n.memory.geometries--;
                }
                function o(t) {
                    const n = [],
                        i = t.index,
                        r = t.attributes.position;
                    let a = 0;
                    if (null !== i) {
                        const t = i.array;
                        a = i.version;
                        for (let e = 0, i = t.length; e < i; e += 3) {
                            const i = t[e + 0],
                                r = t[e + 1],
                                s = t[e + 2];
                            n.push(i, r, r, s, s, i);
                        }
                    } else {
                        const t = r.array;
                        a = r.version;
                        for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                            const t = e + 0,
                                i = e + 1,
                                r = e + 2;
                            n.push(t, i, i, r, r, t);
                        }
                    }
                    const o = new (Pt(n) > 65535 ? vn : gn)(n, 1);
                    o.version = a;
                    const l = s.get(t);
                    l && e.remove(l), s.set(t, o);
                }
                return {
                    get: function (t, e) {
                        return (
                            !0 === r[e.id] || (e.addEventListener('dispose', a), (r[e.id] = !0), n.memory.geometries++),
                            e
                        );
                    },
                    update: function (t) {
                        const n = t.attributes;
                        for (const t in n) e.update(n[t], 34962);
                        const i = t.morphAttributes;
                        for (const t in i) {
                            const n = i[t];
                            for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
                        }
                    },
                    getWireframeAttribute: function (t) {
                        const e = s.get(t);
                        if (e) {
                            const n = t.index;
                            null !== n && e.version < n.version && o(t);
                        } else o(t);
                        return s.get(t);
                    },
                };
            }
            function ji(t, e, n, i) {
                const r = i.isWebGL2;
                let s, a, o;
                (this.setMode = function (t) {
                    s = t;
                }),
                    (this.setIndex = function (t) {
                        (a = t.type), (o = t.bytesPerElement);
                    }),
                    (this.render = function (e, i) {
                        t.drawElements(s, i, a, e * o), n.update(i, s, 1);
                    }),
                    (this.renderInstances = function (i, l, c) {
                        if (0 === c) return;
                        let h, u;
                        if (r) (h = t), (u = 'drawElementsInstanced');
                        else if (
                            ((h = e.get('ANGLE_instanced_arrays')), (u = 'drawElementsInstancedANGLE'), null === h)
                        )
                            return void console.error(
                                'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
                            );
                        h[u](s, l, a, i * o, c), n.update(l, s, c);
                    });
            }
            function qi(t) {
                const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
                return {
                    memory: { geometries: 0, textures: 0 },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function () {
                        e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
                    },
                    update: function (t, n, i) {
                        switch ((e.calls++, n)) {
                            case 4:
                                e.triangles += i * (t / 3);
                                break;
                            case 1:
                                e.lines += i * (t / 2);
                                break;
                            case 3:
                                e.lines += i * (t - 1);
                                break;
                            case 2:
                                e.lines += i * t;
                                break;
                            case 0:
                                e.points += i * t;
                                break;
                            default:
                                console.error('THREE.WebGLInfo: Unknown draw mode:', n);
                        }
                    },
                };
            }
            class Xi extends Ot {
                constructor(t = null, e = 1, n = 1, i = 1) {
                    super(null),
                        (this.image = { data: t, width: e, height: n, depth: i }),
                        (this.magFilter = 1003),
                        (this.minFilter = 1003),
                        (this.wrapR = 1001),
                        (this.generateMipmaps = !1),
                        (this.flipY = !1),
                        (this.unpackAlignment = 1),
                        (this.needsUpdate = !0);
                }
            }
            function Yi(t, e) {
                return t[0] - e[0];
            }
            function Zi(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1]);
            }
            function Ji(t, e) {
                let n = 1;
                const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                i instanceof Int8Array
                    ? (n = 127)
                    : i instanceof Int16Array
                    ? (n = 32767)
                    : i instanceof Int32Array
                    ? (n = 2147483647)
                    : console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', i),
                    t.divideScalar(n);
            }
            function $i(t, e, n) {
                const i = {},
                    r = new Float32Array(8),
                    s = new WeakMap(),
                    a = new Gt(),
                    o = [];
                for (let t = 0; t < 8; t++) o[t] = [t, 0];
                return {
                    update: function (l, c, h, u) {
                        const d = l.morphTargetInfluences;
                        if (!0 === e.isWebGL2) {
                            const i = c.morphAttributes.position.length;
                            let r = s.get(c);
                            if (void 0 === r || r.count !== i) {
                                void 0 !== r && r.texture.dispose();
                                const t = void 0 !== c.morphAttributes.normal,
                                    n = c.morphAttributes.position,
                                    o = c.morphAttributes.normal || [],
                                    l = !0 === t ? 2 : 1;
                                let h = c.attributes.position.count * l,
                                    u = 1;
                                h > e.maxTextureSize && ((u = Math.ceil(h / e.maxTextureSize)), (h = e.maxTextureSize));
                                const d = new Float32Array(h * u * 4 * i),
                                    p = new Xi(d, h, u, i);
                                (p.format = 1023), (p.type = 1015);
                                const m = 4 * l;
                                for (let e = 0; e < i; e++) {
                                    const i = n[e],
                                        r = o[e],
                                        s = h * u * 4 * e;
                                    for (let e = 0; e < i.count; e++) {
                                        a.fromBufferAttribute(i, e), !0 === i.normalized && Ji(a, i);
                                        const n = e * m;
                                        (d[s + n + 0] = a.x),
                                            (d[s + n + 1] = a.y),
                                            (d[s + n + 2] = a.z),
                                            (d[s + n + 3] = 0),
                                            !0 === t &&
                                                (a.fromBufferAttribute(r, e),
                                                !0 === r.normalized && Ji(a, r),
                                                (d[s + n + 4] = a.x),
                                                (d[s + n + 5] = a.y),
                                                (d[s + n + 6] = a.z),
                                                (d[s + n + 7] = 0));
                                    }
                                }
                                (r = { count: i, texture: p, size: new Rt(h, u) }), s.set(c, r);
                            }
                            let o = 0;
                            for (let t = 0; t < d.length; t++) o += d[t];
                            const l = c.morphTargetsRelative ? 1 : 1 - o;
                            u.getUniforms().setValue(t, 'morphTargetBaseInfluence', l),
                                u.getUniforms().setValue(t, 'morphTargetInfluences', d),
                                u.getUniforms().setValue(t, 'morphTargetsTexture', r.texture, n),
                                u.getUniforms().setValue(t, 'morphTargetsTextureSize', r.size);
                        } else {
                            const e = void 0 === d ? 0 : d.length;
                            let n = i[c.id];
                            if (void 0 === n || n.length !== e) {
                                n = [];
                                for (let t = 0; t < e; t++) n[t] = [t, 0];
                                i[c.id] = n;
                            }
                            for (let t = 0; t < e; t++) {
                                const e = n[t];
                                (e[0] = t), (e[1] = d[t]);
                            }
                            n.sort(Zi);
                            for (let t = 0; t < 8; t++)
                                t < e && n[t][1]
                                    ? ((o[t][0] = n[t][0]), (o[t][1] = n[t][1]))
                                    : ((o[t][0] = Number.MAX_SAFE_INTEGER), (o[t][1] = 0));
                            o.sort(Yi);
                            const s = c.morphAttributes.position,
                                a = c.morphAttributes.normal;
                            let l = 0;
                            for (let t = 0; t < 8; t++) {
                                const e = o[t],
                                    n = e[0],
                                    i = e[1];
                                n !== Number.MAX_SAFE_INTEGER && i
                                    ? (s &&
                                          c.getAttribute('morphTarget' + t) !== s[n] &&
                                          c.setAttribute('morphTarget' + t, s[n]),
                                      a &&
                                          c.getAttribute('morphNormal' + t) !== a[n] &&
                                          c.setAttribute('morphNormal' + t, a[n]),
                                      (r[t] = i),
                                      (l += i))
                                    : (s &&
                                          !0 === c.hasAttribute('morphTarget' + t) &&
                                          c.deleteAttribute('morphTarget' + t),
                                      a &&
                                          !0 === c.hasAttribute('morphNormal' + t) &&
                                          c.deleteAttribute('morphNormal' + t),
                                      (r[t] = 0));
                            }
                            const h = c.morphTargetsRelative ? 1 : 1 - l;
                            u.getUniforms().setValue(t, 'morphTargetBaseInfluence', h),
                                u.getUniforms().setValue(t, 'morphTargetInfluences', r);
                        }
                    },
                };
            }
            function Ki(t, e, n, i) {
                let r = new WeakMap();
                function s(t) {
                    const e = t.target;
                    e.removeEventListener('dispose', s),
                        n.remove(e.instanceMatrix),
                        null !== e.instanceColor && n.remove(e.instanceColor);
                }
                return {
                    update: function (t) {
                        const a = i.render.frame,
                            o = t.geometry,
                            l = e.get(t, o);
                        return (
                            r.get(l) !== a && (e.update(l), r.set(l, a)),
                            t.isInstancedMesh &&
                                (!1 === t.hasEventListener('dispose', s) && t.addEventListener('dispose', s),
                                n.update(t.instanceMatrix, 34962),
                                null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                            l
                        );
                    },
                    dispose: function () {
                        r = new WeakMap();
                    },
                };
            }
            Xi.prototype.isDataTexture2DArray = !0;
            class Qi extends Ot {
                constructor(t = null, e = 1, n = 1, i = 1) {
                    super(null),
                        (this.image = { data: t, width: e, height: n, depth: i }),
                        (this.magFilter = 1003),
                        (this.minFilter = 1003),
                        (this.wrapR = 1001),
                        (this.generateMipmaps = !1),
                        (this.flipY = !1),
                        (this.unpackAlignment = 1),
                        (this.needsUpdate = !0);
                }
            }
            Qi.prototype.isDataTexture3D = !0;
            const tr = new Ot(),
                er = new Xi(),
                nr = new Qi(),
                ir = new ti(),
                rr = [],
                sr = [],
                ar = new Float32Array(16),
                or = new Float32Array(9),
                lr = new Float32Array(4);
            function cr(t, e, n) {
                const i = t[0];
                if (i <= 0 || i > 0) return t;
                const r = e * n;
                let s = rr[r];
                if ((void 0 === s && ((s = new Float32Array(r)), (rr[r] = s)), 0 !== e)) {
                    i.toArray(s, 0);
                    for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
                }
                return s;
            }
            function hr(t, e) {
                if (t.length !== e.length) return !1;
                for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
                return !0;
            }
            function ur(t, e) {
                for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
            }
            function dr(t, e) {
                let n = sr[e];
                void 0 === n && ((n = new Int32Array(e)), (sr[e] = n));
                for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                return n;
            }
            function pr(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
            }
            function mr(t, e) {
                const n = this.cache;
                if (void 0 !== e.x)
                    (n[0] === e.x && n[1] === e.y) || (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
                else {
                    if (hr(n, e)) return;
                    t.uniform2fv(this.addr, e), ur(n, e);
                }
            }
            function fr(t, e) {
                const n = this.cache;
                if (void 0 !== e.x)
                    (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                        (t.uniform3f(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
                else if (void 0 !== e.r)
                    (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
                        (t.uniform3f(this.addr, e.r, e.g, e.b), (n[0] = e.r), (n[1] = e.g), (n[2] = e.b));
                else {
                    if (hr(n, e)) return;
                    t.uniform3fv(this.addr, e), ur(n, e);
                }
            }
            function gr(t, e) {
                const n = this.cache;
                if (void 0 !== e.x)
                    (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
                        (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                        (n[0] = e.x),
                        (n[1] = e.y),
                        (n[2] = e.z),
                        (n[3] = e.w));
                else {
                    if (hr(n, e)) return;
                    t.uniform4fv(this.addr, e), ur(n, e);
                }
            }
            function vr(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (hr(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), ur(n, e);
                } else {
                    if (hr(n, i)) return;
                    lr.set(i), t.uniformMatrix2fv(this.addr, !1, lr), ur(n, i);
                }
            }
            function yr(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (hr(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), ur(n, e);
                } else {
                    if (hr(n, i)) return;
                    or.set(i), t.uniformMatrix3fv(this.addr, !1, or), ur(n, i);
                }
            }
            function xr(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (hr(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), ur(n, e);
                } else {
                    if (hr(n, i)) return;
                    ar.set(i), t.uniformMatrix4fv(this.addr, !1, ar), ur(n, i);
                }
            }
            function br(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
            }
            function wr(t, e) {
                const n = this.cache;
                hr(n, e) || (t.uniform2iv(this.addr, e), ur(n, e));
            }
            function _r(t, e) {
                const n = this.cache;
                hr(n, e) || (t.uniform3iv(this.addr, e), ur(n, e));
            }
            function Mr(t, e) {
                const n = this.cache;
                hr(n, e) || (t.uniform4iv(this.addr, e), ur(n, e));
            }
            function Sr(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
            }
            function Tr(t, e) {
                const n = this.cache;
                hr(n, e) || (t.uniform2uiv(this.addr, e), ur(n, e));
            }
            function Er(t, e) {
                const n = this.cache;
                hr(n, e) || (t.uniform3uiv(this.addr, e), ur(n, e));
            }
            function Ar(t, e) {
                const n = this.cache;
                hr(n, e) || (t.uniform4uiv(this.addr, e), ur(n, e));
            }
            function Lr(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTexture2D(e || tr, r);
            }
            function Rr(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture3D(e || nr, r);
            }
            function Cr(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTextureCube(e || ir, r);
            }
            function Pr(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture2DArray(e || er, r);
            }
            function Ir(t, e) {
                t.uniform1fv(this.addr, e);
            }
            function Dr(t, e) {
                const n = cr(e, this.size, 2);
                t.uniform2fv(this.addr, n);
            }
            function Nr(t, e) {
                const n = cr(e, this.size, 3);
                t.uniform3fv(this.addr, n);
            }
            function Fr(t, e) {
                const n = cr(e, this.size, 4);
                t.uniform4fv(this.addr, n);
            }
            function Or(t, e) {
                const n = cr(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, n);
            }
            function Ur(t, e) {
                const n = cr(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, n);
            }
            function kr(t, e) {
                const n = cr(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, n);
            }
            function zr(t, e) {
                t.uniform1iv(this.addr, e);
            }
            function Br(t, e) {
                t.uniform2iv(this.addr, e);
            }
            function Hr(t, e) {
                t.uniform3iv(this.addr, e);
            }
            function Gr(t, e) {
                t.uniform4iv(this.addr, e);
            }
            function Vr(t, e) {
                t.uniform1uiv(this.addr, e);
            }
            function Wr(t, e) {
                t.uniform2uiv(this.addr, e);
            }
            function jr(t, e) {
                t.uniform3uiv(this.addr, e);
            }
            function qr(t, e) {
                t.uniform4uiv(this.addr, e);
            }
            function Xr(t, e, n) {
                const i = e.length,
                    r = dr(n, i);
                t.uniform1iv(this.addr, r);
                for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || tr, r[t]);
            }
            function Yr(t, e, n) {
                const i = e.length,
                    r = dr(n, i);
                t.uniform1iv(this.addr, r);
                for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ir, r[t]);
            }
            function Zr(t, e, n) {
                (this.id = t),
                    (this.addr = n),
                    (this.cache = []),
                    (this.setValue = (function (t) {
                        switch (t) {
                            case 5126:
                                return pr;
                            case 35664:
                                return mr;
                            case 35665:
                                return fr;
                            case 35666:
                                return gr;
                            case 35674:
                                return vr;
                            case 35675:
                                return yr;
                            case 35676:
                                return xr;
                            case 5124:
                            case 35670:
                                return br;
                            case 35667:
                            case 35671:
                                return wr;
                            case 35668:
                            case 35672:
                                return _r;
                            case 35669:
                            case 35673:
                                return Mr;
                            case 5125:
                                return Sr;
                            case 36294:
                                return Tr;
                            case 36295:
                                return Er;
                            case 36296:
                                return Ar;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Lr;
                            case 35679:
                            case 36299:
                            case 36307:
                                return Rr;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return Cr;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return Pr;
                        }
                    })(e.type));
            }
            function Jr(t, e, n) {
                (this.id = t),
                    (this.addr = n),
                    (this.cache = []),
                    (this.size = e.size),
                    (this.setValue = (function (t) {
                        switch (t) {
                            case 5126:
                                return Ir;
                            case 35664:
                                return Dr;
                            case 35665:
                                return Nr;
                            case 35666:
                                return Fr;
                            case 35674:
                                return Or;
                            case 35675:
                                return Ur;
                            case 35676:
                                return kr;
                            case 5124:
                            case 35670:
                                return zr;
                            case 35667:
                            case 35671:
                                return Br;
                            case 35668:
                            case 35672:
                                return Hr;
                            case 35669:
                            case 35673:
                                return Gr;
                            case 5125:
                                return Vr;
                            case 36294:
                                return Wr;
                            case 36295:
                                return jr;
                            case 36296:
                                return qr;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Xr;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return Yr;
                        }
                    })(e.type));
            }
            function $r(t) {
                (this.id = t), (this.seq = []), (this.map = {});
            }
            (Jr.prototype.updateCache = function (t) {
                const e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
                    ur(e, t);
            }),
                ($r.prototype.setValue = function (t, e, n) {
                    const i = this.seq;
                    for (let r = 0, s = i.length; r !== s; ++r) {
                        const s = i[r];
                        s.setValue(t, e[s.id], n);
                    }
                });
            const Kr = /(\w+)(\])?(\[|\.)?/g;
            function Qr(t, e) {
                t.seq.push(e), (t.map[e.id] = e);
            }
            function ts(t, e, n) {
                const i = t.name,
                    r = i.length;
                for (Kr.lastIndex = 0; ; ) {
                    const s = Kr.exec(i),
                        a = Kr.lastIndex;
                    let o = s[1];
                    const l = ']' === s[2],
                        c = s[3];
                    if ((l && (o |= 0), void 0 === c || ('[' === c && a + 2 === r))) {
                        Qr(n, void 0 === c ? new Zr(o, t, e) : new Jr(o, t, e));
                        break;
                    }
                    {
                        let t = n.map[o];
                        void 0 === t && ((t = new $r(o)), Qr(n, t)), (n = t);
                    }
                }
            }
            function es(t, e) {
                (this.seq = []), (this.map = {});
                const n = t.getProgramParameter(e, 35718);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i);
                    ts(n, t.getUniformLocation(e, n.name), this);
                }
            }
            function ns(t, e, n) {
                const i = t.createShader(e);
                return t.shaderSource(i, n), t.compileShader(i), i;
            }
            (es.prototype.setValue = function (t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i);
            }),
                (es.prototype.setOptional = function (t, e, n) {
                    const i = e[n];
                    void 0 !== i && this.setValue(t, n, i);
                }),
                (es.upload = function (t, e, n, i) {
                    for (let r = 0, s = e.length; r !== s; ++r) {
                        const s = e[r],
                            a = n[s.id];
                        !1 !== a.needsUpdate && s.setValue(t, a.value, i);
                    }
                }),
                (es.seqWithValue = function (t, e) {
                    const n = [];
                    for (let i = 0, r = t.length; i !== r; ++i) {
                        const r = t[i];
                        r.id in e && n.push(r);
                    }
                    return n;
                });
            let is = 0;
            function rs(t) {
                switch (t) {
                    case 3e3:
                        return ['Linear', '( value )'];
                    case 3001:
                        return ['sRGB', '( value )'];
                    case 3002:
                        return ['RGBE', '( value )'];
                    case 3004:
                        return ['RGBM', '( value, 7.0 )'];
                    case 3005:
                        return ['RGBM', '( value, 16.0 )'];
                    case 3006:
                        return ['RGBD', '( value, 256.0 )'];
                    case 3007:
                        return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
                    case 3003:
                        return ['LogLuv', '( value )'];
                    default:
                        return console.warn('THREE.WebGLProgram: Unsupported encoding:', t), ['Linear', '( value )'];
                }
            }
            function ss(t, e, n) {
                const i = t.getShaderParameter(e, 35713),
                    r = t.getShaderInfoLog(e).trim();
                return i && '' === r
                    ? ''
                    : n.toUpperCase() +
                          '\n\n' +
                          r +
                          '\n\n' +
                          (function (t) {
                              const e = t.split('\n');
                              for (let t = 0; t < e.length; t++) e[t] = t + 1 + ': ' + e[t];
                              return e.join('\n');
                          })(t.getShaderSource(e));
            }
            function as(t, e) {
                const n = rs(e);
                return 'vec4 ' + t + '( vec4 value ) { return ' + n[0] + 'ToLinear' + n[1] + '; }';
            }
            function os(t, e) {
                const n = rs(e);
                return 'vec4 ' + t + '( vec4 value ) { return LinearTo' + n[0] + n[1] + '; }';
            }
            function ls(t, e) {
                let n;
                switch (e) {
                    case 1:
                        n = 'Linear';
                        break;
                    case 2:
                        n = 'Reinhard';
                        break;
                    case 3:
                        n = 'OptimizedCineon';
                        break;
                    case 4:
                        n = 'ACESFilmic';
                        break;
                    case 5:
                        n = 'Custom';
                        break;
                    default:
                        console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e), (n = 'Linear');
                }
                return 'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }';
            }
            function cs(t) {
                return '' !== t;
            }
            function hs(t, e) {
                return t
                    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
                    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
                    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
                    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
                    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
                    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
                    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
                    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
            }
            function us(t, e) {
                return t
                    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
                    .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
            }
            const ds = /^[ \t]*#include +<([\w\d./]+)>/gm;
            function ps(t) {
                return t.replace(ds, ms);
            }
            function ms(t, e) {
                const n = di[e];
                if (void 0 === n) throw new Error('Can not resolve #include <' + e + '>');
                return ps(n);
            }
            const fs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                gs =
                    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
            function vs(t) {
                return t.replace(gs, xs).replace(fs, ys);
            }
            function ys(t, e, n, i) {
                return (
                    console.warn(
                        'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.',
                    ),
                    xs(0, e, n, i)
                );
            }
            function xs(t, e, n, i) {
                let r = '';
                for (let t = parseInt(e); t < parseInt(n); t++)
                    r += i.replace(/\[\s*i\s*\]/g, '[ ' + t + ' ]').replace(/UNROLLED_LOOP_INDEX/g, t);
                return r;
            }
            function bs(t) {
                let e = 'precision ' + t.precision + ' float;\nprecision ' + t.precision + ' int;';
                return (
                    'highp' === t.precision
                        ? (e += '\n#define HIGH_PRECISION')
                        : 'mediump' === t.precision
                        ? (e += '\n#define MEDIUM_PRECISION')
                        : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
                    e
                );
            }
            function ws(t, e, n, i) {
                const r = t.getContext(),
                    s = n.defines;
                let a = n.vertexShader,
                    o = n.fragmentShader;
                const l = (function (t) {
                        let e = 'SHADOWMAP_TYPE_BASIC';
                        return (
                            1 === t.shadowMapType
                                ? (e = 'SHADOWMAP_TYPE_PCF')
                                : 2 === t.shadowMapType
                                ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
                                : 3 === t.shadowMapType && (e = 'SHADOWMAP_TYPE_VSM'),
                            e
                        );
                    })(n),
                    c = (function (t) {
                        let e = 'ENVMAP_TYPE_CUBE';
                        if (t.envMap)
                            switch (t.envMapMode) {
                                case 301:
                                case 302:
                                    e = 'ENVMAP_TYPE_CUBE';
                                    break;
                                case 306:
                                case 307:
                                    e = 'ENVMAP_TYPE_CUBE_UV';
                            }
                        return e;
                    })(n),
                    h = (function (t) {
                        let e = 'ENVMAP_MODE_REFLECTION';
                        if (t.envMap)
                            switch (t.envMapMode) {
                                case 302:
                                case 307:
                                    e = 'ENVMAP_MODE_REFRACTION';
                            }
                        return e;
                    })(n),
                    u = (function (t) {
                        let e = 'ENVMAP_BLENDING_NONE';
                        if (t.envMap)
                            switch (t.combine) {
                                case 0:
                                    e = 'ENVMAP_BLENDING_MULTIPLY';
                                    break;
                                case 1:
                                    e = 'ENVMAP_BLENDING_MIX';
                                    break;
                                case 2:
                                    e = 'ENVMAP_BLENDING_ADD';
                            }
                        return e;
                    })(n),
                    d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    p = n.isWebGL2
                        ? ''
                        : (function (t) {
                              return [
                                  t.extensionDerivatives ||
                                  t.envMapCubeUV ||
                                  t.bumpMap ||
                                  t.tangentSpaceNormalMap ||
                                  t.clearcoatNormalMap ||
                                  t.flatShading ||
                                  'physical' === t.shaderID
                                      ? '#extension GL_OES_standard_derivatives : enable'
                                      : '',
                                  (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth
                                      ? '#extension GL_EXT_frag_depth : enable'
                                      : '',
                                  t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                                      ? '#extension GL_EXT_draw_buffers : require'
                                      : '',
                                  (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                                  t.rendererExtensionShaderTextureLod
                                      ? '#extension GL_EXT_shader_texture_lod : enable'
                                      : '',
                              ]
                                  .filter(cs)
                                  .join('\n');
                          })(n),
                    m = (function (t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            !1 !== i && e.push('#define ' + n + ' ' + i);
                        }
                        return e.join('\n');
                    })(s),
                    f = r.createProgram();
                let g,
                    v,
                    y = n.glslVersion ? '#version ' + n.glslVersion + '\n' : '';
                n.isRawShaderMaterial
                    ? ((g = [m].filter(cs).join('\n')),
                      g.length > 0 && (g += '\n'),
                      (v = [p, m].filter(cs).join('\n')),
                      v.length > 0 && (v += '\n'))
                    : ((g = [
                          bs(n),
                          '#define SHADER_NAME ' + n.shaderName,
                          m,
                          n.instancing ? '#define USE_INSTANCING' : '',
                          n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
                          n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                          '#define GAMMA_FACTOR ' + d,
                          '#define MAX_BONES ' + n.maxBones,
                          n.useFog && n.fog ? '#define USE_FOG' : '',
                          n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                          n.map ? '#define USE_MAP' : '',
                          n.envMap ? '#define USE_ENVMAP' : '',
                          n.envMap ? '#define ' + h : '',
                          n.lightMap ? '#define USE_LIGHTMAP' : '',
                          n.aoMap ? '#define USE_AOMAP' : '',
                          n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                          n.bumpMap ? '#define USE_BUMPMAP' : '',
                          n.normalMap ? '#define USE_NORMALMAP' : '',
                          n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                          n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
                          n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                          n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                          n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                          n.displacementMap && n.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                          n.specularMap ? '#define USE_SPECULARMAP' : '',
                          n.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
                          n.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
                          n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                          n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                          n.alphaMap ? '#define USE_ALPHAMAP' : '',
                          n.transmission ? '#define USE_TRANSMISSION' : '',
                          n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                          n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                          n.vertexTangents ? '#define USE_TANGENT' : '',
                          n.vertexColors ? '#define USE_COLOR' : '',
                          n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                          n.vertexUvs ? '#define USE_UV' : '',
                          n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                          n.flatShading ? '#define FLAT_SHADED' : '',
                          n.skinning ? '#define USE_SKINNING' : '',
                          n.useVertexTexture ? '#define BONE_TEXTURE' : '',
                          n.morphTargets ? '#define USE_MORPHTARGETS' : '',
                          n.morphNormals && !1 === n.flatShading ? '#define USE_MORPHNORMALS' : '',
                          n.morphTargets && n.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '',
                          n.morphTargets && n.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + n.morphTargetsCount : '',
                          n.doubleSided ? '#define DOUBLE_SIDED' : '',
                          n.flipSided ? '#define FLIP_SIDED' : '',
                          n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                          n.shadowMapEnabled ? '#define ' + l : '',
                          n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                          n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
                          'uniform mat4 modelMatrix;',
                          'uniform mat4 modelViewMatrix;',
                          'uniform mat4 projectionMatrix;',
                          'uniform mat4 viewMatrix;',
                          'uniform mat3 normalMatrix;',
                          'uniform vec3 cameraPosition;',
                          'uniform bool isOrthographic;',
                          '#ifdef USE_INSTANCING',
                          '\tattribute mat4 instanceMatrix;',
                          '#endif',
                          '#ifdef USE_INSTANCING_COLOR',
                          '\tattribute vec3 instanceColor;',
                          '#endif',
                          'attribute vec3 position;',
                          'attribute vec3 normal;',
                          'attribute vec2 uv;',
                          '#ifdef USE_TANGENT',
                          '\tattribute vec4 tangent;',
                          '#endif',
                          '#if defined( USE_COLOR_ALPHA )',
                          '\tattribute vec4 color;',
                          '#elif defined( USE_COLOR )',
                          '\tattribute vec3 color;',
                          '#endif',
                          '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
                          '\tattribute vec3 morphTarget0;',
                          '\tattribute vec3 morphTarget1;',
                          '\tattribute vec3 morphTarget2;',
                          '\tattribute vec3 morphTarget3;',
                          '\t#ifdef USE_MORPHNORMALS',
                          '\t\tattribute vec3 morphNormal0;',
                          '\t\tattribute vec3 morphNormal1;',
                          '\t\tattribute vec3 morphNormal2;',
                          '\t\tattribute vec3 morphNormal3;',
                          '\t#else',
                          '\t\tattribute vec3 morphTarget4;',
                          '\t\tattribute vec3 morphTarget5;',
                          '\t\tattribute vec3 morphTarget6;',
                          '\t\tattribute vec3 morphTarget7;',
                          '\t#endif',
                          '#endif',
                          '#ifdef USE_SKINNING',
                          '\tattribute vec4 skinIndex;',
                          '\tattribute vec4 skinWeight;',
                          '#endif',
                          '\n',
                      ]
                          .filter(cs)
                          .join('\n')),
                      (v = [
                          p,
                          bs(n),
                          '#define SHADER_NAME ' + n.shaderName,
                          m,
                          '#define GAMMA_FACTOR ' + d,
                          n.useFog && n.fog ? '#define USE_FOG' : '',
                          n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                          n.map ? '#define USE_MAP' : '',
                          n.matcap ? '#define USE_MATCAP' : '',
                          n.envMap ? '#define USE_ENVMAP' : '',
                          n.envMap ? '#define ' + c : '',
                          n.envMap ? '#define ' + h : '',
                          n.envMap ? '#define ' + u : '',
                          n.lightMap ? '#define USE_LIGHTMAP' : '',
                          n.aoMap ? '#define USE_AOMAP' : '',
                          n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                          n.bumpMap ? '#define USE_BUMPMAP' : '',
                          n.normalMap ? '#define USE_NORMALMAP' : '',
                          n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                          n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
                          n.clearcoat ? '#define USE_CLEARCOAT' : '',
                          n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                          n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                          n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                          n.specularMap ? '#define USE_SPECULARMAP' : '',
                          n.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
                          n.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
                          n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                          n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                          n.alphaMap ? '#define USE_ALPHAMAP' : '',
                          n.alphaTest ? '#define USE_ALPHATEST' : '',
                          n.sheen ? '#define USE_SHEEN' : '',
                          n.transmission ? '#define USE_TRANSMISSION' : '',
                          n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                          n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                          n.vertexTangents ? '#define USE_TANGENT' : '',
                          n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '',
                          n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                          n.vertexUvs ? '#define USE_UV' : '',
                          n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                          n.gradientMap ? '#define USE_GRADIENTMAP' : '',
                          n.flatShading ? '#define FLAT_SHADED' : '',
                          n.doubleSided ? '#define DOUBLE_SIDED' : '',
                          n.flipSided ? '#define FLIP_SIDED' : '',
                          n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                          n.shadowMapEnabled ? '#define ' + l : '',
                          n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                          n.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                          n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
                          (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod
                              ? '#define TEXTURE_LOD_EXT'
                              : '',
                          'uniform mat4 viewMatrix;',
                          'uniform vec3 cameraPosition;',
                          'uniform bool isOrthographic;',
                          0 !== n.toneMapping ? '#define TONE_MAPPING' : '',
                          0 !== n.toneMapping ? di.tonemapping_pars_fragment : '',
                          0 !== n.toneMapping ? ls('toneMapping', n.toneMapping) : '',
                          n.dithering ? '#define DITHERING' : '',
                          1022 === n.format ? '#define OPAQUE' : '',
                          di.encodings_pars_fragment,
                          n.map ? as('mapTexelToLinear', n.mapEncoding) : '',
                          n.matcap ? as('matcapTexelToLinear', n.matcapEncoding) : '',
                          n.envMap ? as('envMapTexelToLinear', n.envMapEncoding) : '',
                          n.emissiveMap ? as('emissiveMapTexelToLinear', n.emissiveMapEncoding) : '',
                          n.specularTintMap ? as('specularTintMapTexelToLinear', n.specularTintMapEncoding) : '',
                          n.lightMap ? as('lightMapTexelToLinear', n.lightMapEncoding) : '',
                          os('linearToOutputTexel', n.outputEncoding),
                          n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
                          '\n',
                      ]
                          .filter(cs)
                          .join('\n'))),
                    (a = ps(a)),
                    (a = hs(a, n)),
                    (a = us(a, n)),
                    (o = ps(o)),
                    (o = hs(o, n)),
                    (o = us(o, n)),
                    (a = vs(a)),
                    (o = vs(o)),
                    n.isWebGL2 &&
                        !0 !== n.isRawShaderMaterial &&
                        ((y = '#version 300 es\n'),
                        (g =
                            [
                                'precision mediump sampler2DArray;',
                                '#define attribute in',
                                '#define varying out',
                                '#define texture2D texture',
                            ].join('\n') +
                            '\n' +
                            g),
                        (v =
                            [
                                '#define varying in',
                                '300 es' === n.glslVersion ? '' : 'out highp vec4 pc_fragColor;',
                                '300 es' === n.glslVersion ? '' : '#define gl_FragColor pc_fragColor',
                                '#define gl_FragDepthEXT gl_FragDepth',
                                '#define texture2D texture',
                                '#define textureCube texture',
                                '#define texture2DProj textureProj',
                                '#define texture2DLodEXT textureLod',
                                '#define texture2DProjLodEXT textureProjLod',
                                '#define textureCubeLodEXT textureLod',
                                '#define texture2DGradEXT textureGrad',
                                '#define texture2DProjGradEXT textureProjGrad',
                                '#define textureCubeGradEXT textureGrad',
                            ].join('\n') +
                            '\n' +
                            v));
                const x = y + v + o,
                    b = ns(r, 35633, y + g + a),
                    w = ns(r, 35632, x);
                if (
                    (r.attachShader(f, b),
                    r.attachShader(f, w),
                    void 0 !== n.index0AttributeName
                        ? r.bindAttribLocation(f, 0, n.index0AttributeName)
                        : !0 === n.morphTargets && r.bindAttribLocation(f, 0, 'position'),
                    r.linkProgram(f),
                    t.debug.checkShaderErrors)
                ) {
                    const t = r.getProgramInfoLog(f).trim(),
                        e = r.getShaderInfoLog(b).trim(),
                        n = r.getShaderInfoLog(w).trim();
                    let i = !0,
                        s = !0;
                    if (!1 === r.getProgramParameter(f, 35714)) {
                        i = !1;
                        const e = ss(r, b, 'vertex'),
                            n = ss(r, w, 'fragment');
                        console.error(
                            'THREE.WebGLProgram: Shader Error ' +
                                r.getError() +
                                ' - VALIDATE_STATUS ' +
                                r.getProgramParameter(f, 35715) +
                                '\n\nProgram Info Log: ' +
                                t +
                                '\n' +
                                e +
                                '\n' +
                                n,
                        );
                    } else
                        '' !== t
                            ? console.warn('THREE.WebGLProgram: Program Info Log:', t)
                            : ('' !== e && '' !== n) || (s = !1);
                    s &&
                        (this.diagnostics = {
                            runnable: i,
                            programLog: t,
                            vertexShader: { log: e, prefix: g },
                            fragmentShader: { log: n, prefix: v },
                        });
                }
                let _, M;
                return (
                    r.deleteShader(b),
                    r.deleteShader(w),
                    (this.getUniforms = function () {
                        return void 0 === _ && (_ = new es(r, f)), _;
                    }),
                    (this.getAttributes = function () {
                        return (
                            void 0 === M &&
                                (M = (function (t, e) {
                                    const n = {},
                                        i = t.getProgramParameter(e, 35721);
                                    for (let r = 0; r < i; r++) {
                                        const i = t.getActiveAttrib(e, r),
                                            s = i.name;
                                        let a = 1;
                                        35674 === i.type && (a = 2),
                                            35675 === i.type && (a = 3),
                                            35676 === i.type && (a = 4),
                                            (n[s] = {
                                                type: i.type,
                                                location: t.getAttribLocation(e, s),
                                                locationSize: a,
                                            });
                                    }
                                    return n;
                                })(r, f)),
                            M
                        );
                    }),
                    (this.destroy = function () {
                        i.releaseStatesOfProgram(this), r.deleteProgram(f), (this.program = void 0);
                    }),
                    (this.name = n.shaderName),
                    (this.id = is++),
                    (this.cacheKey = e),
                    (this.usedTimes = 1),
                    (this.program = f),
                    (this.vertexShader = b),
                    (this.fragmentShader = w),
                    this
                );
            }
            function _s(t, e, n, i, r, s, a) {
                const o = [],
                    l = r.isWebGL2,
                    c = r.logarithmicDepthBuffer,
                    h = r.floatVertexTextures,
                    u = r.maxVertexUniforms,
                    d = r.vertexTextures;
                let p = r.precision;
                const m = {
                        MeshDepthMaterial: 'depth',
                        MeshDistanceMaterial: 'distanceRGBA',
                        MeshNormalMaterial: 'normal',
                        MeshBasicMaterial: 'basic',
                        MeshLambertMaterial: 'lambert',
                        MeshPhongMaterial: 'phong',
                        MeshToonMaterial: 'toon',
                        MeshStandardMaterial: 'physical',
                        MeshPhysicalMaterial: 'physical',
                        MeshMatcapMaterial: 'matcap',
                        LineBasicMaterial: 'basic',
                        LineDashedMaterial: 'dashed',
                        PointsMaterial: 'points',
                        ShadowMaterial: 'shadow',
                        SpriteMaterial: 'sprite',
                    },
                    f = [
                        'precision',
                        'isWebGL2',
                        'supportsVertexTextures',
                        'outputEncoding',
                        'instancing',
                        'instancingColor',
                        'map',
                        'mapEncoding',
                        'matcap',
                        'matcapEncoding',
                        'envMap',
                        'envMapMode',
                        'envMapEncoding',
                        'envMapCubeUV',
                        'lightMap',
                        'lightMapEncoding',
                        'aoMap',
                        'emissiveMap',
                        'emissiveMapEncoding',
                        'bumpMap',
                        'normalMap',
                        'objectSpaceNormalMap',
                        'tangentSpaceNormalMap',
                        'clearcoat',
                        'clearcoatMap',
                        'clearcoatRoughnessMap',
                        'clearcoatNormalMap',
                        'displacementMap',
                        'specularMap',
                        'specularIntensityMap',
                        'specularTintMap',
                        'specularTintMapEncoding',
                        'roughnessMap',
                        'metalnessMap',
                        'gradientMap',
                        'alphaMap',
                        'alphaTest',
                        'combine',
                        'vertexColors',
                        'vertexAlphas',
                        'vertexTangents',
                        'vertexUvs',
                        'uvsVertexOnly',
                        'fog',
                        'useFog',
                        'fogExp2',
                        'flatShading',
                        'sizeAttenuation',
                        'logarithmicDepthBuffer',
                        'skinning',
                        'maxBones',
                        'useVertexTexture',
                        'morphTargets',
                        'morphNormals',
                        'morphTargetsCount',
                        'premultipliedAlpha',
                        'numDirLights',
                        'numPointLights',
                        'numSpotLights',
                        'numHemiLights',
                        'numRectAreaLights',
                        'numDirLightShadows',
                        'numPointLightShadows',
                        'numSpotLightShadows',
                        'shadowMapEnabled',
                        'shadowMapType',
                        'toneMapping',
                        'physicallyCorrectLights',
                        'doubleSided',
                        'flipSided',
                        'numClippingPlanes',
                        'numClipIntersection',
                        'depthPacking',
                        'dithering',
                        'format',
                        'sheen',
                        'transmission',
                        'transmissionMap',
                        'thicknessMap',
                    ];
                function g(t) {
                    let e;
                    return (
                        t && t.isTexture
                            ? (e = t.encoding)
                            : t && t.isWebGLRenderTarget
                            ? (console.warn(
                                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
                              ),
                              (e = t.texture.encoding))
                            : (e = 3e3),
                        l &&
                            t &&
                            t.isTexture &&
                            1023 === t.format &&
                            1009 === t.type &&
                            3001 === t.encoding &&
                            (e = 3e3),
                        e
                    );
                }
                return {
                    getParameters: function (s, o, f, v, y) {
                        const x = v.fog,
                            b = s.isMeshStandardMaterial ? v.environment : null,
                            w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b),
                            _ = m[s.type],
                            M = y.isSkinnedMesh
                                ? (function (t) {
                                      const e = t.skeleton.bones;
                                      if (h) return 1024;
                                      {
                                          const t = u,
                                              n = Math.floor((t - 20) / 4),
                                              i = Math.min(n, e.length);
                                          return i < e.length
                                              ? (console.warn(
                                                    'THREE.WebGLRenderer: Skeleton has ' +
                                                        e.length +
                                                        ' bones. This GPU supports ' +
                                                        i +
                                                        '.',
                                                ),
                                                0)
                                              : i;
                                      }
                                  })(y)
                                : 0;
                        let S, T;
                        if (
                            (null !== s.precision &&
                                ((p = r.getMaxPrecision(s.precision)),
                                p !== s.precision &&
                                    console.warn(
                                        'THREE.WebGLProgram.getParameters:',
                                        s.precision,
                                        'not supported, using',
                                        p,
                                        'instead.',
                                    )),
                            _)
                        ) {
                            const t = mi[_];
                            (S = t.vertexShader), (T = t.fragmentShader);
                        } else (S = s.vertexShader), (T = s.fragmentShader);
                        const E = t.getRenderTarget(),
                            A = s.alphaTest > 0,
                            L = s.clearcoat > 0;
                        return {
                            isWebGL2: l,
                            shaderID: _,
                            shaderName: s.type,
                            vertexShader: S,
                            fragmentShader: T,
                            defines: s.defines,
                            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                            glslVersion: s.glslVersion,
                            precision: p,
                            instancing: !0 === y.isInstancedMesh,
                            instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
                            supportsVertexTextures: d,
                            outputEncoding: null !== E ? g(E.texture) : t.outputEncoding,
                            map: !!s.map,
                            mapEncoding: g(s.map),
                            matcap: !!s.matcap,
                            matcapEncoding: g(s.matcap),
                            envMap: !!w,
                            envMapMode: w && w.mapping,
                            envMapEncoding: g(w),
                            envMapCubeUV: !!w && (306 === w.mapping || 307 === w.mapping),
                            lightMap: !!s.lightMap,
                            lightMapEncoding: g(s.lightMap),
                            aoMap: !!s.aoMap,
                            emissiveMap: !!s.emissiveMap,
                            emissiveMapEncoding: g(s.emissiveMap),
                            bumpMap: !!s.bumpMap,
                            normalMap: !!s.normalMap,
                            objectSpaceNormalMap: 1 === s.normalMapType,
                            tangentSpaceNormalMap: 0 === s.normalMapType,
                            clearcoat: L,
                            clearcoatMap: L && !!s.clearcoatMap,
                            clearcoatRoughnessMap: L && !!s.clearcoatRoughnessMap,
                            clearcoatNormalMap: L && !!s.clearcoatNormalMap,
                            displacementMap: !!s.displacementMap,
                            roughnessMap: !!s.roughnessMap,
                            metalnessMap: !!s.metalnessMap,
                            specularMap: !!s.specularMap,
                            specularIntensityMap: !!s.specularIntensityMap,
                            specularTintMap: !!s.specularTintMap,
                            specularTintMapEncoding: g(s.specularTintMap),
                            alphaMap: !!s.alphaMap,
                            alphaTest: A,
                            gradientMap: !!s.gradientMap,
                            sheen: s.sheen > 0,
                            transmission: s.transmission > 0,
                            transmissionMap: !!s.transmissionMap,
                            thicknessMap: !!s.thicknessMap,
                            combine: s.combine,
                            vertexTangents: !!s.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
                            vertexColors: s.vertexColors,
                            vertexAlphas:
                                !0 === s.vertexColors &&
                                !!y.geometry &&
                                !!y.geometry.attributes.color &&
                                4 === y.geometry.attributes.color.itemSize,
                            vertexUvs: !!(
                                s.map ||
                                s.bumpMap ||
                                s.normalMap ||
                                s.specularMap ||
                                s.alphaMap ||
                                s.emissiveMap ||
                                s.roughnessMap ||
                                s.metalnessMap ||
                                s.clearcoatMap ||
                                s.clearcoatRoughnessMap ||
                                s.clearcoatNormalMap ||
                                s.displacementMap ||
                                s.transmissionMap ||
                                s.thicknessMap ||
                                s.specularIntensityMap ||
                                s.specularTintMap
                            ),
                            uvsVertexOnly: !(
                                s.map ||
                                s.bumpMap ||
                                s.normalMap ||
                                s.specularMap ||
                                s.alphaMap ||
                                s.emissiveMap ||
                                s.roughnessMap ||
                                s.metalnessMap ||
                                s.clearcoatNormalMap ||
                                s.transmission > 0 ||
                                s.transmissionMap ||
                                s.thicknessMap ||
                                s.specularIntensityMap ||
                                s.specularTintMap ||
                                !s.displacementMap
                            ),
                            fog: !!x,
                            useFog: s.fog,
                            fogExp2: x && x.isFogExp2,
                            flatShading: !!s.flatShading,
                            sizeAttenuation: s.sizeAttenuation,
                            logarithmicDepthBuffer: c,
                            skinning: !0 === y.isSkinnedMesh && M > 0,
                            maxBones: M,
                            useVertexTexture: h,
                            morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
                            morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
                            morphTargetsCount:
                                y.geometry && y.geometry.morphAttributes.position
                                    ? y.geometry.morphAttributes.position.length
                                    : 0,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: a.numPlanes,
                            numClipIntersection: a.numIntersection,
                            format: s.format,
                            dithering: s.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: s.toneMapped ? t.toneMapping : 0,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: s.premultipliedAlpha,
                            doubleSided: 2 === s.side,
                            flipSided: 1 === s.side,
                            depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                            index0AttributeName: s.index0AttributeName,
                            extensionDerivatives: s.extensions && s.extensions.derivatives,
                            extensionFragDepth: s.extensions && s.extensions.fragDepth,
                            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                            extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: l || i.has('EXT_frag_depth'),
                            rendererExtensionDrawBuffers: l || i.has('WEBGL_draw_buffers'),
                            rendererExtensionShaderTextureLod: l || i.has('EXT_shader_texture_lod'),
                            customProgramCacheKey: s.customProgramCacheKey(),
                        };
                    },
                    getProgramCacheKey: function (e) {
                        const n = [];
                        if (
                            (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)),
                            void 0 !== e.defines)
                        )
                            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                        if (!1 === e.isRawShaderMaterial) {
                            for (let t = 0; t < f.length; t++) n.push(e[f[t]]);
                            n.push(t.outputEncoding), n.push(t.gammaFactor);
                        }
                        return n.push(e.customProgramCacheKey), n.join();
                    },
                    getUniforms: function (t) {
                        const e = m[t.type];
                        let n;
                        if (e) {
                            const t = mi[e];
                            n = Zn.clone(t.uniforms);
                        } else n = t.uniforms;
                        return n;
                    },
                    acquireProgram: function (e, n) {
                        let i;
                        for (let t = 0, e = o.length; t < e; t++) {
                            const e = o[t];
                            if (e.cacheKey === n) {
                                (i = e), ++i.usedTimes;
                                break;
                            }
                        }
                        return void 0 === i && ((i = new ws(t, n, e, s)), o.push(i)), i;
                    },
                    releaseProgram: function (t) {
                        if (0 == --t.usedTimes) {
                            const e = o.indexOf(t);
                            (o[e] = o[o.length - 1]), o.pop(), t.destroy();
                        }
                    },
                    programs: o,
                };
            }
            function Ms() {
                let t = new WeakMap();
                return {
                    get: function (e) {
                        let n = t.get(e);
                        return void 0 === n && ((n = {}), t.set(e, n)), n;
                    },
                    remove: function (e) {
                        t.delete(e);
                    },
                    update: function (e, n, i) {
                        t.get(e)[n] = i;
                    },
                    dispose: function () {
                        t = new WeakMap();
                    },
                };
            }
            function Ss(t, e) {
                return t.groupOrder !== e.groupOrder
                    ? t.groupOrder - e.groupOrder
                    : t.renderOrder !== e.renderOrder
                    ? t.renderOrder - e.renderOrder
                    : t.program !== e.program
                    ? t.program.id - e.program.id
                    : t.material.id !== e.material.id
                    ? t.material.id - e.material.id
                    : t.z !== e.z
                    ? t.z - e.z
                    : t.id - e.id;
            }
            function Ts(t, e) {
                return t.groupOrder !== e.groupOrder
                    ? t.groupOrder - e.groupOrder
                    : t.renderOrder !== e.renderOrder
                    ? t.renderOrder - e.renderOrder
                    : t.z !== e.z
                    ? e.z - t.z
                    : t.id - e.id;
            }
            function Es(t) {
                const e = [];
                let n = 0;
                const i = [],
                    r = [],
                    s = [],
                    a = { id: -1 };
                function o(i, r, s, o, l, c) {
                    let h = e[n];
                    const u = t.get(s);
                    return (
                        void 0 === h
                            ? ((h = {
                                  id: i.id,
                                  object: i,
                                  geometry: r,
                                  material: s,
                                  program: u.program || a,
                                  groupOrder: o,
                                  renderOrder: i.renderOrder,
                                  z: l,
                                  group: c,
                              }),
                              (e[n] = h))
                            : ((h.id = i.id),
                              (h.object = i),
                              (h.geometry = r),
                              (h.material = s),
                              (h.program = u.program || a),
                              (h.groupOrder = o),
                              (h.renderOrder = i.renderOrder),
                              (h.z = l),
                              (h.group = c)),
                        n++,
                        h
                    );
                }
                return {
                    opaque: i,
                    transmissive: r,
                    transparent: s,
                    init: function () {
                        (n = 0), (i.length = 0), (r.length = 0), (s.length = 0);
                    },
                    push: function (t, e, n, a, l, c) {
                        const h = o(t, e, n, a, l, c);
                        n.transmission > 0 ? r.push(h) : !0 === n.transparent ? s.push(h) : i.push(h);
                    },
                    unshift: function (t, e, n, a, l, c) {
                        const h = o(t, e, n, a, l, c);
                        n.transmission > 0 ? r.unshift(h) : !0 === n.transparent ? s.unshift(h) : i.unshift(h);
                    },
                    finish: function () {
                        for (let t = n, i = e.length; t < i; t++) {
                            const n = e[t];
                            if (null === n.id) break;
                            (n.id = null),
                                (n.object = null),
                                (n.geometry = null),
                                (n.material = null),
                                (n.program = null),
                                (n.group = null);
                        }
                    },
                    sort: function (t, e) {
                        i.length > 1 && i.sort(t || Ss),
                            r.length > 1 && r.sort(e || Ts),
                            s.length > 1 && s.sort(e || Ts);
                    },
                };
            }
            function As(t) {
                let e = new WeakMap();
                return {
                    get: function (n, i) {
                        let r;
                        return (
                            !1 === e.has(n)
                                ? ((r = new Es(t)), e.set(n, [r]))
                                : i >= e.get(n).length
                                ? ((r = new Es(t)), e.get(n).push(r))
                                : (r = e.get(n)[i]),
                            r
                        );
                    },
                    dispose: function () {
                        e = new WeakMap();
                    },
                };
            }
            function Ls() {
                const t = {};
                return {
                    get: function (e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case 'DirectionalLight':
                                n = { direction: new Gt(), color: new un() };
                                break;
                            case 'SpotLight':
                                n = {
                                    position: new Gt(),
                                    direction: new Gt(),
                                    color: new un(),
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                };
                                break;
                            case 'PointLight':
                                n = { position: new Gt(), color: new un(), distance: 0, decay: 0 };
                                break;
                            case 'HemisphereLight':
                                n = { direction: new Gt(), skyColor: new un(), groundColor: new un() };
                                break;
                            case 'RectAreaLight':
                                n = { color: new un(), position: new Gt(), halfWidth: new Gt(), halfHeight: new Gt() };
                        }
                        return (t[e.id] = n), n;
                    },
                };
            }
            let Rs = 0;
            function Cs(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
            }
            function Ps(t, e) {
                const n = new Ls(),
                    i = (function () {
                        const t = {};
                        return {
                            get: function (e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                let n;
                                switch (e.type) {
                                    case 'DirectionalLight':
                                    case 'SpotLight':
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Rt(),
                                        };
                                        break;
                                    case 'PointLight':
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Rt(),
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3,
                                        };
                                }
                                return (t[e.id] = n), n;
                            },
                        };
                    })(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                    };
                for (let t = 0; t < 9; t++) r.probe.push(new Gt());
                const s = new Gt(),
                    a = new xe(),
                    o = new xe();
                return {
                    setup: function (s, a) {
                        let o = 0,
                            l = 0,
                            c = 0;
                        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                        let h = 0,
                            u = 0,
                            d = 0,
                            p = 0,
                            m = 0,
                            f = 0,
                            g = 0,
                            v = 0;
                        s.sort(Cs);
                        const y = !0 !== a ? Math.PI : 1;
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t],
                                a = e.color,
                                x = e.intensity,
                                b = e.distance,
                                w = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                            if (e.isAmbientLight) (o += a.r * x * y), (l += a.g * x * y), (c += a.b * x * y);
                            else if (e.isLightProbe)
                                for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], x);
                            else if (e.isDirectionalLight) {
                                const t = n.get(e);
                                if ((t.color.copy(e.color).multiplyScalar(e.intensity * y), e.castShadow)) {
                                    const t = e.shadow,
                                        n = i.get(e);
                                    (n.shadowBias = t.bias),
                                        (n.shadowNormalBias = t.normalBias),
                                        (n.shadowRadius = t.radius),
                                        (n.shadowMapSize = t.mapSize),
                                        (r.directionalShadow[h] = n),
                                        (r.directionalShadowMap[h] = w),
                                        (r.directionalShadowMatrix[h] = e.shadow.matrix),
                                        f++;
                                }
                                (r.directional[h] = t), h++;
                            } else if (e.isSpotLight) {
                                const t = n.get(e);
                                if (
                                    (t.position.setFromMatrixPosition(e.matrixWorld),
                                    t.color.copy(a).multiplyScalar(x * y),
                                    (t.distance = b),
                                    (t.coneCos = Math.cos(e.angle)),
                                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                                    (t.decay = e.decay),
                                    e.castShadow)
                                ) {
                                    const t = e.shadow,
                                        n = i.get(e);
                                    (n.shadowBias = t.bias),
                                        (n.shadowNormalBias = t.normalBias),
                                        (n.shadowRadius = t.radius),
                                        (n.shadowMapSize = t.mapSize),
                                        (r.spotShadow[d] = n),
                                        (r.spotShadowMap[d] = w),
                                        (r.spotShadowMatrix[d] = e.shadow.matrix),
                                        v++;
                                }
                                (r.spot[d] = t), d++;
                            } else if (e.isRectAreaLight) {
                                const t = n.get(e);
                                t.color.copy(a).multiplyScalar(x),
                                    t.halfWidth.set(0.5 * e.width, 0, 0),
                                    t.halfHeight.set(0, 0.5 * e.height, 0),
                                    (r.rectArea[p] = t),
                                    p++;
                            } else if (e.isPointLight) {
                                const t = n.get(e);
                                if (
                                    (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                                    (t.distance = e.distance),
                                    (t.decay = e.decay),
                                    e.castShadow)
                                ) {
                                    const t = e.shadow,
                                        n = i.get(e);
                                    (n.shadowBias = t.bias),
                                        (n.shadowNormalBias = t.normalBias),
                                        (n.shadowRadius = t.radius),
                                        (n.shadowMapSize = t.mapSize),
                                        (n.shadowCameraNear = t.camera.near),
                                        (n.shadowCameraFar = t.camera.far),
                                        (r.pointShadow[u] = n),
                                        (r.pointShadowMap[u] = w),
                                        (r.pointShadowMatrix[u] = e.shadow.matrix),
                                        g++;
                                }
                                (r.point[u] = t), u++;
                            } else if (e.isHemisphereLight) {
                                const t = n.get(e);
                                t.skyColor.copy(e.color).multiplyScalar(x * y),
                                    t.groundColor.copy(e.groundColor).multiplyScalar(x * y),
                                    (r.hemi[m] = t),
                                    m++;
                            }
                        }
                        p > 0 &&
                            (e.isWebGL2 || !0 === t.has('OES_texture_float_linear')
                                ? ((r.rectAreaLTC1 = pi.LTC_FLOAT_1), (r.rectAreaLTC2 = pi.LTC_FLOAT_2))
                                : !0 === t.has('OES_texture_half_float_linear')
                                ? ((r.rectAreaLTC1 = pi.LTC_HALF_1), (r.rectAreaLTC2 = pi.LTC_HALF_2))
                                : console.error(
                                      'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.',
                                  )),
                            (r.ambient[0] = o),
                            (r.ambient[1] = l),
                            (r.ambient[2] = c);
                        const x = r.hash;
                        (x.directionalLength === h &&
                            x.pointLength === u &&
                            x.spotLength === d &&
                            x.rectAreaLength === p &&
                            x.hemiLength === m &&
                            x.numDirectionalShadows === f &&
                            x.numPointShadows === g &&
                            x.numSpotShadows === v) ||
                            ((r.directional.length = h),
                            (r.spot.length = d),
                            (r.rectArea.length = p),
                            (r.point.length = u),
                            (r.hemi.length = m),
                            (r.directionalShadow.length = f),
                            (r.directionalShadowMap.length = f),
                            (r.pointShadow.length = g),
                            (r.pointShadowMap.length = g),
                            (r.spotShadow.length = v),
                            (r.spotShadowMap.length = v),
                            (r.directionalShadowMatrix.length = f),
                            (r.pointShadowMatrix.length = g),
                            (r.spotShadowMatrix.length = v),
                            (x.directionalLength = h),
                            (x.pointLength = u),
                            (x.spotLength = d),
                            (x.rectAreaLength = p),
                            (x.hemiLength = m),
                            (x.numDirectionalShadows = f),
                            (x.numPointShadows = g),
                            (x.numSpotShadows = v),
                            (r.version = Rs++));
                    },
                    setupView: function (t, e) {
                        let n = 0,
                            i = 0,
                            l = 0,
                            c = 0,
                            h = 0;
                        const u = e.matrixWorldInverse;
                        for (let e = 0, d = t.length; e < d; e++) {
                            const d = t[e];
                            if (d.isDirectionalLight) {
                                const t = r.directional[n];
                                t.direction.setFromMatrixPosition(d.matrixWorld),
                                    s.setFromMatrixPosition(d.target.matrixWorld),
                                    t.direction.sub(s),
                                    t.direction.transformDirection(u),
                                    n++;
                            } else if (d.isSpotLight) {
                                const t = r.spot[l];
                                t.position.setFromMatrixPosition(d.matrixWorld),
                                    t.position.applyMatrix4(u),
                                    t.direction.setFromMatrixPosition(d.matrixWorld),
                                    s.setFromMatrixPosition(d.target.matrixWorld),
                                    t.direction.sub(s),
                                    t.direction.transformDirection(u),
                                    l++;
                            } else if (d.isRectAreaLight) {
                                const t = r.rectArea[c];
                                t.position.setFromMatrixPosition(d.matrixWorld),
                                    t.position.applyMatrix4(u),
                                    o.identity(),
                                    a.copy(d.matrixWorld),
                                    a.premultiply(u),
                                    o.extractRotation(a),
                                    t.halfWidth.set(0.5 * d.width, 0, 0),
                                    t.halfHeight.set(0, 0.5 * d.height, 0),
                                    t.halfWidth.applyMatrix4(o),
                                    t.halfHeight.applyMatrix4(o),
                                    c++;
                            } else if (d.isPointLight) {
                                const t = r.point[i];
                                t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++;
                            } else if (d.isHemisphereLight) {
                                const t = r.hemi[h];
                                t.direction.setFromMatrixPosition(d.matrixWorld),
                                    t.direction.transformDirection(u),
                                    t.direction.normalize(),
                                    h++;
                            }
                        }
                    },
                    state: r,
                };
            }
            function Is(t, e) {
                const n = new Ps(t, e),
                    i = [],
                    r = [];
                return {
                    init: function () {
                        (i.length = 0), (r.length = 0);
                    },
                    state: { lightsArray: i, shadowsArray: r, lights: n },
                    setupLights: function (t) {
                        n.setup(i, t);
                    },
                    setupLightsView: function (t) {
                        n.setupView(i, t);
                    },
                    pushLight: function (t) {
                        i.push(t);
                    },
                    pushShadow: function (t) {
                        r.push(t);
                    },
                };
            }
            function Ds(t, e) {
                let n = new WeakMap();
                return {
                    get: function (i, r = 0) {
                        let s;
                        return (
                            !1 === n.has(i)
                                ? ((s = new Is(t, e)), n.set(i, [s]))
                                : r >= n.get(i).length
                                ? ((s = new Is(t, e)), n.get(i).push(s))
                                : (s = n.get(i)[r]),
                            s
                        );
                    },
                    dispose: function () {
                        n = new WeakMap();
                    },
                };
            }
            class Ns extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'MeshDepthMaterial'),
                        (this.depthPacking = 3200),
                        (this.map = null),
                        (this.alphaMap = null),
                        (this.displacementMap = null),
                        (this.displacementScale = 1),
                        (this.displacementBias = 0),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.fog = !1),
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.depthPacking = t.depthPacking),
                        (this.map = t.map),
                        (this.alphaMap = t.alphaMap),
                        (this.displacementMap = t.displacementMap),
                        (this.displacementScale = t.displacementScale),
                        (this.displacementBias = t.displacementBias),
                        (this.wireframe = t.wireframe),
                        (this.wireframeLinewidth = t.wireframeLinewidth),
                        this
                    );
                }
            }
            Ns.prototype.isMeshDepthMaterial = !0;
            class Fs extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'MeshDistanceMaterial'),
                        (this.referencePosition = new Gt()),
                        (this.nearDistance = 1),
                        (this.farDistance = 1e3),
                        (this.map = null),
                        (this.alphaMap = null),
                        (this.displacementMap = null),
                        (this.displacementScale = 1),
                        (this.displacementBias = 0),
                        (this.fog = !1),
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.referencePosition.copy(t.referencePosition),
                        (this.nearDistance = t.nearDistance),
                        (this.farDistance = t.farDistance),
                        (this.map = t.map),
                        (this.alphaMap = t.alphaMap),
                        (this.displacementMap = t.displacementMap),
                        (this.displacementScale = t.displacementScale),
                        (this.displacementBias = t.displacementBias),
                        this
                    );
                }
            }
            function Os(t, e, n) {
                let i = new li();
                const r = new Rt(),
                    s = new Rt(),
                    a = new kt(),
                    o = new Ns({ depthPacking: 3201 }),
                    l = new Fs(),
                    c = {},
                    h = n.maxTextureSize,
                    u = { 0: 1, 1: 0, 2: 2 },
                    d = new Jn({
                        uniforms: {
                            shadow_pass: { value: null },
                            resolution: { value: new Rt() },
                            radius: { value: 4 },
                            samples: { value: 8 },
                        },
                        vertexShader: 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
                        fragmentShader:
                            'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
                    }),
                    p = d.clone();
                p.defines.HORIZONTAL_PASS = 1;
                const m = new En();
                m.setAttribute('position', new fn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
                const f = new Wn(m, d),
                    g = this;
                function v(n, i) {
                    const r = e.update(f);
                    (d.uniforms.shadow_pass.value = n.map.texture),
                        (d.uniforms.resolution.value = n.mapSize),
                        (d.uniforms.radius.value = n.radius),
                        (d.uniforms.samples.value = n.blurSamples),
                        t.setRenderTarget(n.mapPass),
                        t.clear(),
                        t.renderBufferDirect(i, null, r, d, f, null),
                        (p.uniforms.shadow_pass.value = n.mapPass.texture),
                        (p.uniforms.resolution.value = n.mapSize),
                        (p.uniforms.radius.value = n.radius),
                        (p.uniforms.samples.value = n.blurSamples),
                        t.setRenderTarget(n.map),
                        t.clear(),
                        t.renderBufferDirect(i, null, r, p, f, null);
                }
                function y(e, n, i, r, s, a, h) {
                    let d = null;
                    const p = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                    if (
                        ((d = void 0 !== p ? p : !0 === r.isPointLight ? l : o),
                        (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) ||
                            (i.displacementMap && 0 !== i.displacementScale) ||
                            (i.alphaMap && i.alphaTest > 0))
                    ) {
                        const t = d.uuid,
                            e = i.uuid;
                        let n = c[t];
                        void 0 === n && ((n = {}), (c[t] = n));
                        let r = n[e];
                        void 0 === r && ((r = d.clone()), (n[e] = r)), (d = r);
                    }
                    return (
                        (d.visible = i.visible),
                        (d.wireframe = i.wireframe),
                        (d.side =
                            3 === h
                                ? null !== i.shadowSide
                                    ? i.shadowSide
                                    : i.side
                                : null !== i.shadowSide
                                ? i.shadowSide
                                : u[i.side]),
                        (d.alphaMap = i.alphaMap),
                        (d.alphaTest = i.alphaTest),
                        (d.clipShadows = i.clipShadows),
                        (d.clippingPlanes = i.clippingPlanes),
                        (d.clipIntersection = i.clipIntersection),
                        (d.displacementMap = i.displacementMap),
                        (d.displacementScale = i.displacementScale),
                        (d.displacementBias = i.displacementBias),
                        (d.wireframeLinewidth = i.wireframeLinewidth),
                        (d.linewidth = i.linewidth),
                        !0 === r.isPointLight &&
                            !0 === d.isMeshDistanceMaterial &&
                            (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
                            (d.nearDistance = s),
                            (d.farDistance = a)),
                        d
                    );
                }
                function x(n, r, s, a, o) {
                    if (!1 === n.visible) return;
                    if (
                        n.layers.test(r.layers) &&
                        (n.isMesh || n.isLine || n.isPoints) &&
                        (n.castShadow || (n.receiveShadow && 3 === o)) &&
                        (!n.frustumCulled || i.intersectsObject(n))
                    ) {
                        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                        const i = e.update(n),
                            r = n.material;
                        if (Array.isArray(r)) {
                            const e = i.groups;
                            for (let l = 0, c = e.length; l < c; l++) {
                                const c = e[l],
                                    h = r[c.materialIndex];
                                if (h && h.visible) {
                                    const e = y(n, 0, h, a, s.near, s.far, o);
                                    t.renderBufferDirect(s, null, i, e, n, c);
                                }
                            }
                        } else if (r.visible) {
                            const e = y(n, 0, r, a, s.near, s.far, o);
                            t.renderBufferDirect(s, null, i, e, n, null);
                        }
                    }
                    const l = n.children;
                    for (let t = 0, e = l.length; t < e; t++) x(l[t], r, s, a, o);
                }
                (this.enabled = !1),
                    (this.autoUpdate = !0),
                    (this.needsUpdate = !1),
                    (this.type = 1),
                    (this.render = function (e, n, o) {
                        if (!1 === g.enabled) return;
                        if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                        if (0 === e.length) return;
                        const l = t.getRenderTarget(),
                            c = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            d = t.state;
                        d.setBlending(0),
                            d.buffers.color.setClear(1, 1, 1, 1),
                            d.buffers.depth.setTest(!0),
                            d.setScissorTest(!1);
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l],
                                u = c.shadow;
                            if (void 0 === u) {
                                console.warn('THREE.WebGLShadowMap:', c, 'has no shadow.');
                                continue;
                            }
                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                            r.copy(u.mapSize);
                            const p = u.getFrameExtents();
                            if (
                                (r.multiply(p),
                                s.copy(u.mapSize),
                                (r.x > h || r.y > h) &&
                                    (r.x > h && ((s.x = Math.floor(h / p.x)), (r.x = s.x * p.x), (u.mapSize.x = s.x)),
                                    r.y > h && ((s.y = Math.floor(h / p.y)), (r.y = s.y * p.y), (u.mapSize.y = s.y))),
                                null === u.map && !u.isPointLightShadow && 3 === this.type)
                            ) {
                                const t = { minFilter: 1006, magFilter: 1006, format: 1023 };
                                (u.map = new zt(r.x, r.y, t)),
                                    (u.map.texture.name = c.name + '.shadowMap'),
                                    (u.mapPass = new zt(r.x, r.y, t)),
                                    u.camera.updateProjectionMatrix();
                            }
                            if (null === u.map) {
                                const t = { minFilter: 1003, magFilter: 1003, format: 1023 };
                                (u.map = new zt(r.x, r.y, t)),
                                    (u.map.texture.name = c.name + '.shadowMap'),
                                    u.camera.updateProjectionMatrix();
                            }
                            t.setRenderTarget(u.map), t.clear();
                            const m = u.getViewportCount();
                            for (let t = 0; t < m; t++) {
                                const e = u.getViewport(t);
                                a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                                    d.viewport(a),
                                    u.updateMatrices(c, t),
                                    (i = u.getFrustum()),
                                    x(n, o, u.camera, c, this.type);
                            }
                            u.isPointLightShadow || 3 !== this.type || v(u, o), (u.needsUpdate = !1);
                        }
                        (g.needsUpdate = !1), t.setRenderTarget(l, c, u);
                    });
            }
            function Us(t, e, n) {
                const i = n.isWebGL2,
                    r = new (function () {
                        let e = !1;
                        const n = new kt();
                        let i = null;
                        const r = new kt(0, 0, 0, 0);
                        return {
                            setMask: function (n) {
                                i === n || e || (t.colorMask(n, n, n, n), (i = n));
                            },
                            setLocked: function (t) {
                                e = t;
                            },
                            setClear: function (e, i, s, a, o) {
                                !0 === o && ((e *= a), (i *= a), (s *= a)),
                                    n.set(e, i, s, a),
                                    !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
                            },
                            reset: function () {
                                (e = !1), (i = null), r.set(-1, 0, 0, 0);
                            },
                        };
                    })(),
                    s = new (function () {
                        let e = !1,
                            n = null,
                            i = null,
                            r = null;
                        return {
                            setTest: function (t) {
                                t ? U(2929) : k(2929);
                            },
                            setMask: function (i) {
                                n === i || e || (t.depthMask(i), (n = i));
                            },
                            setFunc: function (e) {
                                if (i !== e) {
                                    if (e)
                                        switch (e) {
                                            case 0:
                                                t.depthFunc(512);
                                                break;
                                            case 1:
                                                t.depthFunc(519);
                                                break;
                                            case 2:
                                                t.depthFunc(513);
                                                break;
                                            default:
                                                t.depthFunc(515);
                                                break;
                                            case 4:
                                                t.depthFunc(514);
                                                break;
                                            case 5:
                                                t.depthFunc(518);
                                                break;
                                            case 6:
                                                t.depthFunc(516);
                                                break;
                                            case 7:
                                                t.depthFunc(517);
                                        }
                                    else t.depthFunc(515);
                                    i = e;
                                }
                            },
                            setLocked: function (t) {
                                e = t;
                            },
                            setClear: function (e) {
                                r !== e && (t.clearDepth(e), (r = e));
                            },
                            reset: function () {
                                (e = !1), (n = null), (i = null), (r = null);
                            },
                        };
                    })(),
                    a = new (function () {
                        let e = !1,
                            n = null,
                            i = null,
                            r = null,
                            s = null,
                            a = null,
                            o = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function (t) {
                                e || (t ? U(2960) : k(2960));
                            },
                            setMask: function (i) {
                                n === i || e || (t.stencilMask(i), (n = i));
                            },
                            setFunc: function (e, n, a) {
                                (i === e && r === n && s === a) || (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));
                            },
                            setOp: function (e, n, i) {
                                (a === e && o === n && l === i) || (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));
                            },
                            setLocked: function (t) {
                                e = t;
                            },
                            setClear: function (e) {
                                c !== e && (t.clearStencil(e), (c = e));
                            },
                            reset: function () {
                                (e = !1),
                                    (n = null),
                                    (i = null),
                                    (r = null),
                                    (s = null),
                                    (a = null),
                                    (o = null),
                                    (l = null),
                                    (c = null);
                            },
                        };
                    })();
                let o = {},
                    l = null,
                    c = {},
                    h = null,
                    u = !1,
                    d = null,
                    p = null,
                    m = null,
                    f = null,
                    g = null,
                    v = null,
                    y = null,
                    x = !1,
                    b = null,
                    w = null,
                    _ = null,
                    M = null,
                    S = null;
                const T = t.getParameter(35661);
                let E = !1,
                    A = 0;
                const L = t.getParameter(7938);
                -1 !== L.indexOf('WebGL')
                    ? ((A = parseFloat(/^WebGL (\d)/.exec(L)[1])), (E = A >= 1))
                    : -1 !== L.indexOf('OpenGL ES') && ((A = parseFloat(/^OpenGL ES (\d)/.exec(L)[1])), (E = A >= 2));
                let R = null,
                    C = {};
                const P = t.getParameter(3088),
                    I = t.getParameter(2978),
                    D = new kt().fromArray(P),
                    N = new kt().fromArray(I);
                function F(e, n, i) {
                    const r = new Uint8Array(4),
                        s = t.createTexture();
                    t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return s;
                }
                const O = {};
                function U(e) {
                    !0 !== o[e] && (t.enable(e), (o[e] = !0));
                }
                function k(e) {
                    !1 !== o[e] && (t.disable(e), (o[e] = !1));
                }
                (O[3553] = F(3553, 3553, 1)),
                    (O[34067] = F(34067, 34069, 6)),
                    r.setClear(0, 0, 0, 1),
                    s.setClear(1),
                    a.setClear(0),
                    U(2929),
                    s.setFunc(3),
                    G(!1),
                    V(1),
                    U(2884),
                    H(0);
                const z = { 100: 32774, 101: 32778, 102: 32779 };
                if (i) (z[103] = 32775), (z[104] = 32776);
                else {
                    const t = e.get('EXT_blend_minmax');
                    null !== t && ((z[103] = t.MIN_EXT), (z[104] = t.MAX_EXT));
                }
                const B = {
                    200: 0,
                    201: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    205: 771,
                    209: 775,
                    207: 773,
                };
                function H(e, n, i, r, s, a, o, l) {
                    if (0 !== e) {
                        if ((!1 === u && (U(3042), (u = !0)), 5 === e))
                            (s = s || n),
                                (a = a || i),
                                (o = o || r),
                                (n === p && s === g) || (t.blendEquationSeparate(z[n], z[s]), (p = n), (g = s)),
                                (i === m && r === f && a === v && o === y) ||
                                    (t.blendFuncSeparate(B[i], B[r], B[a], B[o]), (m = i), (f = r), (v = a), (y = o)),
                                (d = e),
                                (x = null);
                        else if (e !== d || l !== x) {
                            if (((100 === p && 100 === g) || (t.blendEquation(32774), (p = 100), (g = 100)), l))
                                switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(1, 1);
                                        break;
                                    case 3:
                                        t.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case 4:
                                        t.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error('THREE.WebGLState: Invalid blending: ', e);
                                }
                            else
                                switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(770, 1);
                                        break;
                                    case 3:
                                        t.blendFunc(0, 769);
                                        break;
                                    case 4:
                                        t.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error('THREE.WebGLState: Invalid blending: ', e);
                                }
                            (m = null), (f = null), (v = null), (y = null), (d = e), (x = l);
                        }
                    } else !0 === u && (k(3042), (u = !1));
                }
                function G(e) {
                    b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (b = e));
                }
                function V(e) {
                    0 !== e
                        ? (U(2884),
                          e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032)))
                        : k(2884),
                        (w = e);
                }
                function W(e, n, i) {
                    e ? (U(32823), (M === n && S === i) || (t.polygonOffset(n, i), (M = n), (S = i))) : k(32823);
                }
                function j(e) {
                    void 0 === e && (e = 33984 + T - 1), R !== e && (t.activeTexture(e), (R = e));
                }
                return {
                    buffers: { color: r, depth: s, stencil: a },
                    enable: U,
                    disable: k,
                    bindFramebuffer: function (e, n) {
                        return (
                            null === n && null !== l && (n = l),
                            c[e] !== n &&
                                (t.bindFramebuffer(e, n),
                                (c[e] = n),
                                i && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)),
                                !0)
                        );
                    },
                    bindXRFramebuffer: function (e) {
                        e !== l && (t.bindFramebuffer(36160, e), (l = e));
                    },
                    useProgram: function (e) {
                        return h !== e && (t.useProgram(e), (h = e), !0);
                    },
                    setBlending: H,
                    setMaterial: function (t, e) {
                        2 === t.side ? k(2884) : U(2884);
                        let n = 1 === t.side;
                        e && (n = !n),
                            G(n),
                            1 === t.blending && !1 === t.transparent
                                ? H(0)
                                : H(
                                      t.blending,
                                      t.blendEquation,
                                      t.blendSrc,
                                      t.blendDst,
                                      t.blendEquationAlpha,
                                      t.blendSrcAlpha,
                                      t.blendDstAlpha,
                                      t.premultipliedAlpha,
                                  ),
                            s.setFunc(t.depthFunc),
                            s.setTest(t.depthTest),
                            s.setMask(t.depthWrite),
                            r.setMask(t.colorWrite);
                        const i = t.stencilWrite;
                        a.setTest(i),
                            i &&
                                (a.setMask(t.stencilWriteMask),
                                a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                                a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                            W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                            !0 === t.alphaToCoverage ? U(32926) : k(32926);
                    },
                    setFlipSided: G,
                    setCullFace: V,
                    setLineWidth: function (e) {
                        e !== _ && (E && t.lineWidth(e), (_ = e));
                    },
                    setPolygonOffset: W,
                    setScissorTest: function (t) {
                        t ? U(3089) : k(3089);
                    },
                    activeTexture: j,
                    bindTexture: function (e, n) {
                        null === R && j();
                        let i = C[R];
                        void 0 === i && ((i = { type: void 0, texture: void 0 }), (C[R] = i)),
                            (i.type === e && i.texture === n) ||
                                (t.bindTexture(e, n || O[e]), (i.type = e), (i.texture = n));
                    },
                    unbindTexture: function () {
                        const e = C[R];
                        void 0 !== e &&
                            void 0 !== e.type &&
                            (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0));
                    },
                    compressedTexImage2D: function () {
                        try {
                            t.compressedTexImage2D.apply(t, arguments);
                        } catch (t) {
                            console.error('THREE.WebGLState:', t);
                        }
                    },
                    texImage2D: function () {
                        try {
                            t.texImage2D.apply(t, arguments);
                        } catch (t) {
                            console.error('THREE.WebGLState:', t);
                        }
                    },
                    texImage3D: function () {
                        try {
                            t.texImage3D.apply(t, arguments);
                        } catch (t) {
                            console.error('THREE.WebGLState:', t);
                        }
                    },
                    scissor: function (e) {
                        !1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e));
                    },
                    viewport: function (e) {
                        !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e));
                    },
                    reset: function () {
                        t.disable(3042),
                            t.disable(2884),
                            t.disable(2929),
                            t.disable(32823),
                            t.disable(3089),
                            t.disable(2960),
                            t.disable(32926),
                            t.blendEquation(32774),
                            t.blendFunc(1, 0),
                            t.blendFuncSeparate(1, 0, 1, 0),
                            t.colorMask(!0, !0, !0, !0),
                            t.clearColor(0, 0, 0, 0),
                            t.depthMask(!0),
                            t.depthFunc(513),
                            t.clearDepth(1),
                            t.stencilMask(4294967295),
                            t.stencilFunc(519, 0, 4294967295),
                            t.stencilOp(7680, 7680, 7680),
                            t.clearStencil(0),
                            t.cullFace(1029),
                            t.frontFace(2305),
                            t.polygonOffset(0, 0),
                            t.activeTexture(33984),
                            t.bindFramebuffer(36160, null),
                            !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
                            t.useProgram(null),
                            t.lineWidth(1),
                            t.scissor(0, 0, t.canvas.width, t.canvas.height),
                            t.viewport(0, 0, t.canvas.width, t.canvas.height),
                            (o = {}),
                            (R = null),
                            (C = {}),
                            (l = null),
                            (c = {}),
                            (h = null),
                            (u = !1),
                            (d = null),
                            (p = null),
                            (m = null),
                            (f = null),
                            (g = null),
                            (v = null),
                            (y = null),
                            (x = !1),
                            (b = null),
                            (w = null),
                            (_ = null),
                            (M = null),
                            (S = null),
                            D.set(0, 0, t.canvas.width, t.canvas.height),
                            N.set(0, 0, t.canvas.width, t.canvas.height),
                            r.reset(),
                            s.reset(),
                            a.reset();
                    },
                };
            }
            function ks(t, e, n, i, r, s, a) {
                const o = r.isWebGL2,
                    l = r.maxTextures,
                    c = r.maxCubemapSize,
                    h = r.maxTextureSize,
                    u = r.maxSamples,
                    d = new WeakMap();
                let p,
                    m = !1;
                try {
                    m = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext('2d');
                } catch (t) {}
                function f(t, e) {
                    return m ? new OffscreenCanvas(t, e) : It('canvas');
                }
                function g(t, e, n, i) {
                    let r = 1;
                    if (((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e)) {
                        if (
                            ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                            ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                            ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
                        ) {
                            const i = e ? At : Math.floor,
                                s = i(r * t.width),
                                a = i(r * t.height);
                            void 0 === p && (p = f(s, a));
                            const o = n ? f(s, a) : p;
                            return (
                                (o.width = s),
                                (o.height = a),
                                o.getContext('2d').drawImage(t, 0, 0, s, a),
                                console.warn(
                                    'THREE.WebGLRenderer: Texture has been resized from (' +
                                        t.width +
                                        'x' +
                                        t.height +
                                        ') to (' +
                                        s +
                                        'x' +
                                        a +
                                        ').',
                                ),
                                o
                            );
                        }
                        return (
                            'data' in t &&
                                console.warn(
                                    'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                                        t.width +
                                        'x' +
                                        t.height +
                                        ').',
                                ),
                            t
                        );
                    }
                    return t;
                }
                function v(t) {
                    return Tt(t.width) && Tt(t.height);
                }
                function y(t, e) {
                    return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter;
                }
                function x(e, n, r, s, a = 1) {
                    t.generateMipmap(e), (i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, a)));
                }
                function b(n, i, r, s) {
                    if (!1 === o) return i;
                    if (null !== n) {
                        if (void 0 !== t[n]) return t[n];
                        console.warn(
                            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'",
                        );
                    }
                    let a = i;
                    return (
                        6403 === i && (5126 === r && (a = 33326), 5131 === r && (a = 33325), 5121 === r && (a = 33321)),
                        6407 === i && (5126 === r && (a = 34837), 5131 === r && (a = 34843), 5121 === r && (a = 32849)),
                        6408 === i &&
                            (5126 === r && (a = 34836),
                            5131 === r && (a = 34842),
                            5121 === r && (a = 3001 === s ? 35907 : 32856)),
                        (33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a) || e.get('EXT_color_buffer_float'),
                        a
                    );
                }
                function w(t) {
                    return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
                }
                function _(e) {
                    const n = e.target;
                    n.removeEventListener('dispose', _),
                        (function (e) {
                            const n = i.get(e);
                            void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e));
                        })(n),
                        n.isVideoTexture && d.delete(n),
                        a.memory.textures--;
                }
                function M(e) {
                    const n = e.target;
                    n.removeEventListener('dispose', M),
                        (function (e) {
                            const n = e.texture,
                                r = i.get(e),
                                s = i.get(n);
                            if (e) {
                                if (
                                    (void 0 !== s.__webglTexture &&
                                        (t.deleteTexture(s.__webglTexture), a.memory.textures--),
                                    e.depthTexture && e.depthTexture.dispose(),
                                    e.isWebGLCubeRenderTarget)
                                )
                                    for (let e = 0; e < 6; e++)
                                        t.deleteFramebuffer(r.__webglFramebuffer[e]),
                                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                                else
                                    t.deleteFramebuffer(r.__webglFramebuffer),
                                        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                                        r.__webglMultisampledFramebuffer &&
                                            t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                                        r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                                        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                                if (e.isWebGLMultipleRenderTargets)
                                    for (let e = 0, r = n.length; e < r; e++) {
                                        const r = i.get(n[e]);
                                        r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--),
                                            i.remove(n[e]);
                                    }
                                i.remove(n), i.remove(e);
                            }
                        })(n);
                }
                let S = 0;
                function T(t, e) {
                    const r = i.get(t);
                    if (
                        (t.isVideoTexture &&
                            (function (t) {
                                const e = a.render.frame;
                                d.get(t) !== e && (d.set(t, e), t.update());
                            })(t),
                        t.version > 0 && r.__version !== t.version)
                    ) {
                        const n = t.image;
                        if (void 0 === n)
                            console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
                        else {
                            if (!1 !== n.complete) return void P(r, t, e);
                            console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
                        }
                    }
                    n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
                }
                function E(e, r) {
                    const a = i.get(e);
                    e.version > 0 && a.__version !== e.version
                        ? (function (e, i, r) {
                              if (6 !== i.image.length) return;
                              C(e, i),
                                  n.activeTexture(33984 + r),
                                  n.bindTexture(34067, e.__webglTexture),
                                  t.pixelStorei(37440, i.flipY),
                                  t.pixelStorei(37441, i.premultiplyAlpha),
                                  t.pixelStorei(3317, i.unpackAlignment),
                                  t.pixelStorei(37443, 0);
                              const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                                  l = i.image[0] && i.image[0].isDataTexture,
                                  h = [];
                              for (let t = 0; t < 6; t++)
                                  h[t] = a || l ? (l ? i.image[t].image : i.image[t]) : g(i.image[t], !1, !0, c);
                              const u = h[0],
                                  d = v(u) || o,
                                  p = s.convert(i.format),
                                  m = s.convert(i.type),
                                  f = b(i.internalFormat, p, m, i.encoding);
                              let w;
                              if ((R(34067, i, d), a)) {
                                  for (let t = 0; t < 6; t++) {
                                      w = h[t].mipmaps;
                                      for (let e = 0; e < w.length; e++) {
                                          const r = w[e];
                                          1023 !== i.format && 1022 !== i.format
                                              ? null !== p
                                                  ? n.compressedTexImage2D(
                                                        34069 + t,
                                                        e,
                                                        f,
                                                        r.width,
                                                        r.height,
                                                        0,
                                                        r.data,
                                                    )
                                                  : console.warn(
                                                        'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                                                    )
                                              : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data);
                                      }
                                  }
                                  e.__maxMipLevel = w.length - 1;
                              } else {
                                  w = i.mipmaps;
                                  for (let t = 0; t < 6; t++)
                                      if (l) {
                                          n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data);
                                          for (let e = 0; e < w.length; e++) {
                                              const i = w[e].image[t].image;
                                              n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data);
                                          }
                                      } else {
                                          n.texImage2D(34069 + t, 0, f, p, m, h[t]);
                                          for (let e = 0; e < w.length; e++) {
                                              const i = w[e];
                                              n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t]);
                                          }
                                      }
                                  e.__maxMipLevel = w.length;
                              }
                              y(i, d) && x(34067, i, u.width, u.height),
                                  (e.__version = i.version),
                                  i.onUpdate && i.onUpdate(i);
                          })(a, e, r)
                        : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture));
                }
                const A = { 1e3: 10497, 1001: 33071, 1002: 33648 },
                    L = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
                function R(n, s, a) {
                    if (
                        (a
                            ? (t.texParameteri(n, 10242, A[s.wrapS]),
                              t.texParameteri(n, 10243, A[s.wrapT]),
                              (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, A[s.wrapR]),
                              t.texParameteri(n, 10240, L[s.magFilter]),
                              t.texParameteri(n, 10241, L[s.minFilter]))
                            : (t.texParameteri(n, 10242, 33071),
                              t.texParameteri(n, 10243, 33071),
                              (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
                              (1001 === s.wrapS && 1001 === s.wrapT) ||
                                  console.warn(
                                      'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
                                  ),
                              t.texParameteri(n, 10240, w(s.magFilter)),
                              t.texParameteri(n, 10241, w(s.minFilter)),
                              1003 !== s.minFilter &&
                                  1006 !== s.minFilter &&
                                  console.warn(
                                      'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
                                  )),
                        !0 === e.has('EXT_texture_filter_anisotropic'))
                    ) {
                        const a = e.get('EXT_texture_filter_anisotropic');
                        if (1015 === s.type && !1 === e.has('OES_texture_float_linear')) return;
                        if (!1 === o && 1016 === s.type && !1 === e.has('OES_texture_half_float_linear')) return;
                        (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
                            (t.texParameterf(
                                n,
                                a.TEXTURE_MAX_ANISOTROPY_EXT,
                                Math.min(s.anisotropy, r.getMaxAnisotropy()),
                            ),
                            (i.get(s).__currentAnisotropy = s.anisotropy));
                    }
                }
                function C(e, n) {
                    void 0 === e.__webglInit &&
                        ((e.__webglInit = !0),
                        n.addEventListener('dispose', _),
                        (e.__webglTexture = t.createTexture()),
                        a.memory.textures++);
                }
                function P(e, i, r) {
                    let a = 3553;
                    i.isDataTexture2DArray && (a = 35866),
                        i.isDataTexture3D && (a = 32879),
                        C(e, i),
                        n.activeTexture(33984 + r),
                        n.bindTexture(a, e.__webglTexture),
                        t.pixelStorei(37440, i.flipY),
                        t.pixelStorei(37441, i.premultiplyAlpha),
                        t.pixelStorei(3317, i.unpackAlignment),
                        t.pixelStorei(37443, 0);
                    const l =
                            (function (t) {
                                return (
                                    !o &&
                                    (1001 !== t.wrapS ||
                                        1001 !== t.wrapT ||
                                        (1003 !== t.minFilter && 1006 !== t.minFilter))
                                );
                            })(i) && !1 === v(i.image),
                        c = g(i.image, l, !1, h),
                        u = v(c) || o,
                        d = s.convert(i.format);
                    let p,
                        m = s.convert(i.type),
                        f = b(i.internalFormat, d, m, i.encoding);
                    R(a, i, u);
                    const w = i.mipmaps;
                    if (i.isDepthTexture)
                        (f = 6402),
                            o
                                ? (f =
                                      1015 === i.type
                                          ? 36012
                                          : 1014 === i.type
                                          ? 33190
                                          : 1020 === i.type
                                          ? 35056
                                          : 33189)
                                : 1015 === i.type &&
                                  console.error('WebGLRenderer: Floating point depth texture requires WebGL2.'),
                            1026 === i.format &&
                                6402 === f &&
                                1012 !== i.type &&
                                1014 !== i.type &&
                                (console.warn(
                                    'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',
                                ),
                                (i.type = 1012),
                                (m = s.convert(i.type))),
                            1027 === i.format &&
                                6402 === f &&
                                ((f = 34041),
                                1020 !== i.type &&
                                    (console.warn(
                                        'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',
                                    ),
                                    (i.type = 1020),
                                    (m = s.convert(i.type)))),
                            n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
                    else if (i.isDataTexture)
                        if (w.length > 0 && u) {
                            for (let t = 0, e = w.length; t < e; t++)
                                (p = w[t]), n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                            (i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
                        } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data), (e.__maxMipLevel = 0);
                    else if (i.isCompressedTexture) {
                        for (let t = 0, e = w.length; t < e; t++)
                            (p = w[t]),
                                1023 !== i.format && 1022 !== i.format
                                    ? null !== d
                                        ? n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data)
                                        : console.warn(
                                              'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                                          )
                                    : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                        e.__maxMipLevel = w.length - 1;
                    } else if (i.isDataTexture2DArray)
                        n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), (e.__maxMipLevel = 0);
                    else if (i.isDataTexture3D)
                        n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), (e.__maxMipLevel = 0);
                    else if (w.length > 0 && u) {
                        for (let t = 0, e = w.length; t < e; t++) (p = w[t]), n.texImage2D(3553, t, f, d, m, p);
                        (i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
                    } else n.texImage2D(3553, 0, f, d, m, c), (e.__maxMipLevel = 0);
                    y(i, u) && x(a, i, c.width, c.height), (e.__version = i.version), i.onUpdate && i.onUpdate(i);
                }
                function I(e, r, a, o, l) {
                    const c = s.convert(a.format),
                        h = s.convert(a.type),
                        u = b(a.internalFormat, c, h, a.encoding);
                    32879 === l || 35866 === l
                        ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null)
                        : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null),
                        n.bindFramebuffer(36160, e),
                        t.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0),
                        n.bindFramebuffer(36160, null);
                }
                function D(e, n, i) {
                    if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
                        let r = 33189;
                        if (i) {
                            const e = n.depthTexture;
                            e && e.isDepthTexture && (1015 === e.type ? (r = 36012) : 1014 === e.type && (r = 33190));
                            const i = N(n);
                            t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
                        } else t.renderbufferStorage(36161, r, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e);
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (i) {
                            const e = N(n);
                            t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height);
                        } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e);
                    } else {
                        const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                            r = s.convert(e.format),
                            a = s.convert(e.type),
                            o = b(e.internalFormat, r, a, e.encoding);
                        if (i) {
                            const e = N(n);
                            t.renderbufferStorageMultisample(36161, e, o, n.width, n.height);
                        } else t.renderbufferStorage(36161, o, n.width, n.height);
                    }
                    t.bindRenderbuffer(36161, null);
                }
                function N(t) {
                    return o && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0;
                }
                let F = !1,
                    O = !1;
                (this.allocateTextureUnit = function () {
                    const t = S;
                    return (
                        t >= l &&
                            console.warn(
                                'THREE.WebGLTextures: Trying to use ' +
                                    t +
                                    ' texture units while this GPU supports only ' +
                                    l,
                            ),
                        (S += 1),
                        t
                    );
                }),
                    (this.resetTextureUnits = function () {
                        S = 0;
                    }),
                    (this.setTexture2D = T),
                    (this.setTexture2DArray = function (t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version
                            ? P(r, t, e)
                            : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture));
                    }),
                    (this.setTexture3D = function (t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version
                            ? P(r, t, e)
                            : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture));
                    }),
                    (this.setTextureCube = E),
                    (this.setupRenderTarget = function (e) {
                        const l = e.texture,
                            c = i.get(e),
                            h = i.get(l);
                        e.addEventListener('dispose', M),
                            !0 !== e.isWebGLMultipleRenderTargets &&
                                ((h.__webglTexture = t.createTexture()),
                                (h.__version = l.version),
                                a.memory.textures++);
                        const u = !0 === e.isWebGLCubeRenderTarget,
                            d = !0 === e.isWebGLMultipleRenderTargets,
                            p = !0 === e.isWebGLMultisampleRenderTarget,
                            m = l.isDataTexture3D || l.isDataTexture2DArray,
                            f = v(e) || o;
                        if (
                            (!o ||
                                1022 !== l.format ||
                                (1015 !== l.type && 1016 !== l.type) ||
                                ((l.format = 1023),
                                console.warn(
                                    'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.',
                                )),
                            u)
                        ) {
                            c.__webglFramebuffer = [];
                            for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer();
                        } else if (((c.__webglFramebuffer = t.createFramebuffer()), d))
                            if (r.drawBuffers) {
                                const n = e.texture;
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = i.get(n[e]);
                                    void 0 === r.__webglTexture &&
                                        ((r.__webglTexture = t.createTexture()), a.memory.textures++);
                                }
                            } else
                                console.warn(
                                    'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.',
                                );
                        else if (p)
                            if (o) {
                                (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                                    (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                                    t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                                const i = s.convert(l.format),
                                    r = s.convert(l.type),
                                    a = b(l.internalFormat, i, r, l.encoding),
                                    o = N(e);
                                t.renderbufferStorageMultisample(36161, o, a, e.width, e.height),
                                    n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                                    t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer),
                                    t.bindRenderbuffer(36161, null),
                                    e.depthBuffer &&
                                        ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                                        D(c.__webglDepthRenderbuffer, e, !0)),
                                    n.bindFramebuffer(36160, null);
                            } else
                                console.warn(
                                    'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                                );
                        if (u) {
                            n.bindTexture(34067, h.__webglTexture), R(34067, l, f);
                            for (let t = 0; t < 6; t++) I(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                            y(l, f) && x(34067, l, e.width, e.height), n.unbindTexture();
                        } else if (d) {
                            const t = e.texture;
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r],
                                    a = i.get(s);
                                n.bindTexture(3553, a.__webglTexture),
                                    R(3553, s, f),
                                    I(c.__webglFramebuffer, e, s, 36064 + r, 3553),
                                    y(s, f) && x(3553, s, e.width, e.height);
                            }
                            n.unbindTexture();
                        } else {
                            let t = 3553;
                            m &&
                                (o
                                    ? (t = l.isDataTexture3D ? 32879 : 35866)
                                    : console.warn(
                                          'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.',
                                      )),
                                n.bindTexture(t, h.__webglTexture),
                                R(t, l, f),
                                I(c.__webglFramebuffer, e, l, 36064, t),
                                y(l, f) && x(t, l, e.width, e.height, e.depth),
                                n.unbindTexture();
                        }
                        e.depthBuffer &&
                            (function (e) {
                                const r = i.get(e),
                                    s = !0 === e.isWebGLCubeRenderTarget;
                                if (e.depthTexture) {
                                    if (s) throw new Error('target.depthTexture not supported in Cube render targets');
                                    !(function (e, r) {
                                        if (r && r.isWebGLCubeRenderTarget)
                                            throw new Error('Depth Texture with cube render targets is not supported');
                                        if (
                                            (n.bindFramebuffer(36160, e),
                                            !r.depthTexture || !r.depthTexture.isDepthTexture)
                                        )
                                            throw new Error(
                                                'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
                                            );
                                        (i.get(r.depthTexture).__webglTexture &&
                                            r.depthTexture.image.width === r.width &&
                                            r.depthTexture.image.height === r.height) ||
                                            ((r.depthTexture.image.width = r.width),
                                            (r.depthTexture.image.height = r.height),
                                            (r.depthTexture.needsUpdate = !0)),
                                            T(r.depthTexture, 0);
                                        const s = i.get(r.depthTexture).__webglTexture;
                                        if (1026 === r.depthTexture.format)
                                            t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                                        else {
                                            if (1027 !== r.depthTexture.format)
                                                throw new Error('Unknown depthTexture format');
                                            t.framebufferTexture2D(36160, 33306, 3553, s, 0);
                                        }
                                    })(r.__webglFramebuffer, e);
                                } else if (s) {
                                    r.__webglDepthbuffer = [];
                                    for (let i = 0; i < 6; i++)
                                        n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                                            (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                                            D(r.__webglDepthbuffer[i], e, !1);
                                } else
                                    n.bindFramebuffer(36160, r.__webglFramebuffer),
                                        (r.__webglDepthbuffer = t.createRenderbuffer()),
                                        D(r.__webglDepthbuffer, e, !1);
                                n.bindFramebuffer(36160, null);
                            })(e);
                    }),
                    (this.updateRenderTargetMipmap = function (t) {
                        const e = v(t) || o,
                            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                        for (let s = 0, a = r.length; s < a; s++) {
                            const a = r[s];
                            if (y(a, e)) {
                                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                    r = i.get(a).__webglTexture;
                                n.bindTexture(e, r), x(e, a, t.width, t.height), n.unbindTexture();
                            }
                        }
                    }),
                    (this.updateMultisampleRenderTarget = function (e) {
                        if (e.isWebGLMultisampleRenderTarget)
                            if (o) {
                                const r = e.width,
                                    s = e.height;
                                let a = 16384;
                                e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024);
                                const o = i.get(e);
                                n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer),
                                    n.bindFramebuffer(36009, o.__webglFramebuffer),
                                    t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
                                    n.bindFramebuffer(36008, null),
                                    n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer);
                            } else
                                console.warn(
                                    'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                                );
                    }),
                    (this.safeSetTexture2D = function (t, e) {
                        t &&
                            t.isWebGLRenderTarget &&
                            (!1 === F &&
                                (console.warn(
                                    "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.",
                                ),
                                (F = !0)),
                            (t = t.texture)),
                            T(t, e);
                    }),
                    (this.safeSetTextureCube = function (t, e) {
                        t &&
                            t.isWebGLCubeRenderTarget &&
                            (!1 === O &&
                                (console.warn(
                                    "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
                                ),
                                (O = !0)),
                            (t = t.texture)),
                            E(t, e);
                    });
            }
            function zs(t, e, n) {
                const i = n.isWebGL2;
                return {
                    convert: function (t) {
                        let n;
                        if (1009 === t) return 5121;
                        if (1017 === t) return 32819;
                        if (1018 === t) return 32820;
                        if (1019 === t) return 33635;
                        if (1010 === t) return 5120;
                        if (1011 === t) return 5122;
                        if (1012 === t) return 5123;
                        if (1013 === t) return 5124;
                        if (1014 === t) return 5125;
                        if (1015 === t) return 5126;
                        if (1016 === t)
                            return i
                                ? 5131
                                : ((n = e.get('OES_texture_half_float')), null !== n ? n.HALF_FLOAT_OES : null);
                        if (1021 === t) return 6406;
                        if (1022 === t) return 6407;
                        if (1023 === t) return 6408;
                        if (1024 === t) return 6409;
                        if (1025 === t) return 6410;
                        if (1026 === t) return 6402;
                        if (1027 === t) return 34041;
                        if (1028 === t) return 6403;
                        if (1029 === t) return 36244;
                        if (1030 === t) return 33319;
                        if (1031 === t) return 33320;
                        if (1032 === t) return 36248;
                        if (1033 === t) return 36249;
                        if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                            if (((n = e.get('WEBGL_compressed_texture_s3tc')), null === n)) return null;
                            if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        }
                        if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                            if (((n = e.get('WEBGL_compressed_texture_pvrtc')), null === n)) return null;
                            if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                        }
                        if (36196 === t)
                            return (
                                (n = e.get('WEBGL_compressed_texture_etc1')),
                                null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
                            );
                        if ((37492 === t || 37496 === t) && ((n = e.get('WEBGL_compressed_texture_etc')), null !== n)) {
                            if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                            if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
                        }
                        return 37808 === t ||
                            37809 === t ||
                            37810 === t ||
                            37811 === t ||
                            37812 === t ||
                            37813 === t ||
                            37814 === t ||
                            37815 === t ||
                            37816 === t ||
                            37817 === t ||
                            37818 === t ||
                            37819 === t ||
                            37820 === t ||
                            37821 === t ||
                            37840 === t ||
                            37841 === t ||
                            37842 === t ||
                            37843 === t ||
                            37844 === t ||
                            37845 === t ||
                            37846 === t ||
                            37847 === t ||
                            37848 === t ||
                            37849 === t ||
                            37850 === t ||
                            37851 === t ||
                            37852 === t ||
                            37853 === t
                            ? ((n = e.get('WEBGL_compressed_texture_astc')), null !== n ? t : null)
                            : 36492 === t
                            ? ((n = e.get('EXT_texture_compression_bptc')), null !== n ? t : null)
                            : 1020 === t
                            ? i
                                ? 34042
                                : ((n = e.get('WEBGL_depth_texture')), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
                            : void 0;
                    },
                };
            }
            Fs.prototype.isMeshDistanceMaterial = !0;
            class Bs extends Kn {
                constructor(t = []) {
                    super(), (this.cameras = t);
                }
            }
            Bs.prototype.isArrayCamera = !0;
            class Hs extends We {
                constructor() {
                    super(), (this.type = 'Group');
                }
            }
            Hs.prototype.isGroup = !0;
            const Gs = { type: 'move' };
            class Vs {
                constructor() {
                    (this._targetRay = null), (this._grip = null), (this._hand = null);
                }
                getHandSpace() {
                    return (
                        null === this._hand &&
                            ((this._hand = new Hs()),
                            (this._hand.matrixAutoUpdate = !1),
                            (this._hand.visible = !1),
                            (this._hand.joints = {}),
                            (this._hand.inputState = { pinching: !1 })),
                        this._hand
                    );
                }
                getTargetRaySpace() {
                    return (
                        null === this._targetRay &&
                            ((this._targetRay = new Hs()),
                            (this._targetRay.matrixAutoUpdate = !1),
                            (this._targetRay.visible = !1),
                            (this._targetRay.hasLinearVelocity = !1),
                            (this._targetRay.linearVelocity = new Gt()),
                            (this._targetRay.hasAngularVelocity = !1),
                            (this._targetRay.angularVelocity = new Gt())),
                        this._targetRay
                    );
                }
                getGripSpace() {
                    return (
                        null === this._grip &&
                            ((this._grip = new Hs()),
                            (this._grip.matrixAutoUpdate = !1),
                            (this._grip.visible = !1),
                            (this._grip.hasLinearVelocity = !1),
                            (this._grip.linearVelocity = new Gt()),
                            (this._grip.hasAngularVelocity = !1),
                            (this._grip.angularVelocity = new Gt())),
                        this._grip
                    );
                }
                dispatchEvent(t) {
                    return (
                        null !== this._targetRay && this._targetRay.dispatchEvent(t),
                        null !== this._grip && this._grip.dispatchEvent(t),
                        null !== this._hand && this._hand.dispatchEvent(t),
                        this
                    );
                }
                disconnect(t) {
                    return (
                        this.dispatchEvent({ type: 'disconnected', data: t }),
                        null !== this._targetRay && (this._targetRay.visible = !1),
                        null !== this._grip && (this._grip.visible = !1),
                        null !== this._hand && (this._hand.visible = !1),
                        this
                    );
                }
                update(t, e, n) {
                    let i = null,
                        r = null,
                        s = null;
                    const a = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (t && 'visible-blurred' !== e.session.visibilityState)
                        if (
                            (null !== a &&
                                ((i = e.getPose(t.targetRaySpace, n)),
                                null !== i &&
                                    (a.matrix.fromArray(i.transform.matrix),
                                    a.matrix.decompose(a.position, a.rotation, a.scale),
                                    i.linearVelocity
                                        ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(i.linearVelocity))
                                        : (a.hasLinearVelocity = !1),
                                    i.angularVelocity
                                        ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(i.angularVelocity))
                                        : (a.hasAngularVelocity = !1),
                                    this.dispatchEvent(Gs))),
                            l && t.hand)
                        ) {
                            s = !0;
                            for (const i of t.hand.values()) {
                                const t = e.getJointPose(i, n);
                                if (void 0 === l.joints[i.jointName]) {
                                    const t = new Hs();
                                    (t.matrixAutoUpdate = !1), (t.visible = !1), (l.joints[i.jointName] = t), l.add(t);
                                }
                                const r = l.joints[i.jointName];
                                null !== t &&
                                    (r.matrix.fromArray(t.transform.matrix),
                                    r.matrix.decompose(r.position, r.rotation, r.scale),
                                    (r.jointRadius = t.radius)),
                                    (r.visible = null !== t);
                            }
                            const i = l.joints['index-finger-tip'],
                                r = l.joints['thumb-tip'],
                                a = i.position.distanceTo(r.position),
                                o = 0.02,
                                c = 0.005;
                            l.inputState.pinching && a > o + c
                                ? ((l.inputState.pinching = !1),
                                  this.dispatchEvent({ type: 'pinchend', handedness: t.handedness, target: this }))
                                : !l.inputState.pinching &&
                                  a <= o - c &&
                                  ((l.inputState.pinching = !0),
                                  this.dispatchEvent({ type: 'pinchstart', handedness: t.handedness, target: this }));
                        } else
                            null !== o &&
                                t.gripSpace &&
                                ((r = e.getPose(t.gripSpace, n)),
                                null !== r &&
                                    (o.matrix.fromArray(r.transform.matrix),
                                    o.matrix.decompose(o.position, o.rotation, o.scale),
                                    r.linearVelocity
                                        ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(r.linearVelocity))
                                        : (o.hasLinearVelocity = !1),
                                    r.angularVelocity
                                        ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(r.angularVelocity))
                                        : (o.hasAngularVelocity = !1)));
                    return (
                        null !== a && (a.visible = null !== i),
                        null !== o && (o.visible = null !== r),
                        null !== l && (l.visible = null !== s),
                        this
                    );
                }
            }
            class Ws extends ft {
                constructor(t, e) {
                    super();
                    const n = this,
                        i = t.state;
                    let r = null,
                        s = 1,
                        a = null,
                        o = 'local-floor',
                        l = null,
                        c = null,
                        h = null,
                        u = null,
                        d = null,
                        p = !1,
                        m = null,
                        f = null,
                        g = null,
                        v = null,
                        y = null,
                        x = null;
                    const b = [],
                        w = new Map(),
                        _ = new Kn();
                    _.layers.enable(1), (_.viewport = new kt());
                    const M = new Kn();
                    M.layers.enable(2), (M.viewport = new kt());
                    const S = [_, M],
                        T = new Bs();
                    T.layers.enable(1), T.layers.enable(2);
                    let E = null,
                        A = null;
                    function L(t) {
                        const e = w.get(t.inputSource);
                        e && e.dispatchEvent({ type: t.type, data: t.inputSource });
                    }
                    function R() {
                        w.forEach(function (t, e) {
                            t.disconnect(e);
                        }),
                            w.clear(),
                            (E = null),
                            (A = null),
                            i.bindXRFramebuffer(null),
                            t.setRenderTarget(t.getRenderTarget()),
                            h && e.deleteFramebuffer(h),
                            m && e.deleteFramebuffer(m),
                            f && e.deleteRenderbuffer(f),
                            g && e.deleteRenderbuffer(g),
                            (h = null),
                            (m = null),
                            (f = null),
                            (g = null),
                            (d = null),
                            (u = null),
                            (c = null),
                            (r = null),
                            F.stop(),
                            (n.isPresenting = !1),
                            n.dispatchEvent({ type: 'sessionend' });
                    }
                    function C(t) {
                        const e = r.inputSources;
                        for (let t = 0; t < b.length; t++) w.set(e[t], b[t]);
                        for (let e = 0; e < t.removed.length; e++) {
                            const n = t.removed[e],
                                i = w.get(n);
                            i && (i.dispatchEvent({ type: 'disconnected', data: n }), w.delete(n));
                        }
                        for (let e = 0; e < t.added.length; e++) {
                            const n = t.added[e],
                                i = w.get(n);
                            i && i.dispatchEvent({ type: 'connected', data: n });
                        }
                    }
                    (this.cameraAutoUpdate = !0),
                        (this.enabled = !1),
                        (this.isPresenting = !1),
                        (this.getController = function (t) {
                            let e = b[t];
                            return void 0 === e && ((e = new Vs()), (b[t] = e)), e.getTargetRaySpace();
                        }),
                        (this.getControllerGrip = function (t) {
                            let e = b[t];
                            return void 0 === e && ((e = new Vs()), (b[t] = e)), e.getGripSpace();
                        }),
                        (this.getHand = function (t) {
                            let e = b[t];
                            return void 0 === e && ((e = new Vs()), (b[t] = e)), e.getHandSpace();
                        }),
                        (this.setFramebufferScaleFactor = function (t) {
                            (s = t),
                                !0 === n.isPresenting &&
                                    console.warn(
                                        'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',
                                    );
                        }),
                        (this.setReferenceSpaceType = function (t) {
                            (o = t),
                                !0 === n.isPresenting &&
                                    console.warn(
                                        'THREE.WebXRManager: Cannot change reference space type while presenting.',
                                    );
                        }),
                        (this.getReferenceSpace = function () {
                            return a;
                        }),
                        (this.getBaseLayer = function () {
                            return null !== u ? u : d;
                        }),
                        (this.getBinding = function () {
                            return c;
                        }),
                        (this.getFrame = function () {
                            return v;
                        }),
                        (this.getSession = function () {
                            return r;
                        }),
                        (this.setSession = async function (t) {
                            if (((r = t), null !== r)) {
                                r.addEventListener('select', L),
                                    r.addEventListener('selectstart', L),
                                    r.addEventListener('selectend', L),
                                    r.addEventListener('squeeze', L),
                                    r.addEventListener('squeezestart', L),
                                    r.addEventListener('squeezeend', L),
                                    r.addEventListener('end', R),
                                    r.addEventListener('inputsourceschange', C);
                                const t = e.getContextAttributes();
                                if (
                                    (!0 !== t.xrCompatible && (await e.makeXRCompatible()),
                                    void 0 === r.renderState.layers)
                                ) {
                                    const n = {
                                        antialias: t.antialias,
                                        alpha: t.alpha,
                                        depth: t.depth,
                                        stencil: t.stencil,
                                        framebufferScaleFactor: s,
                                    };
                                    (d = new XRWebGLLayer(r, e, n)), r.updateRenderState({ baseLayer: d });
                                } else if (e instanceof WebGLRenderingContext) {
                                    const n = {
                                        antialias: !0,
                                        alpha: t.alpha,
                                        depth: t.depth,
                                        stencil: t.stencil,
                                        framebufferScaleFactor: s,
                                    };
                                    (d = new XRWebGLLayer(r, e, n)), r.updateRenderState({ layers: [d] });
                                } else {
                                    p = t.antialias;
                                    let n = null;
                                    t.depth &&
                                        ((x = 256),
                                        t.stencil && (x |= 1024),
                                        (y = t.stencil ? 33306 : 36096),
                                        (n = t.stencil ? 35056 : 33190));
                                    const a = { colorFormat: t.alpha ? 32856 : 32849, depthFormat: n, scaleFactor: s };
                                    (c = new XRWebGLBinding(r, e)),
                                        (u = c.createProjectionLayer(a)),
                                        (h = e.createFramebuffer()),
                                        r.updateRenderState({ layers: [u] }),
                                        p &&
                                            ((m = e.createFramebuffer()),
                                            (f = e.createRenderbuffer()),
                                            e.bindRenderbuffer(36161, f),
                                            e.renderbufferStorageMultisample(
                                                36161,
                                                4,
                                                32856,
                                                u.textureWidth,
                                                u.textureHeight,
                                            ),
                                            i.bindFramebuffer(36160, m),
                                            e.framebufferRenderbuffer(36160, 36064, 36161, f),
                                            e.bindRenderbuffer(36161, null),
                                            null !== n &&
                                                ((g = e.createRenderbuffer()),
                                                e.bindRenderbuffer(36161, g),
                                                e.renderbufferStorageMultisample(
                                                    36161,
                                                    4,
                                                    n,
                                                    u.textureWidth,
                                                    u.textureHeight,
                                                ),
                                                e.framebufferRenderbuffer(36160, y, 36161, g),
                                                e.bindRenderbuffer(36161, null)),
                                            i.bindFramebuffer(36160, null));
                                }
                                (a = await r.requestReferenceSpace(o)),
                                    F.setContext(r),
                                    F.start(),
                                    (n.isPresenting = !0),
                                    n.dispatchEvent({ type: 'sessionstart' });
                            }
                        });
                    const P = new Gt(),
                        I = new Gt();
                    function D(t, e) {
                        null === e
                            ? t.matrixWorld.copy(t.matrix)
                            : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                            t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    }
                    (this.updateCamera = function (t) {
                        if (null === r) return;
                        (T.near = M.near = _.near = t.near),
                            (T.far = M.far = _.far = t.far),
                            (E === T.near && A === T.far) ||
                                (r.updateRenderState({ depthNear: T.near, depthFar: T.far }),
                                (E = T.near),
                                (A = T.far));
                        const e = t.parent,
                            n = T.cameras;
                        D(T, e);
                        for (let t = 0; t < n.length; t++) D(n[t], e);
                        T.matrixWorld.decompose(T.position, T.quaternion, T.scale),
                            t.position.copy(T.position),
                            t.quaternion.copy(T.quaternion),
                            t.scale.copy(T.scale),
                            t.matrix.copy(T.matrix),
                            t.matrixWorld.copy(T.matrixWorld);
                        const i = t.children;
                        for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
                        2 === n.length
                            ? (function (t, e, n) {
                                  P.setFromMatrixPosition(e.matrixWorld), I.setFromMatrixPosition(n.matrixWorld);
                                  const i = P.distanceTo(I),
                                      r = e.projectionMatrix.elements,
                                      s = n.projectionMatrix.elements,
                                      a = r[14] / (r[10] - 1),
                                      o = r[14] / (r[10] + 1),
                                      l = (r[9] + 1) / r[5],
                                      c = (r[9] - 1) / r[5],
                                      h = (r[8] - 1) / r[0],
                                      u = (s[8] + 1) / s[0],
                                      d = a * h,
                                      p = a * u,
                                      m = i / (-h + u),
                                      f = m * -h;
                                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                                      t.translateX(f),
                                      t.translateZ(m),
                                      t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                                      t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                  const g = a + m,
                                      v = o + m,
                                      y = d - f,
                                      x = p + (i - f),
                                      b = ((l * o) / v) * g,
                                      w = ((c * o) / v) * g;
                                  t.projectionMatrix.makePerspective(y, x, b, w, g, v);
                              })(T, _, M)
                            : T.projectionMatrix.copy(_.projectionMatrix);
                    }),
                        (this.getCamera = function () {
                            return T;
                        }),
                        (this.getFoveation = function () {
                            return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0;
                        }),
                        (this.setFoveation = function (t) {
                            null !== u && (u.fixedFoveation = t),
                                null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
                        });
                    let N = null;
                    const F = new ci();
                    F.setAnimationLoop(function (t, n) {
                        if (((l = n.getViewerPose(a)), (v = n), null !== l)) {
                            const t = l.views;
                            null !== d && i.bindXRFramebuffer(d.framebuffer);
                            let n = !1;
                            t.length !== T.cameras.length && ((T.cameras.length = 0), (n = !0));
                            for (let r = 0; r < t.length; r++) {
                                const s = t[r];
                                let a = null;
                                if (null !== d) a = d.getViewport(s);
                                else {
                                    const t = c.getViewSubImage(u, s);
                                    i.bindXRFramebuffer(h),
                                        void 0 !== t.depthStencilTexture &&
                                            e.framebufferTexture2D(36160, y, 3553, t.depthStencilTexture, 0),
                                        e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0),
                                        (a = t.viewport);
                                }
                                const o = S[r];
                                o.matrix.fromArray(s.transform.matrix),
                                    o.projectionMatrix.fromArray(s.projectionMatrix),
                                    o.viewport.set(a.x, a.y, a.width, a.height),
                                    0 === r && T.matrix.copy(o.matrix),
                                    !0 === n && T.cameras.push(o);
                            }
                            p && (i.bindXRFramebuffer(m), null !== x && e.clear(x));
                        }
                        const s = r.inputSources;
                        for (let t = 0; t < b.length; t++) {
                            const e = b[t],
                                i = s[t];
                            e.update(i, n, a);
                        }
                        if ((N && N(t, n), p)) {
                            const t = u.textureWidth,
                                n = u.textureHeight;
                            i.bindFramebuffer(36008, m),
                                i.bindFramebuffer(36009, h),
                                e.invalidateFramebuffer(36008, [y]),
                                e.invalidateFramebuffer(36009, [y]),
                                e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728),
                                e.invalidateFramebuffer(36008, [36064]),
                                i.bindFramebuffer(36008, null),
                                i.bindFramebuffer(36009, null),
                                i.bindFramebuffer(36160, m);
                        }
                        v = null;
                    }),
                        (this.setAnimationLoop = function (t) {
                            N = t;
                        }),
                        (this.dispose = function () {});
                }
            }
            function js(t) {
                function e(e, n) {
                    (e.opacity.value = n.opacity),
                        n.color && e.diffuse.value.copy(n.color),
                        n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
                        n.map && (e.map.value = n.map),
                        n.alphaMap && (e.alphaMap.value = n.alphaMap),
                        n.specularMap && (e.specularMap.value = n.specularMap),
                        n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                    const i = t.get(n).envMap;
                    if (i) {
                        (e.envMap.value = i),
                            (e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
                            (e.reflectivity.value = n.reflectivity),
                            (e.ior.value = n.ior),
                            (e.refractionRatio.value = n.refractionRatio);
                        const r = t.get(i).__maxMipLevel;
                        void 0 !== r && (e.maxMipLevel.value = r);
                    }
                    let r, s;
                    n.lightMap && ((e.lightMap.value = n.lightMap), (e.lightMapIntensity.value = n.lightMapIntensity)),
                        n.aoMap && ((e.aoMap.value = n.aoMap), (e.aoMapIntensity.value = n.aoMapIntensity)),
                        n.map
                            ? (r = n.map)
                            : n.specularMap
                            ? (r = n.specularMap)
                            : n.displacementMap
                            ? (r = n.displacementMap)
                            : n.normalMap
                            ? (r = n.normalMap)
                            : n.bumpMap
                            ? (r = n.bumpMap)
                            : n.roughnessMap
                            ? (r = n.roughnessMap)
                            : n.metalnessMap
                            ? (r = n.metalnessMap)
                            : n.alphaMap
                            ? (r = n.alphaMap)
                            : n.emissiveMap
                            ? (r = n.emissiveMap)
                            : n.clearcoatMap
                            ? (r = n.clearcoatMap)
                            : n.clearcoatNormalMap
                            ? (r = n.clearcoatNormalMap)
                            : n.clearcoatRoughnessMap
                            ? (r = n.clearcoatRoughnessMap)
                            : n.specularIntensityMap
                            ? (r = n.specularIntensityMap)
                            : n.specularTintMap
                            ? (r = n.specularTintMap)
                            : n.transmissionMap
                            ? (r = n.transmissionMap)
                            : n.thicknessMap && (r = n.thicknessMap),
                        void 0 !== r &&
                            (r.isWebGLRenderTarget && (r = r.texture),
                            !0 === r.matrixAutoUpdate && r.updateMatrix(),
                            e.uvTransform.value.copy(r.matrix)),
                        n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
                        void 0 !== s &&
                            (s.isWebGLRenderTarget && (s = s.texture),
                            !0 === s.matrixAutoUpdate && s.updateMatrix(),
                            e.uv2Transform.value.copy(s.matrix));
                }
                function n(e, n) {
                    (e.roughness.value = n.roughness),
                        (e.metalness.value = n.metalness),
                        n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
                        n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
                        n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
                        n.bumpMap &&
                            ((e.bumpMap.value = n.bumpMap),
                            (e.bumpScale.value = n.bumpScale),
                            1 === n.side && (e.bumpScale.value *= -1)),
                        n.normalMap &&
                            ((e.normalMap.value = n.normalMap),
                            e.normalScale.value.copy(n.normalScale),
                            1 === n.side && e.normalScale.value.negate()),
                        n.displacementMap &&
                            ((e.displacementMap.value = n.displacementMap),
                            (e.displacementScale.value = n.displacementScale),
                            (e.displacementBias.value = n.displacementBias)),
                        t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
                }
                return {
                    refreshFogUniforms: function (t, e) {
                        t.fogColor.value.copy(e.color),
                            e.isFog
                                ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                                : e.isFogExp2 && (t.fogDensity.value = e.density);
                    },
                    refreshMaterialUniforms: function (t, i, r, s, a) {
                        i.isMeshBasicMaterial
                            ? e(t, i)
                            : i.isMeshLambertMaterial
                            ? (e(t, i),
                              (function (t, e) {
                                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                              })(t, i))
                            : i.isMeshToonMaterial
                            ? (e(t, i),
                              (function (t, e) {
                                  e.gradientMap && (t.gradientMap.value = e.gradientMap),
                                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                                      e.bumpMap &&
                                          ((t.bumpMap.value = e.bumpMap),
                                          (t.bumpScale.value = e.bumpScale),
                                          1 === e.side && (t.bumpScale.value *= -1)),
                                      e.normalMap &&
                                          ((t.normalMap.value = e.normalMap),
                                          t.normalScale.value.copy(e.normalScale),
                                          1 === e.side && t.normalScale.value.negate()),
                                      e.displacementMap &&
                                          ((t.displacementMap.value = e.displacementMap),
                                          (t.displacementScale.value = e.displacementScale),
                                          (t.displacementBias.value = e.displacementBias));
                              })(t, i))
                            : i.isMeshPhongMaterial
                            ? (e(t, i),
                              (function (t, e) {
                                  t.specular.value.copy(e.specular),
                                      (t.shininess.value = Math.max(e.shininess, 1e-4)),
                                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                                      e.bumpMap &&
                                          ((t.bumpMap.value = e.bumpMap),
                                          (t.bumpScale.value = e.bumpScale),
                                          1 === e.side && (t.bumpScale.value *= -1)),
                                      e.normalMap &&
                                          ((t.normalMap.value = e.normalMap),
                                          t.normalScale.value.copy(e.normalScale),
                                          1 === e.side && t.normalScale.value.negate()),
                                      e.displacementMap &&
                                          ((t.displacementMap.value = e.displacementMap),
                                          (t.displacementScale.value = e.displacementScale),
                                          (t.displacementBias.value = e.displacementBias));
                              })(t, i))
                            : i.isMeshStandardMaterial
                            ? (e(t, i),
                              i.isMeshPhysicalMaterial
                                  ? (function (t, e, i) {
                                        n(t, e),
                                            (t.ior.value = e.ior),
                                            e.sheen > 0 &&
                                                (t.sheenTint.value.copy(e.sheenTint).multiplyScalar(e.sheen),
                                                (t.sheenRoughness.value = e.sheenRoughness)),
                                            e.clearcoat > 0 &&
                                                ((t.clearcoat.value = e.clearcoat),
                                                (t.clearcoatRoughness.value = e.clearcoatRoughness),
                                                e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                                                e.clearcoatRoughnessMap &&
                                                    (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                                                e.clearcoatNormalMap &&
                                                    (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                                                    (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                                                    1 === e.side && t.clearcoatNormalScale.value.negate())),
                                            e.transmission > 0 &&
                                                ((t.transmission.value = e.transmission),
                                                (t.transmissionSamplerMap.value = i.texture),
                                                t.transmissionSamplerSize.value.set(i.width, i.height),
                                                e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
                                                (t.thickness.value = e.thickness),
                                                e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                                                (t.attenuationDistance.value = e.attenuationDistance),
                                                t.attenuationTint.value.copy(e.attenuationTint)),
                                            (t.specularIntensity.value = e.specularIntensity),
                                            t.specularTint.value.copy(e.specularTint),
                                            e.specularIntensityMap &&
                                                (t.specularIntensityMap.value = e.specularIntensityMap),
                                            e.specularTintMap && (t.specularTintMap.value = e.specularTintMap);
                                    })(t, i, a)
                                  : n(t, i))
                            : i.isMeshMatcapMaterial
                            ? (e(t, i),
                              (function (t, e) {
                                  e.matcap && (t.matcap.value = e.matcap),
                                      e.bumpMap &&
                                          ((t.bumpMap.value = e.bumpMap),
                                          (t.bumpScale.value = e.bumpScale),
                                          1 === e.side && (t.bumpScale.value *= -1)),
                                      e.normalMap &&
                                          ((t.normalMap.value = e.normalMap),
                                          t.normalScale.value.copy(e.normalScale),
                                          1 === e.side && t.normalScale.value.negate()),
                                      e.displacementMap &&
                                          ((t.displacementMap.value = e.displacementMap),
                                          (t.displacementScale.value = e.displacementScale),
                                          (t.displacementBias.value = e.displacementBias));
                              })(t, i))
                            : i.isMeshDepthMaterial
                            ? (e(t, i),
                              (function (t, e) {
                                  e.displacementMap &&
                                      ((t.displacementMap.value = e.displacementMap),
                                      (t.displacementScale.value = e.displacementScale),
                                      (t.displacementBias.value = e.displacementBias));
                              })(t, i))
                            : i.isMeshDistanceMaterial
                            ? (e(t, i),
                              (function (t, e) {
                                  e.displacementMap &&
                                      ((t.displacementMap.value = e.displacementMap),
                                      (t.displacementScale.value = e.displacementScale),
                                      (t.displacementBias.value = e.displacementBias)),
                                      t.referencePosition.value.copy(e.referencePosition),
                                      (t.nearDistance.value = e.nearDistance),
                                      (t.farDistance.value = e.farDistance);
                              })(t, i))
                            : i.isMeshNormalMaterial
                            ? (e(t, i),
                              (function (t, e) {
                                  e.bumpMap &&
                                      ((t.bumpMap.value = e.bumpMap),
                                      (t.bumpScale.value = e.bumpScale),
                                      1 === e.side && (t.bumpScale.value *= -1)),
                                      e.normalMap &&
                                          ((t.normalMap.value = e.normalMap),
                                          t.normalScale.value.copy(e.normalScale),
                                          1 === e.side && t.normalScale.value.negate()),
                                      e.displacementMap &&
                                          ((t.displacementMap.value = e.displacementMap),
                                          (t.displacementScale.value = e.displacementScale),
                                          (t.displacementBias.value = e.displacementBias));
                              })(t, i))
                            : i.isLineBasicMaterial
                            ? ((function (t, e) {
                                  t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
                              })(t, i),
                              i.isLineDashedMaterial &&
                                  (function (t, e) {
                                      (t.dashSize.value = e.dashSize),
                                          (t.totalSize.value = e.dashSize + e.gapSize),
                                          (t.scale.value = e.scale);
                                  })(t, i))
                            : i.isPointsMaterial
                            ? (function (t, e, n, i) {
                                  let r;
                                  t.diffuse.value.copy(e.color),
                                      (t.opacity.value = e.opacity),
                                      (t.size.value = e.size * n),
                                      (t.scale.value = 0.5 * i),
                                      e.map && (t.map.value = e.map),
                                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                                      e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
                                      void 0 !== r &&
                                          (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                                          t.uvTransform.value.copy(r.matrix));
                              })(t, i, r, s)
                            : i.isSpriteMaterial
                            ? (function (t, e) {
                                  let n;
                                  t.diffuse.value.copy(e.color),
                                      (t.opacity.value = e.opacity),
                                      (t.rotation.value = e.rotation),
                                      e.map && (t.map.value = e.map),
                                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                                      e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
                                      void 0 !== n &&
                                          (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                                          t.uvTransform.value.copy(n.matrix));
                              })(t, i)
                            : i.isShadowMaterial
                            ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
                            : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
                    },
                };
            }
            function qs(t = {}) {
                const e =
                        void 0 !== t.canvas
                            ? t.canvas
                            : (function () {
                                  const t = It('canvas');
                                  return (t.style.display = 'block'), t;
                              })(),
                    n = void 0 !== t.context ? t.context : null,
                    i = void 0 !== t.alpha && t.alpha,
                    r = void 0 === t.depth || t.depth,
                    s = void 0 === t.stencil || t.stencil,
                    a = void 0 !== t.antialias && t.antialias,
                    o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    c = void 0 !== t.powerPreference ? t.powerPreference : 'default',
                    h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                let u = null,
                    d = null;
                const p = [],
                    m = [];
                (this.domElement = e),
                    (this.debug = { checkShaderErrors: !0 }),
                    (this.autoClear = !0),
                    (this.autoClearColor = !0),
                    (this.autoClearDepth = !0),
                    (this.autoClearStencil = !0),
                    (this.sortObjects = !0),
                    (this.clippingPlanes = []),
                    (this.localClippingEnabled = !1),
                    (this.gammaFactor = 2),
                    (this.outputEncoding = 3e3),
                    (this.physicallyCorrectLights = !1),
                    (this.toneMapping = 0),
                    (this.toneMappingExposure = 1);
                const f = this;
                let g = !1,
                    v = 0,
                    y = 0,
                    x = null,
                    b = -1,
                    w = null;
                const _ = new kt(),
                    M = new kt();
                let S = null,
                    T = e.width,
                    E = e.height,
                    A = 1,
                    L = null,
                    R = null;
                const C = new kt(0, 0, T, E),
                    P = new kt(0, 0, T, E);
                let I = !1;
                const D = [],
                    N = new li();
                let F = !1,
                    O = !1,
                    U = null;
                const k = new xe(),
                    z = new Gt(),
                    B = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
                function H() {
                    return null === x ? A : 1;
                }
                let G,
                    V,
                    W,
                    j,
                    q,
                    X,
                    Y,
                    Z,
                    J,
                    $,
                    K,
                    Q,
                    tt,
                    et,
                    nt,
                    it,
                    rt,
                    st,
                    at,
                    ot,
                    lt,
                    ct,
                    ht,
                    ut = n;
                function dt(t, n) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i],
                            s = e.getContext(r, n);
                        if (null !== s) return s;
                    }
                    return null;
                }
                try {
                    const t = {
                        alpha: i,
                        depth: r,
                        stencil: s,
                        antialias: a,
                        premultipliedAlpha: o,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: h,
                    };
                    if (
                        (e.addEventListener('webglcontextlost', ft, !1),
                        e.addEventListener('webglcontextrestored', gt, !1),
                        null === ut)
                    ) {
                        const e = ['webgl2', 'webgl', 'experimental-webgl'];
                        if ((!0 === f.isWebGL1Renderer && e.shift(), (ut = dt(e, t)), null === ut))
                            throw dt(e)
                                ? new Error('Error creating WebGL context with your selected attributes.')
                                : new Error('Error creating WebGL context.');
                    }
                    void 0 === ut.getShaderPrecisionFormat &&
                        (ut.getShaderPrecisionFormat = function () {
                            return { rangeMin: 1, rangeMax: 1, precision: 1 };
                        });
                } catch (t) {
                    throw (console.error('THREE.WebGLRenderer: ' + t.message), t);
                }
                function pt() {
                    (G = new Vi(ut)),
                        (V = new yi(ut, G, t)),
                        G.init(V),
                        (ct = new zs(ut, G, V)),
                        (W = new Us(ut, G, V)),
                        (D[0] = 1029),
                        (j = new qi(ut)),
                        (q = new Ms()),
                        (X = new ks(ut, G, W, q, V, ct, j)),
                        (Y = new bi(f)),
                        (Z = new Gi(f)),
                        (J = new hi(ut, V)),
                        (ht = new gi(ut, G, J, V)),
                        ($ = new Wi(ut, J, j, ht)),
                        (K = new Ki(ut, $, J, j)),
                        (at = new $i(ut, V, X)),
                        (it = new xi(q)),
                        (Q = new _s(f, Y, Z, G, V, ht, it)),
                        (tt = new js(q)),
                        (et = new As(q)),
                        (nt = new Ds(G, V)),
                        (st = new fi(f, Y, W, K, o)),
                        (rt = new Os(f, K, V)),
                        (ot = new vi(ut, G, j, V)),
                        (lt = new ji(ut, G, j, V)),
                        (j.programs = Q.programs),
                        (f.capabilities = V),
                        (f.extensions = G),
                        (f.properties = q),
                        (f.renderLists = et),
                        (f.shadowMap = rt),
                        (f.state = W),
                        (f.info = j);
                }
                pt();
                const mt = new Ws(f, ut);
                function ft(t) {
                    t.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (g = !0);
                }
                function gt() {
                    console.log('THREE.WebGLRenderer: Context Restored.'), (g = !1);
                    const t = j.autoReset,
                        e = rt.enabled,
                        n = rt.autoUpdate,
                        i = rt.needsUpdate,
                        r = rt.type;
                    pt(), (j.autoReset = t), (rt.enabled = e), (rt.autoUpdate = n), (rt.needsUpdate = i), (rt.type = r);
                }
                function vt(t) {
                    const e = t.target;
                    e.removeEventListener('dispose', vt),
                        (function (t) {
                            (function (t) {
                                const e = q.get(t).programs;
                                void 0 !== e &&
                                    e.forEach(function (t) {
                                        Q.releaseProgram(t);
                                    });
                            })(t),
                                q.remove(t);
                        })(e);
                }
                (this.xr = mt),
                    (this.getContext = function () {
                        return ut;
                    }),
                    (this.getContextAttributes = function () {
                        return ut.getContextAttributes();
                    }),
                    (this.forceContextLoss = function () {
                        const t = G.get('WEBGL_lose_context');
                        t && t.loseContext();
                    }),
                    (this.forceContextRestore = function () {
                        const t = G.get('WEBGL_lose_context');
                        t && t.restoreContext();
                    }),
                    (this.getPixelRatio = function () {
                        return A;
                    }),
                    (this.setPixelRatio = function (t) {
                        void 0 !== t && ((A = t), this.setSize(T, E, !1));
                    }),
                    (this.getSize = function (t) {
                        return t.set(T, E);
                    }),
                    (this.setSize = function (t, n, i) {
                        mt.isPresenting
                            ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
                            : ((T = t),
                              (E = n),
                              (e.width = Math.floor(t * A)),
                              (e.height = Math.floor(n * A)),
                              !1 !== i && ((e.style.width = t + 'px'), (e.style.height = n + 'px')),
                              this.setViewport(0, 0, t, n));
                    }),
                    (this.getDrawingBufferSize = function (t) {
                        return t.set(T * A, E * A).floor();
                    }),
                    (this.setDrawingBufferSize = function (t, n, i) {
                        (T = t),
                            (E = n),
                            (A = i),
                            (e.width = Math.floor(t * i)),
                            (e.height = Math.floor(n * i)),
                            this.setViewport(0, 0, t, n);
                    }),
                    (this.getCurrentViewport = function (t) {
                        return t.copy(_);
                    }),
                    (this.getViewport = function (t) {
                        return t.copy(C);
                    }),
                    (this.setViewport = function (t, e, n, i) {
                        t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i),
                            W.viewport(_.copy(C).multiplyScalar(A).floor());
                    }),
                    (this.getScissor = function (t) {
                        return t.copy(P);
                    }),
                    (this.setScissor = function (t, e, n, i) {
                        t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
                            W.scissor(M.copy(P).multiplyScalar(A).floor());
                    }),
                    (this.getScissorTest = function () {
                        return I;
                    }),
                    (this.setScissorTest = function (t) {
                        W.setScissorTest((I = t));
                    }),
                    (this.setOpaqueSort = function (t) {
                        L = t;
                    }),
                    (this.setTransparentSort = function (t) {
                        R = t;
                    }),
                    (this.getClearColor = function (t) {
                        return t.copy(st.getClearColor());
                    }),
                    (this.setClearColor = function () {
                        st.setClearColor.apply(st, arguments);
                    }),
                    (this.getClearAlpha = function () {
                        return st.getClearAlpha();
                    }),
                    (this.setClearAlpha = function () {
                        st.setClearAlpha.apply(st, arguments);
                    }),
                    (this.clear = function (t, e, n) {
                        let i = 0;
                        (void 0 === t || t) && (i |= 16384),
                            (void 0 === e || e) && (i |= 256),
                            (void 0 === n || n) && (i |= 1024),
                            ut.clear(i);
                    }),
                    (this.clearColor = function () {
                        this.clear(!0, !1, !1);
                    }),
                    (this.clearDepth = function () {
                        this.clear(!1, !0, !1);
                    }),
                    (this.clearStencil = function () {
                        this.clear(!1, !1, !0);
                    }),
                    (this.dispose = function () {
                        e.removeEventListener('webglcontextlost', ft, !1),
                            e.removeEventListener('webglcontextrestored', gt, !1),
                            et.dispose(),
                            nt.dispose(),
                            q.dispose(),
                            Y.dispose(),
                            Z.dispose(),
                            K.dispose(),
                            ht.dispose(),
                            mt.dispose(),
                            mt.removeEventListener('sessionstart', xt),
                            mt.removeEventListener('sessionend', bt),
                            U && (U.dispose(), (U = null)),
                            wt.stop();
                    }),
                    (this.renderBufferImmediate = function (t, e) {
                        ht.initAttributes();
                        const n = q.get(t);
                        t.hasPositions && !n.position && (n.position = ut.createBuffer()),
                            t.hasNormals && !n.normal && (n.normal = ut.createBuffer()),
                            t.hasUvs && !n.uv && (n.uv = ut.createBuffer()),
                            t.hasColors && !n.color && (n.color = ut.createBuffer());
                        const i = e.getAttributes();
                        t.hasPositions &&
                            (ut.bindBuffer(34962, n.position),
                            ut.bufferData(34962, t.positionArray, 35048),
                            ht.enableAttribute(i.position.location),
                            ut.vertexAttribPointer(i.position.location, 3, 5126, !1, 0, 0)),
                            t.hasNormals &&
                                (ut.bindBuffer(34962, n.normal),
                                ut.bufferData(34962, t.normalArray, 35048),
                                ht.enableAttribute(i.normal.location),
                                ut.vertexAttribPointer(i.normal.location, 3, 5126, !1, 0, 0)),
                            t.hasUvs &&
                                (ut.bindBuffer(34962, n.uv),
                                ut.bufferData(34962, t.uvArray, 35048),
                                ht.enableAttribute(i.uv.location),
                                ut.vertexAttribPointer(i.uv.location, 2, 5126, !1, 0, 0)),
                            t.hasColors &&
                                (ut.bindBuffer(34962, n.color),
                                ut.bufferData(34962, t.colorArray, 35048),
                                ht.enableAttribute(i.color.location),
                                ut.vertexAttribPointer(i.color.location, 3, 5126, !1, 0, 0)),
                            ht.disableUnusedAttributes(),
                            ut.drawArrays(4, 0, t.count),
                            (t.count = 0);
                    }),
                    (this.renderBufferDirect = function (t, e, n, i, r, s) {
                        null === e && (e = B);
                        const a = r.isMesh && r.matrixWorld.determinant() < 0,
                            o = Lt(t, e, n, i, r);
                        W.setMaterial(i, a);
                        let l = n.index;
                        const c = n.attributes.position;
                        if (null === l) {
                            if (void 0 === c || 0 === c.count) return;
                        } else if (0 === l.count) return;
                        let h,
                            u = 1;
                        !0 === i.wireframe && ((l = $.getWireframeAttribute(n)), (u = 2)), ht.setup(r, i, o, n, l);
                        let d = ot;
                        null !== l && ((h = J.get(l)), (d = lt), d.setIndex(h));
                        const p = null !== l ? l.count : c.count,
                            m = n.drawRange.start * u,
                            f = n.drawRange.count * u,
                            g = null !== s ? s.start * u : 0,
                            v = null !== s ? s.count * u : 1 / 0,
                            y = Math.max(m, g),
                            x = Math.min(p, m + f, g + v) - 1,
                            b = Math.max(0, x - y + 1);
                        if (0 !== b) {
                            if (r.isMesh)
                                !0 === i.wireframe
                                    ? (W.setLineWidth(i.wireframeLinewidth * H()), d.setMode(1))
                                    : d.setMode(4);
                            else if (r.isLine) {
                                let t = i.linewidth;
                                void 0 === t && (t = 1),
                                    W.setLineWidth(t * H()),
                                    r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3);
                            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                            if (r.isInstancedMesh) d.renderInstances(y, b, r.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                d.renderInstances(y, b, t);
                            } else d.render(y, b);
                        }
                    }),
                    (this.compile = function (t, e) {
                        (d = nt.get(t)),
                            d.init(),
                            m.push(d),
                            t.traverseVisible(function (t) {
                                t.isLight &&
                                    t.layers.test(e.layers) &&
                                    (d.pushLight(t), t.castShadow && d.pushShadow(t));
                            }),
                            d.setupLights(f.physicallyCorrectLights),
                            t.traverse(function (e) {
                                const n = e.material;
                                if (n)
                                    if (Array.isArray(n)) for (let i = 0; i < n.length; i++) Et(n[i], t, e);
                                    else Et(n, t, e);
                            }),
                            m.pop(),
                            (d = null);
                    });
                let yt = null;
                function xt() {
                    wt.stop();
                }
                function bt() {
                    wt.start();
                }
                const wt = new ci();
                function _t(t, e, n, i) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || N.intersectsSprite(t)) {
                                i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                                const e = K.update(t),
                                    r = t.material;
                                r.visible && u.push(t, e, r, n, z.z, null);
                            }
                        } else if (t.isImmediateRenderObject)
                            i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k),
                                u.push(t, null, t.material, n, z.z, null);
                        else if (
                            (t.isMesh || t.isLine || t.isPoints) &&
                            (t.isSkinnedMesh &&
                                t.skeleton.frame !== j.render.frame &&
                                (t.skeleton.update(), (t.skeleton.frame = j.render.frame)),
                            !t.frustumCulled || N.intersectsObject(t))
                        ) {
                            i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                            const e = K.update(t),
                                r = t.material;
                            if (Array.isArray(r)) {
                                const i = e.groups;
                                for (let s = 0, a = i.length; s < a; s++) {
                                    const a = i[s],
                                        o = r[a.materialIndex];
                                    o && o.visible && u.push(t, e, o, n, z.z, a);
                                }
                            } else r.visible && u.push(t, e, r, n, z.z, null);
                        }
                    const r = t.children;
                    for (let t = 0, s = r.length; t < s; t++) _t(r[t], e, n, i);
                }
                function Mt(t, e, n, i) {
                    const r = t.opaque,
                        s = t.transmissive,
                        o = t.transparent;
                    d.setupLightsView(n),
                        s.length > 0 &&
                            (function (t, e, n) {
                                if (null === U) {
                                    const t = !0 === a && !0 === V.isWebGL2;
                                    U = new (t ? Bt : zt)(1024, 1024, {
                                        generateMipmaps: !0,
                                        type: null !== ct.convert(1016) ? 1016 : 1009,
                                        minFilter: 1008,
                                        magFilter: 1003,
                                        wrapS: 1001,
                                        wrapT: 1001,
                                    });
                                }
                                const i = f.getRenderTarget();
                                f.setRenderTarget(U), f.clear();
                                const r = f.toneMapping;
                                (f.toneMapping = 0),
                                    St(t, e, n),
                                    (f.toneMapping = r),
                                    X.updateMultisampleRenderTarget(U),
                                    X.updateRenderTargetMipmap(U),
                                    f.setRenderTarget(i);
                            })(r, e, n),
                        i && W.viewport(_.copy(i)),
                        r.length > 0 && St(r, e, n),
                        s.length > 0 && St(s, e, n),
                        o.length > 0 && St(o, e, n);
                }
                function St(t, e, n) {
                    const i = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r],
                            a = s.object,
                            o = s.geometry,
                            l = null === i ? s.material : i,
                            c = s.group;
                        a.layers.test(n.layers) && Tt(a, e, n, o, l, c);
                    }
                }
                function Tt(t, e, n, i, r, s) {
                    if (
                        (t.onBeforeRender(f, e, n, i, r, s),
                        t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                        t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                        r.onBeforeRender(f, e, n, i, t, s),
                        t.isImmediateRenderObject)
                    ) {
                        const s = Lt(n, e, i, r, t);
                        W.setMaterial(r),
                            ht.reset(),
                            (function (t, e) {
                                t.render(function (t) {
                                    f.renderBufferImmediate(t, e);
                                });
                            })(t, s);
                    } else
                        !0 === r.transparent && 2 === r.side
                            ? ((r.side = 1),
                              (r.needsUpdate = !0),
                              f.renderBufferDirect(n, e, i, r, t, s),
                              (r.side = 0),
                              (r.needsUpdate = !0),
                              f.renderBufferDirect(n, e, i, r, t, s),
                              (r.side = 2))
                            : f.renderBufferDirect(n, e, i, r, t, s);
                    t.onAfterRender(f, e, n, i, r, s);
                }
                function Et(t, e, n) {
                    !0 !== e.isScene && (e = B);
                    const i = q.get(t),
                        r = d.state.lights,
                        s = d.state.shadowsArray,
                        a = r.state.version,
                        o = Q.getParameters(t, r.state, s, e, n),
                        l = Q.getProgramCacheKey(o);
                    let c = i.programs;
                    (i.environment = t.isMeshStandardMaterial ? e.environment : null),
                        (i.fog = e.fog),
                        (i.envMap = (t.isMeshStandardMaterial ? Z : Y).get(t.envMap || i.environment)),
                        void 0 === c && (t.addEventListener('dispose', vt), (c = new Map()), (i.programs = c));
                    let h = c.get(l);
                    if (void 0 !== h) {
                        if (i.currentProgram === h && i.lightsStateVersion === a) return At(t, o), h;
                    } else
                        (o.uniforms = Q.getUniforms(t)),
                            t.onBuild(o, f),
                            t.onBeforeCompile(o, f),
                            (h = Q.acquireProgram(o, l)),
                            c.set(l, h),
                            (i.uniforms = o.uniforms);
                    const u = i.uniforms;
                    ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
                        (u.clippingPlanes = it.uniform),
                        At(t, o),
                        (i.needsLights = (function (t) {
                            return (
                                t.isMeshLambertMaterial ||
                                t.isMeshToonMaterial ||
                                t.isMeshPhongMaterial ||
                                t.isMeshStandardMaterial ||
                                t.isShadowMaterial ||
                                (t.isShaderMaterial && !0 === t.lights)
                            );
                        })(t)),
                        (i.lightsStateVersion = a),
                        i.needsLights &&
                            ((u.ambientLightColor.value = r.state.ambient),
                            (u.lightProbe.value = r.state.probe),
                            (u.directionalLights.value = r.state.directional),
                            (u.directionalLightShadows.value = r.state.directionalShadow),
                            (u.spotLights.value = r.state.spot),
                            (u.spotLightShadows.value = r.state.spotShadow),
                            (u.rectAreaLights.value = r.state.rectArea),
                            (u.ltc_1.value = r.state.rectAreaLTC1),
                            (u.ltc_2.value = r.state.rectAreaLTC2),
                            (u.pointLights.value = r.state.point),
                            (u.pointLightShadows.value = r.state.pointShadow),
                            (u.hemisphereLights.value = r.state.hemi),
                            (u.directionalShadowMap.value = r.state.directionalShadowMap),
                            (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
                            (u.spotShadowMap.value = r.state.spotShadowMap),
                            (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
                            (u.pointShadowMap.value = r.state.pointShadowMap),
                            (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
                    const p = h.getUniforms(),
                        m = es.seqWithValue(p.seq, u);
                    return (i.currentProgram = h), (i.uniformsList = m), h;
                }
                function At(t, e) {
                    const n = q.get(t);
                    (n.outputEncoding = e.outputEncoding),
                        (n.instancing = e.instancing),
                        (n.skinning = e.skinning),
                        (n.morphTargets = e.morphTargets),
                        (n.morphNormals = e.morphNormals),
                        (n.morphTargetsCount = e.morphTargetsCount),
                        (n.numClippingPlanes = e.numClippingPlanes),
                        (n.numIntersection = e.numClipIntersection),
                        (n.vertexAlphas = e.vertexAlphas),
                        (n.vertexTangents = e.vertexTangents);
                }
                function Lt(t, e, n, i, r) {
                    !0 !== e.isScene && (e = B), X.resetTextureUnits();
                    const s = e.fog,
                        a = i.isMeshStandardMaterial ? e.environment : null,
                        o = null === x ? f.outputEncoding : x.texture.encoding,
                        l = (i.isMeshStandardMaterial ? Z : Y).get(i.envMap || a),
                        c = !0 === i.vertexColors && !!n && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                        h = !!i.normalMap && !!n && !!n.attributes.tangent,
                        u = !!n && !!n.morphAttributes.position,
                        p = !!n && !!n.morphAttributes.normal,
                        m = n && n.morphAttributes.position ? n.morphAttributes.position.length : 0,
                        g = q.get(i),
                        v = d.state.lights;
                    if (!0 === F && (!0 === O || t !== w)) {
                        const e = t === w && i.id === b;
                        it.setState(i, t, e);
                    }
                    let y = !1;
                    i.version === g.__version
                        ? (g.needsLights && g.lightsStateVersion !== v.state.version) ||
                          g.outputEncoding !== o ||
                          (r.isInstancedMesh && !1 === g.instancing)
                            ? (y = !0)
                            : r.isInstancedMesh || !0 !== g.instancing
                            ? r.isSkinnedMesh && !1 === g.skinning
                                ? (y = !0)
                                : r.isSkinnedMesh || !0 !== g.skinning
                                ? g.envMap !== l || (i.fog && g.fog !== s)
                                    ? (y = !0)
                                    : void 0 === g.numClippingPlanes ||
                                      (g.numClippingPlanes === it.numPlanes && g.numIntersection === it.numIntersection)
                                    ? (g.vertexAlphas !== c ||
                                          g.vertexTangents !== h ||
                                          g.morphTargets !== u ||
                                          g.morphNormals !== p ||
                                          (!0 === V.isWebGL2 && g.morphTargetsCount !== m)) &&
                                      (y = !0)
                                    : (y = !0)
                                : (y = !0)
                            : (y = !0)
                        : ((y = !0), (g.__version = i.version));
                    let _ = g.currentProgram;
                    !0 === y && (_ = Et(i, e, r));
                    let M = !1,
                        S = !1,
                        T = !1;
                    const L = _.getUniforms(),
                        R = g.uniforms;
                    if (
                        (W.useProgram(_.program) && ((M = !0), (S = !0), (T = !0)),
                        i.id !== b && ((b = i.id), (S = !0)),
                        M || w !== t)
                    ) {
                        if (
                            (L.setValue(ut, 'projectionMatrix', t.projectionMatrix),
                            V.logarithmicDepthBuffer &&
                                L.setValue(ut, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)),
                            w !== t && ((w = t), (S = !0), (T = !0)),
                            i.isShaderMaterial ||
                                i.isMeshPhongMaterial ||
                                i.isMeshToonMaterial ||
                                i.isMeshStandardMaterial ||
                                i.envMap)
                        ) {
                            const e = L.map.cameraPosition;
                            void 0 !== e && e.setValue(ut, z.setFromMatrixPosition(t.matrixWorld));
                        }
                        (i.isMeshPhongMaterial ||
                            i.isMeshToonMaterial ||
                            i.isMeshLambertMaterial ||
                            i.isMeshBasicMaterial ||
                            i.isMeshStandardMaterial ||
                            i.isShaderMaterial) &&
                            L.setValue(ut, 'isOrthographic', !0 === t.isOrthographicCamera),
                            (i.isMeshPhongMaterial ||
                                i.isMeshToonMaterial ||
                                i.isMeshLambertMaterial ||
                                i.isMeshBasicMaterial ||
                                i.isMeshStandardMaterial ||
                                i.isShaderMaterial ||
                                i.isShadowMaterial ||
                                r.isSkinnedMesh) &&
                                L.setValue(ut, 'viewMatrix', t.matrixWorldInverse);
                    }
                    if (r.isSkinnedMesh) {
                        L.setOptional(ut, r, 'bindMatrix'), L.setOptional(ut, r, 'bindMatrixInverse');
                        const t = r.skeleton;
                        t &&
                            (V.floatVertexTextures
                                ? (null === t.boneTexture && t.computeBoneTexture(),
                                  L.setValue(ut, 'boneTexture', t.boneTexture, X),
                                  L.setValue(ut, 'boneTextureSize', t.boneTextureSize))
                                : L.setOptional(ut, t, 'boneMatrices'));
                    }
                    var C, P;
                    return (
                        !n ||
                            (void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal) ||
                            at.update(r, n, i, _),
                        (S || g.receiveShadow !== r.receiveShadow) &&
                            ((g.receiveShadow = r.receiveShadow), L.setValue(ut, 'receiveShadow', r.receiveShadow)),
                        S &&
                            (L.setValue(ut, 'toneMappingExposure', f.toneMappingExposure),
                            g.needsLights &&
                                ((P = T),
                                ((C = R).ambientLightColor.needsUpdate = P),
                                (C.lightProbe.needsUpdate = P),
                                (C.directionalLights.needsUpdate = P),
                                (C.directionalLightShadows.needsUpdate = P),
                                (C.pointLights.needsUpdate = P),
                                (C.pointLightShadows.needsUpdate = P),
                                (C.spotLights.needsUpdate = P),
                                (C.spotLightShadows.needsUpdate = P),
                                (C.rectAreaLights.needsUpdate = P),
                                (C.hemisphereLights.needsUpdate = P)),
                            s && i.fog && tt.refreshFogUniforms(R, s),
                            tt.refreshMaterialUniforms(R, i, A, E, U),
                            es.upload(ut, g.uniformsList, R, X)),
                        i.isShaderMaterial &&
                            !0 === i.uniformsNeedUpdate &&
                            (es.upload(ut, g.uniformsList, R, X), (i.uniformsNeedUpdate = !1)),
                        i.isSpriteMaterial && L.setValue(ut, 'center', r.center),
                        L.setValue(ut, 'modelViewMatrix', r.modelViewMatrix),
                        L.setValue(ut, 'normalMatrix', r.normalMatrix),
                        L.setValue(ut, 'modelMatrix', r.matrixWorld),
                        _
                    );
                }
                wt.setAnimationLoop(function (t) {
                    yt && yt(t);
                }),
                    'undefined' != typeof window && wt.setContext(window),
                    (this.setAnimationLoop = function (t) {
                        (yt = t), mt.setAnimationLoop(t), null === t ? wt.stop() : wt.start();
                    }),
                    mt.addEventListener('sessionstart', xt),
                    mt.addEventListener('sessionend', bt),
                    (this.render = function (t, e) {
                        if (void 0 !== e && !0 !== e.isCamera)
                            return void console.error(
                                'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
                            );
                        if (!0 === g) return;
                        !0 === t.autoUpdate && t.updateMatrixWorld(),
                            null === e.parent && e.updateMatrixWorld(),
                            !0 === mt.enabled &&
                                !0 === mt.isPresenting &&
                                (!0 === mt.cameraAutoUpdate && mt.updateCamera(e), (e = mt.getCamera())),
                            !0 === t.isScene && t.onBeforeRender(f, t, e, x),
                            (d = nt.get(t, m.length)),
                            d.init(),
                            m.push(d),
                            k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                            N.setFromProjectionMatrix(k),
                            (O = this.localClippingEnabled),
                            (F = it.init(this.clippingPlanes, O, e)),
                            (u = et.get(t, p.length)),
                            u.init(),
                            p.push(u),
                            _t(t, e, 0, f.sortObjects),
                            u.finish(),
                            !0 === f.sortObjects && u.sort(L, R),
                            !0 === F && it.beginShadows();
                        const n = d.state.shadowsArray;
                        if (
                            (rt.render(n, t, e),
                            !0 === F && it.endShadows(),
                            !0 === this.info.autoReset && this.info.reset(),
                            st.render(u, t),
                            d.setupLights(f.physicallyCorrectLights),
                            e.isArrayCamera)
                        ) {
                            const n = e.cameras;
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                Mt(u, t, i, i.viewport);
                            }
                        } else Mt(u, t, e);
                        null !== x && (X.updateMultisampleRenderTarget(x), X.updateRenderTargetMipmap(x)),
                            !0 === t.isScene && t.onAfterRender(f, t, e),
                            W.buffers.depth.setTest(!0),
                            W.buffers.depth.setMask(!0),
                            W.buffers.color.setMask(!0),
                            W.setPolygonOffset(!1),
                            ht.resetDefaultState(),
                            (b = -1),
                            (w = null),
                            m.pop(),
                            (d = m.length > 0 ? m[m.length - 1] : null),
                            p.pop(),
                            (u = p.length > 0 ? p[p.length - 1] : null);
                    }),
                    (this.getActiveCubeFace = function () {
                        return v;
                    }),
                    (this.getActiveMipmapLevel = function () {
                        return y;
                    }),
                    (this.getRenderTarget = function () {
                        return x;
                    }),
                    (this.setRenderTarget = function (t, e = 0, n = 0) {
                        (x = t),
                            (v = e),
                            (y = n),
                            t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t);
                        let i = null,
                            r = !1,
                            s = !1;
                        if (t) {
                            const n = t.texture;
                            (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                            const a = q.get(t).__webglFramebuffer;
                            t.isWebGLCubeRenderTarget
                                ? ((i = a[e]), (r = !0))
                                : (i = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : a),
                                _.copy(t.viewport),
                                M.copy(t.scissor),
                                (S = t.scissorTest);
                        } else _.copy(C).multiplyScalar(A).floor(), M.copy(P).multiplyScalar(A).floor(), (S = I);
                        if (W.bindFramebuffer(36160, i) && V.drawBuffers) {
                            let e = !1;
                            if (t)
                                if (t.isWebGLMultipleRenderTargets) {
                                    const n = t.texture;
                                    if (D.length !== n.length || 36064 !== D[0]) {
                                        for (let t = 0, e = n.length; t < e; t++) D[t] = 36064 + t;
                                        (D.length = n.length), (e = !0);
                                    }
                                } else (1 === D.length && 36064 === D[0]) || ((D[0] = 36064), (D.length = 1), (e = !0));
                            else (1 === D.length && 1029 === D[0]) || ((D[0] = 1029), (D.length = 1), (e = !0));
                            e && (V.isWebGL2 ? ut.drawBuffers(D) : G.get('WEBGL_draw_buffers').drawBuffersWEBGL(D));
                        }
                        if ((W.viewport(_), W.scissor(M), W.setScissorTest(S), r)) {
                            const i = q.get(t.texture);
                            ut.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n);
                        } else if (s) {
                            const i = q.get(t.texture),
                                r = e || 0;
                            ut.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r);
                        }
                        b = -1;
                    }),
                    (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
                        if (!t || !t.isWebGLRenderTarget)
                            return void console.error(
                                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
                            );
                        let o = q.get(t).__webglFramebuffer;
                        if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
                            W.bindFramebuffer(36160, o);
                            try {
                                const a = t.texture,
                                    o = a.format,
                                    l = a.type;
                                if (1023 !== o && ct.convert(o) !== ut.getParameter(35739))
                                    return void console.error(
                                        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
                                    );
                                const c =
                                    1016 === l &&
                                    (G.has('EXT_color_buffer_half_float') ||
                                        (V.isWebGL2 && G.has('EXT_color_buffer_float')));
                                if (
                                    !(
                                        1009 === l ||
                                        ct.convert(l) === ut.getParameter(35738) ||
                                        (1015 === l &&
                                            (V.isWebGL2 ||
                                                G.has('OES_texture_float') ||
                                                G.has('WEBGL_color_buffer_float'))) ||
                                        c
                                    )
                                )
                                    return void console.error(
                                        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
                                    );
                                36053 === ut.checkFramebufferStatus(36160)
                                    ? e >= 0 &&
                                      e <= t.width - i &&
                                      n >= 0 &&
                                      n <= t.height - r &&
                                      ut.readPixels(e, n, i, r, ct.convert(o), ct.convert(l), s)
                                    : console.error(
                                          'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.',
                                      );
                            } finally {
                                const t = null !== x ? q.get(x).__webglFramebuffer : null;
                                W.bindFramebuffer(36160, t);
                            }
                        }
                    }),
                    (this.copyFramebufferToTexture = function (t, e, n = 0) {
                        const i = Math.pow(2, -n),
                            r = Math.floor(e.image.width * i),
                            s = Math.floor(e.image.height * i);
                        let a = ct.convert(e.format);
                        V.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)),
                            X.setTexture2D(e, 0),
                            ut.copyTexImage2D(3553, n, a, t.x, t.y, r, s, 0),
                            W.unbindTexture();
                    }),
                    (this.copyTextureToTexture = function (t, e, n, i = 0) {
                        const r = e.image.width,
                            s = e.image.height,
                            a = ct.convert(n.format),
                            o = ct.convert(n.type);
                        X.setTexture2D(n, 0),
                            ut.pixelStorei(37440, n.flipY),
                            ut.pixelStorei(37441, n.premultiplyAlpha),
                            ut.pixelStorei(3317, n.unpackAlignment),
                            e.isDataTexture
                                ? ut.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data)
                                : e.isCompressedTexture
                                ? ut.compressedTexSubImage2D(
                                      3553,
                                      i,
                                      t.x,
                                      t.y,
                                      e.mipmaps[0].width,
                                      e.mipmaps[0].height,
                                      a,
                                      e.mipmaps[0].data,
                                  )
                                : ut.texSubImage2D(3553, i, t.x, t.y, a, o, e.image),
                            0 === i && n.generateMipmaps && ut.generateMipmap(3553),
                            W.unbindTexture();
                    }),
                    (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                        if (f.isWebGL1Renderer)
                            return void console.warn(
                                'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.',
                            );
                        const s = t.max.x - t.min.x + 1,
                            a = t.max.y - t.min.y + 1,
                            o = t.max.z - t.min.z + 1,
                            l = ct.convert(i.format),
                            c = ct.convert(i.type);
                        let h;
                        if (i.isDataTexture3D) X.setTexture3D(i, 0), (h = 32879);
                        else {
                            if (!i.isDataTexture2DArray)
                                return void console.warn(
                                    'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.',
                                );
                            X.setTexture2DArray(i, 0), (h = 35866);
                        }
                        ut.pixelStorei(37440, i.flipY),
                            ut.pixelStorei(37441, i.premultiplyAlpha),
                            ut.pixelStorei(3317, i.unpackAlignment);
                        const u = ut.getParameter(3314),
                            d = ut.getParameter(32878),
                            p = ut.getParameter(3316),
                            m = ut.getParameter(3315),
                            g = ut.getParameter(32877),
                            v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                        ut.pixelStorei(3314, v.width),
                            ut.pixelStorei(32878, v.height),
                            ut.pixelStorei(3316, t.min.x),
                            ut.pixelStorei(3315, t.min.y),
                            ut.pixelStorei(32877, t.min.z),
                            n.isDataTexture || n.isDataTexture3D
                                ? ut.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, v.data)
                                : n.isCompressedTexture
                                ? (console.warn(
                                      'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.',
                                  ),
                                  ut.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, v.data))
                                : ut.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, v),
                            ut.pixelStorei(3314, u),
                            ut.pixelStorei(32878, d),
                            ut.pixelStorei(3316, p),
                            ut.pixelStorei(3315, m),
                            ut.pixelStorei(32877, g),
                            0 === r && i.generateMipmaps && ut.generateMipmap(h),
                            W.unbindTexture();
                    }),
                    (this.initTexture = function (t) {
                        X.setTexture2D(t, 0), W.unbindTexture();
                    }),
                    (this.resetState = function () {
                        (v = 0), (y = 0), (x = null), W.reset(), ht.reset();
                    }),
                    'undefined' != typeof __THREE_DEVTOOLS__ &&
                        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
            }
            (class extends qs {}.prototype.isWebGL1Renderer = !0);
            class Xs extends We {
                constructor() {
                    super(),
                        (this.type = 'Scene'),
                        (this.background = null),
                        (this.environment = null),
                        (this.fog = null),
                        (this.overrideMaterial = null),
                        (this.autoUpdate = !0),
                        'undefined' != typeof __THREE_DEVTOOLS__ &&
                            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
                }
                copy(t, e) {
                    return (
                        super.copy(t, e),
                        null !== t.background && (this.background = t.background.clone()),
                        null !== t.environment && (this.environment = t.environment.clone()),
                        null !== t.fog && (this.fog = t.fog.clone()),
                        null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                        (this.autoUpdate = t.autoUpdate),
                        (this.matrixAutoUpdate = t.matrixAutoUpdate),
                        this
                    );
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
                }
            }
            Xs.prototype.isScene = !0;
            class Ys {
                constructor(t, e) {
                    (this.array = t),
                        (this.stride = e),
                        (this.count = void 0 !== t ? t.length / e : 0),
                        (this.usage = 35044),
                        (this.updateRange = { offset: 0, count: -1 }),
                        (this.version = 0),
                        (this.uuid = wt());
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
                setUsage(t) {
                    return (this.usage = t), this;
                }
                copy(t) {
                    return (
                        (this.array = new t.array.constructor(t.array)),
                        (this.count = t.count),
                        (this.stride = t.stride),
                        (this.usage = t.usage),
                        this
                    );
                }
                copyAt(t, e, n) {
                    (t *= this.stride), (n *= e.stride);
                    for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this;
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this;
                }
                clone(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = wt()),
                        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                            (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                        n = new this.constructor(e, this.stride);
                    return n.setUsage(this.usage), n;
                }
                onUpload(t) {
                    return (this.onUploadCallback = t), this;
                }
                toJSON(t) {
                    return (
                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = wt()),
                        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                            (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
                                new Uint32Array(this.array.buffer),
                            )),
                        {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride,
                        }
                    );
                }
            }
            Ys.prototype.isInterleavedBuffer = !0;
            const Zs = new Gt();
            class Js {
                constructor(t, e, n, i = !1) {
                    (this.name = ''),
                        (this.data = t),
                        (this.itemSize = e),
                        (this.offset = n),
                        (this.normalized = !0 === i);
                }
                get count() {
                    return this.data.count;
                }
                get array() {
                    return this.data.array;
                }
                set needsUpdate(t) {
                    this.data.needsUpdate = t;
                }
                applyMatrix4(t) {
                    for (let e = 0, n = this.data.count; e < n; e++)
                        (Zs.x = this.getX(e)),
                            (Zs.y = this.getY(e)),
                            (Zs.z = this.getZ(e)),
                            Zs.applyMatrix4(t),
                            this.setXYZ(e, Zs.x, Zs.y, Zs.z);
                    return this;
                }
                applyNormalMatrix(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        (Zs.x = this.getX(e)),
                            (Zs.y = this.getY(e)),
                            (Zs.z = this.getZ(e)),
                            Zs.applyNormalMatrix(t),
                            this.setXYZ(e, Zs.x, Zs.y, Zs.z);
                    return this;
                }
                transformDirection(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        (Zs.x = this.getX(e)),
                            (Zs.y = this.getY(e)),
                            (Zs.z = this.getZ(e)),
                            Zs.transformDirection(t),
                            this.setXYZ(e, Zs.x, Zs.y, Zs.z);
                    return this;
                }
                setX(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset] = e), this;
                }
                setY(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset + 1] = e), this;
                }
                setZ(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset + 2] = e), this;
                }
                setW(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset + 3] = e), this;
                }
                getX(t) {
                    return this.data.array[t * this.data.stride + this.offset];
                }
                getY(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1];
                }
                getZ(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2];
                }
                getW(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3];
                }
                setXY(t, e, n) {
                    return (
                        (t = t * this.data.stride + this.offset),
                        (this.data.array[t + 0] = e),
                        (this.data.array[t + 1] = n),
                        this
                    );
                }
                setXYZ(t, e, n, i) {
                    return (
                        (t = t * this.data.stride + this.offset),
                        (this.data.array[t + 0] = e),
                        (this.data.array[t + 1] = n),
                        (this.data.array[t + 2] = i),
                        this
                    );
                }
                setXYZW(t, e, n, i, r) {
                    return (
                        (t = t * this.data.stride + this.offset),
                        (this.data.array[t + 0] = e),
                        (this.data.array[t + 1] = n),
                        (this.data.array[t + 2] = i),
                        (this.data.array[t + 3] = r),
                        this
                    );
                }
                clone(t) {
                    if (void 0 === t) {
                        console.log(
                            'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.',
                        );
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
                        }
                        return new fn(new this.array.constructor(t), this.itemSize, this.normalized);
                    }
                    return (
                        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                        void 0 === t.interleavedBuffers[this.data.uuid] &&
                            (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                        new Js(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                    );
                }
                toJSON(t) {
                    if (void 0 === t) {
                        console.log(
                            'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.',
                        );
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized,
                        };
                    }
                    return (
                        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                        void 0 === t.interleavedBuffers[this.data.uuid] &&
                            (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                        {
                            isInterleavedBufferAttribute: !0,
                            itemSize: this.itemSize,
                            data: this.data.uuid,
                            offset: this.offset,
                            normalized: this.normalized,
                        }
                    );
                }
            }
            Js.prototype.isInterleavedBufferAttribute = !0;
            class $s extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'SpriteMaterial'),
                        (this.color = new un(16777215)),
                        (this.map = null),
                        (this.alphaMap = null),
                        (this.rotation = 0),
                        (this.sizeAttenuation = !0),
                        (this.transparent = !0),
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.color.copy(t.color),
                        (this.map = t.map),
                        (this.alphaMap = t.alphaMap),
                        (this.rotation = t.rotation),
                        (this.sizeAttenuation = t.sizeAttenuation),
                        this
                    );
                }
            }
            let Ks;
            $s.prototype.isSpriteMaterial = !0;
            const Qs = new Gt(),
                ta = new Gt(),
                ea = new Gt(),
                na = new Rt(),
                ia = new Rt(),
                ra = new xe(),
                sa = new Gt(),
                aa = new Gt(),
                oa = new Gt(),
                la = new Rt(),
                ca = new Rt(),
                ha = new Rt();
            function ua(t, e, n, i, r, s) {
                na.subVectors(t, n).addScalar(0.5).multiply(i),
                    void 0 !== r ? ((ia.x = s * na.x - r * na.y), (ia.y = r * na.x + s * na.y)) : ia.copy(na),
                    t.copy(e),
                    (t.x += ia.x),
                    (t.y += ia.y),
                    t.applyMatrix4(ra);
            }
            (class extends We {
                constructor(t) {
                    if ((super(), (this.type = 'Sprite'), void 0 === Ks)) {
                        Ks = new En();
                        const t = new Float32Array([
                                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
                            ]),
                            e = new Ys(t, 5);
                        Ks.setIndex([0, 1, 2, 0, 2, 3]),
                            Ks.setAttribute('position', new Js(e, 3, 0, !1)),
                            Ks.setAttribute('uv', new Js(e, 2, 3, !1));
                    }
                    (this.geometry = Ks),
                        (this.material = void 0 !== t ? t : new $s()),
                        (this.center = new Rt(0.5, 0.5));
                }
                raycast(t, e) {
                    null === t.camera &&
                        console.error(
                            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
                        ),
                        ta.setFromMatrixScale(this.matrixWorld),
                        ra.copy(t.camera.matrixWorld),
                        this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
                        ea.setFromMatrixPosition(this.modelViewMatrix),
                        t.camera.isPerspectiveCamera &&
                            !1 === this.material.sizeAttenuation &&
                            ta.multiplyScalar(-ea.z);
                    const n = this.material.rotation;
                    let i, r;
                    0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
                    const s = this.center;
                    ua(sa.set(-0.5, -0.5, 0), ea, s, ta, i, r),
                        ua(aa.set(0.5, -0.5, 0), ea, s, ta, i, r),
                        ua(oa.set(0.5, 0.5, 0), ea, s, ta, i, r),
                        la.set(0, 0),
                        ca.set(1, 0),
                        ha.set(1, 1);
                    let a = t.ray.intersectTriangle(sa, aa, oa, !1, Qs);
                    if (
                        null === a &&
                        (ua(aa.set(-0.5, 0.5, 0), ea, s, ta, i, r),
                        ca.set(0, 1),
                        (a = t.ray.intersectTriangle(sa, oa, aa, !1, Qs)),
                        null === a)
                    )
                        return;
                    const o = t.ray.origin.distanceTo(Qs);
                    o < t.near ||
                        o > t.far ||
                        e.push({
                            distance: o,
                            point: Qs.clone(),
                            uv: en.getUV(Qs, sa, aa, oa, la, ca, ha, new Rt()),
                            face: null,
                            object: this,
                        });
                }
                copy(t) {
                    return (
                        super.copy(t),
                        void 0 !== t.center && this.center.copy(t.center),
                        (this.material = t.material),
                        this
                    );
                }
            }.prototype.isSprite = !0);
            const da = new Gt(),
                pa = new kt(),
                ma = new kt(),
                fa = new Gt(),
                ga = new xe();
            class va extends Wn {
                constructor(t, e) {
                    super(t, e),
                        (this.type = 'SkinnedMesh'),
                        (this.bindMode = 'attached'),
                        (this.bindMatrix = new xe()),
                        (this.bindMatrixInverse = new xe());
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.bindMode = t.bindMode),
                        this.bindMatrix.copy(t.bindMatrix),
                        this.bindMatrixInverse.copy(t.bindMatrixInverse),
                        (this.skeleton = t.skeleton),
                        this
                    );
                }
                bind(t, e) {
                    (this.skeleton = t),
                        void 0 === e &&
                            (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (e = this.matrixWorld)),
                        this.bindMatrix.copy(e),
                        this.bindMatrixInverse.copy(e).invert();
                }
                pose() {
                    this.skeleton.pose();
                }
                normalizeSkinWeights() {
                    const t = new kt(),
                        e = this.geometry.attributes.skinWeight;
                    for (let n = 0, i = e.count; n < i; n++) {
                        (t.x = e.getX(n)), (t.y = e.getY(n)), (t.z = e.getZ(n)), (t.w = e.getW(n));
                        const i = 1 / t.manhattanLength();
                        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
                    }
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t),
                        'attached' === this.bindMode
                            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                            : 'detached' === this.bindMode
                            ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                            : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
                }
                boneTransform(t, e) {
                    const n = this.skeleton,
                        i = this.geometry;
                    pa.fromBufferAttribute(i.attributes.skinIndex, t),
                        ma.fromBufferAttribute(i.attributes.skinWeight, t),
                        da.copy(e).applyMatrix4(this.bindMatrix),
                        e.set(0, 0, 0);
                    for (let t = 0; t < 4; t++) {
                        const i = ma.getComponent(t);
                        if (0 !== i) {
                            const r = pa.getComponent(t);
                            ga.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                                e.addScaledVector(fa.copy(da).applyMatrix4(ga), i);
                        }
                    }
                    return e.applyMatrix4(this.bindMatrixInverse);
                }
            }
            va.prototype.isSkinnedMesh = !0;
            class ya extends We {
                constructor() {
                    super(), (this.type = 'Bone');
                }
            }
            ya.prototype.isBone = !0;
            class xa extends Ot {
                constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
                    super(null, s, a, o, l, c, i, r, h, u),
                        (this.image = { data: t, width: e, height: n }),
                        (this.magFilter = l),
                        (this.minFilter = c),
                        (this.generateMipmaps = !1),
                        (this.flipY = !1),
                        (this.unpackAlignment = 1),
                        (this.needsUpdate = !0);
                }
            }
            xa.prototype.isDataTexture = !0;
            const ba = new xe(),
                wa = new xe();
            class _a {
                constructor(t = [], e = []) {
                    (this.uuid = wt()),
                        (this.bones = t.slice(0)),
                        (this.boneInverses = e),
                        (this.boneMatrices = null),
                        (this.boneTexture = null),
                        (this.boneTextureSize = 0),
                        (this.frame = -1),
                        this.init();
                }
                init() {
                    const t = this.bones,
                        e = this.boneInverses;
                    if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length))
                        this.calculateInverses();
                    else if (t.length !== e.length) {
                        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'),
                            (this.boneInverses = []);
                        for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new xe());
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = new xe();
                        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e);
                    }
                }
                pose() {
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && e.matrixWorld.copy(this.boneInverses[t]).invert();
                    }
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e &&
                            (e.parent && e.parent.isBone
                                ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld))
                                : e.matrix.copy(e.matrixWorld),
                            e.matrix.decompose(e.position, e.quaternion, e.scale));
                    }
                }
                update() {
                    const t = this.bones,
                        e = this.boneInverses,
                        n = this.boneMatrices,
                        i = this.boneTexture;
                    for (let i = 0, r = t.length; i < r; i++) {
                        const r = t[i] ? t[i].matrixWorld : wa;
                        ba.multiplyMatrices(r, e[i]), ba.toArray(n, 16 * i);
                    }
                    null !== i && (i.needsUpdate = !0);
                }
                clone() {
                    return new _a(this.bones, this.boneInverses);
                }
                computeBoneTexture() {
                    let t = Math.sqrt(4 * this.bones.length);
                    (t = Et(t)), (t = Math.max(t, 4));
                    const e = new Float32Array(t * t * 4);
                    e.set(this.boneMatrices);
                    const n = new xa(e, t, t, 1023, 1015);
                    return (this.boneMatrices = e), (this.boneTexture = n), (this.boneTextureSize = t), this;
                }
                getBoneByName(t) {
                    for (let e = 0, n = this.bones.length; e < n; e++) {
                        const n = this.bones[e];
                        if (n.name === t) return n;
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null));
                }
                fromJSON(t, e) {
                    this.uuid = t.uuid;
                    for (let n = 0, i = t.bones.length; n < i; n++) {
                        const i = t.bones[n];
                        let r = e[i];
                        void 0 === r && (console.warn('THREE.Skeleton: No bone found with UUID:', i), (r = new ya())),
                            this.bones.push(r),
                            this.boneInverses.push(new xe().fromArray(t.boneInverses[n]));
                    }
                    return this.init(), this;
                }
                toJSON() {
                    const t = {
                        metadata: { version: 4.5, type: 'Skeleton', generator: 'Skeleton.toJSON' },
                        bones: [],
                        boneInverses: [],
                    };
                    t.uuid = this.uuid;
                    const e = this.bones,
                        n = this.boneInverses;
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i];
                        t.bones.push(r.uuid);
                        const s = n[i];
                        t.boneInverses.push(s.toArray());
                    }
                    return t;
                }
            }
            class Ma extends fn {
                constructor(t, e, n, i = 1) {
                    'number' == typeof n &&
                        ((i = n),
                        (n = !1),
                        console.error(
                            'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',
                        )),
                        super(t, e, n),
                        (this.meshPerAttribute = i);
                }
                copy(t) {
                    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t;
                }
            }
            Ma.prototype.isInstancedBufferAttribute = !0;
            const Sa = new xe(),
                Ta = new xe(),
                Ea = [],
                Aa = new Wn();
            (class extends Wn {
                constructor(t, e, n) {
                    super(t, e),
                        (this.instanceMatrix = new Ma(new Float32Array(16 * n), 16)),
                        (this.instanceColor = null),
                        (this.count = n),
                        (this.frustumCulled = !1);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.instanceMatrix.copy(t.instanceMatrix),
                        null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
                        (this.count = t.count),
                        this
                    );
                }
                getColorAt(t, e) {
                    e.fromArray(this.instanceColor.array, 3 * t);
                }
                getMatrixAt(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t);
                }
                raycast(t, e) {
                    const n = this.matrixWorld,
                        i = this.count;
                    if (((Aa.geometry = this.geometry), (Aa.material = this.material), void 0 !== Aa.material))
                        for (let r = 0; r < i; r++) {
                            this.getMatrixAt(r, Sa),
                                Ta.multiplyMatrices(n, Sa),
                                (Aa.matrixWorld = Ta),
                                Aa.raycast(t, Ea);
                            for (let t = 0, n = Ea.length; t < n; t++) {
                                const n = Ea[t];
                                (n.instanceId = r), (n.object = this), e.push(n);
                            }
                            Ea.length = 0;
                        }
                }
                setColorAt(t, e) {
                    null === this.instanceColor &&
                        (this.instanceColor = new Ma(new Float32Array(3 * this.instanceMatrix.count), 3)),
                        e.toArray(this.instanceColor.array, 3 * t);
                }
                setMatrixAt(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t);
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({ type: 'dispose' });
                }
            }.prototype.isInstancedMesh = !0);
            class La extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'LineBasicMaterial'),
                        (this.color = new un(16777215)),
                        (this.linewidth = 1),
                        (this.linecap = 'round'),
                        (this.linejoin = 'round'),
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.color.copy(t.color),
                        (this.linewidth = t.linewidth),
                        (this.linecap = t.linecap),
                        (this.linejoin = t.linejoin),
                        this
                    );
                }
            }
            La.prototype.isLineBasicMaterial = !0;
            const Ra = new Gt(),
                Ca = new Gt(),
                Pa = new xe(),
                Ia = new ye(),
                Da = new he();
            class Na extends We {
                constructor(t = new En(), e = new La()) {
                    super(), (this.type = 'Line'), (this.geometry = t), (this.material = e), this.updateMorphTargets();
                }
                copy(t) {
                    return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this;
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [0];
                            for (let t = 1, i = e.count; t < i; t++)
                                Ra.fromBufferAttribute(e, t - 1),
                                    Ca.fromBufferAttribute(e, t),
                                    (n[t] = n[t - 1]),
                                    (n[t] += Ra.distanceTo(Ca));
                            t.setAttribute('lineDistance', new yn(n, 1));
                        } else
                            console.warn(
                                'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                            );
                    else
                        t.isGeometry &&
                            console.error(
                                'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                            );
                    return this;
                }
                raycast(t, e) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = t.params.Line.threshold,
                        s = n.drawRange;
                    if (
                        (null === n.boundingSphere && n.computeBoundingSphere(),
                        Da.copy(n.boundingSphere),
                        Da.applyMatrix4(i),
                        (Da.radius += r),
                        !1 === t.ray.intersectsSphere(Da))
                    )
                        return;
                    Pa.copy(i).invert(), Ia.copy(t.ray).applyMatrix4(Pa);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        l = new Gt(),
                        c = new Gt(),
                        h = new Gt(),
                        u = new Gt(),
                        d = this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        const i = n.index,
                            r = n.attributes.position;
                        if (null !== i)
                            for (
                                let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1;
                                n < a;
                                n += d
                            ) {
                                const s = i.getX(n),
                                    a = i.getX(n + 1);
                                if (
                                    (l.fromBufferAttribute(r, s),
                                    c.fromBufferAttribute(r, a),
                                    Ia.distanceSqToSegment(l, c, u, h) > o)
                                )
                                    continue;
                                u.applyMatrix4(this.matrixWorld);
                                const d = t.ray.origin.distanceTo(u);
                                d < t.near ||
                                    d > t.far ||
                                    e.push({
                                        distance: d,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this,
                                    });
                            }
                        else
                            for (
                                let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1;
                                n < i;
                                n += d
                            ) {
                                if (
                                    (l.fromBufferAttribute(r, n),
                                    c.fromBufferAttribute(r, n + 1),
                                    Ia.distanceSqToSegment(l, c, u, h) > o)
                                )
                                    continue;
                                u.applyMatrix4(this.matrixWorld);
                                const i = t.ray.origin.distanceTo(u);
                                i < t.near ||
                                    i > t.far ||
                                    e.push({
                                        distance: i,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this,
                                    });
                            }
                    } else
                        n.isGeometry &&
                            console.error(
                                'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                            );
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e &&
                            e.length > 0 &&
                            console.error(
                                'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
                            );
                    }
                }
            }
            Na.prototype.isLine = !0;
            const Fa = new Gt(),
                Oa = new Gt();
            class Ua extends Na {
                constructor(t, e) {
                    super(t, e), (this.type = 'LineSegments');
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [];
                            for (let t = 0, i = e.count; t < i; t += 2)
                                Fa.fromBufferAttribute(e, t),
                                    Oa.fromBufferAttribute(e, t + 1),
                                    (n[t] = 0 === t ? 0 : n[t - 1]),
                                    (n[t + 1] = n[t] + Fa.distanceTo(Oa));
                            t.setAttribute('lineDistance', new yn(n, 1));
                        } else
                            console.warn(
                                'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                            );
                    else
                        t.isGeometry &&
                            console.error(
                                'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                            );
                    return this;
                }
            }
            Ua.prototype.isLineSegments = !0;
            class ka extends Na {
                constructor(t, e) {
                    super(t, e), (this.type = 'LineLoop');
                }
            }
            ka.prototype.isLineLoop = !0;
            class za extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'PointsMaterial'),
                        (this.color = new un(16777215)),
                        (this.map = null),
                        (this.alphaMap = null),
                        (this.size = 1),
                        (this.sizeAttenuation = !0),
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.color.copy(t.color),
                        (this.map = t.map),
                        (this.alphaMap = t.alphaMap),
                        (this.size = t.size),
                        (this.sizeAttenuation = t.sizeAttenuation),
                        this
                    );
                }
            }
            za.prototype.isPointsMaterial = !0;
            const Ba = new xe(),
                Ha = new ye(),
                Ga = new he(),
                Va = new Gt();
            class Wa extends We {
                constructor(t = new En(), e = new za()) {
                    super(),
                        (this.type = 'Points'),
                        (this.geometry = t),
                        (this.material = e),
                        this.updateMorphTargets();
                }
                copy(t) {
                    return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this;
                }
                raycast(t, e) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = t.params.Points.threshold,
                        s = n.drawRange;
                    if (
                        (null === n.boundingSphere && n.computeBoundingSphere(),
                        Ga.copy(n.boundingSphere),
                        Ga.applyMatrix4(i),
                        (Ga.radius += r),
                        !1 === t.ray.intersectsSphere(Ga))
                    )
                        return;
                    Ba.copy(i).invert(), Ha.copy(t.ray).applyMatrix4(Ba);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            a = n.attributes.position;
                        if (null !== r)
                            for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                const s = r.getX(n);
                                Va.fromBufferAttribute(a, s), ja(Va, s, o, i, t, e, this);
                            }
                        else
                            for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++)
                                Va.fromBufferAttribute(a, n), ja(Va, n, o, i, t, e, this);
                    } else
                        console.error(
                            'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                        );
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e &&
                            e.length > 0 &&
                            console.error(
                                'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
                            );
                    }
                }
            }
            function ja(t, e, n, i, r, s, a) {
                const o = Ha.distanceSqToPoint(t);
                if (o < n) {
                    const n = new Gt();
                    Ha.closestPointToPoint(t, n), n.applyMatrix4(i);
                    const l = r.ray.origin.distanceTo(n);
                    if (l < r.near || l > r.far) return;
                    s.push({ distance: l, distanceToRay: Math.sqrt(o), point: n, index: e, face: null, object: a });
                }
            }
            (Wa.prototype.isPoints = !0),
                (class extends Ot {
                    constructor(t, e, n, i, r, s, a, o, l) {
                        super(t, e, n, i, r, s, a, o, l),
                            (this.format = void 0 !== a ? a : 1022),
                            (this.minFilter = void 0 !== s ? s : 1006),
                            (this.magFilter = void 0 !== r ? r : 1006),
                            (this.generateMipmaps = !1);
                        const c = this;
                        'requestVideoFrameCallback' in t &&
                            t.requestVideoFrameCallback(function e() {
                                (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
                            });
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this);
                    }
                    update() {
                        const t = this.image;
                        0 == 'requestVideoFrameCallback' in t &&
                            t.readyState >= t.HAVE_CURRENT_DATA &&
                            (this.needsUpdate = !0);
                    }
                }.prototype.isVideoTexture = !0);
            class qa extends Ot {
                constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
                    super(null, s, a, o, l, c, i, r, h, u),
                        (this.image = { width: e, height: n }),
                        (this.mipmaps = t),
                        (this.flipY = !1),
                        (this.generateMipmaps = !1);
                }
            }
            (qa.prototype.isCompressedTexture = !0),
                (class extends Ot {
                    constructor(t, e, n, i, r, s, a, o, l) {
                        super(t, e, n, i, r, s, a, o, l), (this.needsUpdate = !0);
                    }
                }.prototype.isCanvasTexture = !0),
                (class extends Ot {
                    constructor(t, e, n, i, r, s, a, o, l, c) {
                        if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c)
                            throw new Error(
                                'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
                            );
                        void 0 === n && 1026 === c && (n = 1012),
                            void 0 === n && 1027 === c && (n = 1020),
                            super(null, i, r, s, a, o, c, n, l),
                            (this.image = { width: t, height: e }),
                            (this.magFilter = void 0 !== a ? a : 1003),
                            (this.minFilter = void 0 !== o ? o : 1003),
                            (this.flipY = !1),
                            (this.generateMipmaps = !1);
                    }
                }.prototype.isDepthTexture = !0),
                new Gt(),
                new Gt(),
                new Gt(),
                new en();
            class Xa {
                constructor() {
                    (this.type = 'Curve'), (this.arcLengthDivisions = 200);
                }
                getPoint() {
                    return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
                }
                getPointAt(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getPoint(n, e);
                }
                getPoints(t = 5) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e;
                }
                getSpacedPoints(t = 5) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e;
                }
                getLength() {
                    const t = this.getLengths();
                    return t[t.length - 1];
                }
                getLengths(t = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                        return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let n,
                        i = this.getPoint(0),
                        r = 0;
                    e.push(0);
                    for (let s = 1; s <= t; s++) (n = this.getPoint(s / t)), (r += n.distanceTo(i)), e.push(r), (i = n);
                    return (this.cacheArcLengths = e), e;
                }
                updateArcLengths() {
                    (this.needsUpdate = !0), this.getLengths();
                }
                getUtoTmapping(t, e) {
                    const n = this.getLengths();
                    let i = 0;
                    const r = n.length;
                    let s;
                    s = e || t * n[r - 1];
                    let a,
                        o = 0,
                        l = r - 1;
                    for (; o <= l; )
                        if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0)) o = i + 1;
                        else {
                            if (!(a > 0)) {
                                l = i;
                                break;
                            }
                            l = i - 1;
                        }
                    if (((i = l), n[i] === s)) return i / (r - 1);
                    const c = n[i];
                    return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
                }
                getTangent(t, e) {
                    const n = 1e-4;
                    let i = t - n,
                        r = t + n;
                    i < 0 && (i = 0), r > 1 && (r = 1);
                    const s = this.getPoint(i),
                        a = this.getPoint(r),
                        o = e || (s.isVector2 ? new Rt() : new Gt());
                    return o.copy(a).sub(s).normalize(), o;
                }
                getTangentAt(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getTangent(n, e);
                }
                computeFrenetFrames(t, e) {
                    const n = new Gt(),
                        i = [],
                        r = [],
                        s = [],
                        a = new Gt(),
                        o = new xe();
                    for (let e = 0; e <= t; e++) {
                        const n = e / t;
                        i[e] = this.getTangentAt(n, new Gt());
                    }
                    (r[0] = new Gt()), (s[0] = new Gt());
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(i[0].x),
                        h = Math.abs(i[0].y),
                        u = Math.abs(i[0].z);
                    c <= l && ((l = c), n.set(1, 0, 0)),
                        h <= l && ((l = h), n.set(0, 1, 0)),
                        u <= l && n.set(0, 0, 1),
                        a.crossVectors(i[0], n).normalize(),
                        r[0].crossVectors(i[0], a),
                        s[0].crossVectors(i[0], r[0]);
                    for (let e = 1; e <= t; e++) {
                        if (
                            ((r[e] = r[e - 1].clone()),
                            (s[e] = s[e - 1].clone()),
                            a.crossVectors(i[e - 1], i[e]),
                            a.length() > Number.EPSILON)
                        ) {
                            a.normalize();
                            const t = Math.acos(_t(i[e - 1].dot(i[e]), -1, 1));
                            r[e].applyMatrix4(o.makeRotationAxis(a, t));
                        }
                        s[e].crossVectors(i[e], r[e]);
                    }
                    if (!0 === e) {
                        let e = Math.acos(_t(r[0].dot(r[t]), -1, 1));
                        (e /= t), i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                        for (let n = 1; n <= t; n++)
                            r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n]);
                    }
                    return { tangents: i, normals: r, binormals: s };
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
                }
                toJSON() {
                    const t = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } };
                    return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t;
                }
                fromJSON(t) {
                    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
                }
            }
            class Ya extends Xa {
                constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                    super(),
                        (this.type = 'EllipseCurve'),
                        (this.aX = t),
                        (this.aY = e),
                        (this.xRadius = n),
                        (this.yRadius = i),
                        (this.aStartAngle = r),
                        (this.aEndAngle = s),
                        (this.aClockwise = a),
                        (this.aRotation = o);
                }
                getPoint(t, e) {
                    const n = e || new Rt(),
                        i = 2 * Math.PI;
                    let r = this.aEndAngle - this.aStartAngle;
                    const s = Math.abs(r) < Number.EPSILON;
                    for (; r < 0; ) r += i;
                    for (; r > i; ) r -= i;
                    r < Number.EPSILON && (r = s ? 0 : i),
                        !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
                    const a = this.aStartAngle + t * r;
                    let o = this.aX + this.xRadius * Math.cos(a),
                        l = this.aY + this.yRadius * Math.sin(a);
                    if (0 !== this.aRotation) {
                        const t = Math.cos(this.aRotation),
                            e = Math.sin(this.aRotation),
                            n = o - this.aX,
                            i = l - this.aY;
                        (o = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
                    }
                    return n.set(o, l);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.aX = t.aX),
                        (this.aY = t.aY),
                        (this.xRadius = t.xRadius),
                        (this.yRadius = t.yRadius),
                        (this.aStartAngle = t.aStartAngle),
                        (this.aEndAngle = t.aEndAngle),
                        (this.aClockwise = t.aClockwise),
                        (this.aRotation = t.aRotation),
                        this
                    );
                }
                toJSON() {
                    const t = super.toJSON();
                    return (
                        (t.aX = this.aX),
                        (t.aY = this.aY),
                        (t.xRadius = this.xRadius),
                        (t.yRadius = this.yRadius),
                        (t.aStartAngle = this.aStartAngle),
                        (t.aEndAngle = this.aEndAngle),
                        (t.aClockwise = this.aClockwise),
                        (t.aRotation = this.aRotation),
                        t
                    );
                }
                fromJSON(t) {
                    return (
                        super.fromJSON(t),
                        (this.aX = t.aX),
                        (this.aY = t.aY),
                        (this.xRadius = t.xRadius),
                        (this.yRadius = t.yRadius),
                        (this.aStartAngle = t.aStartAngle),
                        (this.aEndAngle = t.aEndAngle),
                        (this.aClockwise = t.aClockwise),
                        (this.aRotation = t.aRotation),
                        this
                    );
                }
            }
            Ya.prototype.isEllipseCurve = !0;
            class Za extends Ya {
                constructor(t, e, n, i, r, s) {
                    super(t, e, n, n, i, r, s), (this.type = 'ArcCurve');
                }
            }
            function Ja() {
                let t = 0,
                    e = 0,
                    n = 0,
                    i = 0;
                function r(r, s, a, o) {
                    (t = r), (e = a), (n = -3 * r + 3 * s - 2 * a - o), (i = 2 * r - 2 * s + a + o);
                }
                return {
                    initCatmullRom: function (t, e, n, i, s) {
                        r(e, n, s * (n - t), s * (i - e));
                    },
                    initNonuniformCatmullRom: function (t, e, n, i, s, a, o) {
                        let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,
                            c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
                        (l *= a), (c *= a), r(e, n, l, c);
                    },
                    calc: function (r) {
                        const s = r * r;
                        return t + e * r + n * s + i * (s * r);
                    },
                };
            }
            Za.prototype.isArcCurve = !0;
            const $a = new Gt(),
                Ka = new Ja(),
                Qa = new Ja(),
                to = new Ja();
            class eo extends Xa {
                constructor(t = [], e = !1, n = 'centripetal', i = 0.5) {
                    super(),
                        (this.type = 'CatmullRomCurve3'),
                        (this.points = t),
                        (this.closed = e),
                        (this.curveType = n),
                        (this.tension = i);
                }
                getPoint(t, e = new Gt()) {
                    const n = e,
                        i = this.points,
                        r = i.length,
                        s = (r - (this.closed ? 0 : 1)) * t;
                    let a,
                        o,
                        l = Math.floor(s),
                        c = s - l;
                    this.closed
                        ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
                        : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
                        this.closed || l > 0 ? (a = i[(l - 1) % r]) : ($a.subVectors(i[0], i[1]).add(i[0]), (a = $a));
                    const h = i[l % r],
                        u = i[(l + 1) % r];
                    if (
                        (this.closed || l + 2 < r
                            ? (o = i[(l + 2) % r])
                            : ($a.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = $a)),
                        'centripetal' === this.curveType || 'chordal' === this.curveType)
                    ) {
                        const t = 'chordal' === this.curveType ? 0.5 : 0.25;
                        let e = Math.pow(a.distanceToSquared(h), t),
                            n = Math.pow(h.distanceToSquared(u), t),
                            i = Math.pow(u.distanceToSquared(o), t);
                        n < 1e-4 && (n = 1),
                            e < 1e-4 && (e = n),
                            i < 1e-4 && (i = n),
                            Ka.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i),
                            Qa.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i),
                            to.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i);
                    } else
                        'catmullrom' === this.curveType &&
                            (Ka.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
                            Qa.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
                            to.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
                    return n.set(Ka.calc(c), Qa.calc(c), to.calc(c)), n;
                }
                copy(t) {
                    super.copy(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push(n.clone());
                    }
                    return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, n = this.points.length; e < n; e++) {
                        const n = this.points[e];
                        t.points.push(n.toArray());
                    }
                    return (t.closed = this.closed), (t.curveType = this.curveType), (t.tension = this.tension), t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push(new Gt().fromArray(n));
                    }
                    return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this;
                }
            }
            function no(t, e, n, i, r) {
                const s = 0.5 * (i - e),
                    a = 0.5 * (r - n),
                    o = t * t;
                return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n;
            }
            function io(t, e, n, i) {
                return (
                    (function (t, e) {
                        const n = 1 - t;
                        return n * n * e;
                    })(t, e) +
                    (function (t, e) {
                        return 2 * (1 - t) * t * e;
                    })(t, n) +
                    (function (t, e) {
                        return t * t * e;
                    })(t, i)
                );
            }
            function ro(t, e, n, i, r) {
                return (
                    (function (t, e) {
                        const n = 1 - t;
                        return n * n * n * e;
                    })(t, e) +
                    (function (t, e) {
                        const n = 1 - t;
                        return 3 * n * n * t * e;
                    })(t, n) +
                    (function (t, e) {
                        return 3 * (1 - t) * t * t * e;
                    })(t, i) +
                    (function (t, e) {
                        return t * t * t * e;
                    })(t, r)
                );
            }
            eo.prototype.isCatmullRomCurve3 = !0;
            class so extends Xa {
                constructor(t = new Rt(), e = new Rt(), n = new Rt(), i = new Rt()) {
                    super(),
                        (this.type = 'CubicBezierCurve'),
                        (this.v0 = t),
                        (this.v1 = e),
                        (this.v2 = n),
                        (this.v3 = i);
                }
                getPoint(t, e = new Rt()) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2,
                        a = this.v3;
                    return n.set(ro(t, i.x, r.x, s.x, a.x), ro(t, i.y, r.y, s.y, a.y)), n;
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.v0.copy(t.v0),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this.v3.copy(t.v3),
                        this
                    );
                }
                toJSON() {
                    const t = super.toJSON();
                    return (
                        (t.v0 = this.v0.toArray()),
                        (t.v1 = this.v1.toArray()),
                        (t.v2 = this.v2.toArray()),
                        (t.v3 = this.v3.toArray()),
                        t
                    );
                }
                fromJSON(t) {
                    return (
                        super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this.v3.fromArray(t.v3),
                        this
                    );
                }
            }
            so.prototype.isCubicBezierCurve = !0;
            class ao extends Xa {
                constructor(t = new Gt(), e = new Gt(), n = new Gt(), i = new Gt()) {
                    super(),
                        (this.type = 'CubicBezierCurve3'),
                        (this.v0 = t),
                        (this.v1 = e),
                        (this.v2 = n),
                        (this.v3 = i);
                }
                getPoint(t, e = new Gt()) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2,
                        a = this.v3;
                    return n.set(ro(t, i.x, r.x, s.x, a.x), ro(t, i.y, r.y, s.y, a.y), ro(t, i.z, r.z, s.z, a.z)), n;
                }
                copy(t) {
                    return (
                        super.copy(t),
                        this.v0.copy(t.v0),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this.v3.copy(t.v3),
                        this
                    );
                }
                toJSON() {
                    const t = super.toJSON();
                    return (
                        (t.v0 = this.v0.toArray()),
                        (t.v1 = this.v1.toArray()),
                        (t.v2 = this.v2.toArray()),
                        (t.v3 = this.v3.toArray()),
                        t
                    );
                }
                fromJSON(t) {
                    return (
                        super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this.v3.fromArray(t.v3),
                        this
                    );
                }
            }
            ao.prototype.isCubicBezierCurve3 = !0;
            class oo extends Xa {
                constructor(t = new Rt(), e = new Rt()) {
                    super(), (this.type = 'LineCurve'), (this.v1 = t), (this.v2 = e);
                }
                getPoint(t, e = new Rt()) {
                    const n = e;
                    return (
                        1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                    );
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e);
                }
                getTangent(t, e) {
                    const n = e || new Rt();
                    return n.copy(this.v2).sub(this.v1).normalize(), n;
                }
                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
                }
            }
            oo.prototype.isLineCurve = !0;
            class lo extends Xa {
                constructor(t = new Rt(), e = new Rt(), n = new Rt()) {
                    super(), (this.type = 'QuadraticBezierCurve'), (this.v0 = t), (this.v1 = e), (this.v2 = n);
                }
                getPoint(t, e = new Rt()) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return n.set(io(t, i.x, r.x, s.x), io(t, i.y, r.y, s.y)), n;
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                }
                fromJSON(t) {
                    return (
                        super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this
                    );
                }
            }
            lo.prototype.isQuadraticBezierCurve = !0;
            class co extends Xa {
                constructor(t = new Gt(), e = new Gt(), n = new Gt()) {
                    super(), (this.type = 'QuadraticBezierCurve3'), (this.v0 = t), (this.v1 = e), (this.v2 = n);
                }
                getPoint(t, e = new Gt()) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return n.set(io(t, i.x, r.x, s.x), io(t, i.y, r.y, s.y), io(t, i.z, r.z, s.z)), n;
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                }
                fromJSON(t) {
                    return (
                        super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this
                    );
                }
            }
            co.prototype.isQuadraticBezierCurve3 = !0;
            class ho extends Xa {
                constructor(t = []) {
                    super(), (this.type = 'SplineCurve'), (this.points = t);
                }
                getPoint(t, e = new Rt()) {
                    const n = e,
                        i = this.points,
                        r = (i.length - 1) * t,
                        s = Math.floor(r),
                        a = r - s,
                        o = i[0 === s ? s : s - 1],
                        l = i[s],
                        c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                        h = i[s > i.length - 3 ? i.length - 1 : s + 2];
                    return n.set(no(a, o.x, l.x, c.x, h.x), no(a, o.y, l.y, c.y, h.y)), n;
                }
                copy(t) {
                    super.copy(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push(n.clone());
                    }
                    return this;
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, n = this.points.length; e < n; e++) {
                        const n = this.points[e];
                        t.points.push(n.toArray());
                    }
                    return t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push(new Rt().fromArray(n));
                    }
                    return this;
                }
            }
            ho.prototype.isSplineCurve = !0;
            var uo = Object.freeze({
                __proto__: null,
                ArcCurve: Za,
                CatmullRomCurve3: eo,
                CubicBezierCurve: so,
                CubicBezierCurve3: ao,
                EllipseCurve: Ya,
                LineCurve: oo,
                LineCurve3: class extends Xa {
                    constructor(t = new Gt(), e = new Gt()) {
                        super(), (this.type = 'LineCurve3'), (this.isLineCurve3 = !0), (this.v1 = t), (this.v2 = e);
                    }
                    getPoint(t, e = new Gt()) {
                        const n = e;
                        return (
                            1 === t
                                ? n.copy(this.v2)
                                : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
                            n
                        );
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e);
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
                    }
                },
                QuadraticBezierCurve: lo,
                QuadraticBezierCurve3: co,
                SplineCurve: ho,
            });
            class po extends Xa {
                constructor() {
                    super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
                }
                add(t) {
                    this.curves.push(t);
                }
                closePath() {
                    const t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new oo(e, t));
                }
                getPoint(t, e) {
                    const n = t * this.getLength(),
                        i = this.getCurveLengths();
                    let r = 0;
                    for (; r < i.length; ) {
                        if (i[r] >= n) {
                            const t = i[r] - n,
                                s = this.curves[r],
                                a = s.getLength(),
                                o = 0 === a ? 0 : 1 - t / a;
                            return s.getPointAt(o, e);
                        }
                        r++;
                    }
                    return null;
                }
                getLength() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1];
                }
                updateArcLengths() {
                    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let n = 0, i = this.curves.length; n < i; n++) (e += this.curves[n].getLength()), t.push(e);
                    return (this.cacheLengths = t), t;
                }
                getSpacedPoints(t = 40) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e;
                }
                getPoints(t = 12) {
                    const e = [];
                    let n;
                    for (let i = 0, r = this.curves; i < r.length; i++) {
                        const s = r[i],
                            a =
                                s && s.isEllipseCurve
                                    ? 2 * t
                                    : s && (s.isLineCurve || s.isLineCurve3)
                                    ? 1
                                    : s && s.isSplineCurve
                                    ? t * s.points.length
                                    : t,
                            o = s.getPoints(a);
                        for (let t = 0; t < o.length; t++) {
                            const i = o[t];
                            (n && n.equals(i)) || (e.push(i), (n = i));
                        }
                    }
                    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
                }
                copy(t) {
                    super.copy(t), (this.curves = []);
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push(n.clone());
                    }
                    return (this.autoClose = t.autoClose), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    (t.autoClose = this.autoClose), (t.curves = []);
                    for (let e = 0, n = this.curves.length; e < n; e++) {
                        const n = this.curves[e];
                        t.curves.push(n.toJSON());
                    }
                    return t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push(new uo[n.type]().fromJSON(n));
                    }
                    return this;
                }
            }
            class mo extends po {
                constructor(t) {
                    super(), (this.type = 'Path'), (this.currentPoint = new Rt()), t && this.setFromPoints(t);
                }
                setFromPoints(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                    return this;
                }
                moveTo(t, e) {
                    return this.currentPoint.set(t, e), this;
                }
                lineTo(t, e) {
                    const n = new oo(this.currentPoint.clone(), new Rt(t, e));
                    return this.curves.push(n), this.currentPoint.set(t, e), this;
                }
                quadraticCurveTo(t, e, n, i) {
                    const r = new lo(this.currentPoint.clone(), new Rt(t, e), new Rt(n, i));
                    return this.curves.push(r), this.currentPoint.set(n, i), this;
                }
                bezierCurveTo(t, e, n, i, r, s) {
                    const a = new so(this.currentPoint.clone(), new Rt(t, e), new Rt(n, i), new Rt(r, s));
                    return this.curves.push(a), this.currentPoint.set(r, s), this;
                }
                splineThru(t) {
                    const e = [this.currentPoint.clone()].concat(t),
                        n = new ho(e);
                    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
                }
                arc(t, e, n, i, r, s) {
                    const a = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(t + a, e + o, n, i, r, s), this;
                }
                absarc(t, e, n, i, r, s) {
                    return this.absellipse(t, e, n, n, i, r, s), this;
                }
                ellipse(t, e, n, i, r, s, a, o) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(t + l, e + c, n, i, r, s, a, o), this;
                }
                absellipse(t, e, n, i, r, s, a, o) {
                    const l = new Ya(t, e, n, i, r, s, a, o);
                    if (this.curves.length > 0) {
                        const t = l.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c), this;
                }
                copy(t) {
                    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.currentPoint = this.currentPoint.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
                }
            }
            class fo extends mo {
                constructor(t) {
                    super(t), (this.uuid = wt()), (this.type = 'Shape'), (this.holes = []);
                }
                getPointsHoles(t) {
                    const e = [];
                    for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                    return e;
                }
                extractPoints(t) {
                    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
                }
                copy(t) {
                    super.copy(t), (this.holes = []);
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push(n.clone());
                    }
                    return this;
                }
                toJSON() {
                    const t = super.toJSON();
                    (t.uuid = this.uuid), (t.holes = []);
                    for (let e = 0, n = this.holes.length; e < n; e++) {
                        const n = this.holes[e];
                        t.holes.push(n.toJSON());
                    }
                    return t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push(new mo().fromJSON(n));
                    }
                    return this;
                }
            }
            function go(t, e, n, i, r) {
                let s, a;
                if (
                    r ===
                    (function (t, e, n, i) {
                        let r = 0;
                        for (let s = e, a = n - i; s < n; s += i) (r += (t[a] - t[s]) * (t[s + 1] + t[a + 1])), (a = s);
                        return r;
                    })(t, e, n, i) >
                        0
                )
                    for (s = e; s < n; s += i) a = Uo(s, t[s], t[s + 1], a);
                else for (s = n - i; s >= e; s -= i) a = Uo(s, t[s], t[s + 1], a);
                return a && Po(a, a.next) && (ko(a), (a = a.next)), a;
            }
            function vo(t, e) {
                if (!t) return t;
                e || (e = t);
                let n,
                    i = t;
                do {
                    if (((n = !1), i.steiner || (!Po(i, i.next) && 0 !== Co(i.prev, i, i.next)))) i = i.next;
                    else {
                        if ((ko(i), (i = e = i.prev), i === i.next)) break;
                        n = !0;
                    }
                } while (n || i !== e);
                return e;
            }
            function yo(t, e, n, i, r, s, a) {
                if (!t) return;
                !a &&
                    s &&
                    (function (t, e, n, i) {
                        let r = t;
                        do {
                            null === r.z && (r.z = Eo(r.x, r.y, e, n, i)),
                                (r.prevZ = r.prev),
                                (r.nextZ = r.next),
                                (r = r.next);
                        } while (r !== t);
                        (r.prevZ.nextZ = null),
                            (r.prevZ = null),
                            (function (t) {
                                let e,
                                    n,
                                    i,
                                    r,
                                    s,
                                    a,
                                    o,
                                    l,
                                    c = 1;
                                do {
                                    for (n = t, t = null, s = null, a = 0; n; ) {
                                        for (a++, i = n, o = 0, e = 0; e < c && (o++, (i = i.nextZ), i); e++);
                                        for (l = c; o > 0 || (l > 0 && i); )
                                            0 !== o && (0 === l || !i || n.z <= i.z)
                                                ? ((r = n), (n = n.nextZ), o--)
                                                : ((r = i), (i = i.nextZ), l--),
                                                s ? (s.nextZ = r) : (t = r),
                                                (r.prevZ = s),
                                                (s = r);
                                        n = i;
                                    }
                                    (s.nextZ = null), (c *= 2);
                                } while (a > 1);
                            })(r);
                    })(t, i, r, s);
                let o,
                    l,
                    c = t;
                for (; t.prev !== t.next; )
                    if (((o = t.prev), (l = t.next), s ? bo(t, i, r, s) : xo(t)))
                        e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), ko(t), (t = l.next), (c = l.next);
                    else if ((t = l) === c) {
                        a
                            ? 1 === a
                                ? yo((t = wo(vo(t), e, n)), e, n, i, r, s, 2)
                                : 2 === a && _o(t, e, n, i, r, s)
                            : yo(vo(t), e, n, i, r, s, 1);
                        break;
                    }
            }
            function xo(t) {
                const e = t.prev,
                    n = t,
                    i = t.next;
                if (Co(e, n, i) >= 0) return !1;
                let r = t.next.next;
                for (; r !== t.prev; ) {
                    if (Lo(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Co(r.prev, r, r.next) >= 0) return !1;
                    r = r.next;
                }
                return !0;
            }
            function bo(t, e, n, i) {
                const r = t.prev,
                    s = t,
                    a = t.next;
                if (Co(r, s, a) >= 0) return !1;
                const o = r.x < s.x ? (r.x < a.x ? r.x : a.x) : s.x < a.x ? s.x : a.x,
                    l = r.y < s.y ? (r.y < a.y ? r.y : a.y) : s.y < a.y ? s.y : a.y,
                    c = r.x > s.x ? (r.x > a.x ? r.x : a.x) : s.x > a.x ? s.x : a.x,
                    h = r.y > s.y ? (r.y > a.y ? r.y : a.y) : s.y > a.y ? s.y : a.y,
                    u = Eo(o, l, e, n, i),
                    d = Eo(c, h, e, n, i);
                let p = t.prevZ,
                    m = t.nextZ;
                for (; p && p.z >= u && m && m.z <= d; ) {
                    if (
                        p !== t.prev &&
                        p !== t.next &&
                        Lo(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
                        Co(p.prev, p, p.next) >= 0
                    )
                        return !1;
                    if (
                        ((p = p.prevZ),
                        m !== t.prev &&
                            m !== t.next &&
                            Lo(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
                            Co(m.prev, m, m.next) >= 0)
                    )
                        return !1;
                    m = m.nextZ;
                }
                for (; p && p.z >= u; ) {
                    if (
                        p !== t.prev &&
                        p !== t.next &&
                        Lo(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
                        Co(p.prev, p, p.next) >= 0
                    )
                        return !1;
                    p = p.prevZ;
                }
                for (; m && m.z <= d; ) {
                    if (
                        m !== t.prev &&
                        m !== t.next &&
                        Lo(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
                        Co(m.prev, m, m.next) >= 0
                    )
                        return !1;
                    m = m.nextZ;
                }
                return !0;
            }
            function wo(t, e, n) {
                let i = t;
                do {
                    const r = i.prev,
                        s = i.next.next;
                    !Po(r, s) &&
                        Io(r, i, i.next, s) &&
                        Fo(r, s) &&
                        Fo(s, r) &&
                        (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), ko(i), ko(i.next), (i = t = s)),
                        (i = i.next);
                } while (i !== t);
                return vo(i);
            }
            function _o(t, e, n, i, r, s) {
                let a = t;
                do {
                    let t = a.next.next;
                    for (; t !== a.prev; ) {
                        if (a.i !== t.i && Ro(a, t)) {
                            let o = Oo(a, t);
                            return (
                                (a = vo(a, a.next)),
                                (o = vo(o, o.next)),
                                yo(a, e, n, i, r, s),
                                void yo(o, e, n, i, r, s)
                            );
                        }
                        t = t.next;
                    }
                    a = a.next;
                } while (a !== t);
            }
            function Mo(t, e) {
                return t.x - e.x;
            }
            function So(t, e) {
                if (
                    ((e = (function (t, e) {
                        let n = e;
                        const i = t.x,
                            r = t.y;
                        let s,
                            a = -1 / 0;
                        do {
                            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                const t = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                                if (t <= i && t > a) {
                                    if (((a = t), t === i)) {
                                        if (r === n.y) return n;
                                        if (r === n.next.y) return n.next;
                                    }
                                    s = n.x < n.next.x ? n : n.next;
                                }
                            }
                            n = n.next;
                        } while (n !== e);
                        if (!s) return null;
                        if (i === a) return s;
                        const o = s,
                            l = s.x,
                            c = s.y;
                        let h,
                            u = 1 / 0;
                        n = s;
                        do {
                            i >= n.x &&
                                n.x >= l &&
                                i !== n.x &&
                                Lo(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) &&
                                ((h = Math.abs(r - n.y) / (i - n.x)),
                                Fo(n, t) &&
                                    (h < u || (h === u && (n.x > s.x || (n.x === s.x && To(s, n))))) &&
                                    ((s = n), (u = h))),
                                (n = n.next);
                        } while (n !== o);
                        return s;
                    })(t, e)),
                    e)
                ) {
                    const n = Oo(e, t);
                    vo(e, e.next), vo(n, n.next);
                }
            }
            function To(t, e) {
                return Co(t.prev, t, e.prev) < 0 && Co(e.next, t, t.next) < 0;
            }
            function Eo(t, e, n, i, r) {
                return (
                    (t =
                        1431655765 &
                        ((t =
                            858993459 &
                            ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) | (t << 4))) |
                                (t << 2))) |
                            (t << 1))) |
                    ((e =
                        1431655765 &
                        ((e =
                            858993459 &
                            ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) | (e << 4))) |
                                (e << 2))) |
                            (e << 1))) <<
                        1)
                );
            }
            function Ao(t) {
                let e = t,
                    n = t;
                do {
                    (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
                } while (e !== t);
                return n;
            }
            function Lo(t, e, n, i, r, s, a, o) {
                return (
                    (r - a) * (e - o) - (t - a) * (s - o) >= 0 &&
                    (t - a) * (i - o) - (n - a) * (e - o) >= 0 &&
                    (n - a) * (s - o) - (r - a) * (i - o) >= 0
                );
            }
            function Ro(t, e) {
                return (
                    t.next.i !== e.i &&
                    t.prev.i !== e.i &&
                    !(function (t, e) {
                        let n = t;
                        do {
                            if (
                                n.i !== t.i &&
                                n.next.i !== t.i &&
                                n.i !== e.i &&
                                n.next.i !== e.i &&
                                Io(n, n.next, t, e)
                            )
                                return !0;
                            n = n.next;
                        } while (n !== t);
                        return !1;
                    })(t, e) &&
                    ((Fo(t, e) &&
                        Fo(e, t) &&
                        (function (t, e) {
                            let n = t,
                                i = !1;
                            const r = (t.x + e.x) / 2,
                                s = (t.y + e.y) / 2;
                            do {
                                n.y > s != n.next.y > s &&
                                    n.next.y !== n.y &&
                                    r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                                    (i = !i),
                                    (n = n.next);
                            } while (n !== t);
                            return i;
                        })(t, e) &&
                        (Co(t.prev, t, e.prev) || Co(t, e.prev, e))) ||
                        (Po(t, e) && Co(t.prev, t, t.next) > 0 && Co(e.prev, e, e.next) > 0))
                );
            }
            function Co(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
            }
            function Po(t, e) {
                return t.x === e.x && t.y === e.y;
            }
            function Io(t, e, n, i) {
                const r = No(Co(t, e, n)),
                    s = No(Co(t, e, i)),
                    a = No(Co(n, i, t)),
                    o = No(Co(n, i, e));
                return (
                    (r !== s && a !== o) ||
                    !(0 !== r || !Do(t, n, e)) ||
                    !(0 !== s || !Do(t, i, e)) ||
                    !(0 !== a || !Do(n, t, i)) ||
                    !(0 !== o || !Do(n, e, i))
                );
            }
            function Do(t, e, n) {
                return (
                    e.x <= Math.max(t.x, n.x) &&
                    e.x >= Math.min(t.x, n.x) &&
                    e.y <= Math.max(t.y, n.y) &&
                    e.y >= Math.min(t.y, n.y)
                );
            }
            function No(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0;
            }
            function Fo(t, e) {
                return Co(t.prev, t, t.next) < 0
                    ? Co(t, e, t.next) >= 0 && Co(t, t.prev, e) >= 0
                    : Co(t, e, t.prev) < 0 || Co(t, t.next, e) < 0;
            }
            function Oo(t, e) {
                const n = new zo(t.i, t.x, t.y),
                    i = new zo(e.i, e.x, e.y),
                    r = t.next,
                    s = e.prev;
                return (
                    (t.next = e),
                    (e.prev = t),
                    (n.next = r),
                    (r.prev = n),
                    (i.next = n),
                    (n.prev = i),
                    (s.next = i),
                    (i.prev = s),
                    i
                );
            }
            function Uo(t, e, n, i) {
                const r = new zo(t, e, n);
                return (
                    i
                        ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
                        : ((r.prev = r), (r.next = r)),
                    r
                );
            }
            function ko(t) {
                (t.next.prev = t.prev),
                    (t.prev.next = t.next),
                    t.prevZ && (t.prevZ.nextZ = t.nextZ),
                    t.nextZ && (t.nextZ.prevZ = t.prevZ);
            }
            function zo(t, e, n) {
                (this.i = t),
                    (this.x = e),
                    (this.y = n),
                    (this.prev = null),
                    (this.next = null),
                    (this.z = null),
                    (this.prevZ = null),
                    (this.nextZ = null),
                    (this.steiner = !1);
            }
            class Bo {
                static area(t) {
                    const e = t.length;
                    let n = 0;
                    for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                    return 0.5 * n;
                }
                static isClockWise(t) {
                    return Bo.area(t) < 0;
                }
                static triangulateShape(t, e) {
                    const n = [],
                        i = [],
                        r = [];
                    Ho(t), Go(n, t);
                    let s = t.length;
                    e.forEach(Ho);
                    for (let t = 0; t < e.length; t++) i.push(s), (s += e[t].length), Go(n, e[t]);
                    const a = (function (t, e, n = 2) {
                        const i = e && e.length,
                            r = i ? e[0] * n : t.length;
                        let s = go(t, 0, r, n, !0);
                        const a = [];
                        if (!s || s.next === s.prev) return a;
                        let o, l, c, h, u, d, p;
                        if (
                            (i &&
                                (s = (function (t, e, n, i) {
                                    const r = [];
                                    let s, a, o, l, c;
                                    for (s = 0, a = e.length; s < a; s++)
                                        (o = e[s] * i),
                                            (l = s < a - 1 ? e[s + 1] * i : t.length),
                                            (c = go(t, o, l, i, !1)),
                                            c === c.next && (c.steiner = !0),
                                            r.push(Ao(c));
                                    for (r.sort(Mo), s = 0; s < r.length; s++) So(r[s], n), (n = vo(n, n.next));
                                    return n;
                                })(t, e, s, n)),
                            t.length > 80 * n)
                        ) {
                            (o = c = t[0]), (l = h = t[1]);
                            for (let e = n; e < r; e += n)
                                (u = t[e]),
                                    (d = t[e + 1]),
                                    u < o && (o = u),
                                    d < l && (l = d),
                                    u > c && (c = u),
                                    d > h && (h = d);
                            (p = Math.max(c - o, h - l)), (p = 0 !== p ? 1 / p : 0);
                        }
                        return yo(s, a, n, o, l, p), a;
                    })(n, i);
                    for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
                    return r;
                }
            }
            function Ho(t) {
                const e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop();
            }
            function Go(t, e) {
                for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
            }
            class Vo extends En {
                constructor(
                    t = new fo([new Rt(0.5, 0.5), new Rt(-0.5, 0.5), new Rt(-0.5, -0.5), new Rt(0.5, -0.5)]),
                    e = {},
                ) {
                    super(),
                        (this.type = 'ExtrudeGeometry'),
                        (this.parameters = { shapes: t, options: e }),
                        (t = Array.isArray(t) ? t : [t]);
                    const n = this,
                        i = [],
                        r = [];
                    for (let e = 0, n = t.length; e < n; e++) s(t[e]);
                    function s(t) {
                        const s = [],
                            a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            o = void 0 !== e.steps ? e.steps : 1;
                        let l = void 0 !== e.depth ? e.depth : 1,
                            c = void 0 === e.bevelEnabled || e.bevelEnabled,
                            h = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
                            u = void 0 !== e.bevelSize ? e.bevelSize : h - 0.1,
                            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                        const m = e.extrudePath,
                            f = void 0 !== e.UVGenerator ? e.UVGenerator : Wo;
                        void 0 !== e.amount &&
                            (console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.'),
                            (l = e.amount));
                        let g,
                            v,
                            y,
                            x,
                            b,
                            w = !1;
                        m &&
                            ((g = m.getSpacedPoints(o)),
                            (w = !0),
                            (c = !1),
                            (v = m.computeFrenetFrames(o, !1)),
                            (y = new Gt()),
                            (x = new Gt()),
                            (b = new Gt())),
                            c || ((p = 0), (h = 0), (u = 0), (d = 0));
                        const _ = t.extractPoints(a);
                        let M = _.shape;
                        const S = _.holes;
                        if (!Bo.isClockWise(M)) {
                            M = M.reverse();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                Bo.isClockWise(e) && (S[t] = e.reverse());
                            }
                        }
                        const T = Bo.triangulateShape(M, S),
                            E = M;
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            M = M.concat(e);
                        }
                        function A(t, e, n) {
                            return (
                                e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
                                e.clone().multiplyScalar(n).add(t)
                            );
                        }
                        const L = M.length,
                            R = T.length;
                        function C(t, e, n) {
                            let i, r, s;
                            const a = t.x - e.x,
                                o = t.y - e.y,
                                l = n.x - t.x,
                                c = n.y - t.y,
                                h = a * a + o * o,
                                u = a * c - o * l;
                            if (Math.abs(u) > Number.EPSILON) {
                                const u = Math.sqrt(h),
                                    d = Math.sqrt(l * l + c * c),
                                    p = e.x - o / u,
                                    m = e.y + a / u,
                                    f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l);
                                (i = p + a * f - t.x), (r = m + o * f - t.y);
                                const g = i * i + r * r;
                                if (g <= 2) return new Rt(i, r);
                                s = Math.sqrt(g / 2);
                            } else {
                                let t = !1;
                                a > Number.EPSILON
                                    ? l > Number.EPSILON && (t = !0)
                                    : a < -Number.EPSILON
                                    ? l < -Number.EPSILON && (t = !0)
                                    : Math.sign(o) === Math.sign(c) && (t = !0),
                                    t
                                        ? ((i = -o), (r = a), (s = Math.sqrt(h)))
                                        : ((i = a), (r = o), (s = Math.sqrt(h / 2)));
                            }
                            return new Rt(i / s, r / s);
                        }
                        const P = [];
                        for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++)
                            n === e && (n = 0), i === e && (i = 0), (P[t] = C(E[t], E[n], E[i]));
                        const I = [];
                        let D,
                            N = P.concat();
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            D = [];
                            for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++)
                                i === n && (i = 0), r === n && (r = 0), (D[t] = C(e[t], e[i], e[r]));
                            I.push(D), (N = N.concat(D));
                        }
                        for (let t = 0; t < p; t++) {
                            const e = t / p,
                                n = h * Math.cos((e * Math.PI) / 2),
                                i = u * Math.sin((e * Math.PI) / 2) + d;
                            for (let t = 0, e = E.length; t < e; t++) {
                                const e = A(E[t], P[t], i);
                                U(e.x, e.y, -n);
                            }
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                D = I[t];
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = A(e[t], D[t], i);
                                    U(r.x, r.y, -n);
                                }
                            }
                        }
                        const F = u + d;
                        for (let t = 0; t < L; t++) {
                            const e = c ? A(M[t], N[t], F) : M[t];
                            w
                                ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                                  y.copy(v.binormals[0]).multiplyScalar(e.y),
                                  b.copy(g[0]).add(x).add(y),
                                  U(b.x, b.y, b.z))
                                : U(e.x, e.y, 0);
                        }
                        for (let t = 1; t <= o; t++)
                            for (let e = 0; e < L; e++) {
                                const n = c ? A(M[e], N[e], F) : M[e];
                                w
                                    ? (x.copy(v.normals[t]).multiplyScalar(n.x),
                                      y.copy(v.binormals[t]).multiplyScalar(n.y),
                                      b.copy(g[t]).add(x).add(y),
                                      U(b.x, b.y, b.z))
                                    : U(n.x, n.y, (l / o) * t);
                            }
                        for (let t = p - 1; t >= 0; t--) {
                            const e = t / p,
                                n = h * Math.cos((e * Math.PI) / 2),
                                i = u * Math.sin((e * Math.PI) / 2) + d;
                            for (let t = 0, e = E.length; t < e; t++) {
                                const e = A(E[t], P[t], i);
                                U(e.x, e.y, l + n);
                            }
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                D = I[t];
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = A(e[t], D[t], i);
                                    w ? U(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : U(r.x, r.y, l + n);
                                }
                            }
                        }
                        function O(t, e) {
                            let n = t.length;
                            for (; --n >= 0; ) {
                                const i = n;
                                let r = n - 1;
                                r < 0 && (r = t.length - 1);
                                for (let t = 0, n = o + 2 * p; t < n; t++) {
                                    const n = L * t,
                                        s = L * (t + 1);
                                    z(e + i + n, e + r + n, e + r + s, e + i + s);
                                }
                            }
                        }
                        function U(t, e, n) {
                            s.push(t), s.push(e), s.push(n);
                        }
                        function k(t, e, r) {
                            B(t), B(e), B(r);
                            const s = i.length / 3,
                                a = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
                            H(a[0]), H(a[1]), H(a[2]);
                        }
                        function z(t, e, r, s) {
                            B(t), B(e), B(s), B(e), B(r), B(s);
                            const a = i.length / 3,
                                o = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                            H(o[0]), H(o[1]), H(o[3]), H(o[1]), H(o[2]), H(o[3]);
                        }
                        function B(t) {
                            i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]);
                        }
                        function H(t) {
                            r.push(t.x), r.push(t.y);
                        }
                        !(function () {
                            const t = i.length / 3;
                            if (c) {
                                let t = 0,
                                    e = L * t;
                                for (let t = 0; t < R; t++) {
                                    const n = T[t];
                                    k(n[2] + e, n[1] + e, n[0] + e);
                                }
                                (t = o + 2 * p), (e = L * t);
                                for (let t = 0; t < R; t++) {
                                    const n = T[t];
                                    k(n[0] + e, n[1] + e, n[2] + e);
                                }
                            } else {
                                for (let t = 0; t < R; t++) {
                                    const e = T[t];
                                    k(e[2], e[1], e[0]);
                                }
                                for (let t = 0; t < R; t++) {
                                    const e = T[t];
                                    k(e[0] + L * o, e[1] + L * o, e[2] + L * o);
                                }
                            }
                            n.addGroup(t, i.length / 3 - t, 0);
                        })(),
                            (function () {
                                const t = i.length / 3;
                                let e = 0;
                                O(E, e), (e += E.length);
                                for (let t = 0, n = S.length; t < n; t++) {
                                    const n = S[t];
                                    O(n, e), (e += n.length);
                                }
                                n.addGroup(t, i.length / 3 - t, 1);
                            })();
                    }
                    this.setAttribute('position', new yn(i, 3)),
                        this.setAttribute('uv', new yn(r, 2)),
                        this.computeVertexNormals();
                }
                toJSON() {
                    const t = super.toJSON();
                    return (function (t, e, n) {
                        if (((n.shapes = []), Array.isArray(t)))
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e];
                                n.shapes.push(i.uuid);
                            }
                        else n.shapes.push(t.uuid);
                        return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n;
                    })(this.parameters.shapes, this.parameters.options, t);
                }
                static fromJSON(t, e) {
                    const n = [];
                    for (let i = 0, r = t.shapes.length; i < r; i++) {
                        const r = e[t.shapes[i]];
                        n.push(r);
                    }
                    const i = t.options.extrudePath;
                    return void 0 !== i && (t.options.extrudePath = new uo[i.type]().fromJSON(i)), new Vo(n, t.options);
                }
            }
            const Wo = {
                generateTopUV: function (t, e, n, i, r) {
                    const s = e[3 * n],
                        a = e[3 * n + 1],
                        o = e[3 * i],
                        l = e[3 * i + 1],
                        c = e[3 * r],
                        h = e[3 * r + 1];
                    return [new Rt(s, a), new Rt(o, l), new Rt(c, h)];
                },
                generateSideWallUV: function (t, e, n, i, r, s) {
                    const a = e[3 * n],
                        o = e[3 * n + 1],
                        l = e[3 * n + 2],
                        c = e[3 * i],
                        h = e[3 * i + 1],
                        u = e[3 * i + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        m = e[3 * r + 2],
                        f = e[3 * s],
                        g = e[3 * s + 1],
                        v = e[3 * s + 2];
                    return Math.abs(o - h) < Math.abs(a - c)
                        ? [new Rt(a, 1 - l), new Rt(c, 1 - u), new Rt(d, 1 - m), new Rt(f, 1 - v)]
                        : [new Rt(o, 1 - l), new Rt(h, 1 - u), new Rt(p, 1 - m), new Rt(g, 1 - v)];
                },
            };
            class jo extends En {
                constructor(t = new fo([new Rt(0, 0.5), new Rt(-0.5, -0.5), new Rt(0.5, -0.5)]), e = 12) {
                    super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: t, curveSegments: e });
                    const n = [],
                        i = [],
                        r = [],
                        s = [];
                    let a = 0,
                        o = 0;
                    if (!1 === Array.isArray(t)) l(t);
                    else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), (a += o), (o = 0);
                    function l(t) {
                        const a = i.length / 3,
                            l = t.extractPoints(e);
                        let c = l.shape;
                        const h = l.holes;
                        !1 === Bo.isClockWise(c) && (c = c.reverse());
                        for (let t = 0, e = h.length; t < e; t++) {
                            const e = h[t];
                            !0 === Bo.isClockWise(e) && (h[t] = e.reverse());
                        }
                        const u = Bo.triangulateShape(c, h);
                        for (let t = 0, e = h.length; t < e; t++) {
                            const e = h[t];
                            c = c.concat(e);
                        }
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y);
                        }
                        for (let t = 0, e = u.length; t < e; t++) {
                            const e = u[t],
                                i = e[0] + a,
                                r = e[1] + a,
                                s = e[2] + a;
                            n.push(i, r, s), (o += 3);
                        }
                    }
                    this.setIndex(n),
                        this.setAttribute('position', new yn(i, 3)),
                        this.setAttribute('normal', new yn(r, 3)),
                        this.setAttribute('uv', new yn(s, 2));
                }
                toJSON() {
                    const t = super.toJSON();
                    return (function (t, e) {
                        if (((e.shapes = []), Array.isArray(t)))
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n];
                                e.shapes.push(i.uuid);
                            }
                        else e.shapes.push(t.uuid);
                        return e;
                    })(this.parameters.shapes, t);
                }
                static fromJSON(t, e) {
                    const n = [];
                    for (let i = 0, r = t.shapes.length; i < r; i++) {
                        const r = e[t.shapes[i]];
                        n.push(r);
                    }
                    return new jo(n, t.curveSegments);
                }
            }
            class qo extends rn {
                constructor(t) {
                    super(),
                        (this.type = 'ShadowMaterial'),
                        (this.color = new un(0)),
                        (this.transparent = !0),
                        this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this;
                }
            }
            qo.prototype.isShadowMaterial = !0;
            class Xo extends rn {
                constructor(t) {
                    super(),
                        (this.defines = { STANDARD: '' }),
                        (this.type = 'MeshStandardMaterial'),
                        (this.color = new un(16777215)),
                        (this.roughness = 1),
                        (this.metalness = 0),
                        (this.map = null),
                        (this.lightMap = null),
                        (this.lightMapIntensity = 1),
                        (this.aoMap = null),
                        (this.aoMapIntensity = 1),
                        (this.emissive = new un(0)),
                        (this.emissiveIntensity = 1),
                        (this.emissiveMap = null),
                        (this.bumpMap = null),
                        (this.bumpScale = 1),
                        (this.normalMap = null),
                        (this.normalMapType = 0),
                        (this.normalScale = new Rt(1, 1)),
                        (this.displacementMap = null),
                        (this.displacementScale = 1),
                        (this.displacementBias = 0),
                        (this.roughnessMap = null),
                        (this.metalnessMap = null),
                        (this.alphaMap = null),
                        (this.envMap = null),
                        (this.envMapIntensity = 1),
                        (this.refractionRatio = 0.98),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.wireframeLinecap = 'round'),
                        (this.wireframeLinejoin = 'round'),
                        (this.flatShading = !1),
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.defines = { STANDARD: '' }),
                        this.color.copy(t.color),
                        (this.roughness = t.roughness),
                        (this.metalness = t.metalness),
                        (this.map = t.map),
                        (this.lightMap = t.lightMap),
                        (this.lightMapIntensity = t.lightMapIntensity),
                        (this.aoMap = t.aoMap),
                        (this.aoMapIntensity = t.aoMapIntensity),
                        this.emissive.copy(t.emissive),
                        (this.emissiveMap = t.emissiveMap),
                        (this.emissiveIntensity = t.emissiveIntensity),
                        (this.bumpMap = t.bumpMap),
                        (this.bumpScale = t.bumpScale),
                        (this.normalMap = t.normalMap),
                        (this.normalMapType = t.normalMapType),
                        this.normalScale.copy(t.normalScale),
                        (this.displacementMap = t.displacementMap),
                        (this.displacementScale = t.displacementScale),
                        (this.displacementBias = t.displacementBias),
                        (this.roughnessMap = t.roughnessMap),
                        (this.metalnessMap = t.metalnessMap),
                        (this.alphaMap = t.alphaMap),
                        (this.envMap = t.envMap),
                        (this.envMapIntensity = t.envMapIntensity),
                        (this.refractionRatio = t.refractionRatio),
                        (this.wireframe = t.wireframe),
                        (this.wireframeLinewidth = t.wireframeLinewidth),
                        (this.wireframeLinecap = t.wireframeLinecap),
                        (this.wireframeLinejoin = t.wireframeLinejoin),
                        (this.flatShading = t.flatShading),
                        this
                    );
                }
            }
            Xo.prototype.isMeshStandardMaterial = !0;
            class Yo extends Xo {
                constructor(t) {
                    super(),
                        (this.defines = { STANDARD: '', PHYSICAL: '' }),
                        (this.type = 'MeshPhysicalMaterial'),
                        (this.clearcoatMap = null),
                        (this.clearcoatRoughness = 0),
                        (this.clearcoatRoughnessMap = null),
                        (this.clearcoatNormalScale = new Rt(1, 1)),
                        (this.clearcoatNormalMap = null),
                        (this.ior = 1.5),
                        Object.defineProperty(this, 'reflectivity', {
                            get: function () {
                                return _t((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                            },
                            set: function (t) {
                                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                            },
                        }),
                        (this.sheenTint = new un(0)),
                        (this.sheenRoughness = 1),
                        (this.transmissionMap = null),
                        (this.thickness = 0.01),
                        (this.thicknessMap = null),
                        (this.attenuationDistance = 0),
                        (this.attenuationTint = new un(1, 1, 1)),
                        (this.specularIntensity = 1),
                        (this.specularIntensityMap = null),
                        (this.specularTint = new un(1, 1, 1)),
                        (this.specularTintMap = null),
                        (this._sheen = 0),
                        (this._clearcoat = 0),
                        (this._transmission = 0),
                        this.setValues(t);
                }
                get sheen() {
                    return this._sheen;
                }
                set sheen(t) {
                    this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
                }
                get clearcoat() {
                    return this._clearcoat;
                }
                set clearcoat(t) {
                    this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
                }
                get transmission() {
                    return this._transmission;
                }
                set transmission(t) {
                    this._transmission > 0 != t > 0 && this.version++, (this._transmission = t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.defines = { STANDARD: '', PHYSICAL: '' }),
                        (this.clearcoat = t.clearcoat),
                        (this.clearcoatMap = t.clearcoatMap),
                        (this.clearcoatRoughness = t.clearcoatRoughness),
                        (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
                        (this.clearcoatNormalMap = t.clearcoatNormalMap),
                        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                        (this.ior = t.ior),
                        (this.sheen = t.sheen),
                        this.sheenTint.copy(t.sheenTint),
                        (this.sheenRoughness = t.sheenRoughness),
                        (this.transmission = t.transmission),
                        (this.transmissionMap = t.transmissionMap),
                        (this.thickness = t.thickness),
                        (this.thicknessMap = t.thicknessMap),
                        (this.attenuationDistance = t.attenuationDistance),
                        this.attenuationTint.copy(t.attenuationTint),
                        (this.specularIntensity = t.specularIntensity),
                        (this.specularIntensityMap = t.specularIntensityMap),
                        this.specularTint.copy(t.specularTint),
                        (this.specularTintMap = t.specularTintMap),
                        this
                    );
                }
            }
            (Yo.prototype.isMeshPhysicalMaterial = !0),
                (class extends rn {
                    constructor(t) {
                        super(),
                            (this.type = 'MeshPhongMaterial'),
                            (this.color = new un(16777215)),
                            (this.specular = new un(1118481)),
                            (this.shininess = 30),
                            (this.map = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.emissive = new un(0)),
                            (this.emissiveIntensity = 1),
                            (this.emissiveMap = null),
                            (this.bumpMap = null),
                            (this.bumpScale = 1),
                            (this.normalMap = null),
                            (this.normalMapType = 0),
                            (this.normalScale = new Rt(1, 1)),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.specularMap = null),
                            (this.alphaMap = null),
                            (this.envMap = null),
                            (this.combine = 0),
                            (this.reflectivity = 1),
                            (this.refractionRatio = 0.98),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = 'round'),
                            (this.wireframeLinejoin = 'round'),
                            (this.flatShading = !1),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            this.specular.copy(t.specular),
                            (this.shininess = t.shininess),
                            (this.map = t.map),
                            (this.lightMap = t.lightMap),
                            (this.lightMapIntensity = t.lightMapIntensity),
                            (this.aoMap = t.aoMap),
                            (this.aoMapIntensity = t.aoMapIntensity),
                            this.emissive.copy(t.emissive),
                            (this.emissiveMap = t.emissiveMap),
                            (this.emissiveIntensity = t.emissiveIntensity),
                            (this.bumpMap = t.bumpMap),
                            (this.bumpScale = t.bumpScale),
                            (this.normalMap = t.normalMap),
                            (this.normalMapType = t.normalMapType),
                            this.normalScale.copy(t.normalScale),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            (this.specularMap = t.specularMap),
                            (this.alphaMap = t.alphaMap),
                            (this.envMap = t.envMap),
                            (this.combine = t.combine),
                            (this.reflectivity = t.reflectivity),
                            (this.refractionRatio = t.refractionRatio),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.wireframeLinecap = t.wireframeLinecap),
                            (this.wireframeLinejoin = t.wireframeLinejoin),
                            (this.flatShading = t.flatShading),
                            this
                        );
                    }
                }.prototype.isMeshPhongMaterial = !0),
                (class extends rn {
                    constructor(t) {
                        super(),
                            (this.defines = { TOON: '' }),
                            (this.type = 'MeshToonMaterial'),
                            (this.color = new un(16777215)),
                            (this.map = null),
                            (this.gradientMap = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.emissive = new un(0)),
                            (this.emissiveIntensity = 1),
                            (this.emissiveMap = null),
                            (this.bumpMap = null),
                            (this.bumpScale = 1),
                            (this.normalMap = null),
                            (this.normalMapType = 0),
                            (this.normalScale = new Rt(1, 1)),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.alphaMap = null),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = 'round'),
                            (this.wireframeLinejoin = 'round'),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            (this.map = t.map),
                            (this.gradientMap = t.gradientMap),
                            (this.lightMap = t.lightMap),
                            (this.lightMapIntensity = t.lightMapIntensity),
                            (this.aoMap = t.aoMap),
                            (this.aoMapIntensity = t.aoMapIntensity),
                            this.emissive.copy(t.emissive),
                            (this.emissiveMap = t.emissiveMap),
                            (this.emissiveIntensity = t.emissiveIntensity),
                            (this.bumpMap = t.bumpMap),
                            (this.bumpScale = t.bumpScale),
                            (this.normalMap = t.normalMap),
                            (this.normalMapType = t.normalMapType),
                            this.normalScale.copy(t.normalScale),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            (this.alphaMap = t.alphaMap),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.wireframeLinecap = t.wireframeLinecap),
                            (this.wireframeLinejoin = t.wireframeLinejoin),
                            this
                        );
                    }
                }.prototype.isMeshToonMaterial = !0),
                (class extends rn {
                    constructor(t) {
                        super(),
                            (this.type = 'MeshNormalMaterial'),
                            (this.bumpMap = null),
                            (this.bumpScale = 1),
                            (this.normalMap = null),
                            (this.normalMapType = 0),
                            (this.normalScale = new Rt(1, 1)),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.fog = !1),
                            (this.flatShading = !1),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.bumpMap = t.bumpMap),
                            (this.bumpScale = t.bumpScale),
                            (this.normalMap = t.normalMap),
                            (this.normalMapType = t.normalMapType),
                            this.normalScale.copy(t.normalScale),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.flatShading = t.flatShading),
                            this
                        );
                    }
                }.prototype.isMeshNormalMaterial = !0),
                (class extends rn {
                    constructor(t) {
                        super(),
                            (this.type = 'MeshLambertMaterial'),
                            (this.color = new un(16777215)),
                            (this.map = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.emissive = new un(0)),
                            (this.emissiveIntensity = 1),
                            (this.emissiveMap = null),
                            (this.specularMap = null),
                            (this.alphaMap = null),
                            (this.envMap = null),
                            (this.combine = 0),
                            (this.reflectivity = 1),
                            (this.refractionRatio = 0.98),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = 'round'),
                            (this.wireframeLinejoin = 'round'),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            (this.map = t.map),
                            (this.lightMap = t.lightMap),
                            (this.lightMapIntensity = t.lightMapIntensity),
                            (this.aoMap = t.aoMap),
                            (this.aoMapIntensity = t.aoMapIntensity),
                            this.emissive.copy(t.emissive),
                            (this.emissiveMap = t.emissiveMap),
                            (this.emissiveIntensity = t.emissiveIntensity),
                            (this.specularMap = t.specularMap),
                            (this.alphaMap = t.alphaMap),
                            (this.envMap = t.envMap),
                            (this.combine = t.combine),
                            (this.reflectivity = t.reflectivity),
                            (this.refractionRatio = t.refractionRatio),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.wireframeLinecap = t.wireframeLinecap),
                            (this.wireframeLinejoin = t.wireframeLinejoin),
                            this
                        );
                    }
                }.prototype.isMeshLambertMaterial = !0),
                (class extends rn {
                    constructor(t) {
                        super(),
                            (this.defines = { MATCAP: '' }),
                            (this.type = 'MeshMatcapMaterial'),
                            (this.color = new un(16777215)),
                            (this.matcap = null),
                            (this.map = null),
                            (this.bumpMap = null),
                            (this.bumpScale = 1),
                            (this.normalMap = null),
                            (this.normalMapType = 0),
                            (this.normalScale = new Rt(1, 1)),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.alphaMap = null),
                            (this.flatShading = !1),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.defines = { MATCAP: '' }),
                            this.color.copy(t.color),
                            (this.matcap = t.matcap),
                            (this.map = t.map),
                            (this.bumpMap = t.bumpMap),
                            (this.bumpScale = t.bumpScale),
                            (this.normalMap = t.normalMap),
                            (this.normalMapType = t.normalMapType),
                            this.normalScale.copy(t.normalScale),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            (this.alphaMap = t.alphaMap),
                            (this.flatShading = t.flatShading),
                            this
                        );
                    }
                }.prototype.isMeshMatcapMaterial = !0),
                (class extends La {
                    constructor(t) {
                        super(),
                            (this.type = 'LineDashedMaterial'),
                            (this.scale = 1),
                            (this.dashSize = 3),
                            (this.gapSize = 1),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.scale = t.scale),
                            (this.dashSize = t.dashSize),
                            (this.gapSize = t.gapSize),
                            this
                        );
                    }
                }.prototype.isLineDashedMaterial = !0);
            const Zo = {
                arraySlice: function (t, e, n) {
                    return Zo.isTypedArray(t)
                        ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
                        : t.slice(e, n);
                },
                convertArray: function (t, e, n) {
                    return !t || (!n && t.constructor === e)
                        ? t
                        : 'number' == typeof e.BYTES_PER_ELEMENT
                        ? new e(t)
                        : Array.prototype.slice.call(t);
                },
                isTypedArray: function (t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView);
                },
                getKeyframeOrder: function (t) {
                    const e = t.length,
                        n = new Array(e);
                    for (let t = 0; t !== e; ++t) n[t] = t;
                    return (
                        n.sort(function (e, n) {
                            return t[e] - t[n];
                        }),
                        n
                    );
                },
                sortedArray: function (t, e, n) {
                    const i = t.length,
                        r = new t.constructor(i);
                    for (let s = 0, a = 0; a !== i; ++s) {
                        const i = n[s] * e;
                        for (let n = 0; n !== e; ++n) r[a++] = t[i + n];
                    }
                    return r;
                },
                flattenJSON: function (t, e, n, i) {
                    let r = 1,
                        s = t[0];
                    for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
                    if (void 0 === s) return;
                    let a = s[i];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                (a = s[i]), void 0 !== a && (e.push(s.time), n.push.apply(n, a)), (s = t[r++]);
                            } while (void 0 !== s);
                        else if (void 0 !== a.toArray)
                            do {
                                (a = s[i]), void 0 !== a && (e.push(s.time), a.toArray(n, n.length)), (s = t[r++]);
                            } while (void 0 !== s);
                        else
                            do {
                                (a = s[i]), void 0 !== a && (e.push(s.time), n.push(a)), (s = t[r++]);
                            } while (void 0 !== s);
                },
                subclip: function (t, e, n, i, r = 30) {
                    const s = t.clone();
                    s.name = e;
                    const a = [];
                    for (let t = 0; t < s.tracks.length; ++t) {
                        const e = s.tracks[t],
                            o = e.getValueSize(),
                            l = [],
                            c = [];
                        for (let t = 0; t < e.times.length; ++t) {
                            const s = e.times[t] * r;
                            if (!(s < n || s >= i)) {
                                l.push(e.times[t]);
                                for (let n = 0; n < o; ++n) c.push(e.values[t * o + n]);
                            }
                        }
                        0 !== l.length &&
                            ((e.times = Zo.convertArray(l, e.times.constructor)),
                            (e.values = Zo.convertArray(c, e.values.constructor)),
                            a.push(e));
                    }
                    s.tracks = a;
                    let o = 1 / 0;
                    for (let t = 0; t < s.tracks.length; ++t) o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                    for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
                    return s.resetDuration(), s;
                },
                makeClipAdditive: function (t, e = 0, n = t, i = 30) {
                    i <= 0 && (i = 30);
                    const r = n.tracks.length,
                        s = e / i;
                    for (let e = 0; e < r; ++e) {
                        const i = n.tracks[e],
                            r = i.ValueTypeName;
                        if ('bool' === r || 'string' === r) continue;
                        const a = t.tracks.find(function (t) {
                            return t.name === i.name && t.ValueTypeName === r;
                        });
                        if (void 0 === a) continue;
                        let o = 0;
                        const l = i.getValueSize();
                        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                        let c = 0;
                        const h = a.getValueSize();
                        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                        const u = i.times.length - 1;
                        let d;
                        if (s <= i.times[0]) {
                            const t = o,
                                e = l - o;
                            d = Zo.arraySlice(i.values, t, e);
                        } else if (s >= i.times[u]) {
                            const t = u * l + o,
                                e = t + l - o;
                            d = Zo.arraySlice(i.values, t, e);
                        } else {
                            const t = i.createInterpolant(),
                                e = o,
                                n = l - o;
                            t.evaluate(s), (d = Zo.arraySlice(t.resultBuffer, e, n));
                        }
                        'quaternion' === r && new Ht().fromArray(d).normalize().conjugate().toArray(d);
                        const p = a.times.length;
                        for (let t = 0; t < p; ++t) {
                            const e = t * h + c;
                            if ('quaternion' === r) Ht.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                            else {
                                const t = h - 2 * c;
                                for (let n = 0; n < t; ++n) a.values[e + n] -= d[n];
                            }
                        }
                    }
                    return (t.blendMode = 2501), t;
                },
            };
            class Jo {
                constructor(t, e, n, i) {
                    (this.parameterPositions = t),
                        (this._cachedIndex = 0),
                        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
                        (this.sampleValues = e),
                        (this.valueSize = n),
                        (this.settings = null),
                        (this.DefaultSettings_ = {});
                }
                evaluate(t) {
                    const e = this.parameterPositions;
                    let n = this._cachedIndex,
                        i = e[n],
                        r = e[n - 1];
                    t: {
                        e: {
                            let s;
                            n: {
                                i: if (!(t < i)) {
                                    for (let s = n + 2; ; ) {
                                        if (void 0 === i) {
                                            if (t < r) break i;
                                            return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, t, r);
                                        }
                                        if (n === s) break;
                                        if (((r = i), (i = e[++n]), t < i)) break e;
                                    }
                                    s = e.length;
                                    break n;
                                }
                                if (t >= r) break t;
                                {
                                    const a = e[1];
                                    t < a && ((n = 2), (r = a));
                                    for (let s = n - 2; ; ) {
                                        if (void 0 === r) return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                                        if (n === s) break;
                                        if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                                    }
                                    (s = n), (n = 0);
                                }
                            }
                            for (; n < s; ) {
                                const i = (n + s) >>> 1;
                                t < e[i] ? (s = i) : (n = i + 1);
                            }
                            if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                                return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                            if (void 0 === i)
                                return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, t);
                        }
                        (this._cachedIndex = n), this.intervalChanged_(n, r, i);
                    }
                    return this.interpolate_(n, r, t, i);
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_;
                }
                copySampleValue_(t) {
                    const e = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = t * i;
                    for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                    return e;
                }
                interpolate_() {
                    throw new Error('call to abstract method');
                }
                intervalChanged_() {}
            }
            (Jo.prototype.beforeStart_ = Jo.prototype.copySampleValue_),
                (Jo.prototype.afterEnd_ = Jo.prototype.copySampleValue_);
            class $o extends Jo {
                constructor(t, e, n, i) {
                    super(t, e, n, i),
                        (this._weightPrev = -0),
                        (this._offsetPrev = -0),
                        (this._weightNext = -0),
                        (this._offsetNext = -0),
                        (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
                }
                intervalChanged_(t, e, n) {
                    const i = this.parameterPositions;
                    let r = t - 2,
                        s = t + 1,
                        a = i[r],
                        o = i[s];
                    if (void 0 === a)
                        switch (this.getSettings_().endingStart) {
                            case 2401:
                                (r = t), (a = 2 * e - n);
                                break;
                            case 2402:
                                (r = i.length - 2), (a = e + i[r] - i[r + 1]);
                                break;
                            default:
                                (r = t), (a = n);
                        }
                    if (void 0 === o)
                        switch (this.getSettings_().endingEnd) {
                            case 2401:
                                (s = t), (o = 2 * n - e);
                                break;
                            case 2402:
                                (s = 1), (o = n + i[1] - i[0]);
                                break;
                            default:
                                (s = t - 1), (o = e);
                        }
                    const l = 0.5 * (n - e),
                        c = this.valueSize;
                    (this._weightPrev = l / (e - a)),
                        (this._weightNext = l / (o - n)),
                        (this._offsetPrev = r * c),
                        (this._offsetNext = s * c);
                }
                interpolate_(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        l = o - a,
                        c = this._offsetPrev,
                        h = this._offsetNext,
                        u = this._weightPrev,
                        d = this._weightNext,
                        p = (n - e) / (i - e),
                        m = p * p,
                        f = m * p,
                        g = -u * f + 2 * u * m - u * p,
                        v = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
                        y = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
                        x = d * f - d * m;
                    for (let t = 0; t !== a; ++t) r[t] = g * s[c + t] + v * s[l + t] + y * s[o + t] + x * s[h + t];
                    return r;
                }
            }
            class Ko extends Jo {
                constructor(t, e, n, i) {
                    super(t, e, n, i);
                }
                interpolate_(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        l = o - a,
                        c = (n - e) / (i - e),
                        h = 1 - c;
                    for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
                    return r;
                }
            }
            class Qo extends Jo {
                constructor(t, e, n, i) {
                    super(t, e, n, i);
                }
                interpolate_(t) {
                    return this.copySampleValue_(t - 1);
                }
            }
            class tl {
                constructor(t, e, n, i) {
                    if (void 0 === t) throw new Error('THREE.KeyframeTrack: track name is undefined');
                    if (void 0 === e || 0 === e.length)
                        throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t);
                    (this.name = t),
                        (this.times = Zo.convertArray(e, this.TimeBufferType)),
                        (this.values = Zo.convertArray(n, this.ValueBufferType)),
                        this.setInterpolation(i || this.DefaultInterpolation);
                }
                static toJSON(t) {
                    const e = t.constructor;
                    let n;
                    if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                    else {
                        n = {
                            name: t.name,
                            times: Zo.convertArray(t.times, Array),
                            values: Zo.convertArray(t.values, Array),
                        };
                        const e = t.getInterpolation();
                        e !== t.DefaultInterpolation && (n.interpolation = e);
                    }
                    return (n.type = t.ValueTypeName), n;
                }
                InterpolantFactoryMethodDiscrete(t) {
                    return new Qo(this.times, this.values, this.getValueSize(), t);
                }
                InterpolantFactoryMethodLinear(t) {
                    return new Ko(this.times, this.values, this.getValueSize(), t);
                }
                InterpolantFactoryMethodSmooth(t) {
                    return new $o(this.times, this.values, this.getValueSize(), t);
                }
                setInterpolation(t) {
                    let e;
                    switch (t) {
                        case 2300:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case 2301:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            e = this.InterpolantFactoryMethodSmooth;
                    }
                    if (void 0 === e) {
                        const e =
                            'unsupported interpolation for ' +
                            this.ValueTypeName +
                            ' keyframe track named ' +
                            this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(e);
                            this.setInterpolation(this.DefaultInterpolation);
                        }
                        return console.warn('THREE.KeyframeTrack:', e), this;
                    }
                    return (this.createInterpolant = e), this;
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return 2300;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302;
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length;
                }
                shift(t) {
                    if (0 !== t) {
                        const e = this.times;
                        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
                    }
                    return this;
                }
                scale(t) {
                    if (1 !== t) {
                        const e = this.times;
                        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
                    }
                    return this;
                }
                trim(t, e) {
                    const n = this.times,
                        i = n.length;
                    let r = 0,
                        s = i - 1;
                    for (; r !== i && n[r] < t; ) ++r;
                    for (; -1 !== s && n[s] > e; ) --s;
                    if ((++s, 0 !== r || s !== i)) {
                        r >= s && ((s = Math.max(s, 1)), (r = s - 1));
                        const t = this.getValueSize();
                        (this.times = Zo.arraySlice(n, r, s)), (this.values = Zo.arraySlice(this.values, r * t, s * t));
                    }
                    return this;
                }
                validate() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) != 0 &&
                        (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (t = !1));
                    const n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error('THREE.KeyframeTrack: Track is empty.', this), (t = !1));
                    let s = null;
                    for (let e = 0; e !== r; e++) {
                        const i = n[e];
                        if ('number' == typeof i && isNaN(i)) {
                            console.error('THREE.KeyframeTrack: Time is not a valid number.', this, e, i), (t = !1);
                            break;
                        }
                        if (null !== s && s > i) {
                            console.error('THREE.KeyframeTrack: Out of order keys.', this, e, i, s), (t = !1);
                            break;
                        }
                        s = i;
                    }
                    if (void 0 !== i && Zo.isTypedArray(i))
                        for (let e = 0, n = i.length; e !== n; ++e) {
                            const n = i[e];
                            if (isNaN(n)) {
                                console.error('THREE.KeyframeTrack: Value is not a valid number.', this, e, n),
                                    (t = !1);
                                break;
                            }
                        }
                    return t;
                }
                optimize() {
                    const t = Zo.arraySlice(this.times),
                        e = Zo.arraySlice(this.values),
                        n = this.getValueSize(),
                        i = 2302 === this.getInterpolation(),
                        r = t.length - 1;
                    let s = 1;
                    for (let a = 1; a < r; ++a) {
                        let r = !1;
                        const o = t[a];
                        if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                            if (i) r = !0;
                            else {
                                const t = a * n,
                                    i = t - n,
                                    s = t + n;
                                for (let a = 0; a !== n; ++a) {
                                    const n = e[t + a];
                                    if (n !== e[i + a] || n !== e[s + a]) {
                                        r = !0;
                                        break;
                                    }
                                }
                            }
                        if (r) {
                            if (a !== s) {
                                t[s] = t[a];
                                const i = a * n,
                                    r = s * n;
                                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
                            }
                            ++s;
                        }
                    }
                    if (r > 0) {
                        t[s] = t[r];
                        for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
                        ++s;
                    }
                    return (
                        s !== t.length
                            ? ((this.times = Zo.arraySlice(t, 0, s)), (this.values = Zo.arraySlice(e, 0, s * n)))
                            : ((this.times = t), (this.values = e)),
                        this
                    );
                }
                clone() {
                    const t = Zo.arraySlice(this.times, 0),
                        e = Zo.arraySlice(this.values, 0),
                        n = new (0, this.constructor)(this.name, t, e);
                    return (n.createInterpolant = this.createInterpolant), n;
                }
            }
            (tl.prototype.TimeBufferType = Float32Array),
                (tl.prototype.ValueBufferType = Float32Array),
                (tl.prototype.DefaultInterpolation = 2301);
            class el extends tl {}
            (el.prototype.ValueTypeName = 'bool'),
                (el.prototype.ValueBufferType = Array),
                (el.prototype.DefaultInterpolation = 2300),
                (el.prototype.InterpolantFactoryMethodLinear = void 0),
                (el.prototype.InterpolantFactoryMethodSmooth = void 0);
            class nl extends tl {}
            nl.prototype.ValueTypeName = 'color';
            class il extends tl {}
            il.prototype.ValueTypeName = 'number';
            class rl extends Jo {
                constructor(t, e, n, i) {
                    super(t, e, n, i);
                }
                interpolate_(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = (n - e) / (i - e);
                    let l = t * a;
                    for (let t = l + a; l !== t; l += 4) Ht.slerpFlat(r, 0, s, l - a, s, l, o);
                    return r;
                }
            }
            class sl extends tl {
                InterpolantFactoryMethodLinear(t) {
                    return new rl(this.times, this.values, this.getValueSize(), t);
                }
            }
            (sl.prototype.ValueTypeName = 'quaternion'),
                (sl.prototype.DefaultInterpolation = 2301),
                (sl.prototype.InterpolantFactoryMethodSmooth = void 0);
            class al extends tl {}
            (al.prototype.ValueTypeName = 'string'),
                (al.prototype.ValueBufferType = Array),
                (al.prototype.DefaultInterpolation = 2300),
                (al.prototype.InterpolantFactoryMethodLinear = void 0),
                (al.prototype.InterpolantFactoryMethodSmooth = void 0);
            class ol extends tl {}
            ol.prototype.ValueTypeName = 'vector';
            class ll {
                constructor(t, e = -1, n, i = 2500) {
                    (this.name = t),
                        (this.tracks = n),
                        (this.duration = e),
                        (this.blendMode = i),
                        (this.uuid = wt()),
                        this.duration < 0 && this.resetDuration();
                }
                static parse(t) {
                    const e = [],
                        n = t.tracks,
                        i = 1 / (t.fps || 1);
                    for (let t = 0, r = n.length; t !== r; ++t) e.push(cl(n[t]).scale(i));
                    const r = new this(t.name, t.duration, e, t.blendMode);
                    return (r.uuid = t.uuid), r;
                }
                static toJSON(t) {
                    const e = [],
                        n = t.tracks,
                        i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
                    for (let t = 0, i = n.length; t !== i; ++t) e.push(tl.toJSON(n[t]));
                    return i;
                }
                static CreateFromMorphTargetSequence(t, e, n, i) {
                    const r = e.length,
                        s = [];
                    for (let t = 0; t < r; t++) {
                        let a = [],
                            o = [];
                        a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
                        const l = Zo.getKeyframeOrder(a);
                        (a = Zo.sortedArray(a, 1, l)),
                            (o = Zo.sortedArray(o, 1, l)),
                            i || 0 !== a[0] || (a.push(r), o.push(o[0])),
                            s.push(new il('.morphTargetInfluences[' + e[t].name + ']', a, o).scale(1 / n));
                    }
                    return new this(t, -1, s);
                }
                static findByName(t, e) {
                    let n = t;
                    if (!Array.isArray(t)) {
                        const e = t;
                        n = (e.geometry && e.geometry.animations) || e.animations;
                    }
                    for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
                    return null;
                }
                static CreateClipsFromMorphTargetSequences(t, e, n) {
                    const i = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e],
                            s = n.name.match(r);
                        if (s && s.length > 1) {
                            const t = s[1];
                            let e = i[t];
                            e || (i[t] = e = []), e.push(n);
                        }
                    }
                    const s = [];
                    for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                    return s;
                }
                static parseAnimation(t, e) {
                    if (!t) return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null;
                    const n = function (t, e, n, i, r) {
                            if (0 !== n.length) {
                                const s = [],
                                    a = [];
                                Zo.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a));
                            }
                        },
                        i = [],
                        r = t.name || 'default',
                        s = t.fps || 30,
                        a = t.blendMode;
                    let o = t.length || -1;
                    const l = t.hierarchy || [];
                    for (let t = 0; t < l.length; t++) {
                        const r = l[t].keys;
                        if (r && 0 !== r.length)
                            if (r[0].morphTargets) {
                                const t = {};
                                let e;
                                for (e = 0; e < r.length; e++)
                                    if (r[e].morphTargets)
                                        for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                                for (const n in t) {
                                    const t = [],
                                        s = [];
                                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                        const i = r[e];
                                        t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                                    }
                                    i.push(new il('.morphTargetInfluence[' + n + ']', t, s));
                                }
                                o = t.length * (s || 1);
                            } else {
                                const s = '.bones[' + e[t].name + ']';
                                n(ol, s + '.position', r, 'pos', i),
                                    n(sl, s + '.quaternion', r, 'rot', i),
                                    n(ol, s + '.scale', r, 'scl', i);
                            }
                    }
                    return 0 === i.length ? null : new this(r, o, i, a);
                }
                resetDuration() {
                    let t = 0;
                    for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                        const n = this.tracks[e];
                        t = Math.max(t, n.times[n.times.length - 1]);
                    }
                    return (this.duration = t), this;
                }
                trim() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this;
                }
                validate() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t;
                }
                optimize() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this;
                }
                clone() {
                    const t = [];
                    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new this.constructor(this.name, this.duration, t, this.blendMode);
                }
                toJSON() {
                    return this.constructor.toJSON(this);
                }
            }
            function cl(t) {
                if (void 0 === t.type) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
                const e = (function (t) {
                    switch (t.toLowerCase()) {
                        case 'scalar':
                        case 'double':
                        case 'float':
                        case 'number':
                        case 'integer':
                            return il;
                        case 'vector':
                        case 'vector2':
                        case 'vector3':
                        case 'vector4':
                            return ol;
                        case 'color':
                            return nl;
                        case 'quaternion':
                            return sl;
                        case 'bool':
                        case 'boolean':
                            return el;
                        case 'string':
                            return al;
                    }
                    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t);
                })(t.type);
                if (void 0 === t.times) {
                    const e = [],
                        n = [];
                    Zo.flattenJSON(t.keys, e, n, 'value'), (t.times = e), (t.values = n);
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
            }
            const hl = {
                    enabled: !1,
                    files: {},
                    add: function (t, e) {
                        !1 !== this.enabled && (this.files[t] = e);
                    },
                    get: function (t) {
                        if (!1 !== this.enabled) return this.files[t];
                    },
                    remove: function (t) {
                        delete this.files[t];
                    },
                    clear: function () {
                        this.files = {};
                    },
                },
                ul = new (class {
                    constructor(t, e, n) {
                        const i = this;
                        let r,
                            s = !1,
                            a = 0,
                            o = 0;
                        const l = [];
                        (this.onStart = void 0),
                            (this.onLoad = t),
                            (this.onProgress = e),
                            (this.onError = n),
                            (this.itemStart = function (t) {
                                o++, !1 === s && void 0 !== i.onStart && i.onStart(t, a, o), (s = !0);
                            }),
                            (this.itemEnd = function (t) {
                                a++,
                                    void 0 !== i.onProgress && i.onProgress(t, a, o),
                                    a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
                            }),
                            (this.itemError = function (t) {
                                void 0 !== i.onError && i.onError(t);
                            }),
                            (this.resolveURL = function (t) {
                                return r ? r(t) : t;
                            }),
                            (this.setURLModifier = function (t) {
                                return (r = t), this;
                            }),
                            (this.addHandler = function (t, e) {
                                return l.push(t, e), this;
                            }),
                            (this.removeHandler = function (t) {
                                const e = l.indexOf(t);
                                return -1 !== e && l.splice(e, 2), this;
                            }),
                            (this.getHandler = function (t) {
                                for (let e = 0, n = l.length; e < n; e += 2) {
                                    const n = l[e],
                                        i = l[e + 1];
                                    if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
                                }
                                return null;
                            });
                    }
                })();
            class dl {
                constructor(t) {
                    (this.manager = void 0 !== t ? t : ul),
                        (this.crossOrigin = 'anonymous'),
                        (this.withCredentials = !1),
                        (this.path = ''),
                        (this.resourcePath = ''),
                        (this.requestHeader = {});
                }
                load() {}
                loadAsync(t, e) {
                    const n = this;
                    return new Promise(function (i, r) {
                        n.load(t, i, e, r);
                    });
                }
                parse() {}
                setCrossOrigin(t) {
                    return (this.crossOrigin = t), this;
                }
                setWithCredentials(t) {
                    return (this.withCredentials = t), this;
                }
                setPath(t) {
                    return (this.path = t), this;
                }
                setResourcePath(t) {
                    return (this.resourcePath = t), this;
                }
                setRequestHeader(t) {
                    return (this.requestHeader = t), this;
                }
            }
            const pl = {};
            class ml extends dl {
                constructor(t) {
                    super(t);
                }
                load(t, e, n, i) {
                    void 0 === t && (t = ''),
                        void 0 !== this.path && (t = this.path + t),
                        (t = this.manager.resolveURL(t));
                    const r = this,
                        s = hl.get(t);
                    if (void 0 !== s)
                        return (
                            r.manager.itemStart(t),
                            setTimeout(function () {
                                e && e(s), r.manager.itemEnd(t);
                            }, 0),
                            s
                        );
                    if (void 0 !== pl[t]) return void pl[t].push({ onLoad: e, onProgress: n, onError: i });
                    const a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                    let o;
                    if (a) {
                        const n = a[1],
                            s = !!a[2];
                        let o = a[3];
                        (o = decodeURIComponent(o)), s && (o = atob(o));
                        try {
                            let i;
                            const s = (this.responseType || '').toLowerCase();
                            switch (s) {
                                case 'arraybuffer':
                                case 'blob':
                                    const t = new Uint8Array(o.length);
                                    for (let e = 0; e < o.length; e++) t[e] = o.charCodeAt(e);
                                    i = 'blob' === s ? new Blob([t.buffer], { type: n }) : t.buffer;
                                    break;
                                case 'document':
                                    const e = new DOMParser();
                                    i = e.parseFromString(o, n);
                                    break;
                                case 'json':
                                    i = JSON.parse(o);
                                    break;
                                default:
                                    i = o;
                            }
                            setTimeout(function () {
                                e && e(i), r.manager.itemEnd(t);
                            }, 0);
                        } catch (e) {
                            setTimeout(function () {
                                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
                            }, 0);
                        }
                    } else {
                        (pl[t] = []),
                            pl[t].push({ onLoad: e, onProgress: n, onError: i }),
                            (o = new XMLHttpRequest()),
                            o.open('GET', t, !0),
                            o.addEventListener(
                                'load',
                                function (e) {
                                    const n = this.response,
                                        i = pl[t];
                                    if ((delete pl[t], 200 === this.status || 0 === this.status)) {
                                        0 === this.status && console.warn('THREE.FileLoader: HTTP Status 0 received.'),
                                            hl.add(t, n);
                                        for (let t = 0, e = i.length; t < e; t++) {
                                            const e = i[t];
                                            e.onLoad && e.onLoad(n);
                                        }
                                        r.manager.itemEnd(t);
                                    } else {
                                        for (let t = 0, n = i.length; t < n; t++) {
                                            const n = i[t];
                                            n.onError && n.onError(e);
                                        }
                                        r.manager.itemError(t), r.manager.itemEnd(t);
                                    }
                                },
                                !1,
                            ),
                            o.addEventListener(
                                'progress',
                                function (e) {
                                    const n = pl[t];
                                    for (let t = 0, i = n.length; t < i; t++) {
                                        const i = n[t];
                                        i.onProgress && i.onProgress(e);
                                    }
                                },
                                !1,
                            ),
                            o.addEventListener(
                                'error',
                                function (e) {
                                    const n = pl[t];
                                    delete pl[t];
                                    for (let t = 0, i = n.length; t < i; t++) {
                                        const i = n[t];
                                        i.onError && i.onError(e);
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t);
                                },
                                !1,
                            ),
                            o.addEventListener(
                                'abort',
                                function (e) {
                                    const n = pl[t];
                                    delete pl[t];
                                    for (let t = 0, i = n.length; t < i; t++) {
                                        const i = n[t];
                                        i.onError && i.onError(e);
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t);
                                },
                                !1,
                            ),
                            void 0 !== this.responseType && (o.responseType = this.responseType),
                            void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
                            o.overrideMimeType &&
                                o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain');
                        for (const t in this.requestHeader) o.setRequestHeader(t, this.requestHeader[t]);
                        o.send(null);
                    }
                    return r.manager.itemStart(t), o;
                }
                setResponseType(t) {
                    return (this.responseType = t), this;
                }
                setMimeType(t) {
                    return (this.mimeType = t), this;
                }
            }
            class fl extends dl {
                constructor(t) {
                    super(t);
                }
                load(t, e, n, i) {
                    void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
                    const r = this,
                        s = hl.get(t);
                    if (void 0 !== s)
                        return (
                            r.manager.itemStart(t),
                            setTimeout(function () {
                                e && e(s), r.manager.itemEnd(t);
                            }, 0),
                            s
                        );
                    const a = It('img');
                    function o() {
                        a.removeEventListener('load', o, !1),
                            a.removeEventListener('error', l, !1),
                            hl.add(t, this),
                            e && e(this),
                            r.manager.itemEnd(t);
                    }
                    function l(e) {
                        a.removeEventListener('load', o, !1),
                            a.removeEventListener('error', l, !1),
                            i && i(e),
                            r.manager.itemError(t),
                            r.manager.itemEnd(t);
                    }
                    return (
                        a.addEventListener('load', o, !1),
                        a.addEventListener('error', l, !1),
                        'data:' !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
                        r.manager.itemStart(t),
                        (a.src = t),
                        a
                    );
                }
            }
            class gl extends dl {
                constructor(t) {
                    super(t);
                }
                load(t, e, n, i) {
                    const r = new ti(),
                        s = new fl(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    let a = 0;
                    function o(n) {
                        s.load(
                            t[n],
                            function (t) {
                                (r.images[n] = t), a++, 6 === a && ((r.needsUpdate = !0), e && e(r));
                            },
                            void 0,
                            i,
                        );
                    }
                    for (let e = 0; e < t.length; ++e) o(e);
                    return r;
                }
            }
            class vl extends dl {
                constructor(t) {
                    super(t);
                }
                load(t, e, n, i) {
                    const r = this,
                        s = new xa(),
                        a = new ml(this.manager);
                    return (
                        a.setResponseType('arraybuffer'),
                        a.setRequestHeader(this.requestHeader),
                        a.setPath(this.path),
                        a.setWithCredentials(r.withCredentials),
                        a.load(
                            t,
                            function (t) {
                                const n = r.parse(t);
                                n &&
                                    (void 0 !== n.image
                                        ? (s.image = n.image)
                                        : void 0 !== n.data &&
                                          ((s.image.width = n.width),
                                          (s.image.height = n.height),
                                          (s.image.data = n.data)),
                                    (s.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001),
                                    (s.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001),
                                    (s.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006),
                                    (s.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
                                    (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                                    void 0 !== n.encoding && (s.encoding = n.encoding),
                                    void 0 !== n.flipY && (s.flipY = n.flipY),
                                    void 0 !== n.format && (s.format = n.format),
                                    void 0 !== n.type && (s.type = n.type),
                                    void 0 !== n.mipmaps && ((s.mipmaps = n.mipmaps), (s.minFilter = 1008)),
                                    1 === n.mipmapCount && (s.minFilter = 1006),
                                    void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps),
                                    (s.needsUpdate = !0),
                                    e && e(s, n));
                            },
                            n,
                            i,
                        ),
                        s
                    );
                }
            }
            class yl extends dl {
                constructor(t) {
                    super(t);
                }
                load(t, e, n, i) {
                    const r = new Ot(),
                        s = new fl(this.manager);
                    return (
                        s.setCrossOrigin(this.crossOrigin),
                        s.setPath(this.path),
                        s.load(
                            t,
                            function (t) {
                                (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
                            },
                            n,
                            i,
                        ),
                        r
                    );
                }
            }
            class xl extends We {
                constructor(t, e = 1) {
                    super(), (this.type = 'Light'), (this.color = new un(t)), (this.intensity = e);
                }
                dispose() {}
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), (this.intensity = t.intensity), this;
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                        (e.object.color = this.color.getHex()),
                        (e.object.intensity = this.intensity),
                        void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                        void 0 !== this.distance && (e.object.distance = this.distance),
                        void 0 !== this.angle && (e.object.angle = this.angle),
                        void 0 !== this.decay && (e.object.decay = this.decay),
                        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                        e
                    );
                }
            }
            (xl.prototype.isLight = !0),
                (class extends xl {
                    constructor(t, e, n) {
                        super(t, n),
                            (this.type = 'HemisphereLight'),
                            this.position.copy(We.DefaultUp),
                            this.updateMatrix(),
                            (this.groundColor = new un(e));
                    }
                    copy(t) {
                        return xl.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
                    }
                }.prototype.isHemisphereLight = !0);
            const bl = new xe(),
                wl = new Gt(),
                _l = new Gt();
            class Ml {
                constructor(t) {
                    (this.camera = t),
                        (this.bias = 0),
                        (this.normalBias = 0),
                        (this.radius = 1),
                        (this.blurSamples = 8),
                        (this.mapSize = new Rt(512, 512)),
                        (this.map = null),
                        (this.mapPass = null),
                        (this.matrix = new xe()),
                        (this.autoUpdate = !0),
                        (this.needsUpdate = !1),
                        (this._frustum = new li()),
                        (this._frameExtents = new Rt(1, 1)),
                        (this._viewportCount = 1),
                        (this._viewports = [new kt(0, 0, 1, 1)]);
                }
                getViewportCount() {
                    return this._viewportCount;
                }
                getFrustum() {
                    return this._frustum;
                }
                updateMatrices(t) {
                    const e = this.camera,
                        n = this.matrix;
                    wl.setFromMatrixPosition(t.matrixWorld),
                        e.position.copy(wl),
                        _l.setFromMatrixPosition(t.target.matrixWorld),
                        e.lookAt(_l),
                        e.updateMatrixWorld(),
                        bl.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(bl),
                        n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                        n.multiply(e.projectionMatrix),
                        n.multiply(e.matrixWorldInverse);
                }
                getViewport(t) {
                    return this._viewports[t];
                }
                getFrameExtents() {
                    return this._frameExtents;
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
                }
                copy(t) {
                    return (
                        (this.camera = t.camera.clone()),
                        (this.bias = t.bias),
                        (this.radius = t.radius),
                        this.mapSize.copy(t.mapSize),
                        this
                    );
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                toJSON() {
                    const t = {};
                    return (
                        0 !== this.bias && (t.bias = this.bias),
                        0 !== this.normalBias && (t.normalBias = this.normalBias),
                        1 !== this.radius && (t.radius = this.radius),
                        (512 === this.mapSize.x && 512 === this.mapSize.y) || (t.mapSize = this.mapSize.toArray()),
                        (t.camera = this.camera.toJSON(!1).object),
                        delete t.camera.matrix,
                        t
                    );
                }
            }
            class Sl extends Ml {
                constructor() {
                    super(new Kn(50, 1, 0.5, 500)), (this.focus = 1);
                }
                updateMatrices(t) {
                    const e = this.camera,
                        n = 2 * yt * t.angle * this.focus,
                        i = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    (n === e.fov && i === e.aspect && r === e.far) ||
                        ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
                        super.updateMatrices(t);
                }
                copy(t) {
                    return super.copy(t), (this.focus = t.focus), this;
                }
            }
            Sl.prototype.isSpotLightShadow = !0;
            class Tl extends xl {
                constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
                    super(t, e),
                        (this.type = 'SpotLight'),
                        this.position.copy(We.DefaultUp),
                        this.updateMatrix(),
                        (this.target = new We()),
                        (this.distance = n),
                        (this.angle = i),
                        (this.penumbra = r),
                        (this.decay = s),
                        (this.shadow = new Sl());
                }
                get power() {
                    return this.intensity * Math.PI;
                }
                set power(t) {
                    this.intensity = t / Math.PI;
                }
                dispose() {
                    this.shadow.dispose();
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.distance = t.distance),
                        (this.angle = t.angle),
                        (this.penumbra = t.penumbra),
                        (this.decay = t.decay),
                        (this.target = t.target.clone()),
                        (this.shadow = t.shadow.clone()),
                        this
                    );
                }
            }
            Tl.prototype.isSpotLight = !0;
            const El = new xe(),
                Al = new Gt(),
                Ll = new Gt();
            class Rl extends Ml {
                constructor() {
                    super(new Kn(90, 1, 0.5, 500)),
                        (this._frameExtents = new Rt(4, 2)),
                        (this._viewportCount = 6),
                        (this._viewports = [
                            new kt(2, 1, 1, 1),
                            new kt(0, 1, 1, 1),
                            new kt(3, 1, 1, 1),
                            new kt(1, 1, 1, 1),
                            new kt(3, 0, 1, 1),
                            new kt(1, 0, 1, 1),
                        ]),
                        (this._cubeDirections = [
                            new Gt(1, 0, 0),
                            new Gt(-1, 0, 0),
                            new Gt(0, 0, 1),
                            new Gt(0, 0, -1),
                            new Gt(0, 1, 0),
                            new Gt(0, -1, 0),
                        ]),
                        (this._cubeUps = [
                            new Gt(0, 1, 0),
                            new Gt(0, 1, 0),
                            new Gt(0, 1, 0),
                            new Gt(0, 1, 0),
                            new Gt(0, 0, 1),
                            new Gt(0, 0, -1),
                        ]);
                }
                updateMatrices(t, e = 0) {
                    const n = this.camera,
                        i = this.matrix,
                        r = t.distance || n.far;
                    r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
                        Al.setFromMatrixPosition(t.matrixWorld),
                        n.position.copy(Al),
                        Ll.copy(n.position),
                        Ll.add(this._cubeDirections[e]),
                        n.up.copy(this._cubeUps[e]),
                        n.lookAt(Ll),
                        n.updateMatrixWorld(),
                        i.makeTranslation(-Al.x, -Al.y, -Al.z),
                        El.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(El);
                }
            }
            Rl.prototype.isPointLightShadow = !0;
            class Cl extends xl {
                constructor(t, e, n = 0, i = 1) {
                    super(t, e),
                        (this.type = 'PointLight'),
                        (this.distance = n),
                        (this.decay = i),
                        (this.shadow = new Rl());
                }
                get power() {
                    return 4 * this.intensity * Math.PI;
                }
                set power(t) {
                    this.intensity = t / (4 * Math.PI);
                }
                dispose() {
                    this.shadow.dispose();
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.distance = t.distance),
                        (this.decay = t.decay),
                        (this.shadow = t.shadow.clone()),
                        this
                    );
                }
            }
            Cl.prototype.isPointLight = !0;
            class Pl extends Ml {
                constructor() {
                    super(new wi(-5, 5, 5, -5, 0.5, 500));
                }
            }
            Pl.prototype.isDirectionalLightShadow = !0;
            class Il extends xl {
                constructor(t, e) {
                    super(t, e),
                        (this.type = 'DirectionalLight'),
                        this.position.copy(We.DefaultUp),
                        this.updateMatrix(),
                        (this.target = new We()),
                        (this.shadow = new Pl());
                }
                dispose() {
                    this.shadow.dispose();
                }
                copy(t) {
                    return super.copy(t), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this;
                }
            }
            (Il.prototype.isDirectionalLight = !0),
                (class extends xl {
                    constructor(t, e) {
                        super(t, e), (this.type = 'AmbientLight');
                    }
                }.prototype.isAmbientLight = !0),
                (class extends xl {
                    constructor(t, e, n = 10, i = 10) {
                        super(t, e), (this.type = 'RectAreaLight'), (this.width = n), (this.height = i);
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI;
                    }
                    set power(t) {
                        this.intensity = t / (this.width * this.height * Math.PI);
                    }
                    copy(t) {
                        return super.copy(t), (this.width = t.width), (this.height = t.height), this;
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (e.object.width = this.width), (e.object.height = this.height), e;
                    }
                }.prototype.isRectAreaLight = !0);
            class Dl {
                constructor() {
                    this.coefficients = [];
                    for (let t = 0; t < 9; t++) this.coefficients.push(new Gt());
                }
                set(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this;
                }
                zero() {
                    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this;
                }
                getAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return (
                        e.copy(s[0]).multiplyScalar(0.282095),
                        e.addScaledVector(s[1], 0.488603 * i),
                        e.addScaledVector(s[2], 0.488603 * r),
                        e.addScaledVector(s[3], 0.488603 * n),
                        e.addScaledVector(s[4], n * i * 1.092548),
                        e.addScaledVector(s[5], i * r * 1.092548),
                        e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
                        e.addScaledVector(s[7], n * r * 1.092548),
                        e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
                        e
                    );
                }
                getIrradianceAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return (
                        e.copy(s[0]).multiplyScalar(0.886227),
                        e.addScaledVector(s[1], 1.023328 * i),
                        e.addScaledVector(s[2], 1.023328 * r),
                        e.addScaledVector(s[3], 1.023328 * n),
                        e.addScaledVector(s[4], 0.858086 * n * i),
                        e.addScaledVector(s[5], 0.858086 * i * r),
                        e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
                        e.addScaledVector(s[7], 0.858086 * n * r),
                        e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
                        e
                    );
                }
                add(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this;
                }
                addScaledSH(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                    return this;
                }
                scale(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this;
                }
                lerp(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                    return this;
                }
                equals(t) {
                    for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0;
                }
                copy(t) {
                    return this.set(t.coefficients);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                fromArray(t, e = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                    return this;
                }
                toArray(t = [], e = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                    return t;
                }
                static getBasisAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z;
                    (e[0] = 0.282095),
                        (e[1] = 0.488603 * i),
                        (e[2] = 0.488603 * r),
                        (e[3] = 0.488603 * n),
                        (e[4] = 1.092548 * n * i),
                        (e[5] = 1.092548 * i * r),
                        (e[6] = 0.315392 * (3 * r * r - 1)),
                        (e[7] = 1.092548 * n * r),
                        (e[8] = 0.546274 * (n * n - i * i));
                }
            }
            Dl.prototype.isSphericalHarmonics3 = !0;
            class Nl extends xl {
                constructor(t = new Dl(), e = 1) {
                    super(void 0, e), (this.sh = t);
                }
                copy(t) {
                    return super.copy(t), this.sh.copy(t.sh), this;
                }
                fromJSON(t) {
                    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (e.object.sh = this.sh.toArray()), e;
                }
            }
            Nl.prototype.isLightProbe = !0;
            class Fl {
                static decodeText(t) {
                    if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(t);
                    let e = '';
                    for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                    try {
                        return decodeURIComponent(escape(e));
                    } catch (t) {
                        return e;
                    }
                }
                static extractUrlBase(t) {
                    const e = t.lastIndexOf('/');
                    return -1 === e ? './' : t.substr(0, e + 1);
                }
            }
            (class extends En {
                constructor() {
                    super(), (this.type = 'InstancedBufferGeometry'), (this.instanceCount = 1 / 0);
                }
                copy(t) {
                    return super.copy(t), (this.instanceCount = t.instanceCount), this;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                toJSON() {
                    const t = super.toJSON(this);
                    return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t;
                }
            }.prototype.isInstancedBufferGeometry = !0);
            class Ol extends dl {
                constructor(t) {
                    super(t),
                        'undefined' == typeof createImageBitmap &&
                            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
                        'undefined' == typeof fetch && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
                        (this.options = { premultiplyAlpha: 'none' });
                }
                setOptions(t) {
                    return (this.options = t), this;
                }
                load(t, e, n, i) {
                    void 0 === t && (t = ''),
                        void 0 !== this.path && (t = this.path + t),
                        (t = this.manager.resolveURL(t));
                    const r = this,
                        s = hl.get(t);
                    if (void 0 !== s)
                        return (
                            r.manager.itemStart(t),
                            setTimeout(function () {
                                e && e(s), r.manager.itemEnd(t);
                            }, 0),
                            s
                        );
                    const a = {};
                    (a.credentials = 'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
                        (a.headers = this.requestHeader),
                        fetch(t, a)
                            .then(function (t) {
                                return t.blob();
                            })
                            .then(function (t) {
                                return createImageBitmap(t, Object.assign(r.options, { colorSpaceConversion: 'none' }));
                            })
                            .then(function (n) {
                                hl.add(t, n), e && e(n), r.manager.itemEnd(t);
                            })
                            .catch(function (e) {
                                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
                            }),
                        r.manager.itemStart(t);
                }
            }
            let Ul;
            Ol.prototype.isImageBitmapLoader = !0;
            class kl extends dl {
                constructor(t) {
                    super(t);
                }
                load(t, e, n, i) {
                    const r = this,
                        s = new ml(this.manager);
                    s.setResponseType('arraybuffer'),
                        s.setPath(this.path),
                        s.setRequestHeader(this.requestHeader),
                        s.setWithCredentials(this.withCredentials),
                        s.load(
                            t,
                            function (n) {
                                try {
                                    const t = n.slice(0);
                                    (void 0 === Ul && (Ul = new (window.AudioContext || window.webkitAudioContext)()),
                                    Ul).decodeAudioData(t, function (t) {
                                        e(t);
                                    });
                                } catch (e) {
                                    i ? i(e) : console.error(e), r.manager.itemError(t);
                                }
                            },
                            n,
                            i,
                        );
                }
            }
            ((class extends Nl {
                constructor(t, e, n = 1) {
                    super(void 0, n);
                    const i = new un().set(t),
                        r = new un().set(e),
                        s = new Gt(i.r, i.g, i.b),
                        a = new Gt(r.r, r.g, r.b),
                        o = Math.sqrt(Math.PI),
                        l = o * Math.sqrt(0.75);
                    this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
                        this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);
                }
            }.prototype.isHemisphereLightProbe = !0),
                (class extends Nl {
                    constructor(t, e = 1) {
                        super(void 0, e);
                        const n = new un().set(t);
                        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
                    }
                }.prototype.isAmbientLightProbe = !0));
            class zl {
                constructor(t, e, n) {
                    let i, r, s;
                    switch (((this.binding = t), (this.valueSize = n), e)) {
                        case 'quaternion':
                            (i = this._slerp),
                                (r = this._slerpAdditive),
                                (s = this._setAdditiveIdentityQuaternion),
                                (this.buffer = new Float64Array(6 * n)),
                                (this._workIndex = 5);
                            break;
                        case 'string':
                        case 'bool':
                            (i = this._select),
                                (r = this._select),
                                (s = this._setAdditiveIdentityOther),
                                (this.buffer = new Array(5 * n));
                            break;
                        default:
                            (i = this._lerp),
                                (r = this._lerpAdditive),
                                (s = this._setAdditiveIdentityNumeric),
                                (this.buffer = new Float64Array(5 * n));
                    }
                    (this._mixBufferRegion = i),
                        (this._mixBufferRegionAdditive = r),
                        (this._setIdentity = s),
                        (this._origIndex = 3),
                        (this._addIndex = 4),
                        (this.cumulativeWeight = 0),
                        (this.cumulativeWeightAdditive = 0),
                        (this.useCount = 0),
                        (this.referenceCount = 0);
                }
                accumulate(t, e) {
                    const n = this.buffer,
                        i = this.valueSize,
                        r = t * i + i;
                    let s = this.cumulativeWeight;
                    if (0 === s) {
                        for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                        s = e;
                    } else {
                        s += e;
                        const t = e / s;
                        this._mixBufferRegion(n, r, 0, t, i);
                    }
                    this.cumulativeWeight = s;
                }
                accumulateAdditive(t) {
                    const e = this.buffer,
                        n = this.valueSize,
                        i = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(),
                        this._mixBufferRegionAdditive(e, i, 0, t, n),
                        (this.cumulativeWeightAdditive += t);
                }
                apply(t) {
                    const e = this.valueSize,
                        n = this.buffer,
                        i = t * e + e,
                        r = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        a = this.binding;
                    if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)) {
                        const t = e * this._origIndex;
                        this._mixBufferRegion(n, i, t, 1 - r, e);
                    }
                    s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                    for (let t = e, r = e + e; t !== r; ++t)
                        if (n[t] !== n[t + e]) {
                            a.setValue(n, i);
                            break;
                        }
                }
                saveOriginalState() {
                    const t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        i = n * this._origIndex;
                    t.getValue(e, i);
                    for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
                    this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
                }
                restoreOriginalState() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t);
                }
                _setAdditiveIdentityNumeric() {
                    const t = this._addIndex * this.valueSize,
                        e = t + this.valueSize;
                    for (let n = t; n < e; n++) this.buffer[n] = 0;
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1);
                }
                _setAdditiveIdentityOther() {
                    const t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n];
                }
                _select(t, e, n, i, r) {
                    if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
                }
                _slerp(t, e, n, i) {
                    Ht.slerpFlat(t, e, t, e, t, n, i);
                }
                _slerpAdditive(t, e, n, i, r) {
                    const s = this._workIndex * r;
                    Ht.multiplyQuaternionsFlat(t, s, t, e, t, n), Ht.slerpFlat(t, e, t, e, t, s, i);
                }
                _lerp(t, e, n, i, r) {
                    const s = 1 - i;
                    for (let a = 0; a !== r; ++a) {
                        const r = e + a;
                        t[r] = t[r] * s + t[n + a] * i;
                    }
                }
                _lerpAdditive(t, e, n, i, r) {
                    for (let s = 0; s !== r; ++s) {
                        const r = e + s;
                        t[r] = t[r] + t[n + s] * i;
                    }
                }
            }
            const Bl = new RegExp('[\\[\\]\\.:\\/]', 'g'),
                Hl = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']',
                Gl = /((?:WC+[\/:])*)/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
                Vl = /(WCOD+)?/.source.replace('WCOD', Hl),
                Wl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
                jl = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
                ql = new RegExp('^' + Gl + Vl + Wl + jl + '$'),
                Xl = ['material', 'materials', 'bones'];
            class Yl {
                constructor(t, e, n) {
                    (this.path = e),
                        (this.parsedPath = n || Yl.parseTrackName(e)),
                        (this.node = Yl.findNode(t, this.parsedPath.nodeName) || t),
                        (this.rootNode = t),
                        (this.getValue = this._getValue_unbound),
                        (this.setValue = this._setValue_unbound);
                }
                static create(t, e, n) {
                    return t && t.isAnimationObjectGroup ? new Yl.Composite(t, e, n) : new Yl(t, e, n);
                }
                static sanitizeNodeName(t) {
                    return t.replace(/\s/g, '_').replace(Bl, '');
                }
                static parseTrackName(t) {
                    const e = ql.exec(t);
                    if (!e) throw new Error('PropertyBinding: Cannot parse trackName: ' + t);
                    const n = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6],
                        },
                        i = n.nodeName && n.nodeName.lastIndexOf('.');
                    if (void 0 !== i && -1 !== i) {
                        const t = n.nodeName.substring(i + 1);
                        -1 !== Xl.indexOf(t) && ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length)
                        throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + t);
                    return n;
                }
                static findNode(t, e) {
                    if (!e || '' === e || '.' === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        const n = t.skeleton.getBoneByName(e);
                        if (void 0 !== n) return n;
                    }
                    if (t.children) {
                        const n = function (t) {
                                for (let i = 0; i < t.length; i++) {
                                    const r = t[i];
                                    if (r.name === e || r.uuid === e) return r;
                                    const s = n(r.children);
                                    if (s) return s;
                                }
                                return null;
                            },
                            i = n(t.children);
                        if (i) return i;
                    }
                    return null;
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(t, e) {
                    t[e] = this.targetObject[this.propertyName];
                }
                _getValue_array(t, e) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
                }
                _getValue_arrayElement(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex];
                }
                _getValue_toArray(t, e) {
                    this.resolvedProperty.toArray(t, e);
                }
                _setValue_direct(t, e) {
                    this.targetObject[this.propertyName] = t[e];
                }
                _setValue_direct_setNeedsUpdate(t, e) {
                    (this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0);
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                    (this.targetObject[this.propertyName] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0);
                }
                _setValue_array(t, e) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                }
                _setValue_array_setNeedsUpdate(t, e) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                    this.targetObject.needsUpdate = !0;
                }
                _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0;
                }
                _setValue_arrayElement(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e];
                }
                _setValue_arrayElement_setNeedsUpdate(t, e) {
                    (this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.needsUpdate = !0);
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                    (this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0);
                }
                _setValue_fromArray(t, e) {
                    this.resolvedProperty.fromArray(t, e);
                }
                _setValue_fromArray_setNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0);
                }
                _getValue_unbound(t, e) {
                    this.bind(), this.getValue(t, e);
                }
                _setValue_unbound(t, e) {
                    this.bind(), this.setValue(t, e);
                }
                bind() {
                    let t = this.node;
                    const e = this.parsedPath,
                        n = e.objectName,
                        i = e.propertyName;
                    let r = e.propertyIndex;
                    if (
                        (t || ((t = Yl.findNode(this.rootNode, e.nodeName) || this.rootNode), (this.node = t)),
                        (this.getValue = this._getValue_unavailable),
                        (this.setValue = this._setValue_unavailable),
                        !t)
                    )
                        return void console.error(
                            'THREE.PropertyBinding: Trying to update node for track: ' +
                                this.path +
                                " but it wasn't found.",
                        );
                    if (n) {
                        let i = e.objectIndex;
                        switch (n) {
                            case 'materials':
                                if (!t.material)
                                    return void console.error(
                                        'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                                        this,
                                    );
                                if (!t.material.materials)
                                    return void console.error(
                                        'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                                        this,
                                    );
                                t = t.material.materials;
                                break;
                            case 'bones':
                                if (!t.skeleton)
                                    return void console.error(
                                        'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                                        this,
                                    );
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === i) {
                                        i = e;
                                        break;
                                    }
                                break;
                            default:
                                if (void 0 === t[n])
                                    return void console.error(
                                        'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                                        this,
                                    );
                                t = t[n];
                        }
                        if (void 0 !== i) {
                            if (void 0 === t[i])
                                return void console.error(
                                    'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                                    this,
                                    t,
                                );
                            t = t[i];
                        }
                    }
                    const s = t[i];
                    if (void 0 === s) {
                        const n = e.nodeName;
                        return void console.error(
                            'THREE.PropertyBinding: Trying to update property for track: ' +
                                n +
                                '.' +
                                i +
                                " but it wasn't found.",
                            t,
                        );
                    }
                    let a = this.Versioning.None;
                    (this.targetObject = t),
                        void 0 !== t.needsUpdate
                            ? (a = this.Versioning.NeedsUpdate)
                            : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ('morphTargetInfluences' === i) {
                            if (!t.geometry)
                                return void console.error(
                                    'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                                    this,
                                );
                            if (!t.geometry.isBufferGeometry)
                                return void console.error(
                                    'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
                                    this,
                                );
                            if (!t.geometry.morphAttributes)
                                return void console.error(
                                    'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                                    this,
                                );
                            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
                        }
                        (o = this.BindingType.ArrayElement), (this.resolvedProperty = s), (this.propertyIndex = r);
                    } else
                        void 0 !== s.fromArray && void 0 !== s.toArray
                            ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
                            : Array.isArray(s)
                            ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
                            : (this.propertyName = i);
                    (this.getValue = this.GetterByBindingType[o]),
                        (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
                }
                unbind() {
                    (this.node = null),
                        (this.getValue = this._getValue_unbound),
                        (this.setValue = this._setValue_unbound);
                }
            }
            (Yl.Composite = class {
                constructor(t, e, n) {
                    const i = n || Yl.parseTrackName(e);
                    (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
                }
                getValue(t, e) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(t, e);
                }
                setValue(t, e) {
                    const n = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e);
                }
                bind() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind();
                }
                unbind() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind();
                }
            }),
                (Yl.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }),
                (Yl.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
                (Yl.prototype.GetterByBindingType = [
                    Yl.prototype._getValue_direct,
                    Yl.prototype._getValue_array,
                    Yl.prototype._getValue_arrayElement,
                    Yl.prototype._getValue_toArray,
                ]),
                (Yl.prototype.SetterByBindingTypeAndVersioning = [
                    [
                        Yl.prototype._setValue_direct,
                        Yl.prototype._setValue_direct_setNeedsUpdate,
                        Yl.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
                    ],
                    [
                        Yl.prototype._setValue_array,
                        Yl.prototype._setValue_array_setNeedsUpdate,
                        Yl.prototype._setValue_array_setMatrixWorldNeedsUpdate,
                    ],
                    [
                        Yl.prototype._setValue_arrayElement,
                        Yl.prototype._setValue_arrayElement_setNeedsUpdate,
                        Yl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
                    ],
                    [
                        Yl.prototype._setValue_fromArray,
                        Yl.prototype._setValue_fromArray_setNeedsUpdate,
                        Yl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
                    ],
                ]);
            class Zl {
                constructor(t, e, n = null, i = e.blendMode) {
                    (this._mixer = t), (this._clip = e), (this._localRoot = n), (this.blendMode = i);
                    const r = e.tracks,
                        s = r.length,
                        a = new Array(s),
                        o = { endingStart: 2400, endingEnd: 2400 };
                    for (let t = 0; t !== s; ++t) {
                        const e = r[t].createInterpolant(null);
                        (a[t] = e), (e.settings = o);
                    }
                    (this._interpolantSettings = o),
                        (this._interpolants = a),
                        (this._propertyBindings = new Array(s)),
                        (this._cacheIndex = null),
                        (this._byClipCacheIndex = null),
                        (this._timeScaleInterpolant = null),
                        (this._weightInterpolant = null),
                        (this.loop = 2201),
                        (this._loopCount = -1),
                        (this._startTime = null),
                        (this.time = 0),
                        (this.timeScale = 1),
                        (this._effectiveTimeScale = 1),
                        (this.weight = 1),
                        (this._effectiveWeight = 1),
                        (this.repetitions = 1 / 0),
                        (this.paused = !1),
                        (this.enabled = !0),
                        (this.clampWhenFinished = !1),
                        (this.zeroSlopeAtStart = !0),
                        (this.zeroSlopeAtEnd = !0);
                }
                play() {
                    return this._mixer._activateAction(this), this;
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset();
                }
                reset() {
                    return (
                        (this.paused = !1),
                        (this.enabled = !0),
                        (this.time = 0),
                        (this._loopCount = -1),
                        (this._startTime = null),
                        this.stopFading().stopWarping()
                    );
                }
                isRunning() {
                    return (
                        this.enabled &&
                        !this.paused &&
                        0 !== this.timeScale &&
                        null === this._startTime &&
                        this._mixer._isActiveAction(this)
                    );
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this);
                }
                startAt(t) {
                    return (this._startTime = t), this;
                }
                setLoop(t, e) {
                    return (this.loop = t), (this.repetitions = e), this;
                }
                setEffectiveWeight(t) {
                    return (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading();
                }
                getEffectiveWeight() {
                    return this._effectiveWeight;
                }
                fadeIn(t) {
                    return this._scheduleFading(t, 0, 1);
                }
                fadeOut(t) {
                    return this._scheduleFading(t, 1, 0);
                }
                crossFadeFrom(t, e, n) {
                    if ((t.fadeOut(e), this.fadeIn(e), n)) {
                        const n = this._clip.duration,
                            i = t._clip.duration,
                            r = i / n,
                            s = n / i;
                        t.warp(1, r, e), this.warp(s, 1, e);
                    }
                    return this;
                }
                crossFadeTo(t, e, n) {
                    return t.crossFadeFrom(this, e, n);
                }
                stopFading() {
                    const t = this._weightInterpolant;
                    return (
                        null !== t && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
                        this
                    );
                }
                setEffectiveTimeScale(t) {
                    return (this.timeScale = t), (this._effectiveTimeScale = this.paused ? 0 : t), this.stopWarping();
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale;
                }
                setDuration(t) {
                    return (this.timeScale = this._clip.duration / t), this.stopWarping();
                }
                syncWith(t) {
                    return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping();
                }
                halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t);
                }
                warp(t, e, n) {
                    const i = this._mixer,
                        r = i.time,
                        s = this.timeScale;
                    let a = this._timeScaleInterpolant;
                    null === a && ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
                    const o = a.parameterPositions,
                        l = a.sampleValues;
                    return (o[0] = r), (o[1] = r + n), (l[0] = t / s), (l[1] = e / s), this;
                }
                stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return (
                        null !== t && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
                        this
                    );
                }
                getMixer() {
                    return this._mixer;
                }
                getClip() {
                    return this._clip;
                }
                getRoot() {
                    return this._localRoot || this._mixer._root;
                }
                _update(t, e, n, i) {
                    if (!this.enabled) return void this._updateWeight(t);
                    const r = this._startTime;
                    if (null !== r) {
                        const i = (t - r) * n;
                        if (i < 0 || 0 === n) return;
                        (this._startTime = null), (e = n * i);
                    }
                    e *= this._updateTimeScale(t);
                    const s = this._updateTime(e),
                        a = this._updateWeight(t);
                    if (a > 0) {
                        const t = this._interpolants,
                            e = this._propertyBindings;
                        if (2501 === this.blendMode)
                            for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(a);
                        else for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, a);
                    }
                }
                _updateWeight(t) {
                    let e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        const n = this._weightInterpolant;
                        if (null !== n) {
                            const i = n.evaluate(t)[0];
                            (e *= i),
                                t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1));
                        }
                    }
                    return (this._effectiveWeight = e), e;
                }
                _updateTimeScale(t) {
                    let e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        const n = this._timeScaleInterpolant;
                        null !== n &&
                            ((e *= n.evaluate(t)[0]),
                            t > n.parameterPositions[1] &&
                                (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)));
                    }
                    return (this._effectiveTimeScale = e), e;
                }
                _updateTime(t) {
                    const e = this._clip.duration,
                        n = this.loop;
                    let i = this.time + t,
                        r = this._loopCount;
                    const s = 2202 === n;
                    if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                    if (2200 === n) {
                        -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
                        t: {
                            if (i >= e) i = e;
                            else {
                                if (!(i < 0)) {
                                    this.time = i;
                                    break t;
                                }
                                i = 0;
                            }
                            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                                (this.time = i),
                                this._mixer.dispatchEvent({
                                    type: 'finished',
                                    action: this,
                                    direction: t < 0 ? -1 : 1,
                                });
                        }
                    } else {
                        if (
                            (-1 === r &&
                                (t >= 0
                                    ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                                    : this._setEndings(0 === this.repetitions, !0, s)),
                            i >= e || i < 0)
                        ) {
                            const n = Math.floor(i / e);
                            (i -= e * n), (r += Math.abs(n));
                            const a = this.repetitions - r;
                            if (a <= 0)
                                this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                                    (i = t > 0 ? e : 0),
                                    (this.time = i),
                                    this._mixer.dispatchEvent({
                                        type: 'finished',
                                        action: this,
                                        direction: t > 0 ? 1 : -1,
                                    });
                            else {
                                if (1 === a) {
                                    const e = t < 0;
                                    this._setEndings(e, !e, s);
                                } else this._setEndings(!1, !1, s);
                                (this._loopCount = r),
                                    (this.time = i),
                                    this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: n });
                            }
                        } else this.time = i;
                        if (s && 1 == (1 & r)) return e - i;
                    }
                    return i;
                }
                _setEndings(t, e, n) {
                    const i = this._interpolantSettings;
                    n
                        ? ((i.endingStart = 2401), (i.endingEnd = 2401))
                        : ((i.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : 2400) : 2402),
                          (i.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
                }
                _scheduleFading(t, e, n) {
                    const i = this._mixer,
                        r = i.time;
                    let s = this._weightInterpolant;
                    null === s && ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
                    const a = s.parameterPositions,
                        o = s.sampleValues;
                    return (a[0] = r), (o[0] = e), (a[1] = r + t), (o[1] = n), this;
                }
            }
            class Jl extends ft {
                constructor(t) {
                    super(),
                        (this._root = t),
                        this._initMemoryManager(),
                        (this._accuIndex = 0),
                        (this.time = 0),
                        (this.timeScale = 1);
                }
                _bindAction(t, e) {
                    const n = t._localRoot || this._root,
                        i = t._clip.tracks,
                        r = i.length,
                        s = t._propertyBindings,
                        a = t._interpolants,
                        o = n.uuid,
                        l = this._bindingsByRootAndName;
                    let c = l[o];
                    void 0 === c && ((c = {}), (l[o] = c));
                    for (let t = 0; t !== r; ++t) {
                        const r = i[t],
                            l = r.name;
                        let h = c[l];
                        if (void 0 !== h) s[t] = h;
                        else {
                            if (((h = s[t]), void 0 !== h)) {
                                null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                                continue;
                            }
                            const i = e && e._propertyBindings[t].binding.parsedPath;
                            (h = new zl(Yl.create(n, l, i), r.ValueTypeName, r.getValueSize())),
                                ++h.referenceCount,
                                this._addInactiveBinding(h, o, l),
                                (s[t] = h);
                        }
                        a[t].resultBuffer = h.buffer;
                    }
                }
                _activateAction(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            const e = (t._localRoot || this._root).uuid,
                                n = t._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e);
                        }
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
                        }
                        this._lendAction(t);
                    }
                }
                _deactivateAction(t) {
                    if (this._isActiveAction(t)) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n));
                        }
                        this._takeBackAction(t);
                    }
                }
                _initMemoryManager() {
                    (this._actions = []),
                        (this._nActiveActions = 0),
                        (this._actionsByClip = {}),
                        (this._bindings = []),
                        (this._nActiveBindings = 0),
                        (this._bindingsByRootAndName = {}),
                        (this._controlInterpolants = []),
                        (this._nActiveControlInterpolants = 0);
                    const t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length;
                            },
                            get inUse() {
                                return t._nActiveActions;
                            },
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length;
                            },
                            get inUse() {
                                return t._nActiveBindings;
                            },
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length;
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants;
                            },
                        },
                    };
                }
                _isActiveAction(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions;
                }
                _addInactiveAction(t, e, n) {
                    const i = this._actions,
                        r = this._actionsByClip;
                    let s = r[e];
                    if (void 0 === s)
                        (s = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (r[e] = s);
                    else {
                        const e = s.knownActions;
                        (t._byClipCacheIndex = e.length), e.push(t);
                    }
                    (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);
                }
                _removeInactiveAction(t) {
                    const e = this._actions,
                        n = e[e.length - 1],
                        i = t._cacheIndex;
                    (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
                    const r = t._clip.uuid,
                        s = this._actionsByClip,
                        a = s[r],
                        o = a.knownActions,
                        l = o[o.length - 1],
                        c = t._byClipCacheIndex;
                    (l._byClipCacheIndex = c),
                        (o[c] = l),
                        o.pop(),
                        (t._byClipCacheIndex = null),
                        delete a.actionByRoot[(t._localRoot || this._root).uuid],
                        0 === o.length && delete s[r],
                        this._removeInactiveBindingsForAction(t);
                }
                _removeInactiveBindingsForAction(t) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.referenceCount && this._removeInactiveBinding(n);
                    }
                }
                _lendAction(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        i = this._nActiveActions++,
                        r = e[i];
                    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
                }
                _takeBackAction(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        i = --this._nActiveActions,
                        r = e[i];
                    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
                }
                _addInactiveBinding(t, e, n) {
                    const i = this._bindingsByRootAndName,
                        r = this._bindings;
                    let s = i[e];
                    void 0 === s && ((s = {}), (i[e] = s)), (s[n] = t), (t._cacheIndex = r.length), r.push(t);
                }
                _removeInactiveBinding(t) {
                    const e = this._bindings,
                        n = t.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        s = this._bindingsByRootAndName,
                        a = s[i],
                        o = e[e.length - 1],
                        l = t._cacheIndex;
                    (o._cacheIndex = l), (e[l] = o), e.pop(), delete a[r], 0 === Object.keys(a).length && delete s[i];
                }
                _lendBinding(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        i = this._nActiveBindings++,
                        r = e[i];
                    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
                }
                _takeBackBinding(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        i = --this._nActiveBindings,
                        r = e[i];
                    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
                }
                _lendControlInterpolant() {
                    const t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++;
                    let n = t[e];
                    return (
                        void 0 === n &&
                            ((n = new Ko(
                                new Float32Array(2),
                                new Float32Array(2),
                                1,
                                this._controlInterpolantsResultBuffer,
                            )),
                            (n.__cacheIndex = e),
                            (t[e] = n)),
                        n
                    );
                }
                _takeBackControlInterpolant(t) {
                    const e = this._controlInterpolants,
                        n = t.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = e[i];
                    (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
                }
                clipAction(t, e, n) {
                    const i = e || this._root,
                        r = i.uuid;
                    let s = 'string' == typeof t ? ll.findByName(i, t) : t;
                    const a = null !== s ? s.uuid : t,
                        o = this._actionsByClip[a];
                    let l = null;
                    if ((void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o)) {
                        const t = o.actionByRoot[r];
                        if (void 0 !== t && t.blendMode === n) return t;
                        (l = o.knownActions[0]), null === s && (s = l._clip);
                    }
                    if (null === s) return null;
                    const c = new Zl(this, s, e, n);
                    return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
                }
                existingAction(t, e) {
                    const n = e || this._root,
                        i = n.uuid,
                        r = 'string' == typeof t ? ll.findByName(n, t) : t,
                        s = r ? r.uuid : t,
                        a = this._actionsByClip[s];
                    return (void 0 !== a && a.actionByRoot[i]) || null;
                }
                stopAllAction() {
                    const t = this._actions;
                    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                    return this;
                }
                update(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                        n = this._nActiveActions,
                        i = (this.time += t),
                        r = Math.sign(t),
                        s = (this._accuIndex ^= 1);
                    for (let a = 0; a !== n; ++a) e[a]._update(i, t, r, s);
                    const a = this._bindings,
                        o = this._nActiveBindings;
                    for (let t = 0; t !== o; ++t) a[t].apply(s);
                    return this;
                }
                setTime(t) {
                    this.time = 0;
                    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                    return this.update(t);
                }
                getRoot() {
                    return this._root;
                }
                uncacheClip(t) {
                    const e = this._actions,
                        n = t.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        const t = r.knownActions;
                        for (let n = 0, i = t.length; n !== i; ++n) {
                            const i = t[n];
                            this._deactivateAction(i);
                            const r = i._cacheIndex,
                                s = e[e.length - 1];
                            (i._cacheIndex = null),
                                (i._byClipCacheIndex = null),
                                (s._cacheIndex = r),
                                (e[r] = s),
                                e.pop(),
                                this._removeInactiveBindingsForAction(i);
                        }
                        delete i[n];
                    }
                }
                uncacheRoot(t) {
                    const e = t.uuid,
                        n = this._actionsByClip;
                    for (const t in n) {
                        const i = n[t].actionByRoot[e];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
                    }
                    const i = this._bindingsByRootAndName[e];
                    if (void 0 !== i)
                        for (const t in i) {
                            const e = i[t];
                            e.restoreOriginalState(), this._removeInactiveBinding(e);
                        }
                }
                uncacheAction(t, e) {
                    const n = this.existingAction(t, e);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
                }
            }
            function $l(t, e) {
                return t.distance - e.distance;
            }
            function Kl(t, e, n, i) {
                if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
                    const i = t.children;
                    for (let t = 0, r = i.length; t < r; t++) Kl(i[t], e, n, !0);
                }
            }
            (Jl.prototype._controlInterpolantsResultBuffer = new Float32Array(1)),
                (class extends Ys {
                    constructor(t, e, n = 1) {
                        super(t, e), (this.meshPerAttribute = n);
                    }
                    copy(t) {
                        return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
                    }
                    clone(t) {
                        const e = super.clone(t);
                        return (e.meshPerAttribute = this.meshPerAttribute), e;
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (e.isInstancedInterleavedBuffer = !0), (e.meshPerAttribute = this.meshPerAttribute), e;
                    }
                }.prototype.isInstancedInterleavedBuffer = !0);
            class Ql {
                constructor(t = 1, e = 0, n = 0) {
                    return (this.radius = t), (this.phi = e), (this.theta = n), this;
                }
                set(t, e, n) {
                    return (this.radius = t), (this.phi = e), (this.theta = n), this;
                }
                copy(t) {
                    return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this;
                }
                makeSafe() {
                    const t = 1e-6;
                    return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
                }
                setFromVector3(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z);
                }
                setFromCartesianCoords(t, e, n) {
                    return (
                        (this.radius = Math.sqrt(t * t + e * e + n * n)),
                        0 === this.radius
                            ? ((this.theta = 0), (this.phi = 0))
                            : ((this.theta = Math.atan2(t, n)), (this.phi = Math.acos(_t(e / this.radius, -1, 1)))),
                        this
                    );
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            (class extends We {
                constructor(t) {
                    super(),
                        (this.material = t),
                        (this.render = function () {}),
                        (this.hasPositions = !1),
                        (this.hasNormals = !1),
                        (this.hasColors = !1),
                        (this.hasUvs = !1),
                        (this.positionArray = null),
                        (this.normalArray = null),
                        (this.colorArray = null),
                        (this.uvArray = null),
                        (this.count = 0);
                }
            }.prototype.isImmediateRenderObject = !0);
            const tc = new Gt(),
                ec = new xe(),
                nc = new xe();
            function ic(t) {
                const e = [];
                t && t.isBone && e.push(t);
                for (let n = 0; n < t.children.length; n++) e.push.apply(e, ic(t.children[n]));
                return e;
            }
            const rc = new Float32Array(1),
                sc = new Int32Array(rc.buffer);
            class ac {
                static toHalfFloat(t) {
                    t > 65504 && (console.warn('THREE.DataUtils.toHalfFloat(): value exceeds 65504.'), (t = 65504)),
                        (rc[0] = t);
                    const e = sc[0];
                    let n = (e >> 16) & 32768,
                        i = (e >> 12) & 2047;
                    const r = (e >> 23) & 255;
                    return r < 103
                        ? n
                        : r > 142
                        ? ((n |= 31744), (n |= (255 == r ? 0 : 1) && 8388607 & e), n)
                        : r < 113
                        ? ((i |= 2048), (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)), n)
                        : ((n |= ((r - 112) << 10) | (i >> 1)), (n += 1 & i), n);
                }
            }
            (Xa.create = function (t, e) {
                return (
                    console.log('THREE.Curve.create() has been deprecated'),
                    (t.prototype = Object.create(Xa.prototype)),
                    (t.prototype.constructor = t),
                    (t.prototype.getPoint = e),
                    t
                );
            }),
                (mo.prototype.fromPoints = function (t) {
                    return (
                        console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().'),
                        this.setFromPoints(t)
                    );
                }),
                (class extends Ua {
                    constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
                        (n = new un(n)), (i = new un(i));
                        const r = e / 2,
                            s = t / e,
                            a = t / 2,
                            o = [],
                            l = [];
                        for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {
                            o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                            const e = t === r ? n : i;
                            e.toArray(l, c),
                                (c += 3),
                                e.toArray(l, c),
                                (c += 3),
                                e.toArray(l, c),
                                (c += 3),
                                e.toArray(l, c),
                                (c += 3);
                        }
                        const c = new En();
                        c.setAttribute('position', new yn(o, 3)),
                            c.setAttribute('color', new yn(l, 3)),
                            super(c, new La({ vertexColors: !0, toneMapped: !1 })),
                            (this.type = 'GridHelper');
                    }
                }.prototype.setColors = function () {
                    console.error(
                        'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.',
                    );
                }),
                (class extends Ua {
                    constructor(t) {
                        const e = ic(t),
                            n = new En(),
                            i = [],
                            r = [],
                            s = new un(0, 0, 1),
                            a = new un(0, 1, 0);
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            n.parent &&
                                n.parent.isBone &&
                                (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
                        }
                        n.setAttribute('position', new yn(i, 3)),
                            n.setAttribute('color', new yn(r, 3)),
                            super(
                                n,
                                new La({
                                    vertexColors: !0,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    toneMapped: !1,
                                    transparent: !0,
                                }),
                            ),
                            (this.type = 'SkeletonHelper'),
                            (this.isSkeletonHelper = !0),
                            (this.root = t),
                            (this.bones = e),
                            (this.matrix = t.matrixWorld),
                            (this.matrixAutoUpdate = !1);
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones,
                            n = this.geometry,
                            i = n.getAttribute('position');
                        nc.copy(this.root.matrixWorld).invert();
                        for (let t = 0, n = 0; t < e.length; t++) {
                            const r = e[t];
                            r.parent &&
                                r.parent.isBone &&
                                (ec.multiplyMatrices(nc, r.matrixWorld),
                                tc.setFromMatrixPosition(ec),
                                i.setXYZ(n, tc.x, tc.y, tc.z),
                                ec.multiplyMatrices(nc, r.parent.matrixWorld),
                                tc.setFromMatrixPosition(ec),
                                i.setXYZ(n + 1, tc.x, tc.y, tc.z),
                                (n += 2));
                        }
                        (n.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(t);
                    }
                }.prototype.update = function () {
                    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
                }),
                (dl.prototype.extractUrlBase = function (t) {
                    return (
                        console.warn(
                            'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.',
                        ),
                        Fl.extractUrlBase(t)
                    );
                }),
                (dl.Handlers = {
                    add: function () {
                        console.error(
                            'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.',
                        );
                    },
                    get: function () {
                        console.error(
                            'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.',
                        );
                    },
                }),
                (jt.prototype.center = function (t) {
                    return console.warn('THREE.Box3: .center() has been renamed to .getCenter().'), this.getCenter(t);
                }),
                (jt.prototype.empty = function () {
                    return console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'), this.isEmpty();
                }),
                (jt.prototype.isIntersectionBox = function (t) {
                    return (
                        console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().'),
                        this.intersectsBox(t)
                    );
                }),
                (jt.prototype.isIntersectionSphere = function (t) {
                    return (
                        console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
                        this.intersectsSphere(t)
                    );
                }),
                (jt.prototype.size = function (t) {
                    return console.warn('THREE.Box3: .size() has been renamed to .getSize().'), this.getSize(t);
                }),
                (he.prototype.empty = function () {
                    return console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().'), this.isEmpty();
                }),
                (li.prototype.setFromMatrix = function (t) {
                    return (
                        console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().'),
                        this.setFromProjectionMatrix(t)
                    );
                }),
                (Ct.prototype.flattenToArrayOffset = function (t, e) {
                    return (
                        console.warn(
                            'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
                        ),
                        this.toArray(t, e)
                    );
                }),
                (Ct.prototype.multiplyVector3 = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.',
                        ),
                        t.applyMatrix3(this)
                    );
                }),
                (Ct.prototype.multiplyVector3Array = function () {
                    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
                }),
                (Ct.prototype.applyToBufferAttribute = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.',
                        ),
                        t.applyMatrix3(this)
                    );
                }),
                (Ct.prototype.applyToVector3Array = function () {
                    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
                }),
                (Ct.prototype.getInverse = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',
                        ),
                        this.copy(t).invert()
                    );
                }),
                (xe.prototype.extractPosition = function (t) {
                    return (
                        console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().'),
                        this.copyPosition(t)
                    );
                }),
                (xe.prototype.flattenToArrayOffset = function (t, e) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
                        ),
                        this.toArray(t, e)
                    );
                }),
                (xe.prototype.getPosition = function () {
                    return (
                        console.warn(
                            'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.',
                        ),
                        new Gt().setFromMatrixColumn(this, 3)
                    );
                }),
                (xe.prototype.setRotationFromQuaternion = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().',
                        ),
                        this.makeRotationFromQuaternion(t)
                    );
                }),
                (xe.prototype.multiplyToArray = function () {
                    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
                }),
                (xe.prototype.multiplyVector3 = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.',
                        ),
                        t.applyMatrix4(this)
                    );
                }),
                (xe.prototype.multiplyVector4 = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.',
                        ),
                        t.applyMatrix4(this)
                    );
                }),
                (xe.prototype.multiplyVector3Array = function () {
                    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
                }),
                (xe.prototype.rotateAxis = function (t) {
                    console.warn(
                        'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.',
                    ),
                        t.transformDirection(this);
                }),
                (xe.prototype.crossVector = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.',
                        ),
                        t.applyMatrix4(this)
                    );
                }),
                (xe.prototype.translate = function () {
                    console.error('THREE.Matrix4: .translate() has been removed.');
                }),
                (xe.prototype.rotateX = function () {
                    console.error('THREE.Matrix4: .rotateX() has been removed.');
                }),
                (xe.prototype.rotateY = function () {
                    console.error('THREE.Matrix4: .rotateY() has been removed.');
                }),
                (xe.prototype.rotateZ = function () {
                    console.error('THREE.Matrix4: .rotateZ() has been removed.');
                }),
                (xe.prototype.rotateByAxis = function () {
                    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
                }),
                (xe.prototype.applyToBufferAttribute = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.',
                        ),
                        t.applyMatrix4(this)
                    );
                }),
                (xe.prototype.applyToVector3Array = function () {
                    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
                }),
                (xe.prototype.makeFrustum = function (t, e, n, i, r, s) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.',
                        ),
                        this.makePerspective(t, e, i, n, r, s)
                    );
                }),
                (xe.prototype.getInverse = function (t) {
                    return (
                        console.warn(
                            'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',
                        ),
                        this.copy(t).invert()
                    );
                }),
                (si.prototype.isIntersectionLine = function (t) {
                    return (
                        console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().'),
                        this.intersectsLine(t)
                    );
                }),
                (Ht.prototype.multiplyVector3 = function (t) {
                    return (
                        console.warn(
                            'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',
                        ),
                        t.applyQuaternion(this)
                    );
                }),
                (Ht.prototype.inverse = function () {
                    return console.warn('THREE.Quaternion: .inverse() has been renamed to invert().'), this.invert();
                }),
                (ye.prototype.isIntersectionBox = function (t) {
                    return (
                        console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'),
                        this.intersectsBox(t)
                    );
                }),
                (ye.prototype.isIntersectionPlane = function (t) {
                    return (
                        console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().'),
                        this.intersectsPlane(t)
                    );
                }),
                (ye.prototype.isIntersectionSphere = function (t) {
                    return (
                        console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
                        this.intersectsSphere(t)
                    );
                }),
                (en.prototype.area = function () {
                    return console.warn('THREE.Triangle: .area() has been renamed to .getArea().'), this.getArea();
                }),
                (en.prototype.barycoordFromPoint = function (t, e) {
                    return (
                        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'),
                        this.getBarycoord(t, e)
                    );
                }),
                (en.prototype.midpoint = function (t) {
                    return (
                        console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().'),
                        this.getMidpoint(t)
                    );
                }),
                (en.prototypenormal = function (t) {
                    return (
                        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'), this.getNormal(t)
                    );
                }),
                (en.prototype.plane = function (t) {
                    return console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().'), this.getPlane(t);
                }),
                (en.barycoordFromPoint = function (t, e, n, i, r) {
                    return (
                        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'),
                        en.getBarycoord(t, e, n, i, r)
                    );
                }),
                (en.normal = function (t, e, n, i) {
                    return (
                        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'),
                        en.getNormal(t, e, n, i)
                    );
                }),
                (fo.prototype.extractAllPoints = function (t) {
                    return (
                        console.warn(
                            'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.',
                        ),
                        this.extractPoints(t)
                    );
                }),
                (fo.prototype.extrude = function (t) {
                    return (
                        console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.'),
                        new Vo(this, t)
                    );
                }),
                (fo.prototype.makeGeometry = function (t) {
                    return (
                        console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.'),
                        new jo(this, t)
                    );
                }),
                (Rt.prototype.fromAttribute = function (t, e, n) {
                    return (
                        console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().'),
                        this.fromBufferAttribute(t, e, n)
                    );
                }),
                (Rt.prototype.distanceToManhattan = function (t) {
                    return (
                        console.warn(
                            'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
                        ),
                        this.manhattanDistanceTo(t)
                    );
                }),
                (Rt.prototype.lengthManhattan = function () {
                    return (
                        console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().'),
                        this.manhattanLength()
                    );
                }),
                (Gt.prototype.setEulerFromRotationMatrix = function () {
                    console.error(
                        'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.',
                    );
                }),
                (Gt.prototype.setEulerFromQuaternion = function () {
                    console.error(
                        'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.',
                    );
                }),
                (Gt.prototype.getPositionFromMatrix = function (t) {
                    return (
                        console.warn(
                            'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().',
                        ),
                        this.setFromMatrixPosition(t)
                    );
                }),
                (Gt.prototype.getScaleFromMatrix = function (t) {
                    return (
                        console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().'),
                        this.setFromMatrixScale(t)
                    );
                }),
                (Gt.prototype.getColumnFromMatrix = function (t, e) {
                    return (
                        console.warn(
                            'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().',
                        ),
                        this.setFromMatrixColumn(e, t)
                    );
                }),
                (Gt.prototype.applyProjection = function (t) {
                    return (
                        console.warn(
                            'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.',
                        ),
                        this.applyMatrix4(t)
                    );
                }),
                (Gt.prototype.fromAttribute = function (t, e, n) {
                    return (
                        console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().'),
                        this.fromBufferAttribute(t, e, n)
                    );
                }),
                (Gt.prototype.distanceToManhattan = function (t) {
                    return (
                        console.warn(
                            'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
                        ),
                        this.manhattanDistanceTo(t)
                    );
                }),
                (Gt.prototype.lengthManhattan = function () {
                    return (
                        console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().'),
                        this.manhattanLength()
                    );
                }),
                (kt.prototype.fromAttribute = function (t, e, n) {
                    return (
                        console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().'),
                        this.fromBufferAttribute(t, e, n)
                    );
                }),
                (kt.prototype.lengthManhattan = function () {
                    return (
                        console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().'),
                        this.manhattanLength()
                    );
                }),
                (We.prototype.getChildByName = function (t) {
                    return (
                        console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().'),
                        this.getObjectByName(t)
                    );
                }),
                (We.prototype.renderDepth = function () {
                    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
                }),
                (We.prototype.translate = function (t, e) {
                    return (
                        console.warn(
                            'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.',
                        ),
                        this.translateOnAxis(e, t)
                    );
                }),
                (We.prototype.getWorldRotation = function () {
                    console.error(
                        'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.',
                    );
                }),
                (We.prototype.applyMatrix = function (t) {
                    return (
                        console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().'),
                        this.applyMatrix4(t)
                    );
                }),
                Object.defineProperties(We.prototype, {
                    eulerOrder: {
                        get: function () {
                            return (
                                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'), this.rotation.order
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
                                (this.rotation.order = t);
                        },
                    },
                    useQuaternion: {
                        get: function () {
                            console.warn(
                                'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
                            );
                        },
                        set: function () {
                            console.warn(
                                'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
                            );
                        },
                    },
                }),
                (Wn.prototype.setDrawMode = function () {
                    console.error(
                        'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
                    );
                }),
                Object.defineProperties(Wn.prototype, {
                    drawMode: {
                        get: function () {
                            return (
                                console.error(
                                    'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.',
                                ),
                                0
                            );
                        },
                        set: function () {
                            console.error(
                                'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
                            );
                        },
                    },
                }),
                (va.prototype.initBones = function () {
                    console.error('THREE.SkinnedMesh: initBones() has been removed.');
                }),
                (Kn.prototype.setLens = function (t, e) {
                    console.warn(
                        'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.',
                    ),
                        void 0 !== e && (this.filmGauge = e),
                        this.setFocalLength(t);
                }),
                Object.defineProperties(xl.prototype, {
                    onlyShadow: {
                        set: function () {
                            console.warn('THREE.Light: .onlyShadow has been removed.');
                        },
                    },
                    shadowCameraFov: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'),
                                (this.shadow.camera.fov = t);
                        },
                    },
                    shadowCameraLeft: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'),
                                (this.shadow.camera.left = t);
                        },
                    },
                    shadowCameraRight: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.'),
                                (this.shadow.camera.right = t);
                        },
                    },
                    shadowCameraTop: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.'),
                                (this.shadow.camera.top = t);
                        },
                    },
                    shadowCameraBottom: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'),
                                (this.shadow.camera.bottom = t);
                        },
                    },
                    shadowCameraNear: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.'),
                                (this.shadow.camera.near = t);
                        },
                    },
                    shadowCameraFar: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.'),
                                (this.shadow.camera.far = t);
                        },
                    },
                    shadowCameraVisible: {
                        set: function () {
                            console.warn(
                                'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.',
                            );
                        },
                    },
                    shadowBias: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowBias is now .shadow.bias.'), (this.shadow.bias = t);
                        },
                    },
                    shadowDarkness: {
                        set: function () {
                            console.warn('THREE.Light: .shadowDarkness has been removed.');
                        },
                    },
                    shadowMapWidth: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'),
                                (this.shadow.mapSize.width = t);
                        },
                    },
                    shadowMapHeight: {
                        set: function (t) {
                            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'),
                                (this.shadow.mapSize.height = t);
                        },
                    },
                }),
                Object.defineProperties(fn.prototype, {
                    length: {
                        get: function () {
                            return (
                                console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.'),
                                this.array.length
                            );
                        },
                    },
                    dynamic: {
                        get: function () {
                            return (
                                console.warn(
                                    'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
                                ),
                                35048 === this.usage
                            );
                        },
                        set: function () {
                            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'),
                                this.setUsage(35048);
                        },
                    },
                }),
                (fn.prototype.setDynamic = function (t) {
                    return (
                        console.warn(
                            'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.',
                        ),
                        this.setUsage(!0 === t ? 35048 : 35044),
                        this
                    );
                }),
                (fn.prototype.copyIndicesArray = function () {
                    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
                }),
                (fn.prototype.setArray = function () {
                    console.error(
                        'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
                    );
                }),
                (En.prototype.addIndex = function (t) {
                    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'),
                        this.setIndex(t);
                }),
                (En.prototype.addAttribute = function (t, e) {
                    return (
                        console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().'),
                        (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
                            ? 'index' === t
                                ? (console.warn(
                                      'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.',
                                  ),
                                  this.setIndex(e),
                                  this)
                                : this.setAttribute(t, e)
                            : (console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'),
                              this.setAttribute(t, new fn(arguments[1], arguments[2])))
                    );
                }),
                (En.prototype.addDrawCall = function (t, e, n) {
                    void 0 !== n &&
                        console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'),
                        console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().'),
                        this.addGroup(t, e);
                }),
                (En.prototype.clearDrawCalls = function () {
                    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'), this.clearGroups();
                }),
                (En.prototype.computeOffsets = function () {
                    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
                }),
                (En.prototype.removeAttribute = function (t) {
                    return (
                        console.warn(
                            'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().',
                        ),
                        this.deleteAttribute(t)
                    );
                }),
                (En.prototype.applyMatrix = function (t) {
                    return (
                        console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().'),
                        this.applyMatrix4(t)
                    );
                }),
                Object.defineProperties(En.prototype, {
                    drawcalls: {
                        get: function () {
                            return (
                                console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.'),
                                this.groups
                            );
                        },
                    },
                    offsets: {
                        get: function () {
                            return (
                                console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.'), this.groups
                            );
                        },
                    },
                }),
                (Ys.prototype.setDynamic = function (t) {
                    return (
                        console.warn(
                            'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.',
                        ),
                        this.setUsage(!0 === t ? 35048 : 35044),
                        this
                    );
                }),
                (Ys.prototype.setArray = function () {
                    console.error(
                        'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
                    );
                }),
                (Vo.prototype.getArrays = function () {
                    console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
                }),
                (Vo.prototype.addShapeList = function () {
                    console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
                }),
                (Vo.prototype.addShape = function () {
                    console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
                }),
                (Xs.prototype.dispose = function () {
                    console.error('THREE.Scene: .dispose() has been removed.');
                }),
                Object.defineProperties(rn.prototype, {
                    wrapAround: {
                        get: function () {
                            console.warn('THREE.Material: .wrapAround has been removed.');
                        },
                        set: function () {
                            console.warn('THREE.Material: .wrapAround has been removed.');
                        },
                    },
                    overdraw: {
                        get: function () {
                            console.warn('THREE.Material: .overdraw has been removed.');
                        },
                        set: function () {
                            console.warn('THREE.Material: .overdraw has been removed.');
                        },
                    },
                    wrapRGB: {
                        get: function () {
                            return console.warn('THREE.Material: .wrapRGB has been removed.'), new un();
                        },
                    },
                    shading: {
                        get: function () {
                            console.error(
                                'THREE.' +
                                    this.type +
                                    ': .shading has been removed. Use the boolean .flatShading instead.',
                            );
                        },
                        set: function (t) {
                            console.warn(
                                'THREE.' +
                                    this.type +
                                    ': .shading has been removed. Use the boolean .flatShading instead.',
                            ),
                                (this.flatShading = 1 === t);
                        },
                    },
                    stencilMask: {
                        get: function () {
                            return (
                                console.warn(
                                    'THREE.' +
                                        this.type +
                                        ': .stencilMask has been removed. Use .stencilFuncMask instead.',
                                ),
                                this.stencilFuncMask
                            );
                        },
                        set: function (t) {
                            console.warn(
                                'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.',
                            ),
                                (this.stencilFuncMask = t);
                        },
                    },
                    vertexTangents: {
                        get: function () {
                            console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
                        },
                        set: function () {
                            console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
                        },
                    },
                }),
                Object.defineProperties(Jn.prototype, {
                    derivatives: {
                        get: function () {
                            return (
                                console.warn(
                                    'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                                ),
                                this.extensions.derivatives
                            );
                        },
                        set: function (t) {
                            console.warn(
                                'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                            ),
                                (this.extensions.derivatives = t);
                        },
                    },
                }),
                (qs.prototype.clearTarget = function (t, e, n, i) {
                    console.warn(
                        'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.',
                    ),
                        this.setRenderTarget(t),
                        this.clear(e, n, i);
                }),
                (qs.prototype.animate = function (t) {
                    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().'),
                        this.setAnimationLoop(t);
                }),
                (qs.prototype.getCurrentRenderTarget = function () {
                    return (
                        console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().'),
                        this.getRenderTarget()
                    );
                }),
                (qs.prototype.getMaxAnisotropy = function () {
                    return (
                        console.warn(
                            'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().',
                        ),
                        this.capabilities.getMaxAnisotropy()
                    );
                }),
                (qs.prototype.getPrecision = function () {
                    return (
                        console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'),
                        this.capabilities.precision
                    );
                }),
                (qs.prototype.resetGLState = function () {
                    return (
                        console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().'), this.state.reset()
                    );
                }),
                (qs.prototype.supportsFloatTextures = function () {
                    return (
                        console.warn(
                            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).",
                        ),
                        this.extensions.get('OES_texture_float')
                    );
                }),
                (qs.prototype.supportsHalfFloatTextures = function () {
                    return (
                        console.warn(
                            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).",
                        ),
                        this.extensions.get('OES_texture_half_float')
                    );
                }),
                (qs.prototype.supportsStandardDerivatives = function () {
                    return (
                        console.warn(
                            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).",
                        ),
                        this.extensions.get('OES_standard_derivatives')
                    );
                }),
                (qs.prototype.supportsCompressedTextureS3TC = function () {
                    return (
                        console.warn(
                            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).",
                        ),
                        this.extensions.get('WEBGL_compressed_texture_s3tc')
                    );
                }),
                (qs.prototype.supportsCompressedTexturePVRTC = function () {
                    return (
                        console.warn(
                            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).",
                        ),
                        this.extensions.get('WEBGL_compressed_texture_pvrtc')
                    );
                }),
                (qs.prototype.supportsBlendMinMax = function () {
                    return (
                        console.warn(
                            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).",
                        ),
                        this.extensions.get('EXT_blend_minmax')
                    );
                }),
                (qs.prototype.supportsVertexTextures = function () {
                    return (
                        console.warn(
                            'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.',
                        ),
                        this.capabilities.vertexTextures
                    );
                }),
                (qs.prototype.supportsInstancedArrays = function () {
                    return (
                        console.warn(
                            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).",
                        ),
                        this.extensions.get('ANGLE_instanced_arrays')
                    );
                }),
                (qs.prototype.enableScissorTest = function (t) {
                    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'),
                        this.setScissorTest(t);
                }),
                (qs.prototype.initMaterial = function () {
                    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
                }),
                (qs.prototype.addPrePlugin = function () {
                    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
                }),
                (qs.prototype.addPostPlugin = function () {
                    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
                }),
                (qs.prototype.updateShadowMap = function () {
                    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
                }),
                (qs.prototype.setFaceCulling = function () {
                    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
                }),
                (qs.prototype.allocTextureUnit = function () {
                    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
                }),
                (qs.prototype.setTexture = function () {
                    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
                }),
                (qs.prototype.setTexture2D = function () {
                    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
                }),
                (qs.prototype.setTextureCube = function () {
                    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
                }),
                (qs.prototype.getActiveMipMapLevel = function () {
                    return (
                        console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().'),
                        this.getActiveMipmapLevel()
                    );
                }),
                Object.defineProperties(qs.prototype, {
                    shadowMapEnabled: {
                        get: function () {
                            return this.shadowMap.enabled;
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'),
                                (this.shadowMap.enabled = t);
                        },
                    },
                    shadowMapType: {
                        get: function () {
                            return this.shadowMap.type;
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'),
                                (this.shadowMap.type = t);
                        },
                    },
                    shadowMapCullFace: {
                        get: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
                            );
                        },
                        set: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
                            );
                        },
                    },
                    context: {
                        get: function () {
                            return (
                                console.warn(
                                    'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.',
                                ),
                                this.getContext()
                            );
                        },
                    },
                    vr: {
                        get: function () {
                            return console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr'), this.xr;
                        },
                    },
                    gammaInput: {
                        get: function () {
                            return (
                                console.warn(
                                    'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
                                ),
                                !1
                            );
                        },
                        set: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
                            );
                        },
                    },
                    gammaOutput: {
                        get: function () {
                            return (
                                console.warn(
                                    'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
                                ),
                                !1
                            );
                        },
                        set: function (t) {
                            console.warn(
                                'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
                            ),
                                (this.outputEncoding = !0 === t ? 3001 : 3e3);
                        },
                    },
                    toneMappingWhitePoint: {
                        get: function () {
                            return console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.'), 1;
                        },
                        set: function () {
                            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
                        },
                    },
                }),
                Object.defineProperties(Os.prototype, {
                    cullFace: {
                        get: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
                            );
                        },
                        set: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
                            );
                        },
                    },
                    renderReverseSided: {
                        get: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
                            );
                        },
                        set: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
                            );
                        },
                    },
                    renderSingleSided: {
                        get: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
                            );
                        },
                        set: function () {
                            console.warn(
                                'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
                            );
                        },
                    },
                }),
                Object.defineProperties(zt.prototype, {
                    wrapS: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'),
                                this.texture.wrapS
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'),
                                (this.texture.wrapS = t);
                        },
                    },
                    wrapT: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'),
                                this.texture.wrapT
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'),
                                (this.texture.wrapT = t);
                        },
                    },
                    magFilter: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
                                this.texture.magFilter
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
                                (this.texture.magFilter = t);
                        },
                    },
                    minFilter: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
                                this.texture.minFilter
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
                                (this.texture.minFilter = t);
                        },
                    },
                    anisotropy: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
                                this.texture.anisotropy
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
                                (this.texture.anisotropy = t);
                        },
                    },
                    offset: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
                                this.texture.offset
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
                                (this.texture.offset = t);
                        },
                    },
                    repeat: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
                                this.texture.repeat
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
                                (this.texture.repeat = t);
                        },
                    },
                    format: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
                                this.texture.format
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
                                (this.texture.format = t);
                        },
                    },
                    type: {
                        get: function () {
                            return (
                                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'), this.texture.type
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
                                (this.texture.type = t);
                        },
                    },
                    generateMipmaps: {
                        get: function () {
                            return (
                                console.warn(
                                    'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
                                ),
                                this.texture.generateMipmaps
                            );
                        },
                        set: function (t) {
                            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'),
                                (this.texture.generateMipmaps = t);
                        },
                    },
                }),
                (class extends We {
                    constructor(t) {
                        super(),
                            (this.type = 'Audio'),
                            (this.listener = t),
                            (this.context = t.context),
                            (this.gain = this.context.createGain()),
                            this.gain.connect(t.getInput()),
                            (this.autoplay = !1),
                            (this.buffer = null),
                            (this.detune = 0),
                            (this.loop = !1),
                            (this.loopStart = 0),
                            (this.loopEnd = 0),
                            (this.offset = 0),
                            (this.duration = void 0),
                            (this.playbackRate = 1),
                            (this.isPlaying = !1),
                            (this.hasPlaybackControl = !0),
                            (this.source = null),
                            (this.sourceType = 'empty'),
                            (this._startedAt = 0),
                            (this._progress = 0),
                            (this._connected = !1),
                            (this.filters = []);
                    }
                    getOutput() {
                        return this.gain;
                    }
                    setNodeSource(t) {
                        return (
                            (this.hasPlaybackControl = !1),
                            (this.sourceType = 'audioNode'),
                            (this.source = t),
                            this.connect(),
                            this
                        );
                    }
                    setMediaElementSource(t) {
                        return (
                            (this.hasPlaybackControl = !1),
                            (this.sourceType = 'mediaNode'),
                            (this.source = this.context.createMediaElementSource(t)),
                            this.connect(),
                            this
                        );
                    }
                    setMediaStreamSource(t) {
                        return (
                            (this.hasPlaybackControl = !1),
                            (this.sourceType = 'mediaStreamNode'),
                            (this.source = this.context.createMediaStreamSource(t)),
                            this.connect(),
                            this
                        );
                    }
                    setBuffer(t) {
                        return (this.buffer = t), (this.sourceType = 'buffer'), this.autoplay && this.play(), this;
                    }
                    play(t = 0) {
                        if (!0 === this.isPlaying) return void console.warn('THREE.Audio: Audio is already playing.');
                        if (!1 === this.hasPlaybackControl)
                            return void console.warn('THREE.Audio: this Audio has no playback control.');
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return (
                            (e.buffer = this.buffer),
                            (e.loop = this.loop),
                            (e.loopStart = this.loopStart),
                            (e.loopEnd = this.loopEnd),
                            (e.onended = this.onEnded.bind(this)),
                            e.start(this._startedAt, this._progress + this.offset, this.duration),
                            (this.isPlaying = !0),
                            (this.source = e),
                            this.setDetune(this.detune),
                            this.setPlaybackRate(this.playbackRate),
                            this.connect()
                        );
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl)
                            return (
                                !0 === this.isPlaying &&
                                    ((this._progress +=
                                        Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
                                    !0 === this.loop &&
                                        (this._progress = this._progress % (this.duration || this.buffer.duration)),
                                    this.source.stop(),
                                    (this.source.onended = null),
                                    (this.isPlaying = !1)),
                                this
                            );
                        console.warn('THREE.Audio: this Audio has no playback control.');
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl)
                            return (
                                (this._progress = 0),
                                this.source.stop(),
                                (this.source.onended = null),
                                (this.isPlaying = !1),
                                this
                            );
                        console.warn('THREE.Audio: this Audio has no playback control.');
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++)
                                this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput());
                        } else this.source.connect(this.getOutput());
                        return (this._connected = !0), this;
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++)
                                this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput());
                        } else this.source.disconnect(this.getOutput());
                        return (this._connected = !1), this;
                    }
                    getFilters() {
                        return this.filters;
                    }
                    setFilters(t) {
                        return (
                            t || (t = []),
                            !0 === this._connected
                                ? (this.disconnect(), (this.filters = t.slice()), this.connect())
                                : (this.filters = t.slice()),
                            this
                        );
                    }
                    setDetune(t) {
                        if (((this.detune = t), void 0 !== this.source.detune))
                            return (
                                !0 === this.isPlaying &&
                                    this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
                                this
                            );
                    }
                    getDetune() {
                        return this.detune;
                    }
                    getFilter() {
                        return this.getFilters()[0];
                    }
                    setFilter(t) {
                        return this.setFilters(t ? [t] : []);
                    }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl)
                            return (
                                (this.playbackRate = t),
                                !0 === this.isPlaying &&
                                    this.source.playbackRate.setTargetAtTime(
                                        this.playbackRate,
                                        this.context.currentTime,
                                        0.01,
                                    ),
                                this
                            );
                        console.warn('THREE.Audio: this Audio has no playback control.');
                    }
                    getPlaybackRate() {
                        return this.playbackRate;
                    }
                    onEnded() {
                        this.isPlaying = !1;
                    }
                    getLoop() {
                        return !1 === this.hasPlaybackControl
                            ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
                            : this.loop;
                    }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl)
                            return (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn('THREE.Audio: this Audio has no playback control.');
                    }
                    setLoopStart(t) {
                        return (this.loopStart = t), this;
                    }
                    setLoopEnd(t) {
                        return (this.loopEnd = t), this;
                    }
                    getVolume() {
                        return this.gain.gain.value;
                    }
                    setVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
                    }
                }.prototype.load = function (t) {
                    console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
                    const e = this;
                    return (
                        new kl().load(t, function (t) {
                            e.setBuffer(t);
                        }),
                        this
                    );
                }),
                (Qn.prototype.updateCubeMap = function (t, e) {
                    return console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'), this.update(t, e);
                }),
                (Qn.prototype.clear = function (t, e, n, i) {
                    return (
                        console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().'),
                        this.renderTarget.clear(t, e, n, i)
                    );
                }),
                (Nt.crossOrigin = void 0),
                (Nt.loadTexture = function (t, e, n, i) {
                    console.warn(
                        'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.',
                    );
                    const r = new yl();
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s;
                }),
                (Nt.loadTextureCube = function (t, e, n, i) {
                    console.warn(
                        'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.',
                    );
                    const r = new gl();
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s;
                }),
                (Nt.loadCompressedTexture = function () {
                    console.error(
                        'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.',
                    );
                }),
                (Nt.loadCompressedTextureCube = function () {
                    console.error(
                        'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.',
                    );
                }),
                'undefined' != typeof __THREE_DEVTOOLS__ &&
                    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: '133' } })),
                'undefined' != typeof window &&
                    (window.__THREE__
                        ? console.warn('WARNING: Multiple instances of Three.js being imported.')
                        : (window.__THREE__ = '133'));
            const oc = new WeakMap();
            function lc() {
                let t, e;
                function n(t, e, n, i, r, s) {
                    const a = s.num_components(),
                        o = n.num_points() * a,
                        l = o * r.BYTES_PER_ELEMENT,
                        c = (function (t, e) {
                            switch (e) {
                                case Float32Array:
                                    return t.DT_FLOAT32;
                                case Int8Array:
                                    return t.DT_INT8;
                                case Int16Array:
                                    return t.DT_INT16;
                                case Int32Array:
                                    return t.DT_INT32;
                                case Uint8Array:
                                    return t.DT_UINT8;
                                case Uint16Array:
                                    return t.DT_UINT16;
                                case Uint32Array:
                                    return t.DT_UINT32;
                            }
                        })(t, r),
                        h = t._malloc(l);
                    e.GetAttributeDataArrayForAllPoints(n, s, c, l, h);
                    const u = new r(t.HEAPF32.buffer, h, o).slice();
                    return t._free(h), { name: i, array: u, itemSize: a };
                }
                onmessage = function (i) {
                    const r = i.data;
                    switch (r.type) {
                        case 'init':
                            (t = r.decoderConfig),
                                (e = new Promise(function (e) {
                                    (t.onModuleLoaded = function (t) {
                                        e({ draco: t });
                                    }),
                                        DracoDecoderModule(t);
                                }));
                            break;
                        case 'decode':
                            const i = r.buffer,
                                s = r.taskConfig;
                            e.then((t) => {
                                const e = t.draco,
                                    a = new e.Decoder(),
                                    o = new e.DecoderBuffer();
                                o.Init(new Int8Array(i), i.byteLength);
                                try {
                                    const t = (function (t, e, i, r) {
                                            const s = r.attributeIDs,
                                                a = r.attributeTypes;
                                            let o, l;
                                            const c = e.GetEncodedGeometryType(i);
                                            if (c === t.TRIANGULAR_MESH)
                                                (o = new t.Mesh()), (l = e.DecodeBufferToMesh(i, o));
                                            else {
                                                if (c !== t.POINT_CLOUD)
                                                    throw new Error('THREE.DRACOLoader: Unexpected geometry type.');
                                                (o = new t.PointCloud()), (l = e.DecodeBufferToPointCloud(i, o));
                                            }
                                            if (!l.ok() || 0 === o.ptr)
                                                throw new Error('THREE.DRACOLoader: Decoding failed: ' + l.error_msg());
                                            const h = { index: null, attributes: [] };
                                            for (const i in s) {
                                                const l = self[a[i]];
                                                let c, u;
                                                if (r.useUniqueIDs) (u = s[i]), (c = e.GetAttributeByUniqueId(o, u));
                                                else {
                                                    if (((u = e.GetAttributeId(o, t[s[i]])), -1 === u)) continue;
                                                    c = e.GetAttribute(o, u);
                                                }
                                                h.attributes.push(n(t, e, o, i, l, c));
                                            }
                                            return (
                                                c === t.TRIANGULAR_MESH &&
                                                    (h.index = (function (t, e, n) {
                                                        const i = 3 * n.num_faces(),
                                                            r = 4 * i,
                                                            s = t._malloc(r);
                                                        e.GetTrianglesUInt32Array(n, r, s);
                                                        const a = new Uint32Array(t.HEAPF32.buffer, s, i).slice();
                                                        return t._free(s), { array: a, itemSize: 1 };
                                                    })(t, e, o)),
                                                t.destroy(o),
                                                h
                                            );
                                        })(e, a, o, s),
                                        i = t.attributes.map((t) => t.array.buffer);
                                    t.index && i.push(t.index.array.buffer),
                                        self.postMessage({ type: 'decode', id: r.id, geometry: t }, i);
                                } catch (t) {
                                    console.error(t), self.postMessage({ type: 'error', id: r.id, error: t.message });
                                } finally {
                                    e.destroy(o), e.destroy(a);
                                }
                            });
                    }
                };
            }
            class cc extends dl {
                constructor(t) {
                    super(t),
                        (this.dracoLoader = null),
                        (this.ktx2Loader = null),
                        (this.meshoptDecoder = null),
                        (this.pluginCallbacks = []),
                        this.register(function (t) {
                            return new mc(t);
                        }),
                        this.register(function (t) {
                            return new xc(t);
                        }),
                        this.register(function (t) {
                            return new bc(t);
                        }),
                        this.register(function (t) {
                            return new fc(t);
                        }),
                        this.register(function (t) {
                            return new gc(t);
                        }),
                        this.register(function (t) {
                            return new vc(t);
                        }),
                        this.register(function (t) {
                            return new yc(t);
                        }),
                        this.register(function (t) {
                            return new dc(t);
                        }),
                        this.register(function (t) {
                            return new wc(t);
                        });
                }
                load(t, e, n, i) {
                    const r = this;
                    let s;
                    (s =
                        '' !== this.resourcePath
                            ? this.resourcePath
                            : '' !== this.path
                            ? this.path
                            : Fl.extractUrlBase(t)),
                        this.manager.itemStart(t);
                    const a = function (e) {
                            i ? i(e) : console.error(e), r.manager.itemError(t), r.manager.itemEnd(t);
                        },
                        o = new ml(this.manager);
                    o.setPath(this.path),
                        o.setResponseType('arraybuffer'),
                        o.setRequestHeader(this.requestHeader),
                        o.setWithCredentials(this.withCredentials),
                        o.load(
                            t,
                            function (n) {
                                try {
                                    r.parse(
                                        n,
                                        s,
                                        function (n) {
                                            e(n), r.manager.itemEnd(t);
                                        },
                                        a,
                                    );
                                } catch (t) {
                                    a(t);
                                }
                            },
                            n,
                            a,
                        );
                }
                setDRACOLoader(t) {
                    return (this.dracoLoader = t), this;
                }
                setDDSLoader() {
                    throw new Error(
                        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
                    );
                }
                setKTX2Loader(t) {
                    return (this.ktx2Loader = t), this;
                }
                setMeshoptDecoder(t) {
                    return (this.meshoptDecoder = t), this;
                }
                register(t) {
                    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
                }
                unregister(t) {
                    return (
                        -1 !== this.pluginCallbacks.indexOf(t) &&
                            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                        this
                    );
                }
                parse(t, e, n, i) {
                    let r;
                    const s = {},
                        a = {};
                    if ('string' == typeof t) r = t;
                    else if (Fl.decodeText(new Uint8Array(t, 0, 4)) === _c) {
                        try {
                            s[uc.KHR_BINARY_GLTF] = new Mc(t);
                        } catch (t) {
                            return void (i && i(t));
                        }
                        r = s[uc.KHR_BINARY_GLTF].content;
                    } else r = Fl.decodeText(new Uint8Array(t));
                    const o = JSON.parse(r);
                    if (void 0 === o.asset || o.asset.version[0] < 2)
                        return void (
                            i && i(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))
                        );
                    const l = new Xc(o, {
                        path: e || this.resourcePath || '',
                        crossOrigin: this.crossOrigin,
                        requestHeader: this.requestHeader,
                        manager: this.manager,
                        ktx2Loader: this.ktx2Loader,
                        meshoptDecoder: this.meshoptDecoder,
                    });
                    l.fileLoader.setRequestHeader(this.requestHeader);
                    for (let t = 0; t < this.pluginCallbacks.length; t++) {
                        const e = this.pluginCallbacks[t](l);
                        (a[e.name] = e), (s[e.name] = !0);
                    }
                    if (o.extensionsUsed)
                        for (let t = 0; t < o.extensionsUsed.length; ++t) {
                            const e = o.extensionsUsed[t],
                                n = o.extensionsRequired || [];
                            switch (e) {
                                case uc.KHR_MATERIALS_UNLIT:
                                    s[e] = new pc();
                                    break;
                                case uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                    s[e] = new Ac();
                                    break;
                                case uc.KHR_DRACO_MESH_COMPRESSION:
                                    s[e] = new Sc(o, this.dracoLoader);
                                    break;
                                case uc.KHR_TEXTURE_TRANSFORM:
                                    s[e] = new Tc();
                                    break;
                                case uc.KHR_MESH_QUANTIZATION:
                                    s[e] = new Lc();
                                    break;
                                default:
                                    n.indexOf(e) >= 0 &&
                                        void 0 === a[e] &&
                                        console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".');
                            }
                        }
                    l.setExtensions(s), l.setPlugins(a), l.parse(n, i);
                }
            }
            function hc() {
                let t = {};
                return {
                    get: function (e) {
                        return t[e];
                    },
                    add: function (e, n) {
                        t[e] = n;
                    },
                    remove: function (e) {
                        delete t[e];
                    },
                    removeAll: function () {
                        t = {};
                    },
                };
            }
            const uc = {
                KHR_BINARY_GLTF: 'KHR_binary_glTF',
                KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
                KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
                KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
                KHR_MATERIALS_IOR: 'KHR_materials_ior',
                KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
                KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
                KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
                KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
                KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
                KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
                KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
                KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
                EXT_TEXTURE_WEBP: 'EXT_texture_webp',
                EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
            };
            class dc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} });
                }
                _markDefs() {
                    const t = this.parser,
                        e = this.parser.json.nodes || [];
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        i.extensions &&
                            i.extensions[this.name] &&
                            void 0 !== i.extensions[this.name].light &&
                            t._addNodeRef(this.cache, i.extensions[this.name].light);
                    }
                }
                _loadLight(t) {
                    const e = this.parser,
                        n = 'light:' + t;
                    let i = e.cache.get(n);
                    if (i) return i;
                    const r = e.json,
                        s = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[t];
                    let a;
                    const o = new un(16777215);
                    void 0 !== s.color && o.fromArray(s.color);
                    const l = void 0 !== s.range ? s.range : 0;
                    switch (s.type) {
                        case 'directional':
                            (a = new Il(o)), a.target.position.set(0, 0, -1), a.add(a.target);
                            break;
                        case 'point':
                            (a = new Cl(o)), (a.distance = l);
                            break;
                        case 'spot':
                            (a = new Tl(o)),
                                (a.distance = l),
                                (s.spot = s.spot || {}),
                                (s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
                                (s.spot.outerConeAngle =
                                    void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4),
                                (a.angle = s.spot.outerConeAngle),
                                (a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
                                a.target.position.set(0, 0, -1),
                                a.add(a.target);
                            break;
                        default:
                            throw new Error('THREE.GLTFLoader: Unexpected light type: ' + s.type);
                    }
                    return (
                        a.position.set(0, 0, 0),
                        (a.decay = 2),
                        void 0 !== s.intensity && (a.intensity = s.intensity),
                        (a.name = e.createUniqueName(s.name || 'light_' + t)),
                        (i = Promise.resolve(a)),
                        e.cache.add(n, i),
                        i
                    );
                }
                createNodeAttachment(t) {
                    const e = this,
                        n = this.parser,
                        i = n.json.nodes[t],
                        r = ((i.extensions && i.extensions[this.name]) || {}).light;
                    return void 0 === r
                        ? null
                        : this._loadLight(r).then(function (t) {
                              return n._getNodeRef(e.cache, r, t);
                          });
                }
            }
            class pc {
                constructor() {
                    this.name = uc.KHR_MATERIALS_UNLIT;
                }
                getMaterialType() {
                    return dn;
                }
                extendParams(t, e, n) {
                    const i = [];
                    (t.color = new un(1, 1, 1)), (t.opacity = 1);
                    const r = e.pbrMetallicRoughness;
                    if (r) {
                        if (Array.isArray(r.baseColorFactor)) {
                            const e = r.baseColorFactor;
                            t.color.fromArray(e), (t.opacity = e[3]);
                        }
                        void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, 'map', r.baseColorTexture));
                    }
                    return Promise.all(i);
                }
            }
            class mc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.KHR_MATERIALS_CLEARCOAT);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Yo : null;
                }
                extendMaterialParams(t, e) {
                    const n = this.parser,
                        i = n.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    if (
                        (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
                        void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, 'clearcoatMap', s.clearcoatTexture)),
                        void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
                        void 0 !== s.clearcoatRoughnessTexture &&
                            r.push(n.assignTexture(e, 'clearcoatRoughnessMap', s.clearcoatRoughnessTexture)),
                        void 0 !== s.clearcoatNormalTexture &&
                            (r.push(n.assignTexture(e, 'clearcoatNormalMap', s.clearcoatNormalTexture)),
                            void 0 !== s.clearcoatNormalTexture.scale))
                    ) {
                        const t = s.clearcoatNormalTexture.scale;
                        e.clearcoatNormalScale = new Rt(t, t);
                    }
                    return Promise.all(r);
                }
            }
            class fc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.KHR_MATERIALS_TRANSMISSION);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Yo : null;
                }
                extendMaterialParams(t, e) {
                    const n = this.parser,
                        i = n.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    return (
                        void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor),
                        void 0 !== s.transmissionTexture &&
                            r.push(n.assignTexture(e, 'transmissionMap', s.transmissionTexture)),
                        Promise.all(r)
                    );
                }
            }
            class gc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.KHR_MATERIALS_VOLUME);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Yo : null;
                }
                extendMaterialParams(t, e) {
                    const n = this.parser,
                        i = n.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    (e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
                        void 0 !== s.thicknessTexture && r.push(n.assignTexture(e, 'thicknessMap', s.thicknessTexture)),
                        (e.attenuationDistance = s.attenuationDistance || 0);
                    const a = s.attenuationColor || [1, 1, 1];
                    return (e.attenuationTint = new un(a[0], a[1], a[2])), Promise.all(r);
                }
            }
            class vc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.KHR_MATERIALS_IOR);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Yo : null;
                }
                extendMaterialParams(t, e) {
                    const n = this.parser.json.materials[t];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const i = n.extensions[this.name];
                    return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
                }
            }
            class yc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.KHR_MATERIALS_SPECULAR);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Yo : null;
                }
                extendMaterialParams(t, e) {
                    const n = this.parser,
                        i = n.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = i.extensions[this.name];
                    (e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1),
                        void 0 !== s.specularTexture &&
                            r.push(n.assignTexture(e, 'specularIntensityMap', s.specularTexture));
                    const a = s.specularColorFactor || [1, 1, 1];
                    return (
                        (e.specularTint = new un(a[0], a[1], a[2])),
                        void 0 !== s.specularColorTexture &&
                            r.push(
                                n.assignTexture(e, 'specularTintMap', s.specularColorTexture).then(function (t) {
                                    t.encoding = 3001;
                                }),
                            ),
                        Promise.all(r)
                    );
                }
            }
            class xc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.KHR_TEXTURE_BASISU);
                }
                loadTexture(t) {
                    const e = this.parser,
                        n = e.json,
                        i = n.textures[t];
                    if (!i.extensions || !i.extensions[this.name]) return null;
                    const r = i.extensions[this.name],
                        s = n.images[r.source],
                        a = e.options.ktx2Loader;
                    if (!a) {
                        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error(
                                'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures',
                            );
                        return null;
                    }
                    return e.loadTextureImage(t, s, a);
                }
            }
            class bc {
                constructor(t) {
                    (this.parser = t), (this.name = uc.EXT_TEXTURE_WEBP), (this.isSupported = null);
                }
                loadTexture(t) {
                    const e = this.name,
                        n = this.parser,
                        i = n.json,
                        r = i.textures[t];
                    if (!r.extensions || !r.extensions[e]) return null;
                    const s = r.extensions[e],
                        a = i.images[s.source];
                    let o = n.textureLoader;
                    if (a.uri) {
                        const t = n.options.manager.getHandler(a.uri);
                        null !== t && (o = t);
                    }
                    return this.detectSupport().then(function (r) {
                        if (r) return n.loadTextureImage(t, a, o);
                        if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                            throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
                        return n.loadTexture(t);
                    });
                }
                detectSupport() {
                    return (
                        this.isSupported ||
                            (this.isSupported = new Promise(function (t) {
                                const e = new Image();
                                (e.src =
                                    'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
                                    (e.onload = e.onerror =
                                        function () {
                                            t(1 === e.height);
                                        });
                            })),
                        this.isSupported
                    );
                }
            }
            class wc {
                constructor(t) {
                    (this.name = uc.EXT_MESHOPT_COMPRESSION), (this.parser = t);
                }
                loadBufferView(t) {
                    const e = this.parser.json,
                        n = e.bufferViews[t];
                    if (n.extensions && n.extensions[this.name]) {
                        const t = n.extensions[this.name],
                            i = this.parser.getDependency('buffer', t.buffer),
                            r = this.parser.options.meshoptDecoder;
                        if (!r || !r.supported) {
                            if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                                throw new Error(
                                    'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files',
                                );
                            return null;
                        }
                        return Promise.all([i, r.ready]).then(function (e) {
                            const n = t.byteOffset || 0,
                                i = t.byteLength || 0,
                                s = t.count,
                                a = t.byteStride,
                                o = new ArrayBuffer(s * a),
                                l = new Uint8Array(e[0], n, i);
                            return r.decodeGltfBuffer(new Uint8Array(o), s, a, l, t.mode, t.filter), o;
                        });
                    }
                    return null;
                }
            }
            const _c = 'glTF';
            class Mc {
                constructor(t) {
                    (this.name = uc.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
                    const e = new DataView(t, 0, 12);
                    if (
                        ((this.header = {
                            magic: Fl.decodeText(new Uint8Array(t.slice(0, 4))),
                            version: e.getUint32(4, !0),
                            length: e.getUint32(8, !0),
                        }),
                        this.header.magic !== _c)
                    )
                        throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
                    if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
                    const n = this.header.length - 12,
                        i = new DataView(t, 12);
                    let r = 0;
                    for (; r < n; ) {
                        const e = i.getUint32(r, !0);
                        r += 4;
                        const n = i.getUint32(r, !0);
                        if (((r += 4), 1313821514 === n)) {
                            const n = new Uint8Array(t, 12 + r, e);
                            this.content = Fl.decodeText(n);
                        } else if (5130562 === n) {
                            const n = 12 + r;
                            this.body = t.slice(n, n + e);
                        }
                        r += e;
                    }
                    if (null === this.content) throw new Error('THREE.GLTFLoader: JSON content not found.');
                }
            }
            class Sc {
                constructor(t, e) {
                    if (!e) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
                    (this.name = uc.KHR_DRACO_MESH_COMPRESSION),
                        (this.json = t),
                        (this.dracoLoader = e),
                        this.dracoLoader.preload();
                }
                decodePrimitive(t, e) {
                    const n = this.json,
                        i = this.dracoLoader,
                        r = t.extensions[this.name].bufferView,
                        s = t.extensions[this.name].attributes,
                        a = {},
                        o = {},
                        l = {};
                    for (const t in s) {
                        const e = Oc[t] || t.toLowerCase();
                        a[e] = s[t];
                    }
                    for (const e in t.attributes) {
                        const i = Oc[e] || e.toLowerCase();
                        if (void 0 !== s[e]) {
                            const r = n.accessors[t.attributes[e]],
                                s = Ic[r.componentType];
                            (l[i] = s), (o[i] = !0 === r.normalized);
                        }
                    }
                    return e.getDependency('bufferView', r).then(function (t) {
                        return new Promise(function (e) {
                            i.decodeDracoFile(
                                t,
                                function (t) {
                                    for (const e in t.attributes) {
                                        const n = t.attributes[e],
                                            i = o[e];
                                        void 0 !== i && (n.normalized = i);
                                    }
                                    e(t);
                                },
                                a,
                                l,
                            );
                        });
                    });
                }
            }
            class Tc {
                constructor() {
                    this.name = uc.KHR_TEXTURE_TRANSFORM;
                }
                extendTexture(t, e) {
                    return (
                        void 0 !== e.texCoord &&
                            console.warn(
                                'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.',
                            ),
                        (void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale) ||
                            ((t = t.clone()),
                            void 0 !== e.offset && t.offset.fromArray(e.offset),
                            void 0 !== e.rotation && (t.rotation = e.rotation),
                            void 0 !== e.scale && t.repeat.fromArray(e.scale),
                            (t.needsUpdate = !0)),
                        t
                    );
                }
            }
            class Ec extends Xo {
                constructor(t) {
                    super(), (this.isGLTFSpecularGlossinessMaterial = !0);
                    const e = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\n'),
                        n = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\n'),
                        i = [
                            'vec3 specularFactor = specular;',
                            '#ifdef USE_SPECULARMAP',
                            '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
                            '\ttexelSpecular = sRGBToLinear( texelSpecular );',
                            '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
                            '\tspecularFactor *= texelSpecular.rgb;',
                            '#endif',
                        ].join('\n'),
                        r = [
                            'float glossinessFactor = glossiness;',
                            '#ifdef USE_GLOSSINESSMAP',
                            '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
                            '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
                            '\tglossinessFactor *= texelGlossiness.a;',
                            '#endif',
                        ].join('\n'),
                        s = [
                            'PhysicalMaterial material;',
                            'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
                            'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
                            'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
                            'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
                            'material.roughness += geometryRoughness;',
                            'material.roughness = min( material.roughness, 1.0 );',
                            'material.specularColor = specularFactor;',
                        ].join('\n'),
                        a = {
                            specular: { value: new un().setHex(16777215) },
                            glossiness: { value: 1 },
                            specularMap: { value: null },
                            glossinessMap: { value: null },
                        };
                    (this._extraUniforms = a),
                        (this.onBeforeCompile = function (t) {
                            for (const e in a) t.uniforms[e] = a[e];
                            t.fragmentShader = t.fragmentShader
                                .replace('uniform float roughness;', 'uniform vec3 specular;')
                                .replace('uniform float metalness;', 'uniform float glossiness;')
                                .replace('#include <roughnessmap_pars_fragment>', e)
                                .replace('#include <metalnessmap_pars_fragment>', n)
                                .replace('#include <roughnessmap_fragment>', i)
                                .replace('#include <metalnessmap_fragment>', r)
                                .replace('#include <lights_physical_fragment>', s);
                        }),
                        Object.defineProperties(this, {
                            specular: {
                                get: function () {
                                    return a.specular.value;
                                },
                                set: function (t) {
                                    a.specular.value = t;
                                },
                            },
                            specularMap: {
                                get: function () {
                                    return a.specularMap.value;
                                },
                                set: function (t) {
                                    (a.specularMap.value = t),
                                        t ? (this.defines.USE_SPECULARMAP = '') : delete this.defines.USE_SPECULARMAP;
                                },
                            },
                            glossiness: {
                                get: function () {
                                    return a.glossiness.value;
                                },
                                set: function (t) {
                                    a.glossiness.value = t;
                                },
                            },
                            glossinessMap: {
                                get: function () {
                                    return a.glossinessMap.value;
                                },
                                set: function (t) {
                                    (a.glossinessMap.value = t),
                                        t
                                            ? ((this.defines.USE_GLOSSINESSMAP = ''), (this.defines.USE_UV = ''))
                                            : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
                                },
                            },
                        }),
                        delete this.metalness,
                        delete this.roughness,
                        delete this.metalnessMap,
                        delete this.roughnessMap,
                        this.setValues(t);
                }
                copy(t) {
                    return (
                        super.copy(t),
                        (this.specularMap = t.specularMap),
                        this.specular.copy(t.specular),
                        (this.glossinessMap = t.glossinessMap),
                        (this.glossiness = t.glossiness),
                        delete this.metalness,
                        delete this.roughness,
                        delete this.metalnessMap,
                        delete this.roughnessMap,
                        this
                    );
                }
            }
            class Ac {
                constructor() {
                    (this.name = uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
                        (this.specularGlossinessParams = [
                            'color',
                            'map',
                            'lightMap',
                            'lightMapIntensity',
                            'aoMap',
                            'aoMapIntensity',
                            'emissive',
                            'emissiveIntensity',
                            'emissiveMap',
                            'bumpMap',
                            'bumpScale',
                            'normalMap',
                            'normalMapType',
                            'displacementMap',
                            'displacementScale',
                            'displacementBias',
                            'specularMap',
                            'specular',
                            'glossinessMap',
                            'glossiness',
                            'alphaMap',
                            'envMap',
                            'envMapIntensity',
                            'refractionRatio',
                        ]);
                }
                getMaterialType() {
                    return Ec;
                }
                extendParams(t, e, n) {
                    const i = e.extensions[this.name];
                    (t.color = new un(1, 1, 1)), (t.opacity = 1);
                    const r = [];
                    if (Array.isArray(i.diffuseFactor)) {
                        const e = i.diffuseFactor;
                        t.color.fromArray(e), (t.opacity = e[3]);
                    }
                    if (
                        (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, 'map', i.diffuseTexture)),
                        (t.emissive = new un(0, 0, 0)),
                        (t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
                        (t.specular = new un(1, 1, 1)),
                        Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor),
                        void 0 !== i.specularGlossinessTexture)
                    ) {
                        const e = i.specularGlossinessTexture;
                        r.push(n.assignTexture(t, 'glossinessMap', e)), r.push(n.assignTexture(t, 'specularMap', e));
                    }
                    return Promise.all(r);
                }
                createMaterial(t) {
                    const e = new Ec(t);
                    return (
                        (e.fog = !0),
                        (e.color = t.color),
                        (e.map = void 0 === t.map ? null : t.map),
                        (e.lightMap = null),
                        (e.lightMapIntensity = 1),
                        (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
                        (e.aoMapIntensity = 1),
                        (e.emissive = t.emissive),
                        (e.emissiveIntensity = 1),
                        (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
                        (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
                        (e.bumpScale = 1),
                        (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
                        (e.normalMapType = 0),
                        t.normalScale && (e.normalScale = t.normalScale),
                        (e.displacementMap = null),
                        (e.displacementScale = 1),
                        (e.displacementBias = 0),
                        (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
                        (e.specular = t.specular),
                        (e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap),
                        (e.glossiness = t.glossiness),
                        (e.alphaMap = null),
                        (e.envMap = void 0 === t.envMap ? null : t.envMap),
                        (e.envMapIntensity = 1),
                        (e.refractionRatio = 0.98),
                        e
                    );
                }
            }
            class Lc {
                constructor() {
                    this.name = uc.KHR_MESH_QUANTIZATION;
                }
            }
            class Rc extends Jo {
                constructor(t, e, n, i) {
                    super(t, e, n, i);
                }
                copySampleValue_(t) {
                    const e = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = t * i * 3 + i;
                    for (let t = 0; t !== i; t++) e[t] = n[r + t];
                    return e;
                }
            }
            (Rc.prototype.beforeStart_ = Rc.prototype.copySampleValue_),
                (Rc.prototype.afterEnd_ = Rc.prototype.copySampleValue_),
                (Rc.prototype.interpolate_ = function (t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = 2 * a,
                        l = 3 * a,
                        c = i - e,
                        h = (n - e) / c,
                        u = h * h,
                        d = u * h,
                        p = t * l,
                        m = p - l,
                        f = -2 * d + 3 * u,
                        g = d - u,
                        v = 1 - f,
                        y = g - u + h;
                    for (let t = 0; t !== a; t++) {
                        const e = s[m + t + a],
                            n = s[m + t + o] * c,
                            i = s[p + t + a],
                            l = s[p + t] * c;
                        r[t] = v * e + y * n + f * i + g * l;
                    }
                    return r;
                });
            const Cc = new Ht();
            class Pc extends Rc {
                interpolate_(t, e, n, i) {
                    const r = super.interpolate_(t, e, n, i);
                    return Cc.fromArray(r).normalize().toArray(r), r;
                }
            }
            const Ic = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array,
                },
                Dc = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 },
                Nc = { 33071: 1001, 33648: 1002, 10497: 1e3 },
                Fc = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
                Oc = {
                    POSITION: 'position',
                    NORMAL: 'normal',
                    TANGENT: 'tangent',
                    TEXCOORD_0: 'uv',
                    TEXCOORD_1: 'uv2',
                    COLOR_0: 'color',
                    WEIGHTS_0: 'skinWeight',
                    JOINTS_0: 'skinIndex',
                },
                Uc = {
                    scale: 'scale',
                    translation: 'position',
                    rotation: 'quaternion',
                    weights: 'morphTargetInfluences',
                },
                kc = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 };
            function zc(t, e) {
                return 'string' != typeof t || '' === t
                    ? ''
                    : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
                      /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
            }
            function Bc(t) {
                return (
                    void 0 === t.DefaultMaterial &&
                        (t.DefaultMaterial = new Xo({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: 0,
                        })),
                    t.DefaultMaterial
                );
            }
            function Hc(t, e, n) {
                for (const i in n.extensions)
                    void 0 === t[i] &&
                        ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
                        (e.userData.gltfExtensions[i] = n.extensions[i]));
            }
            function Gc(t, e) {
                void 0 !== e.extras &&
                    ('object' == typeof e.extras
                        ? Object.assign(t.userData, e.extras)
                        : console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras));
            }
            function Vc(t, e) {
                if ((t.updateMorphTargets(), void 0 !== e.weights))
                    for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
                if (e.extras && Array.isArray(e.extras.targetNames)) {
                    const n = e.extras.targetNames;
                    if (t.morphTargetInfluences.length === n.length) {
                        t.morphTargetDictionary = {};
                        for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e;
                    } else console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
                }
            }
            function Wc(t) {
                const e = t.extensions && t.extensions[uc.KHR_DRACO_MESH_COMPRESSION];
                let n;
                return (
                    (n = e
                        ? 'draco:' + e.bufferView + ':' + e.indices + ':' + jc(e.attributes)
                        : t.indices + ':' + jc(t.attributes) + ':' + t.mode),
                    n
                );
            }
            function jc(t) {
                let e = '';
                const n = Object.keys(t).sort();
                for (let i = 0, r = n.length; i < r; i++) e += n[i] + ':' + t[n[i]] + ';';
                return e;
            }
            function qc(t) {
                switch (t) {
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
                }
            }
            class Xc {
                constructor(t = {}, e = {}) {
                    (this.json = t),
                        (this.extensions = {}),
                        (this.plugins = {}),
                        (this.options = e),
                        (this.cache = new hc()),
                        (this.associations = new Map()),
                        (this.primitiveCache = {}),
                        (this.meshCache = { refs: {}, uses: {} }),
                        (this.cameraCache = { refs: {}, uses: {} }),
                        (this.lightCache = { refs: {}, uses: {} }),
                        (this.textureCache = {}),
                        (this.nodeNamesUsed = {}),
                        'undefined' != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent)
                            ? (this.textureLoader = new Ol(this.options.manager))
                            : (this.textureLoader = new yl(this.options.manager)),
                        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                        this.textureLoader.setRequestHeader(this.options.requestHeader),
                        (this.fileLoader = new ml(this.options.manager)),
                        this.fileLoader.setResponseType('arraybuffer'),
                        'use-credentials' === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
                }
                setExtensions(t) {
                    this.extensions = t;
                }
                setPlugins(t) {
                    this.plugins = t;
                }
                parse(t, e) {
                    const n = this,
                        i = this.json,
                        r = this.extensions;
                    this.cache.removeAll(),
                        this._invokeAll(function (t) {
                            return t._markDefs && t._markDefs();
                        }),
                        Promise.all(
                            this._invokeAll(function (t) {
                                return t.beforeRoot && t.beforeRoot();
                            }),
                        )
                            .then(function () {
                                return Promise.all([
                                    n.getDependencies('scene'),
                                    n.getDependencies('animation'),
                                    n.getDependencies('camera'),
                                ]);
                            })
                            .then(function (e) {
                                const s = {
                                    scene: e[0][i.scene || 0],
                                    scenes: e[0],
                                    animations: e[1],
                                    cameras: e[2],
                                    asset: i.asset,
                                    parser: n,
                                    userData: {},
                                };
                                Hc(r, s, i),
                                    Gc(s, i),
                                    Promise.all(
                                        n._invokeAll(function (t) {
                                            return t.afterRoot && t.afterRoot(s);
                                        }),
                                    ).then(function () {
                                        t(s);
                                    });
                            })
                            .catch(e);
                }
                _markDefs() {
                    const t = this.json.nodes || [],
                        e = this.json.skins || [],
                        n = this.json.meshes || [];
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n].joints;
                        for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0;
                    }
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e];
                        void 0 !== i.mesh &&
                            (this._addNodeRef(this.meshCache, i.mesh),
                            void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                            void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera);
                    }
                }
                _addNodeRef(t, e) {
                    void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
                }
                _getNodeRef(t, e, n) {
                    if (t.refs[e] <= 1) return n;
                    const i = n.clone(),
                        r = (t, e) => {
                            const n = this.associations.get(t);
                            null != n && this.associations.set(e, n);
                            for (const [n, i] of t.children.entries()) r(i, e.children[n]);
                        };
                    return r(n, i), (i.name += '_instance_' + t.uses[e]++), i;
                }
                _invokeOne(t) {
                    const e = Object.values(this.plugins);
                    e.push(this);
                    for (let n = 0; n < e.length; n++) {
                        const i = t(e[n]);
                        if (i) return i;
                    }
                    return null;
                }
                _invokeAll(t) {
                    const e = Object.values(this.plugins);
                    e.unshift(this);
                    const n = [];
                    for (let i = 0; i < e.length; i++) {
                        const r = t(e[i]);
                        r && n.push(r);
                    }
                    return n;
                }
                getDependency(t, e) {
                    const n = t + ':' + e;
                    let i = this.cache.get(n);
                    if (!i) {
                        switch (t) {
                            case 'scene':
                                i = this.loadScene(e);
                                break;
                            case 'node':
                                i = this.loadNode(e);
                                break;
                            case 'mesh':
                                i = this._invokeOne(function (t) {
                                    return t.loadMesh && t.loadMesh(e);
                                });
                                break;
                            case 'accessor':
                                i = this.loadAccessor(e);
                                break;
                            case 'bufferView':
                                i = this._invokeOne(function (t) {
                                    return t.loadBufferView && t.loadBufferView(e);
                                });
                                break;
                            case 'buffer':
                                i = this.loadBuffer(e);
                                break;
                            case 'material':
                                i = this._invokeOne(function (t) {
                                    return t.loadMaterial && t.loadMaterial(e);
                                });
                                break;
                            case 'texture':
                                i = this._invokeOne(function (t) {
                                    return t.loadTexture && t.loadTexture(e);
                                });
                                break;
                            case 'skin':
                                i = this.loadSkin(e);
                                break;
                            case 'animation':
                                i = this.loadAnimation(e);
                                break;
                            case 'camera':
                                i = this.loadCamera(e);
                                break;
                            default:
                                throw new Error('Unknown type: ' + t);
                        }
                        this.cache.add(n, i);
                    }
                    return i;
                }
                getDependencies(t) {
                    let e = this.cache.get(t);
                    if (!e) {
                        const n = this,
                            i = this.json[t + ('mesh' === t ? 'es' : 's')] || [];
                        (e = Promise.all(
                            i.map(function (e, i) {
                                return n.getDependency(t, i);
                            }),
                        )),
                            this.cache.add(t, e);
                    }
                    return e;
                }
                loadBuffer(t) {
                    const e = this.json.buffers[t],
                        n = this.fileLoader;
                    if (e.type && 'arraybuffer' !== e.type)
                        throw new Error('THREE.GLTFLoader: ' + e.type + ' buffer type is not supported.');
                    if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[uc.KHR_BINARY_GLTF].body);
                    const i = this.options;
                    return new Promise(function (t, r) {
                        n.load(zc(e.uri, i.path), t, void 0, function () {
                            r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
                        });
                    });
                }
                loadBufferView(t) {
                    const e = this.json.bufferViews[t];
                    return this.getDependency('buffer', e.buffer).then(function (t) {
                        const n = e.byteLength || 0,
                            i = e.byteOffset || 0;
                        return t.slice(i, i + n);
                    });
                }
                loadAccessor(t) {
                    const e = this,
                        n = this.json,
                        i = this.json.accessors[t];
                    if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                    const r = [];
                    return (
                        void 0 !== i.bufferView ? r.push(this.getDependency('bufferView', i.bufferView)) : r.push(null),
                        void 0 !== i.sparse &&
                            (r.push(this.getDependency('bufferView', i.sparse.indices.bufferView)),
                            r.push(this.getDependency('bufferView', i.sparse.values.bufferView))),
                        Promise.all(r).then(function (t) {
                            const r = t[0],
                                s = Fc[i.type],
                                a = Ic[i.componentType],
                                o = a.BYTES_PER_ELEMENT,
                                l = o * s,
                                c = i.byteOffset || 0,
                                h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                                u = !0 === i.normalized;
                            let d, p;
                            if (h && h !== l) {
                                const t = Math.floor(c / h),
                                    n =
                                        'InterleavedBuffer:' +
                                        i.bufferView +
                                        ':' +
                                        i.componentType +
                                        ':' +
                                        t +
                                        ':' +
                                        i.count;
                                let l = e.cache.get(n);
                                l ||
                                    ((d = new a(r, t * h, (i.count * h) / o)),
                                    (l = new Ys(d, h / o)),
                                    e.cache.add(n, l)),
                                    (p = new Js(l, s, (c % h) / o, u));
                            } else (d = null === r ? new a(i.count * s) : new a(r, c, i.count * s)), (p = new fn(d, s, u));
                            if (void 0 !== i.sparse) {
                                const e = Fc.SCALAR,
                                    n = Ic[i.sparse.indices.componentType],
                                    o = i.sparse.indices.byteOffset || 0,
                                    l = i.sparse.values.byteOffset || 0,
                                    c = new n(t[1], o, i.sparse.count * e),
                                    h = new a(t[2], l, i.sparse.count * s);
                                null !== r && (p = new fn(p.array.slice(), p.itemSize, p.normalized));
                                for (let t = 0, e = c.length; t < e; t++) {
                                    const e = c[t];
                                    if (
                                        (p.setX(e, h[t * s]),
                                        s >= 2 && p.setY(e, h[t * s + 1]),
                                        s >= 3 && p.setZ(e, h[t * s + 2]),
                                        s >= 4 && p.setW(e, h[t * s + 3]),
                                        s >= 5)
                                    )
                                        throw new Error(
                                            'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.',
                                        );
                                }
                            }
                            return p;
                        })
                    );
                }
                loadTexture(t) {
                    const e = this.json,
                        n = this.options,
                        i = e.textures[t],
                        r = e.images[i.source];
                    let s = this.textureLoader;
                    if (r.uri) {
                        const t = n.manager.getHandler(r.uri);
                        null !== t && (s = t);
                    }
                    return this.loadTextureImage(t, r, s);
                }
                loadTextureImage(t, e, n) {
                    const i = this,
                        r = this.json,
                        s = this.options,
                        a = r.textures[t],
                        o = (e.uri || e.bufferView) + ':' + a.sampler;
                    if (this.textureCache[o]) return this.textureCache[o];
                    const l = self.URL || self.webkitURL;
                    let c = e.uri || '',
                        h = !1;
                    if (void 0 !== e.bufferView)
                        c = i.getDependency('bufferView', e.bufferView).then(function (t) {
                            h = !0;
                            const n = new Blob([t], { type: e.mimeType });
                            return (c = l.createObjectURL(n)), c;
                        });
                    else if (void 0 === e.uri)
                        throw new Error('THREE.GLTFLoader: Image ' + t + ' is missing URI and bufferView');
                    const u = Promise.resolve(c)
                        .then(function (t) {
                            return new Promise(function (e, i) {
                                let r = e;
                                !0 === n.isImageBitmapLoader &&
                                    (r = function (t) {
                                        const n = new Ot(t);
                                        (n.needsUpdate = !0), e(n);
                                    }),
                                    n.load(zc(t, s.path), r, void 0, i);
                            });
                        })
                        .then(function (e) {
                            !0 === h && l.revokeObjectURL(c), (e.flipY = !1), a.name && (e.name = a.name);
                            const n = (r.samplers || {})[a.sampler] || {};
                            return (
                                (e.magFilter = Dc[n.magFilter] || 1006),
                                (e.minFilter = Dc[n.minFilter] || 1008),
                                (e.wrapS = Nc[n.wrapS] || 1e3),
                                (e.wrapT = Nc[n.wrapT] || 1e3),
                                i.associations.set(e, { textures: t }),
                                e
                            );
                        })
                        .catch(function () {
                            return console.error("THREE.GLTFLoader: Couldn't load texture", c), null;
                        });
                    return (this.textureCache[o] = u), u;
                }
                assignTexture(t, e, n) {
                    const i = this;
                    return this.getDependency('texture', n.index).then(function (r) {
                        if (
                            (void 0 === n.texCoord ||
                                0 == n.texCoord ||
                                ('aoMap' === e && 1 == n.texCoord) ||
                                console.warn(
                                    'THREE.GLTFLoader: Custom UV set ' +
                                        n.texCoord +
                                        ' for texture ' +
                                        e +
                                        ' not yet supported.',
                                ),
                            i.extensions[uc.KHR_TEXTURE_TRANSFORM])
                        ) {
                            const t = void 0 !== n.extensions ? n.extensions[uc.KHR_TEXTURE_TRANSFORM] : void 0;
                            if (t) {
                                const e = i.associations.get(r);
                                (r = i.extensions[uc.KHR_TEXTURE_TRANSFORM].extendTexture(r, t)),
                                    i.associations.set(r, e);
                            }
                        }
                        return (t[e] = r), r;
                    });
                }
                assignFinalMaterial(t) {
                    const e = t.geometry;
                    let n = t.material;
                    const i = void 0 === e.attributes.tangent,
                        r = void 0 !== e.attributes.color,
                        s = void 0 === e.attributes.normal;
                    if (t.isPoints) {
                        const t = 'PointsMaterial:' + n.uuid;
                        let e = this.cache.get(t);
                        e ||
                            ((e = new za()),
                            rn.prototype.copy.call(e, n),
                            e.color.copy(n.color),
                            (e.map = n.map),
                            (e.sizeAttenuation = !1),
                            this.cache.add(t, e)),
                            (n = e);
                    } else if (t.isLine) {
                        const t = 'LineBasicMaterial:' + n.uuid;
                        let e = this.cache.get(t);
                        e ||
                            ((e = new La()), rn.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)),
                            (n = e);
                    }
                    if (i || r || s) {
                        let t = 'ClonedMaterial:' + n.uuid + ':';
                        n.isGLTFSpecularGlossinessMaterial && (t += 'specular-glossiness:'),
                            i && (t += 'derivative-tangents:'),
                            r && (t += 'vertex-colors:'),
                            s && (t += 'flat-shading:');
                        let e = this.cache.get(t);
                        e ||
                            ((e = n.clone()),
                            r && (e.vertexColors = !0),
                            s && (e.flatShading = !0),
                            i &&
                                (e.normalScale && (e.normalScale.y *= -1),
                                e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                            this.cache.add(t, e),
                            this.associations.set(e, this.associations.get(n))),
                            (n = e);
                    }
                    n.aoMap &&
                        void 0 === e.attributes.uv2 &&
                        void 0 !== e.attributes.uv &&
                        e.setAttribute('uv2', e.attributes.uv),
                        (t.material = n);
                }
                getMaterialType() {
                    return Xo;
                }
                loadMaterial(t) {
                    const e = this,
                        n = this.json,
                        i = this.extensions,
                        r = n.materials[t];
                    let s;
                    const a = {},
                        o = r.extensions || {},
                        l = [];
                    if (o[uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                        const t = i[uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                        (s = t.getMaterialType()), l.push(t.extendParams(a, r, e));
                    } else if (o[uc.KHR_MATERIALS_UNLIT]) {
                        const t = i[uc.KHR_MATERIALS_UNLIT];
                        (s = t.getMaterialType()), l.push(t.extendParams(a, r, e));
                    } else {
                        const n = r.pbrMetallicRoughness || {};
                        if (((a.color = new un(1, 1, 1)), (a.opacity = 1), Array.isArray(n.baseColorFactor))) {
                            const t = n.baseColorFactor;
                            a.color.fromArray(t), (a.opacity = t[3]);
                        }
                        void 0 !== n.baseColorTexture && l.push(e.assignTexture(a, 'map', n.baseColorTexture)),
                            (a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
                            (a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
                            void 0 !== n.metallicRoughnessTexture &&
                                (l.push(e.assignTexture(a, 'metalnessMap', n.metallicRoughnessTexture)),
                                l.push(e.assignTexture(a, 'roughnessMap', n.metallicRoughnessTexture))),
                            (s = this._invokeOne(function (e) {
                                return e.getMaterialType && e.getMaterialType(t);
                            })),
                            l.push(
                                Promise.all(
                                    this._invokeAll(function (e) {
                                        return e.extendMaterialParams && e.extendMaterialParams(t, a);
                                    }),
                                ),
                            );
                    }
                    !0 === r.doubleSided && (a.side = 2);
                    const c = r.alphaMode || 'OPAQUE';
                    if (
                        ('BLEND' === c
                            ? ((a.transparent = !0), (a.depthWrite = !1))
                            : ((a.format = 1022),
                              (a.transparent = !1),
                              'MASK' === c && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
                        void 0 !== r.normalTexture &&
                            s !== dn &&
                            (l.push(e.assignTexture(a, 'normalMap', r.normalTexture)),
                            (a.normalScale = new Rt(1, 1)),
                            void 0 !== r.normalTexture.scale))
                    ) {
                        const t = r.normalTexture.scale;
                        a.normalScale.set(t, t);
                    }
                    return (
                        void 0 !== r.occlusionTexture &&
                            s !== dn &&
                            (l.push(e.assignTexture(a, 'aoMap', r.occlusionTexture)),
                            void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)),
                        void 0 !== r.emissiveFactor && s !== dn && (a.emissive = new un().fromArray(r.emissiveFactor)),
                        void 0 !== r.emissiveTexture &&
                            s !== dn &&
                            l.push(e.assignTexture(a, 'emissiveMap', r.emissiveTexture)),
                        Promise.all(l).then(function () {
                            let n;
                            return (
                                (n =
                                    s === Ec
                                        ? i[uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a)
                                        : new s(a)),
                                r.name && (n.name = r.name),
                                n.map && (n.map.encoding = 3001),
                                n.emissiveMap && (n.emissiveMap.encoding = 3001),
                                Gc(n, r),
                                e.associations.set(n, { materials: t }),
                                r.extensions && Hc(i, n, r),
                                n
                            );
                        })
                    );
                }
                createUniqueName(t) {
                    const e = Yl.sanitizeNodeName(t || '');
                    let n = e;
                    for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + '_' + t;
                    return (this.nodeNamesUsed[n] = !0), n;
                }
                loadGeometries(t) {
                    const e = this,
                        n = this.extensions,
                        i = this.primitiveCache;
                    function r(t) {
                        return n[uc.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (n) {
                            return Zc(n, t, e);
                        });
                    }
                    const s = [];
                    for (let n = 0, a = t.length; n < a; n++) {
                        const a = t[n],
                            o = Wc(a),
                            l = i[o];
                        if (l) s.push(l.promise);
                        else {
                            let t;
                            (t =
                                a.extensions && a.extensions[uc.KHR_DRACO_MESH_COMPRESSION]
                                    ? r(a)
                                    : Zc(new En(), a, e)),
                                (i[o] = { primitive: a, promise: t }),
                                s.push(t);
                        }
                    }
                    return Promise.all(s);
                }
                loadMesh(t) {
                    const e = this,
                        n = this.json,
                        i = this.extensions,
                        r = n.meshes[t],
                        s = r.primitives,
                        a = [];
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e =
                            void 0 === s[t].material ? Bc(this.cache) : this.getDependency('material', s[t].material);
                        a.push(e);
                    }
                    return (
                        a.push(e.loadGeometries(s)),
                        Promise.all(a).then(function (n) {
                            const a = n.slice(0, n.length - 1),
                                o = n[n.length - 1],
                                l = [];
                            for (let n = 0, c = o.length; n < c; n++) {
                                const c = o[n],
                                    h = s[n];
                                let u;
                                const d = a[n];
                                if (4 === h.mode || 5 === h.mode || 6 === h.mode || void 0 === h.mode)
                                    (u = !0 === r.isSkinnedMesh ? new va(c, d) : new Wn(c, d)),
                                        !0 !== u.isSkinnedMesh ||
                                            u.geometry.attributes.skinWeight.normalized ||
                                            u.normalizeSkinWeights(),
                                        5 === h.mode
                                            ? (u.geometry = Jc(u.geometry, 1))
                                            : 6 === h.mode && (u.geometry = Jc(u.geometry, 2));
                                else if (1 === h.mode) u = new Ua(c, d);
                                else if (3 === h.mode) u = new Na(c, d);
                                else if (2 === h.mode) u = new ka(c, d);
                                else {
                                    if (0 !== h.mode)
                                        throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + h.mode);
                                    u = new Wa(c, d);
                                }
                                Object.keys(u.geometry.morphAttributes).length > 0 && Vc(u, r),
                                    (u.name = e.createUniqueName(r.name || 'mesh_' + t)),
                                    Gc(u, r),
                                    h.extensions && Hc(i, u, h),
                                    e.assignFinalMaterial(u),
                                    l.push(u);
                            }
                            for (let n = 0, i = l.length; n < i; n++)
                                e.associations.set(l[n], { meshes: t, primitives: n });
                            if (1 === l.length) return l[0];
                            const c = new Hs();
                            e.associations.set(c, { meshes: t });
                            for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
                            return c;
                        })
                    );
                }
                loadCamera(t) {
                    let e;
                    const n = this.json.cameras[t],
                        i = n[n.type];
                    if (i)
                        return (
                            'perspective' === n.type
                                ? (e = new Kn(Lt.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6))
                                : 'orthographic' === n.type &&
                                  (e = new wi(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
                            n.name && (e.name = this.createUniqueName(n.name)),
                            Gc(e, n),
                            Promise.resolve(e)
                        );
                    console.warn('THREE.GLTFLoader: Missing camera parameters.');
                }
                loadSkin(t) {
                    const e = this.json.skins[t],
                        n = { joints: e.joints };
                    return void 0 === e.inverseBindMatrices
                        ? Promise.resolve(n)
                        : this.getDependency('accessor', e.inverseBindMatrices).then(function (t) {
                              return (n.inverseBindMatrices = t), n;
                          });
                }
                loadAnimation(t) {
                    const e = this.json.animations[t],
                        n = [],
                        i = [],
                        r = [],
                        s = [],
                        a = [];
                    for (let t = 0, o = e.channels.length; t < o; t++) {
                        const o = e.channels[t],
                            l = e.samplers[o.sampler],
                            c = o.target,
                            h = void 0 !== c.node ? c.node : c.id,
                            u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
                            d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                        n.push(this.getDependency('node', h)),
                            i.push(this.getDependency('accessor', u)),
                            r.push(this.getDependency('accessor', d)),
                            s.push(l),
                            a.push(c);
                    }
                    return Promise.all([
                        Promise.all(n),
                        Promise.all(i),
                        Promise.all(r),
                        Promise.all(s),
                        Promise.all(a),
                    ]).then(function (n) {
                        const i = n[0],
                            r = n[1],
                            s = n[2],
                            a = n[3],
                            o = n[4],
                            l = [];
                        for (let t = 0, e = i.length; t < e; t++) {
                            const e = i[t],
                                n = r[t],
                                c = s[t],
                                h = a[t],
                                u = o[t];
                            if (void 0 === e) continue;
                            let d;
                            switch ((e.updateMatrix(), (e.matrixAutoUpdate = !0), Uc[u.path])) {
                                case Uc.weights:
                                    d = il;
                                    break;
                                case Uc.rotation:
                                    d = sl;
                                    break;
                                default:
                                    d = ol;
                            }
                            const p = e.name ? e.name : e.uuid,
                                m = void 0 !== h.interpolation ? kc[h.interpolation] : 2301,
                                f = [];
                            Uc[u.path] === Uc.weights
                                ? e.traverse(function (t) {
                                      !0 === t.isMesh && t.morphTargetInfluences && f.push(t.name ? t.name : t.uuid);
                                  })
                                : f.push(p);
                            let g = c.array;
                            if (c.normalized) {
                                const t = qc(g.constructor),
                                    e = new Float32Array(g.length);
                                for (let n = 0, i = g.length; n < i; n++) e[n] = g[n] * t;
                                g = e;
                            }
                            for (let t = 0, e = f.length; t < e; t++) {
                                const e = new d(f[t] + '.' + Uc[u.path], n.array, g, m);
                                'CUBICSPLINE' === h.interpolation &&
                                    ((e.createInterpolant = function (t) {
                                        return new (this instanceof sl ? Pc : Rc)(
                                            this.times,
                                            this.values,
                                            this.getValueSize() / 3,
                                            t,
                                        );
                                    }),
                                    (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
                                    l.push(e);
                            }
                        }
                        const c = e.name ? e.name : 'animation_' + t;
                        return new ll(c, void 0, l);
                    });
                }
                createNodeMesh(t) {
                    const e = this.json,
                        n = this,
                        i = e.nodes[t];
                    return void 0 === i.mesh
                        ? null
                        : n.getDependency('mesh', i.mesh).then(function (t) {
                              const e = n._getNodeRef(n.meshCache, i.mesh, t);
                              return (
                                  void 0 !== i.weights &&
                                      e.traverse(function (t) {
                                          if (t.isMesh)
                                              for (let e = 0, n = i.weights.length; e < n; e++)
                                                  t.morphTargetInfluences[e] = i.weights[e];
                                      }),
                                  e
                              );
                          });
                }
                loadNode(t) {
                    const e = this.json,
                        n = this.extensions,
                        i = this,
                        r = e.nodes[t],
                        s = r.name ? i.createUniqueName(r.name) : '';
                    return (function () {
                        const e = [],
                            n = i._invokeOne(function (e) {
                                return e.createNodeMesh && e.createNodeMesh(t);
                            });
                        return (
                            n && e.push(n),
                            void 0 !== r.camera &&
                                e.push(
                                    i.getDependency('camera', r.camera).then(function (t) {
                                        return i._getNodeRef(i.cameraCache, r.camera, t);
                                    }),
                                ),
                            i
                                ._invokeAll(function (e) {
                                    return e.createNodeAttachment && e.createNodeAttachment(t);
                                })
                                .forEach(function (t) {
                                    e.push(t);
                                }),
                            Promise.all(e)
                        );
                    })().then(function (e) {
                        let a;
                        if (
                            ((a =
                                !0 === r.isBone
                                    ? new ya()
                                    : e.length > 1
                                    ? new Hs()
                                    : 1 === e.length
                                    ? e[0]
                                    : new We()),
                            a !== e[0])
                        )
                            for (let t = 0, n = e.length; t < n; t++) a.add(e[t]);
                        if (
                            (r.name && ((a.userData.name = r.name), (a.name = s)),
                            Gc(a, r),
                            r.extensions && Hc(n, a, r),
                            void 0 !== r.matrix)
                        ) {
                            const t = new xe();
                            t.fromArray(r.matrix), a.applyMatrix4(t);
                        } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
                        return i.associations.has(a) || i.associations.set(a, {}), (i.associations.get(a).nodes = t), a;
                    });
                }
                loadScene(t) {
                    const e = this.json,
                        n = this.extensions,
                        i = this.json.scenes[t],
                        r = this,
                        s = new Hs();
                    i.name && (s.name = r.createUniqueName(i.name)), Gc(s, i), i.extensions && Hc(n, s, i);
                    const a = i.nodes || [],
                        o = [];
                    for (let t = 0, n = a.length; t < n; t++) o.push(Yc(a[t], s, e, r));
                    return Promise.all(o).then(function () {
                        return (
                            (r.associations = ((t) => {
                                const e = new Map();
                                for (const [t, n] of r.associations)
                                    (t instanceof rn || t instanceof Ot) && e.set(t, n);
                                return (
                                    t.traverse((t) => {
                                        const n = r.associations.get(t);
                                        null != n && e.set(t, n);
                                    }),
                                    e
                                );
                            })(s)),
                            s
                        );
                    });
                }
            }
            function Yc(t, e, n, i) {
                const r = n.nodes[t];
                return i
                    .getDependency('node', t)
                    .then(function (t) {
                        if (void 0 === r.skin) return t;
                        let e;
                        return i
                            .getDependency('skin', r.skin)
                            .then(function (t) {
                                e = t;
                                const n = [];
                                for (let t = 0, r = e.joints.length; t < r; t++)
                                    n.push(i.getDependency('node', e.joints[t]));
                                return Promise.all(n);
                            })
                            .then(function (n) {
                                return (
                                    t.traverse(function (t) {
                                        if (!t.isMesh) return;
                                        const i = [],
                                            r = [];
                                        for (let t = 0, s = n.length; t < s; t++) {
                                            const s = n[t];
                                            if (s) {
                                                i.push(s);
                                                const n = new xe();
                                                void 0 !== e.inverseBindMatrices &&
                                                    n.fromArray(e.inverseBindMatrices.array, 16 * t),
                                                    r.push(n);
                                            } else
                                                console.warn(
                                                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                                                    e.joints[t],
                                                );
                                        }
                                        t.bind(new _a(i, r), t.matrixWorld);
                                    }),
                                    t
                                );
                            });
                    })
                    .then(function (t) {
                        e.add(t);
                        const s = [];
                        if (r.children) {
                            const e = r.children;
                            for (let r = 0, a = e.length; r < a; r++) {
                                const a = e[r];
                                s.push(Yc(a, t, n, i));
                            }
                        }
                        return Promise.all(s);
                    });
            }
            function Zc(t, e, n) {
                const i = e.attributes,
                    r = [];
                function s(e, i) {
                    return n.getDependency('accessor', e).then(function (e) {
                        t.setAttribute(i, e);
                    });
                }
                for (const e in i) {
                    const n = Oc[e] || e.toLowerCase();
                    n in t.attributes || r.push(s(i[e], n));
                }
                if (void 0 !== e.indices && !t.index) {
                    const i = n.getDependency('accessor', e.indices).then(function (e) {
                        t.setIndex(e);
                    });
                    r.push(i);
                }
                return (
                    Gc(t, e),
                    (function (t, e, n) {
                        const i = e.attributes,
                            r = new jt();
                        if (void 0 === i.POSITION) return;
                        {
                            const t = n.json.accessors[i.POSITION],
                                e = t.min,
                                s = t.max;
                            if (void 0 === e || void 0 === s)
                                return void console.warn(
                                    'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
                                );
                            if ((r.set(new Gt(e[0], e[1], e[2]), new Gt(s[0], s[1], s[2])), t.normalized)) {
                                const e = qc(Ic[t.componentType]);
                                r.min.multiplyScalar(e), r.max.multiplyScalar(e);
                            }
                        }
                        const s = e.targets;
                        if (void 0 !== s) {
                            const t = new Gt(),
                                e = new Gt();
                            for (let i = 0, r = s.length; i < r; i++) {
                                const r = s[i];
                                if (void 0 !== r.POSITION) {
                                    const i = n.json.accessors[r.POSITION],
                                        s = i.min,
                                        a = i.max;
                                    if (void 0 !== s && void 0 !== a) {
                                        if (
                                            (e.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                                            e.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                                            e.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                                            i.normalized)
                                        ) {
                                            const t = qc(Ic[i.componentType]);
                                            e.multiplyScalar(t);
                                        }
                                        t.max(e);
                                    } else
                                        console.warn(
                                            'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
                                        );
                                }
                            }
                            r.expandByVector(t);
                        }
                        t.boundingBox = r;
                        const a = new he();
                        r.getCenter(a.center), (a.radius = r.min.distanceTo(r.max) / 2), (t.boundingSphere = a);
                    })(t, e, n),
                    Promise.all(r).then(function () {
                        return void 0 !== e.targets
                            ? (function (t, e, n) {
                                  let i = !1,
                                      r = !1;
                                  for (let t = 0, n = e.length; t < n; t++) {
                                      const n = e[t];
                                      if ((void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), i && r))
                                          break;
                                  }
                                  if (!i && !r) return Promise.resolve(t);
                                  const s = [],
                                      a = [];
                                  for (let o = 0, l = e.length; o < l; o++) {
                                      const l = e[o];
                                      if (i) {
                                          const e =
                                              void 0 !== l.POSITION
                                                  ? n.getDependency('accessor', l.POSITION)
                                                  : t.attributes.position;
                                          s.push(e);
                                      }
                                      if (r) {
                                          const e =
                                              void 0 !== l.NORMAL
                                                  ? n.getDependency('accessor', l.NORMAL)
                                                  : t.attributes.normal;
                                          a.push(e);
                                      }
                                  }
                                  return Promise.all([Promise.all(s), Promise.all(a)]).then(function (e) {
                                      const n = e[0],
                                          s = e[1];
                                      return (
                                          i && (t.morphAttributes.position = n),
                                          r && (t.morphAttributes.normal = s),
                                          (t.morphTargetsRelative = !0),
                                          t
                                      );
                                  });
                              })(t, e.targets, n)
                            : t;
                    })
                );
            }
            function Jc(t, e) {
                let n = t.getIndex();
                if (null === n) {
                    const e = [],
                        i = t.getAttribute('position');
                    if (void 0 === i)
                        return (
                            console.error(
                                'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',
                            ),
                            t
                        );
                    for (let t = 0; t < i.count; t++) e.push(t);
                    t.setIndex(e), (n = t.getIndex());
                }
                const i = n.count - 2,
                    r = [];
                if (2 === e) for (let t = 1; t <= i; t++) r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1));
                else
                    for (let t = 0; t < i; t++)
                        t % 2 == 0
                            ? (r.push(n.getX(t)), r.push(n.getX(t + 1)), r.push(n.getX(t + 2)))
                            : (r.push(n.getX(t + 2)), r.push(n.getX(t + 1)), r.push(n.getX(t)));
                r.length / 3 !== i &&
                    console.error(
                        'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.',
                    );
                const s = t.clone();
                return s.setIndex(r), s;
            }
            class $c {
                constructor(t = 4) {
                    (this.pool = t),
                        (this.queue = []),
                        (this.workers = []),
                        (this.workersResolve = []),
                        (this.workerStatus = 0);
                }
                _initWorker(t) {
                    if (!this.workers[t]) {
                        const e = this.workerCreator();
                        e.addEventListener('message', this._onMessage.bind(this, t)), (this.workers[t] = e);
                    }
                }
                _getIdleWorker() {
                    for (let t = 0; t < this.pool; t++) if (!(this.workerStatus & (1 << t))) return t;
                    return -1;
                }
                _onMessage(t, e) {
                    const n = this.workersResolve[t];
                    if ((n && n(e), this.queue.length)) {
                        const { resolve: e, msg: n, transfer: i } = this.queue.shift();
                        (this.workersResolve[t] = e), this.workers[t].postMessage(n, i);
                    } else this.workerStatus ^= 1 << t;
                }
                setWorkerCreator(t) {
                    this.workerCreator = t;
                }
                setWorkerLimit(t) {
                    this.pool = t;
                }
                postMessage(t, e) {
                    return new Promise((n) => {
                        const i = this._getIdleWorker();
                        -1 !== i
                            ? (this._initWorker(i),
                              (this.workerStatus |= 1 << i),
                              (this.workersResolve[i] = n),
                              this.workers[i].postMessage(t, e))
                            : this.queue.push({ resolve: n, msg: t, transfer: e });
                    });
                }
                dispose() {
                    this.workers.forEach((t) => t.terminate()),
                        (this.workersResolve.length = 0),
                        (this.workers.length = 0),
                        (this.queue.length = 0),
                        (this.workerStatus = 0);
                }
            }
            const Kc = new WeakMap();
            class Qc extends dl {
                constructor(t) {
                    super(t),
                        (this.transcoderPath = ''),
                        (this.transcoderBinary = null),
                        (this.transcoderPending = null),
                        (this.workerPool = new $c()),
                        (this.workerSourceURL = ''),
                        (this.workerConfig = null),
                        'undefined' != typeof MSC_TRANSCODER &&
                            console.warn(
                                'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.',
                            );
                }
                setTranscoderPath(t) {
                    return (this.transcoderPath = t), this;
                }
                setWorkerLimit(t) {
                    return this.workerPool.setWorkerLimit(t), this;
                }
                detectSupport(t) {
                    return (
                        (this.workerConfig = {
                            astcSupported: t.extensions.has('WEBGL_compressed_texture_astc'),
                            etc1Supported: t.extensions.has('WEBGL_compressed_texture_etc1'),
                            etc2Supported: t.extensions.has('WEBGL_compressed_texture_etc'),
                            dxtSupported: t.extensions.has('WEBGL_compressed_texture_s3tc'),
                            bptcSupported: t.extensions.has('EXT_texture_compression_bptc'),
                            pvrtcSupported:
                                t.extensions.has('WEBGL_compressed_texture_pvrtc') ||
                                t.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),
                        }),
                        this
                    );
                }
                dispose() {
                    return (
                        this.workerPool.dispose(),
                        this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                        this
                    );
                }
                init() {
                    if (!this.transcoderPending) {
                        const t = new ml(this.manager);
                        t.setPath(this.transcoderPath), t.setWithCredentials(this.withCredentials);
                        const e = t.loadAsync('basis_transcoder.js'),
                            n = new ml(this.manager);
                        n.setPath(this.transcoderPath),
                            n.setResponseType('arraybuffer'),
                            n.setWithCredentials(this.withCredentials);
                        const i = n.loadAsync('basis_transcoder.wasm');
                        this.transcoderPending = Promise.all([e, i]).then(([t, e]) => {
                            const n = Qc.BasisWorker.toString(),
                                i = [
                                    '/* constants */',
                                    'let _EngineFormat = ' + JSON.stringify(Qc.EngineFormat),
                                    'let _TranscoderFormat = ' + JSON.stringify(Qc.TranscoderFormat),
                                    'let _BasisFormat = ' + JSON.stringify(Qc.BasisFormat),
                                    '/* basis_transcoder.js */',
                                    t,
                                    '/* worker */',
                                    n.substring(n.indexOf('{') + 1, n.lastIndexOf('}')),
                                ].join('\n');
                            (this.workerSourceURL = URL.createObjectURL(new Blob([i]))),
                                (this.transcoderBinary = e),
                                this.workerPool.setWorkerCreator(() => {
                                    const t = new Worker(this.workerSourceURL),
                                        e = this.transcoderBinary.slice(0);
                                    return (
                                        t.postMessage(
                                            { type: 'init', config: this.workerConfig, transcoderBinary: e },
                                            [e],
                                        ),
                                        t
                                    );
                                });
                        });
                    }
                    return this.transcoderPending;
                }
                load(t, e, n, i) {
                    if (null === this.workerConfig)
                        throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.');
                    const r = new ml(this.manager);
                    r.setResponseType('arraybuffer'), r.setWithCredentials(this.withCredentials);
                    const s = new qa();
                    return (
                        r.load(
                            t,
                            (t) => {
                                if (Kc.has(t)) return Kc.get(t).promise.then(e).catch(i);
                                this._createTexture([t])
                                    .then(function (t) {
                                        s.copy(t), (s.needsUpdate = !0), e && e(s);
                                    })
                                    .catch(i);
                            },
                            n,
                            i,
                        ),
                        s
                    );
                }
                _createTextureFrom(t) {
                    const {
                        mipmaps: e,
                        width: n,
                        height: i,
                        format: r,
                        type: s,
                        error: a,
                        dfdTransferFn: o,
                        dfdFlags: l,
                    } = t;
                    if ('error' === s) return Promise.reject(a);
                    const c = new qa(e, n, i, r, 1009);
                    return (
                        (c.minFilter = 1 === e.length ? 1006 : 1008),
                        (c.magFilter = 1006),
                        (c.generateMipmaps = !1),
                        (c.needsUpdate = !0),
                        (c.encoding = 2 === o ? 3001 : 3e3),
                        (c.premultiplyAlpha = !!(1 & l)),
                        c
                    );
                }
                _createTexture(t, e = {}) {
                    const n = e,
                        i = this.init()
                            .then(() =>
                                this.workerPool.postMessage({ type: 'transcode', buffers: t, taskConfig: n }, t),
                            )
                            .then((t) => this._createTextureFrom(t.data));
                    return Kc.set(t[0], { promise: i }), i;
                }
                dispose() {
                    return URL.revokeObjectURL(this.workerSourceURL), this.workerPool.dispose(), this;
                }
            }
            var th, eh;
            (Qc.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }),
                (Qc.TranscoderFormat = {
                    ETC1: 0,
                    ETC2: 1,
                    BC1: 2,
                    BC3: 3,
                    BC4: 4,
                    BC5: 5,
                    BC7_M6_OPAQUE_ONLY: 6,
                    BC7_M5: 7,
                    PVRTC1_4_RGB: 8,
                    PVRTC1_4_RGBA: 9,
                    ASTC_4x4: 10,
                    ATC_RGB: 11,
                    ATC_RGBA_INTERPOLATED_ALPHA: 12,
                    RGBA32: 13,
                    RGB565: 14,
                    BGR565: 15,
                    RGBA4444: 16,
                }),
                (Qc.EngineFormat = {
                    RGBAFormat: 1023,
                    RGBA_ASTC_4x4_Format: 37808,
                    RGBA_BPTC_Format: 36492,
                    RGBA_ETC2_EAC_Format: 37496,
                    RGBA_PVRTC_4BPPV1_Format: 35842,
                    RGBA_S3TC_DXT5_Format: 33779,
                    RGB_ETC1_Format: 36196,
                    RGB_ETC2_Format: 37492,
                    RGB_PVRTC_4BPPV1_Format: 35840,
                    RGB_S3TC_DXT1_Format: 33776,
                }),
                (Qc.BasisWorker = function () {
                    let t, e, n;
                    const i = _EngineFormat,
                        r = _TranscoderFormat,
                        s = _BasisFormat;
                    self.addEventListener('message', function (a) {
                        const h = a.data;
                        switch (h.type) {
                            case 'init':
                                (t = h.config),
                                    (u = h.transcoderBinary),
                                    (e = new Promise((t) => {
                                        (n = { wasmBinary: u, onRuntimeInitialized: t }), BASIS(n);
                                    }).then(() => {
                                        n.initializeBasis(),
                                            void 0 === n.KTX2File &&
                                                console.warn(
                                                    'THREE.KTX2Loader: Please update Basis Universal transcoder.',
                                                );
                                    }));
                                break;
                            case 'transcode':
                                e.then(() => {
                                    try {
                                        const {
                                                width: e,
                                                height: a,
                                                hasAlpha: u,
                                                mipmaps: d,
                                                format: p,
                                                dfdTransferFn: m,
                                                dfdFlags: f,
                                            } = (function (e) {
                                                const a = new n.KTX2File(new Uint8Array(e));
                                                function h() {
                                                    a.close(), a.delete();
                                                }
                                                if (!a.isValid())
                                                    throw (
                                                        (h(),
                                                        new Error(
                                                            'THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file',
                                                        ))
                                                    );
                                                const u = a.isUASTC() ? s.UASTC_4x4 : s.ETC1S,
                                                    d = a.getWidth(),
                                                    p = a.getHeight(),
                                                    m = a.getLevels(),
                                                    f = a.getHasAlpha(),
                                                    g = a.getDFDTransferFunc(),
                                                    v = a.getDFDFlags(),
                                                    { transcoderFormat: y, engineFormat: x } = (function (e, n, a, h) {
                                                        let u, d;
                                                        const p = e === s.ETC1S ? o : l;
                                                        for (let i = 0; i < p.length; i++) {
                                                            const r = p[i];
                                                            if (
                                                                t[r.if] &&
                                                                r.basisFormat.includes(e) &&
                                                                (!r.needsPowerOfTwo || (c(n) && c(a)))
                                                            )
                                                                return (
                                                                    (u = r.transcoderFormat[h ? 1 : 0]),
                                                                    (d = r.engineFormat[h ? 1 : 0]),
                                                                    { transcoderFormat: u, engineFormat: d }
                                                                );
                                                        }
                                                        return (
                                                            console.warn(
                                                                'THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.',
                                                            ),
                                                            (u = r.RGBA32),
                                                            (d = i.RGBAFormat),
                                                            { transcoderFormat: u, engineFormat: d }
                                                        );
                                                    })(u, d, p, f);
                                                if (!d || !p || !m)
                                                    throw (h(), new Error('THREE.KTX2Loader:\tInvalid texture'));
                                                if (!a.startTranscoding())
                                                    throw (
                                                        (h(), new Error('THREE.KTX2Loader: .startTranscoding failed'))
                                                    );
                                                const b = [];
                                                for (let t = 0; t < m; t++) {
                                                    const e = a.getImageLevelInfo(t, 0, 0),
                                                        n = e.origWidth,
                                                        i = e.origHeight,
                                                        r = new Uint8Array(a.getImageTranscodedSizeInBytes(t, 0, 0, y));
                                                    if (!a.transcodeImage(r, t, 0, 0, y, 0, -1, -1))
                                                        throw (
                                                            (h(),
                                                            new Error('THREE.KTX2Loader: .transcodeImage failed.'))
                                                        );
                                                    b.push({ data: r, width: n, height: i });
                                                }
                                                return (
                                                    h(),
                                                    {
                                                        width: d,
                                                        height: p,
                                                        hasAlpha: f,
                                                        mipmaps: b,
                                                        format: x,
                                                        dfdTransferFn: g,
                                                        dfdFlags: v,
                                                    }
                                                );
                                            })(h.buffers[0]),
                                            g = [];
                                        for (let t = 0; t < d.length; ++t) g.push(d[t].data.buffer);
                                        self.postMessage(
                                            {
                                                type: 'transcode',
                                                id: h.id,
                                                width: e,
                                                height: a,
                                                hasAlpha: u,
                                                mipmaps: d,
                                                format: p,
                                                dfdTransferFn: m,
                                                dfdFlags: f,
                                            },
                                            g,
                                        );
                                    } catch (t) {
                                        console.error(t),
                                            self.postMessage({ type: 'error', id: h.id, error: t.message });
                                    }
                                });
                        }
                        var u;
                    });
                    const a = [
                            {
                                if: 'astcSupported',
                                basisFormat: [s.UASTC_4x4],
                                transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4],
                                engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
                                priorityETC1S: 1 / 0,
                                priorityUASTC: 1,
                                needsPowerOfTwo: !1,
                            },
                            {
                                if: 'bptcSupported',
                                basisFormat: [s.ETC1S, s.UASTC_4x4],
                                transcoderFormat: [r.BC7_M5, r.BC7_M5],
                                engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
                                priorityETC1S: 3,
                                priorityUASTC: 2,
                                needsPowerOfTwo: !1,
                            },
                            {
                                if: 'dxtSupported',
                                basisFormat: [s.ETC1S, s.UASTC_4x4],
                                transcoderFormat: [r.BC1, r.BC3],
                                engineFormat: [i.RGB_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
                                priorityETC1S: 4,
                                priorityUASTC: 5,
                                needsPowerOfTwo: !1,
                            },
                            {
                                if: 'etc2Supported',
                                basisFormat: [s.ETC1S, s.UASTC_4x4],
                                transcoderFormat: [r.ETC1, r.ETC2],
                                engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
                                priorityETC1S: 1,
                                priorityUASTC: 3,
                                needsPowerOfTwo: !1,
                            },
                            {
                                if: 'etc1Supported',
                                basisFormat: [s.ETC1S, s.UASTC_4x4],
                                transcoderFormat: [r.ETC1, r.ETC1],
                                engineFormat: [i.RGB_ETC1_Format, i.RGB_ETC1_Format],
                                priorityETC1S: 2,
                                priorityUASTC: 4,
                                needsPowerOfTwo: !1,
                            },
                            {
                                if: 'pvrtcSupported',
                                basisFormat: [s.ETC1S, s.UASTC_4x4],
                                transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA],
                                engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
                                priorityETC1S: 5,
                                priorityUASTC: 6,
                                needsPowerOfTwo: !0,
                            },
                        ],
                        o = a.sort(function (t, e) {
                            return t.priorityETC1S - e.priorityETC1S;
                        }),
                        l = a.sort(function (t, e) {
                            return t.priorityUASTC - e.priorityUASTC;
                        });
                    function c(t) {
                        return t <= 2 || (0 == (t & (t - 1)) && 0 !== t);
                    }
                });
            const nh = Symbol('retainerCount'),
                ih = Symbol('recentlyUsed'),
                rh = Symbol('evict'),
                sh = Symbol('evictionThreshold'),
                ah = Symbol('cache');
            class oh {
                constructor(t, e = 5) {
                    (this[th] = new Map()), (this[eh] = []), (this[ah] = t), (this[sh] = e);
                }
                set evictionThreshold(t) {
                    (this[sh] = t), this[rh]();
                }
                get evictionThreshold() {
                    return this[sh];
                }
                get cache() {
                    return this[ah];
                }
                retainerCount(t) {
                    return this[nh].get(t) || 0;
                }
                reset() {
                    this[nh].clear(), (this[ih] = []);
                }
                retain(t) {
                    this[nh].has(t) || this[nh].set(t, 0), this[nh].set(t, this[nh].get(t) + 1);
                    const e = this[ih].indexOf(t);
                    -1 !== e && this[ih].splice(e, 1), this[ih].unshift(t), this[rh]();
                }
                release(t) {
                    this[nh].has(t) && this[nh].set(t, Math.max(this[nh].get(t) - 1, 0)), this[rh]();
                }
                [((th = nh), (eh = ih), rh)]() {
                    if (!(this[ih].length < this[sh]))
                        for (let t = this[ih].length - 1; t >= this[sh]; --t) {
                            const e = this[ih][t];
                            0 === this[nh].get(e) && (this[ah].delete(e), this[ih].splice(t, 1));
                        }
                }
            }
            const lh = (t, e) => {
                const n = new Map();
                for (const i of t.mappings)
                    for (const t of i.variants) n.set(e[t], { material: null, gltfMaterialIndex: i.material });
                return n;
            };
            class ch {
                constructor(t) {
                    (this.parser = t), (this.name = 'KHR_materials_variants');
                }
                afterRoot(t) {
                    const e = this.parser,
                        n = e.json;
                    if (void 0 === n.extensions || void 0 === n.extensions[this.name]) return null;
                    const i = ((t) => {
                        const e = [],
                            n = new Set();
                        for (const i of t) {
                            let t = i,
                                r = 0;
                            for (; n.has(t); ) t = i + '.' + ++r;
                            n.add(t), e.push(t);
                        }
                        return e;
                    })((n.extensions[this.name].variants || []).map((t) => t.name));
                    for (const r of t.scenes)
                        r.traverse((t) => {
                            const r = e.associations.get(t);
                            if (null == r || null == r.meshes) return;
                            const s = r.meshes,
                                a = n.meshes[s].primitives,
                                o = 'isMesh' in t ? [t] : t.children;
                            for (let t = 0; t < a.length; t++) {
                                const e = a[t].extensions;
                                e && e[this.name] && (o[t].userData.variantMaterials = lh(e[this.name], i));
                            }
                        });
                    return (t.userData.variants = i), Promise.resolve();
                }
            }
            var hh, uh;
            const dh = new Map(),
                ph = new Map();
            let mh;
            const fh = new (class extends dl {
                constructor(t) {
                    super(t),
                        (this.decoderPath = ''),
                        (this.decoderConfig = {}),
                        (this.decoderBinary = null),
                        (this.decoderPending = null),
                        (this.workerLimit = 4),
                        (this.workerPool = []),
                        (this.workerNextTaskID = 1),
                        (this.workerSourceURL = ''),
                        (this.defaultAttributeIDs = {
                            position: 'POSITION',
                            normal: 'NORMAL',
                            color: 'COLOR',
                            uv: 'TEX_COORD',
                        }),
                        (this.defaultAttributeTypes = {
                            position: 'Float32Array',
                            normal: 'Float32Array',
                            color: 'Float32Array',
                            uv: 'Float32Array',
                        });
                }
                setDecoderPath(t) {
                    return (this.decoderPath = t), this;
                }
                setDecoderConfig(t) {
                    return (this.decoderConfig = t), this;
                }
                setWorkerLimit(t) {
                    return (this.workerLimit = t), this;
                }
                load(t, e, n, i) {
                    const r = new ml(this.manager);
                    r.setPath(this.path),
                        r.setResponseType('arraybuffer'),
                        r.setRequestHeader(this.requestHeader),
                        r.setWithCredentials(this.withCredentials),
                        r.load(
                            t,
                            (t) => {
                                const n = {
                                    attributeIDs: this.defaultAttributeIDs,
                                    attributeTypes: this.defaultAttributeTypes,
                                    useUniqueIDs: !1,
                                };
                                this.decodeGeometry(t, n).then(e).catch(i);
                            },
                            n,
                            i,
                        );
                }
                decodeDracoFile(t, e, n, i) {
                    const r = {
                        attributeIDs: n || this.defaultAttributeIDs,
                        attributeTypes: i || this.defaultAttributeTypes,
                        useUniqueIDs: !!n,
                    };
                    this.decodeGeometry(t, r).then(e);
                }
                decodeGeometry(t, e) {
                    for (const t in e.attributeTypes) {
                        const n = e.attributeTypes[t];
                        void 0 !== n.BYTES_PER_ELEMENT && (e.attributeTypes[t] = n.name);
                    }
                    const n = JSON.stringify(e);
                    if (oc.has(t)) {
                        const e = oc.get(t);
                        if (e.key === n) return e.promise;
                        if (0 === t.byteLength)
                            throw new Error(
                                'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.',
                            );
                    }
                    let i;
                    const r = this.workerNextTaskID++,
                        s = t.byteLength,
                        a = this._getWorker(r, s)
                            .then(
                                (n) => (
                                    (i = n),
                                    new Promise((n, s) => {
                                        (i._callbacks[r] = { resolve: n, reject: s }),
                                            i.postMessage({ type: 'decode', id: r, taskConfig: e, buffer: t }, [t]);
                                    })
                                ),
                            )
                            .then((t) => this._createGeometry(t.geometry));
                    return (
                        a
                            .catch(() => !0)
                            .then(() => {
                                i && r && this._releaseTask(i, r);
                            }),
                        oc.set(t, { key: n, promise: a }),
                        a
                    );
                }
                _createGeometry(t) {
                    const e = new En();
                    t.index && e.setIndex(new fn(t.index.array, 1));
                    for (let n = 0; n < t.attributes.length; n++) {
                        const i = t.attributes[n],
                            r = i.name,
                            s = i.array,
                            a = i.itemSize;
                        e.setAttribute(r, new fn(s, a));
                    }
                    return e;
                }
                _loadLibrary(t, e) {
                    const n = new ml(this.manager);
                    return (
                        n.setPath(this.decoderPath),
                        n.setResponseType(e),
                        n.setWithCredentials(this.withCredentials),
                        new Promise((e, i) => {
                            n.load(t, e, void 0, i);
                        })
                    );
                }
                preload() {
                    return this._initDecoder(), this;
                }
                _initDecoder() {
                    if (this.decoderPending) return this.decoderPending;
                    const t = 'object' != typeof WebAssembly || 'js' === this.decoderConfig.type,
                        e = [];
                    return (
                        t
                            ? e.push(this._loadLibrary('draco_decoder.js', 'text'))
                            : (e.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
                              e.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))),
                        (this.decoderPending = Promise.all(e).then((e) => {
                            const n = e[0];
                            t || (this.decoderConfig.wasmBinary = e[1]);
                            const i = lc.toString(),
                                r = [
                                    '/* draco decoder */',
                                    n,
                                    '',
                                    '/* worker */',
                                    i.substring(i.indexOf('{') + 1, i.lastIndexOf('}')),
                                ].join('\n');
                            this.workerSourceURL = URL.createObjectURL(new Blob([r]));
                        })),
                        this.decoderPending
                    );
                }
                _getWorker(t, e) {
                    return this._initDecoder().then(() => {
                        if (this.workerPool.length < this.workerLimit) {
                            const t = new Worker(this.workerSourceURL);
                            (t._callbacks = {}),
                                (t._taskCosts = {}),
                                (t._taskLoad = 0),
                                t.postMessage({ type: 'init', decoderConfig: this.decoderConfig }),
                                (t.onmessage = function (e) {
                                    const n = e.data;
                                    switch (n.type) {
                                        case 'decode':
                                            t._callbacks[n.id].resolve(n);
                                            break;
                                        case 'error':
                                            t._callbacks[n.id].reject(n);
                                            break;
                                        default:
                                            console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"');
                                    }
                                }),
                                this.workerPool.push(t);
                        } else
                            this.workerPool.sort(function (t, e) {
                                return t._taskLoad > e._taskLoad ? -1 : 1;
                            });
                        const n = this.workerPool[this.workerPool.length - 1];
                        return (n._taskCosts[t] = e), (n._taskLoad += e), n;
                    });
                }
                _releaseTask(t, e) {
                    (t._taskLoad -= t._taskCosts[e]), delete t._callbacks[e], delete t._taskCosts[e];
                }
                debug() {
                    console.log(
                        'Task load: ',
                        this.workerPool.map((t) => t._taskLoad),
                    );
                }
                dispose() {
                    for (let t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate();
                    return (this.workerPool.length = 0), this;
                }
            })();
            let gh;
            const vh = new Qc();
            let yh, xh;
            const bh = Symbol('loader'),
                wh = Symbol('evictionPolicy'),
                _h = Symbol('GLTFInstance');
            class Mh extends ft {
                constructor(t) {
                    super(),
                        (this[uh] = new cc().register((t) => new ch(t))),
                        (this[_h] = t),
                        this[bh].setDRACOLoader(fh),
                        this[bh].setKTX2Loader(vh);
                }
                static setDRACODecoderLocation(t) {
                    (mh = t), fh.setDecoderPath(t);
                }
                static getDRACODecoderLocation() {
                    return mh;
                }
                static setKTX2TranscoderLocation(t) {
                    (gh = t), vh.setTranscoderPath(t);
                }
                static getKTX2TranscoderLocation() {
                    return gh;
                }
                static setMeshoptDecoderLocation(t) {
                    var e;
                    yh !== t &&
                        ((yh = t),
                        (xh = ((e = t),
                        new Promise((t, n) => {
                            const i = document.createElement('script');
                            document.body.appendChild(i), (i.onload = t), (i.onerror = n), (i.async = !0), (i.src = e);
                        }))
                            .then(() => MeshoptDecoder.ready)
                            .then(() => MeshoptDecoder)));
                }
                static getMeshoptDecoderLocation() {
                    return yh;
                }
                static initializeKTX2Loader(t) {
                    vh.detectSupport(t);
                }
                static get cache() {
                    return dh;
                }
                static clearCache() {
                    dh.forEach((t, e) => {
                        this.delete(e);
                    }),
                        this[wh].reset();
                }
                static has(t) {
                    return dh.has(t);
                }
                static async delete(t) {
                    if (!this.has(t)) return;
                    const e = dh.get(t);
                    ph.delete(t), dh.delete(t), (await e).dispose();
                }
                static hasFinishedLoading(t) {
                    return !!ph.get(t);
                }
                get [((hh = wh), (uh = bh), wh)]() {
                    return this.constructor[wh];
                }
                async preload(t, e, n = () => {}) {
                    if ((this.dispatchEvent({ type: 'preload', element: e, src: t }), !dh.has(t))) {
                        null != xh && this[bh].setMeshoptDecoder(await xh);
                        const e = ((t, e, n = () => {}) => {
                                const i = (t) => {
                                    const e = t.loaded / t.total;
                                    n(Math.max(0, Math.min(1, isFinite(e) ? e : 1)));
                                };
                                return new Promise((n, r) => {
                                    e.load(t, n, i, r);
                                });
                            })(t, this[bh], (t) => {
                                n(0.8 * t);
                            }),
                            i = this[_h],
                            r = e.then((t) => i.prepare(t)).then((t) => (n(0.9), new i(t)));
                        dh.set(t, r);
                    }
                    await dh.get(t), ph.set(t, !0), n && n(1);
                }
                async load(t, e, n = () => {}) {
                    await this.preload(t, e, n);
                    const i = await dh.get(t),
                        r = await i.clone();
                    return (
                        this[wh].retain(t),
                        (r.dispose = (() => {
                            const e = r.dispose;
                            let n = !1;
                            return () => {
                                n || ((n = !0), e.apply(r), this[wh].release(t));
                            };
                        })()),
                        r
                    );
                }
            }
            Mh[hh] = new oh(Mh);
            class Sh extends We {
                constructor(t) {
                    super(),
                        (this.element = t || document.createElement('div')),
                        (this.element.style.position = 'absolute'),
                        (this.element.style.userSelect = 'none'),
                        this.element.setAttribute('draggable', !1),
                        this.addEventListener('removed', function () {
                            this.traverse(function (t) {
                                t.element instanceof Element &&
                                    null !== t.element.parentNode &&
                                    t.element.parentNode.removeChild(t.element);
                            });
                        });
                }
                copy(t, e) {
                    return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this;
                }
            }
            Sh.prototype.isCSS2DObject = !0;
            const Th = new Gt(),
                Eh = new xe(),
                Ah = new xe(),
                Lh = new Gt(),
                Rh = new Gt();
            class Ch {
                constructor() {
                    const t = this;
                    let e, n, i, r;
                    const s = { objects: new WeakMap() },
                        a = document.createElement('div');
                    function o(e, n, c) {
                        if (e.isCSS2DObject) {
                            e.onBeforeRender(t, n, c), Th.setFromMatrixPosition(e.matrixWorld), Th.applyMatrix4(Ah);
                            const o = e.element;
                            /apple/i.test(navigator.vendor)
                                ? (o.style.transform =
                                      'translate(-50%,-50%) translate(' +
                                      Math.round(Th.x * i + i) +
                                      'px,' +
                                      Math.round(-Th.y * r + r) +
                                      'px)')
                                : (o.style.transform =
                                      'translate(-50%,-50%) translate(' +
                                      (Th.x * i + i) +
                                      'px,' +
                                      (-Th.y * r + r) +
                                      'px)'),
                                (o.style.display = e.visible && Th.z >= -1 && Th.z <= 1 ? '' : 'none');
                            const h = { distanceToCameraSquared: l(c, e) };
                            s.objects.set(e, h), o.parentNode !== a && a.appendChild(o), e.onAfterRender(t, n, c);
                        }
                        for (let t = 0, i = e.children.length; t < i; t++) o(e.children[t], n, c);
                    }
                    function l(t, e) {
                        return (
                            Lh.setFromMatrixPosition(t.matrixWorld),
                            Rh.setFromMatrixPosition(e.matrixWorld),
                            Lh.distanceToSquared(Rh)
                        );
                    }
                    (a.style.overflow = 'hidden'),
                        (this.domElement = a),
                        (this.getSize = function () {
                            return { width: e, height: n };
                        }),
                        (this.render = function (t, e) {
                            !0 === t.autoUpdate && t.updateMatrixWorld(),
                                null === e.parent && e.updateMatrixWorld(),
                                Eh.copy(e.matrixWorldInverse),
                                Ah.multiplyMatrices(e.projectionMatrix, Eh),
                                o(t, t, e),
                                (function (t) {
                                    const e = (function (t) {
                                            const e = [];
                                            return (
                                                t.traverse(function (t) {
                                                    t.isCSS2DObject && e.push(t);
                                                }),
                                                e
                                            );
                                        })(t).sort(function (t, e) {
                                            return (
                                                s.objects.get(t).distanceToCameraSquared -
                                                s.objects.get(e).distanceToCameraSquared
                                            );
                                        }),
                                        n = e.length;
                                    for (let t = 0, i = e.length; t < i; t++) e[t].element.style.zIndex = n - t;
                                })(t);
                        }),
                        (this.setSize = function (t, s) {
                            (e = t),
                                (n = s),
                                (i = e / 2),
                                (r = n / 2),
                                (a.style.width = t + 'px'),
                                (a.style.height = s + 'px');
                        });
                }
            }
            const Ph = (t) => (t && 'null' !== t ? Dh(t) : null),
                Ih = () => {
                    if (ot) return;
                    const t = [];
                    throw (
                        (it || t.push('WebXR Device API'),
                        rt || t.push('WebXR Hit Test API'),
                        new Error(
                            `The following APIs are required for AR, but are missing in this browser: ${t.join(', ')}`,
                        ))
                    );
                },
                Dh = (t) => new URL(t, window.location.toString()).toString(),
                Nh = (t, e) => {
                    let n = null;
                    return (...i) => {
                        null != n && self.clearTimeout(n),
                            (n = self.setTimeout(() => {
                                (n = null), t(...i);
                            }, e));
                    };
                },
                Fh = (t, e, n) => Math.max(e, Math.min(n, t)),
                Oh = (() => {
                    const t = (() => {
                        const t = null != document.head ? Array.from(document.head.querySelectorAll('meta')) : [];
                        for (const e of t) if ('viewport' === e.name) return !0;
                        return !1;
                    })();
                    return (
                        t ||
                            console.warn(
                                'No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.',
                            ),
                        () => (t ? window.devicePixelRatio : 1)
                    );
                })(),
                Uh = (() => {
                    const t = new RegExp('[?&]model-viewer-debug-mode(&|$)');
                    return () =>
                        (self.ModelViewerElement && self.ModelViewerElement.debugMode) ||
                        (self.location && self.location.search && self.location.search.match(t));
                })(),
                kh = (t = 0) => new Promise((e) => setTimeout(e, t));
            class zh {
                constructor(t = 50) {
                    (this.velocity = 0), (this.naturalFrequency = 0), this.setDecayTime(t);
                }
                setDecayTime(t) {
                    this.naturalFrequency = 1 / Math.max(0.001, t);
                }
                update(t, e, n, i) {
                    const r = 2e-4 * this.naturalFrequency;
                    if (null == t || 0 === i) return e;
                    if (t === e && 0 === this.velocity) return e;
                    if (n < 0) return t;
                    const s = t - e,
                        a = this.velocity + this.naturalFrequency * s,
                        o = s + n * a,
                        l = Math.exp(-this.naturalFrequency * n),
                        c = (a - this.naturalFrequency * o) * l,
                        h = -this.naturalFrequency * (c + a * l);
                    return Math.abs(c) < r * Math.abs(i) && h * s >= 0
                        ? ((this.velocity = 0), e)
                        : ((this.velocity = c), e + o * l);
                }
            }
            const Bh = (t, e) => ({ type: 'number', number: t, unit: e }),
                Hh = (() => {
                    const t = {};
                    return (e) => {
                        const n = e;
                        if (n in t) return t[n];
                        const i = [];
                        let r = 0;
                        for (; e; ) {
                            if (++r > 1e3) {
                                e = '';
                                break;
                            }
                            const t = Gh(e),
                                n = t.nodes[0];
                            if (null == n || 0 === n.terms.length) break;
                            i.push(n), (e = t.remainingInput);
                        }
                        return (t[n] = i);
                    };
                })(),
                Gh = (() => {
                    const t = /^(\-\-|[a-z\u0240-\uffff])/i,
                        e = /^([\*\+\/]|[\-]\s)/i,
                        n = /^[\),]/;
                    return (i) => {
                        const r = [];
                        for (; i.length && ((i = i.trim()), !n.test(i)); )
                            if ('(' === i[0]) {
                                const { nodes: t, remainingInput: e } = qh(i);
                                (i = e),
                                    r.push({ type: 'function', name: { type: 'ident', value: 'calc' }, arguments: t });
                            } else if (t.test(i)) {
                                const t = Vh(i),
                                    e = t.nodes[0];
                                if ('(' === (i = t.remainingInput)[0]) {
                                    const { nodes: t, remainingInput: n } = qh(i);
                                    r.push({ type: 'function', name: e, arguments: t }), (i = n);
                                } else r.push(e);
                            } else if (e.test(i)) r.push({ type: 'operator', value: i[0] }), (i = i.slice(1));
                            else {
                                const { nodes: t, remainingInput: e } = '#' === i[0] ? jh(i) : Wh(i);
                                if (0 === t.length) break;
                                r.push(t[0]), (i = e);
                            }
                        return { nodes: [{ type: 'expression', terms: r }], remainingInput: i };
                    };
                })(),
                Vh = (() => {
                    const t = /[^a-z0-9_\-\u0240-\uffff]/i;
                    return (e) => {
                        const n = e.match(t);
                        return {
                            nodes: [{ type: 'ident', value: null == n ? e : e.substr(0, n.index) }],
                            remainingInput: null == n ? '' : e.substr(n.index),
                        };
                    };
                })(),
                Wh = (() => {
                    const t = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,
                        e = /^[a-z%]+/i,
                        n = /^(m|mm|cm|rad|deg|[%])$/;
                    return (i) => {
                        const r = i.match(t),
                            s = null == r ? '0' : r[0],
                            a = (i = null == s ? i : i.slice(s.length)).match(e);
                        let o = null != a && '' !== a[0] ? a[0] : null;
                        const l = null == a ? i : i.slice(o.length);
                        return (
                            null == o || n.test(o) || (o = null),
                            { nodes: [{ type: 'number', number: parseFloat(s) || 0, unit: o }], remainingInput: l }
                        );
                    };
                })(),
                jh = (() => {
                    const t = /^[a-f0-9]*/i;
                    return (e) => {
                        const n = (e = e.slice(1).trim()).match(t);
                        return {
                            nodes: null == n ? [] : [{ type: 'hex', value: n[0] }],
                            remainingInput: null == n ? e : e.slice(n[0].length),
                        };
                    };
                })(),
                qh = (t) => {
                    const e = [];
                    for (t = t.slice(1).trim(); t.length; ) {
                        const n = Gh(t);
                        if ((e.push(n.nodes[0]), ',' === (t = n.remainingInput.trim())[0])) t = t.slice(1).trim();
                        else if (')' === t[0]) {
                            t = t.slice(1);
                            break;
                        }
                    }
                    return { nodes: e, remainingInput: t };
                },
                Xh = Symbol('visitedTypes');
            class Yh {
                constructor(t) {
                    this[Xh] = t;
                }
                walk(t, e) {
                    const n = t.slice();
                    for (; n.length; ) {
                        const t = n.shift();
                        switch ((this[Xh].indexOf(t.type) > -1 && e(t), t.type)) {
                            case 'expression':
                                n.unshift(...t.terms);
                                break;
                            case 'function':
                                n.unshift(t.name, ...t.arguments);
                        }
                    }
                }
            }
            const Zh = Object.freeze({ type: 'number', number: 0, unit: null }),
                Jh = (t, e = 0) => {
                    let { number: n, unit: i } = t;
                    if (isFinite(n)) {
                        if ('rad' === t.unit || null == t.unit) return t;
                    } else (n = e), (i = 'rad');
                    return {
                        type: 'number',
                        number: (('deg' === i && null != n ? n : 0) * Math.PI) / 180,
                        unit: 'rad',
                    };
                },
                $h = (t, e = 0) => {
                    let n,
                        { number: i, unit: r } = t;
                    if (isFinite(i)) {
                        if ('m' === t.unit) return t;
                    } else (i = e), (r = 'm');
                    switch (r) {
                        default:
                            n = 1;
                            break;
                        case 'cm':
                            n = 0.01;
                            break;
                        case 'mm':
                            n = 0.001;
                    }
                    return { type: 'number', number: n * i, unit: 'm' };
                },
                Kh = (() => {
                    const t = (t) => t,
                        e = { rad: t, deg: Jh, m: t, mm: $h, cm: $h };
                    return (t, n = Zh) => {
                        isFinite(t.number) || ((t.number = n.number), (t.unit = n.unit));
                        const { unit: i } = t;
                        if (null == i) return t;
                        const r = e[i];
                        return null == r ? n : r(t);
                    };
                })();
            class Qh extends Sh {
                constructor(t) {
                    super(document.createElement('div')),
                        (this.normal = new Gt(0, 1, 0)),
                        (this.initialized = !1),
                        (this.referenceCount = 1),
                        (this.pivot = document.createElement('div')),
                        (this.slot = document.createElement('slot')),
                        this.element.classList.add('annotation-wrapper'),
                        (this.slot.name = t.name),
                        this.element.appendChild(this.pivot),
                        this.pivot.appendChild(this.slot),
                        this.updatePosition(t.position),
                        this.updateNormal(t.normal);
                }
                get facingCamera() {
                    return !this.element.classList.contains('hide');
                }
                show() {
                    (this.facingCamera && this.initialized) || this.updateVisibility(!0);
                }
                hide() {
                    (!this.facingCamera && this.initialized) || this.updateVisibility(!1);
                }
                increment() {
                    this.referenceCount++;
                }
                decrement() {
                    return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount;
                }
                updatePosition(t) {
                    if (null == t) return;
                    const e = Hh(t)[0].terms;
                    for (let t = 0; t < 3; ++t) this.position.setComponent(t, Kh(e[t]).number);
                    this.updateMatrixWorld();
                }
                updateNormal(t) {
                    if (null == t) return;
                    const e = Hh(t)[0].terms;
                    for (let t = 0; t < 3; ++t) this.normal.setComponent(t, Kh(e[t]).number);
                }
                orient(t) {
                    this.pivot.style.transform = `rotate(${t}rad)`;
                }
                updateVisibility(t) {
                    t ? this.element.classList.remove('hide') : this.element.classList.add('hide'),
                        this.slot.assignedNodes().forEach((e) => {
                            if (e.nodeType !== Node.ELEMENT_NODE) return;
                            const n = e,
                                i = n.dataset.visibilityAttribute;
                            if (null != i) {
                                const e = `data-${i}`;
                                t ? n.setAttribute(e, '') : n.removeAttribute(e);
                            }
                            n.dispatchEvent(new CustomEvent('hotspot-visibility', { detail: { visible: t } }));
                        }),
                        (this.initialized = !0);
                }
            }
            const tu = (t, e, n) => {
                let i = n;
                const r = new Gt();
                return (
                    t.traverse((t) => {
                        let n, s;
                        t.updateWorldMatrix(!1, !1);
                        const a = t.geometry;
                        if (void 0 !== a)
                            if (a.isGeometry) {
                                const o = a.vertices;
                                for (n = 0, s = o.length; n < s; n++)
                                    r.copy(o[n]), r.applyMatrix4(t.matrixWorld), (i = e(i, r));
                            } else if (a.isBufferGeometry) {
                                const { position: o } = a.attributes;
                                if (void 0 !== o) {
                                    const a = ((t) => {
                                        if (!t.normalized) return 1;
                                        const e = t.array;
                                        return e instanceof Int8Array
                                            ? 1 / 127
                                            : e instanceof Uint8Array
                                            ? 1 / 255
                                            : e instanceof Int16Array
                                            ? 1 / 32767
                                            : e instanceof Uint16Array
                                            ? 1 / 65535
                                            : 1;
                                    })(o);
                                    for (n = 0, s = o.count; n < s; n++)
                                        r.fromBufferAttribute(o, n),
                                            r.multiplyScalar(a),
                                            r.applyMatrix4(t.matrixWorld),
                                            (i = e(i, r));
                                }
                            }
                    }),
                    i
                );
            };
            class eu extends Il {
                constructor(t, e, n) {
                    super(),
                        (this.shadowMaterial = new qo()),
                        (this.boundingBox = new jt()),
                        (this.size = new Gt()),
                        (this.shadowScale = 1),
                        (this.isAnimated = !1),
                        (this.side = 'bottom'),
                        (this.needsUpdate = !1),
                        (this.intensity = 0),
                        (this.castShadow = !0),
                        (this.frustumCulled = !1),
                        (this.floor = new Wn(new ui(), this.shadowMaterial)),
                        this.floor.rotateX(-Math.PI / 2),
                        (this.floor.receiveShadow = !0),
                        (this.floor.castShadow = !1),
                        (this.floor.frustumCulled = !1),
                        this.add(this.floor),
                        t.target.add(this),
                        (this.target = t.target),
                        this.setScene(t, e, n);
                }
                setScene(t, e, n) {
                    if (
                        ((this.side = n),
                        (this.isAnimated = t.animationNames.length > 0),
                        this.boundingBox.copy(t.boundingBox),
                        this.size.copy(t.size),
                        'back' === this.side)
                    ) {
                        const { min: t, max: e } = this.boundingBox;
                        ([t.y, t.z] = [t.z, t.y]),
                            ([e.y, e.z] = [e.z, e.y]),
                            ([this.size.y, this.size.z] = [this.size.z, this.size.y]),
                            (this.rotation.x = Math.PI / 2),
                            (this.rotation.y = Math.PI);
                    } else (this.rotation.x = 0), (this.rotation.y = 0);
                    const { boundingBox: i, size: r } = this;
                    if (this.isAnimated) {
                        const t = 2 * Math.max(r.x, r.y, r.z);
                        (r.y = t),
                            i.expandByVector(r.subScalar(t).multiplyScalar(-0.5)),
                            (i.max.y = i.min.y + t),
                            r.set(t, t, t);
                    }
                    i.getCenter(this.floor.position);
                    const s = i.max.y + 0.002 * r.y;
                    'bottom' === n
                        ? ((this.position.y = s), (this.position.z = 0))
                        : ((this.position.y = 0), (this.position.z = s)),
                        this.setSoftness(e);
                }
                setSoftness(t) {
                    const e = Math.pow(2, 9 - 3 * t);
                    this.setMapSize(e);
                }
                setMapSize(t) {
                    const { camera: e, mapSize: n, map: i } = this.shadow,
                        { size: r, boundingBox: s } = this;
                    null != i && (i.dispose(), (this.shadow.map = null)), this.isAnimated && (t *= 2);
                    const a = Math.floor(r.x > r.z ? t : (t * r.x) / r.z),
                        o = Math.floor(r.x > r.z ? (t * r.z) / r.x : t);
                    n.set(a, o);
                    const l = (2.5 * r.x) / a,
                        c = (2.5 * r.z) / o;
                    (e.left = -s.max.x - l),
                        (e.right = -s.min.x + l),
                        (e.bottom = s.min.z - c),
                        (e.top = s.max.z + c),
                        this.setScaleAndOffset(this.shadowScale, 0),
                        this.floor.scale.set(r.x + 2 * l, r.z + 2 * c, 1),
                        (this.needsUpdate = !0),
                        (this.shadow.needsUpdate = !0);
                }
                setIntensity(t) {
                    (this.shadowMaterial.opacity = t),
                        t > 0
                            ? ((this.visible = !0), (this.floor.visible = !0))
                            : ((this.visible = !1), (this.floor.visible = !1));
                }
                getIntensity() {
                    return this.shadowMaterial.opacity;
                }
                setRotation(t) {
                    if ('bottom' !== this.side)
                        return this.shadow.camera.up.set(0, 1, 0), void this.shadow.updateMatrices(this);
                    this.shadow.camera.up.set(Math.sin(t), 0, Math.cos(t)), this.shadow.updateMatrices(this);
                }
                setScaleAndOffset(t, e) {
                    const n = this.size.y,
                        { camera: i } = this.shadow;
                    (this.shadowScale = t),
                        (i.near = 0),
                        (i.far = n - e / t),
                        i.updateProjectionMatrix(),
                        i.scale.setScalar(t);
                    const r = 0.002 * n;
                    this.floor.position.y = 2 * r - i.far;
                }
            }
            const nu = (22.5 * Math.PI) / 180,
                iu = Math.sin(nu),
                ru = Math.tan(nu),
                su = new Gt(),
                au = new Gt(),
                ou = new Gt(),
                lu = new (class {
                    constructor(t, e, n = 0, i = 1 / 0) {
                        (this.ray = new ye(t, e)),
                            (this.near = n),
                            (this.far = i),
                            (this.camera = null),
                            (this.layers = new Ce()),
                            (this.params = {
                                Mesh: {},
                                Line: { threshold: 1 },
                                LOD: {},
                                Points: { threshold: 1 },
                                Sprite: {},
                            });
                    }
                    set(t, e) {
                        this.ray.set(t, e);
                    }
                    setFromCamera(t, e) {
                        e && e.isPerspectiveCamera
                            ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                              this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(),
                              (this.camera = e))
                            : e && e.isOrthographicCamera
                            ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                              this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                              (this.camera = e))
                            : console.error('THREE.Raycaster: Unsupported camera type: ' + e.type);
                    }
                    intersectObject(t, e = !0, n = []) {
                        return Kl(t, this, n, e), n.sort($l), n;
                    }
                    intersectObjects(t, e = !0, n = []) {
                        for (let i = 0, r = t.length; i < r; i++) Kl(t[i], this, n, e);
                        return n.sort($l), n;
                    }
                })(),
                cu = new Gt(),
                hu = new Rt();
            class uu extends Xs {
                constructor({ canvas: t, element: e, width: n, height: i }) {
                    super(),
                        (this.context = null),
                        (this.annotationRenderer = new Ch()),
                        (this.schemaElement = document.createElement('script')),
                        (this.width = 1),
                        (this.height = 1),
                        (this.aspect = 1),
                        (this.renderCount = 0),
                        (this.externalRenderer = null),
                        (this.camera = new Kn(45, 1, 0.1, 100)),
                        (this.xrCamera = null),
                        (this.url = null),
                        (this.target = new We()),
                        (this.modelContainer = new We()),
                        (this.animationNames = []),
                        (this.boundingBox = new jt()),
                        (this.size = new Gt()),
                        (this.idealCameraDistance = 0),
                        (this.fieldOfViewAspect = 0),
                        (this.framedFieldOfView = 45),
                        (this.shadow = null),
                        (this.shadowIntensity = 0),
                        (this.shadowSoftness = 1),
                        (this.exposure = 1),
                        (this.canScale = !0),
                        (this.tightBounds = !1),
                        (this.isDirty = !1),
                        (this.goalTarget = new Gt()),
                        (this.targetDamperX = new zh()),
                        (this.targetDamperY = new zh()),
                        (this.targetDamperZ = new zh()),
                        (this._currentGLTF = null),
                        (this.cancelPendingSourceChange = null),
                        (this.animationsByName = new Map()),
                        (this.currentAnimationAction = null),
                        (this.name = 'ModelScene'),
                        (this.element = e),
                        (this.canvas = t),
                        (this.camera = new Kn(45, 1, 0.1, 100)),
                        (this.camera.name = 'MainCamera'),
                        this.add(this.target),
                        this.setSize(n, i),
                        (this.target.name = 'Target'),
                        (this.modelContainer.name = 'ModelContainer'),
                        this.target.add(this.modelContainer),
                        (this.mixer = new Jl(this.modelContainer));
                    const { domElement: r } = this.annotationRenderer,
                        { style: s } = r;
                    (s.display = 'none'),
                        (s.pointerEvents = 'none'),
                        (s.position = 'absolute'),
                        (s.top = '0'),
                        this.element.shadowRoot.querySelector('.default').appendChild(r),
                        this.schemaElement.setAttribute('type', 'application/ld+json');
                }
                createContext() {
                    this.context = this.canvas.getContext('2d');
                }
                getCamera() {
                    return null != this.xrCamera ? this.xrCamera : this.camera;
                }
                queueRender() {
                    this.isDirty = !0;
                }
                shouldRender() {
                    return this.isDirty;
                }
                hasRendered() {
                    this.isDirty = !1;
                }
                async setObject(t) {
                    this.reset(), this.modelContainer.add(t), await this.setupScene();
                }
                async setSource(t, e = () => {}) {
                    if (!t || t === this.url) return void e(1);
                    if ((this.reset(), (this.url = t), null != this.externalRenderer)) {
                        const t = await this.externalRenderer.load(e);
                        return (
                            (this.idealCameraDistance = t.framedRadius / iu),
                            (this.fieldOfViewAspect = t.fieldOfViewAspect),
                            this.frameModel(),
                            void this.dispatchEvent({ type: 'model-load', url: this.url })
                        );
                    }
                    let n;
                    null != this.cancelPendingSourceChange &&
                        (this.cancelPendingSourceChange(), (this.cancelPendingSourceChange = null));
                    try {
                        n = await new Promise(async (n, i) => {
                            this.cancelPendingSourceChange = () => i();
                            try {
                                n(await this.element[Qd].loader.load(t, this.element, e));
                            } catch (t) {
                                i(t);
                            }
                        });
                    } catch (t) {
                        if (null == t) return;
                        throw t;
                    }
                    this.reset(),
                        (this.url = t),
                        (this._currentGLTF = n),
                        null != n && this.modelContainer.add(n.scene);
                    const { animations: i } = n,
                        r = new Map(),
                        s = [];
                    for (const t of i) r.set(t.name, t), s.push(t.name);
                    (this.animations = i),
                        (this.animationsByName = r),
                        (this.animationNames = s),
                        await this.setupScene();
                }
                async setupScene() {
                    this.updateBoundingBox();
                    let t = null;
                    !0 === this.tightBounds &&
                        (await this.element.requestUpdate('cameraTarget'), (t = this.getTarget())),
                        this.updateFraming(t),
                        this.frameModel(),
                        this.updateShadow(),
                        this.setShadowIntensity(this.shadowIntensity),
                        this.dispatchEvent({ type: 'model-load', url: this.url });
                }
                reset() {
                    (this.url = null), this.queueRender(), null != this.shadow && this.shadow.setIntensity(0);
                    const t = this._currentGLTF;
                    if (null != t) {
                        for (const t of this.modelContainer.children) this.modelContainer.remove(t);
                        t.dispose(), (this._currentGLTF = null);
                    }
                    null != this.currentAnimationAction &&
                        (this.currentAnimationAction.stop(), (this.currentAnimationAction = null)),
                        this.mixer.stopAllAction(),
                        this.mixer.uncacheRoot(this);
                }
                get currentGLTF() {
                    return this._currentGLTF;
                }
                setSize(t, e) {
                    if (this.width !== t || this.height !== e) {
                        if (
                            ((this.width = Math.max(t, 1)),
                            (this.height = Math.max(e, 1)),
                            this.annotationRenderer.setSize(t, e),
                            (this.aspect = this.width / this.height),
                            this.frameModel(),
                            null != this.externalRenderer)
                        ) {
                            const n = Oh();
                            this.externalRenderer.resize(t * n, e * n);
                        }
                        this.queueRender();
                    }
                }
                updateBoundingBox() {
                    if ((this.target.remove(this.modelContainer), !0 === this.tightBounds)) {
                        const t = (t, e) => t.expandByPoint(e);
                        this.boundingBox = tu(this.modelContainer, t, new jt());
                    } else this.boundingBox.setFromObject(this.modelContainer);
                    this.boundingBox.getSize(this.size), this.target.add(this.modelContainer);
                }
                updateFraming(t = null) {
                    this.target.remove(this.modelContainer), null == t && (t = this.boundingBox.getCenter(new Gt()));
                    const e = Math.sqrt(tu(this.modelContainer, (e, n) => Math.max(e, t.distanceToSquared(n)), 0));
                    (this.idealCameraDistance = e / iu),
                        (this.fieldOfViewAspect =
                            tu(
                                this.modelContainer,
                                (e, n) => {
                                    n.sub(t);
                                    const i = Math.sqrt(n.x * n.x + n.z * n.z);
                                    return Math.max(e, i / (this.idealCameraDistance - Math.abs(n.y)));
                                },
                                0,
                            ) / ru),
                        this.target.add(this.modelContainer);
                }
                frameModel() {
                    const t = ru * Math.max(1, this.fieldOfViewAspect / this.aspect);
                    this.framedFieldOfView = (2 * Math.atan(t) * 180) / Math.PI;
                }
                getNDC(t, e) {
                    if (null != this.xrCamera) hu.set(t / window.screen.width, e / window.screen.height);
                    else {
                        const n = this.element.getBoundingClientRect();
                        hu.set((t - n.x) / this.width, (e - n.y) / this.height);
                    }
                    return hu.multiplyScalar(2).subScalar(1), (hu.y *= -1), hu;
                }
                getSize() {
                    return { width: this.width, height: this.height };
                }
                setTarget(t, e, n) {
                    this.goalTarget.set(-t, -e, -n);
                }
                setTargetDamperDecayTime(t) {
                    this.targetDamperX.setDecayTime(t),
                        this.targetDamperY.setDecayTime(t),
                        this.targetDamperZ.setDecayTime(t);
                }
                getTarget() {
                    return cu.copy(this.goalTarget).multiplyScalar(-1);
                }
                jumpToGoal() {
                    this.updateTarget(1e4);
                }
                updateTarget(t) {
                    const e = this.goalTarget,
                        n = this.target.position;
                    if (!e.equals(n)) {
                        const i = this.idealCameraDistance;
                        let { x: r, y: s, z: a } = n;
                        (r = this.targetDamperX.update(r, e.x, t, i)),
                            (s = this.targetDamperY.update(s, e.y, t, i)),
                            (a = this.targetDamperZ.update(a, e.z, t, i)),
                            this.target.position.set(r, s, a),
                            this.target.updateMatrixWorld(),
                            this.setShadowRotation(this.yaw),
                            this.queueRender();
                    }
                }
                pointTowards(t, e) {
                    const { x: n, z: i } = this.position;
                    this.yaw = Math.atan2(t - n, e - i);
                }
                set yaw(t) {
                    (this.rotation.y = t), this.updateMatrixWorld(!0), this.setShadowRotation(t), this.queueRender();
                }
                get yaw() {
                    return this.rotation.y;
                }
                set animationTime(t) {
                    this.mixer.setTime(t);
                }
                get animationTime() {
                    return null != this.currentAnimationAction ? this.currentAnimationAction.time : 0;
                }
                get duration() {
                    return null != this.currentAnimationAction && this.currentAnimationAction.getClip()
                        ? this.currentAnimationAction.getClip().duration
                        : 0;
                }
                get hasActiveAnimation() {
                    return null != this.currentAnimationAction;
                }
                playAnimation(t = null, e = 0) {
                    if (null == this._currentGLTF) return;
                    const { animations: n } = this;
                    if (null == n || 0 === n.length)
                        return void console.warn('Cannot play animation (model does not have any animations)');
                    let i = null;
                    null != t && (i = this.animationsByName.get(t)), null == i && (i = n[0]);
                    try {
                        const { currentAnimationAction: t } = this,
                            n = this.mixer.clipAction(i, this);
                        (this.currentAnimationAction = n),
                            this.element.paused
                                ? this.mixer.stopAllAction()
                                : null != t && n !== t && n.crossFadeFrom(t, e, !1),
                            (n.enabled = !0),
                            n.play();
                    } catch (t) {
                        console.error(t);
                    }
                }
                stopAnimation() {
                    (this.currentAnimationAction = null), this.mixer.stopAllAction();
                }
                updateAnimation(t) {
                    this.mixer.update(t);
                }
                updateShadow() {
                    const t = this.shadow;
                    if (null != t) {
                        const e = 'wall' === this.element.arPlacement ? 'back' : 'bottom';
                        t.setScene(this, this.shadowSoftness, e), t.setRotation(this.yaw);
                    }
                }
                setShadowIntensity(t) {
                    if (((this.shadowIntensity = t), null != this._currentGLTF && !(t <= 0 && null == this.shadow))) {
                        if (null == this.shadow) {
                            const t = 'wall' === this.element.arPlacement ? 'back' : 'bottom';
                            (this.shadow = new eu(this, this.shadowSoftness, t)), this.shadow.setRotation(this.yaw);
                        }
                        this.shadow.setIntensity(t);
                    }
                }
                setShadowSoftness(t) {
                    this.shadowSoftness = t;
                    const e = this.shadow;
                    null != e && e.setSoftness(t);
                }
                setShadowRotation(t) {
                    const e = this.shadow;
                    null != e && e.setRotation(t);
                }
                isShadowDirty() {
                    const t = this.shadow;
                    if (null == t) return !1;
                    {
                        const { needsUpdate: e } = t;
                        return (t.needsUpdate = !1), e;
                    }
                }
                setShadowScaleAndOffset(t, e) {
                    const n = this.shadow;
                    null != n && n.setScaleAndOffset(t, e);
                }
                get raycaster() {
                    return lu;
                }
                positionAndNormalFromPoint(t, e = this) {
                    this.raycaster.setFromCamera(t, this.getCamera());
                    const n = this.raycaster.intersectObject(e, !0);
                    if (0 === n.length) return null;
                    const i = n[0];
                    return null == i.face
                        ? null
                        : (i.face.normal.applyNormalMatrix(new Ct().getNormalMatrix(i.object.matrixWorld)),
                          { position: i.point, normal: i.face.normal });
                }
                addHotspot(t) {
                    this.target.add(t), this.annotationRenderer.domElement.appendChild(t.element);
                }
                removeHotspot(t) {
                    this.target.remove(t);
                }
                forHotspots(t) {
                    const { children: e } = this.target;
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        i instanceof Qh && t(i);
                    }
                }
                updateHotspots(t) {
                    this.forHotspots((e) => {
                        su.copy(t),
                            au.setFromMatrixPosition(e.matrixWorld),
                            su.sub(au),
                            ou.copy(e.normal).transformDirection(this.target.matrixWorld),
                            su.dot(ou) < 0 ? e.hide() : e.show();
                    });
                }
                orientHotspots(t) {
                    this.forHotspots((e) => {
                        e.orient(t);
                    });
                }
                setHotspotsVisibility(t) {
                    this.forHotspots((e) => {
                        e.visible = t;
                    });
                }
                updateSchema(t) {
                    var e;
                    const { schemaElement: n, element: i } = this,
                        { alt: r, poster: s, iosSrc: a } = i;
                    if (null != t) {
                        const i = [
                            {
                                '@type': 'MediaObject',
                                contentUrl: t,
                                encodingFormat:
                                    'gltf' ===
                                    (null === (e = t.split('.').pop()) || void 0 === e ? void 0 : e.toLowerCase())
                                        ? 'model/gltf+json'
                                        : 'model/gltf-binary',
                            },
                        ];
                        a && i.push({ '@type': 'MediaObject', contentUrl: a, encodingFormat: 'model/vnd.usdz+zip' });
                        const o = {
                            '@context': 'http://schema.org/',
                            '@type': '3DModel',
                            image: null != s ? s : void 0,
                            name: null != r ? r : void 0,
                            encoding: i,
                        };
                        (n.textContent = JSON.stringify(o)), document.head.appendChild(n);
                    } else null != n.parentElement && n.parentElement.removeChild(n);
                }
            }
            const du = (function () {
                    const t = new _i({
                        uniforms: {
                            roughnessMap: { value: null },
                            normalMap: { value: null },
                            texelSize: { value: new Rt(1, 1) },
                        },
                        vertexShader:
                            '\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t',
                        fragmentShader:
                            '\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t',
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                    return (t.type = 'RoughnessMipmapper'), t;
                })(),
                pu = new Wn(new ui(2, 2), du),
                mu = new wi(0, 1, 0, 1, 0, 1);
            let fu = null,
                gu = null;
            class vu {
                constructor(t) {
                    (gu = t), gu.compile(pu, mu);
                }
                generateMipmaps(t) {
                    if ('roughnessMap' in t == 0) return;
                    const { roughnessMap: e, normalMap: n } = t;
                    if (null === e || null === n || !e.generateMipmaps || t.userData.roughnessUpdated) return;
                    t.userData.roughnessUpdated = !0;
                    let i = Math.max(e.image.width, n.image.width),
                        r = Math.max(e.image.height, n.image.height);
                    if (!Lt.isPowerOfTwo(i) || !Lt.isPowerOfTwo(r)) return;
                    const s = gu.getRenderTarget(),
                        a = gu.autoClear;
                    if (
                        ((gu.autoClear = !1),
                        (null !== fu && fu.width === i && fu.height === r) ||
                            (null !== fu && fu.dispose(),
                            (fu = new zt(i, r, { depthBuffer: !1 })),
                            (fu.scissorTest = !0)),
                        i !== e.image.width || r !== e.image.height)
                    ) {
                        const n = {
                                wrapS: e.wrapS,
                                wrapT: e.wrapT,
                                magFilter: e.magFilter,
                                minFilter: e.minFilter,
                                depthBuffer: !1,
                            },
                            s = new zt(i, r, n);
                        (s.texture.generateMipmaps = !0),
                            gu.setRenderTarget(s),
                            (t.roughnessMap = s.texture),
                            t.metalnessMap == e && (t.metalnessMap = t.roughnessMap),
                            t.aoMap == e && (t.aoMap = t.roughnessMap),
                            t.roughnessMap.offset.copy(e.offset),
                            t.roughnessMap.repeat.copy(e.repeat),
                            t.roughnessMap.center.copy(e.center),
                            (t.roughnessMap.rotation = e.rotation),
                            (t.roughnessMap.matrixAutoUpdate = e.matrixAutoUpdate),
                            t.roughnessMap.matrix.copy(e.matrix);
                    }
                    (du.uniforms.roughnessMap.value = e), (du.uniforms.normalMap.value = n);
                    const o = new Rt(0, 0),
                        l = du.uniforms.texelSize.value;
                    for (let e = 0; i >= 1 && r >= 1; ++e, i /= 2, r /= 2)
                        l.set(1 / i, 1 / r),
                            0 == e && l.set(0, 0),
                            fu.viewport.set(o.x, o.y, i, r),
                            fu.scissor.set(o.x, o.y, i, r),
                            gu.setRenderTarget(fu),
                            gu.render(pu, mu),
                            gu.copyFramebufferToTexture(o, t.roughnessMap, e),
                            (du.uniforms.roughnessMap.value = t.roughnessMap);
                    e !== t.roughnessMap && e.dispose(), gu.setRenderTarget(s), (gu.autoClear = a);
                }
                dispose() {
                    du.dispose(), pu.geometry.dispose(), null != fu && fu.dispose();
                }
            }
            var yu = function (t, e, n, i) {
                for (
                    var r,
                        s = arguments.length,
                        a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                        o = t.length - 1;
                    o >= 0;
                    o--
                )
                    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                return s > 3 && a && Object.defineProperty(e, n, a), a;
            };
            const xu = Symbol('currentEnvironmentMap'),
                bu = Symbol('applyEnvironmentMap'),
                wu = Symbol('updateEnvironment'),
                _u = Symbol('cancelEnvironmentUpdate'),
                Mu = Symbol('onPreload');
            class Su {
                constructor(t, e, n, i, r) {
                    (this.xrLight = t),
                        (this.renderer = e),
                        (this.lightProbe = n),
                        (this.xrWebGLBinding = null),
                        (this.estimationStartCallback = r),
                        (this.frameCallback = this.onXRFrame.bind(this));
                    const s = e.xr.getSession();
                    if (i && 'XRWebGLBinding' in window) {
                        const n = new ei(16);
                        t.environment = n.texture;
                        const i = e.getContext();
                        switch (s.preferredReflectionFormat) {
                            case 'srgba8':
                                i.getExtension('EXT_sRGB');
                                break;
                            case 'rgba16f':
                                i.getExtension('OES_texture_half_float');
                        }
                        (this.xrWebGLBinding = new XRWebGLBinding(s, i)),
                            this.lightProbe.addEventListener('reflectionchange', () => {
                                this.updateReflection();
                            });
                    }
                    s.requestAnimationFrame(this.frameCallback);
                }
                updateReflection() {
                    const t = this.renderer.properties.get(this.xrLight.environment);
                    if (t) {
                        const e = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
                        e && (t.__webglTexture = e);
                    }
                }
                onXRFrame(t, e) {
                    if (!this.xrLight) return;
                    e.session.requestAnimationFrame(this.frameCallback);
                    const n = e.getLightEstimate(this.lightProbe);
                    if (n) {
                        this.xrLight.lightProbe.sh.fromArray(n.sphericalHarmonicsCoefficients),
                            (this.xrLight.lightProbe.intensity = 1);
                        const t = Math.max(
                            1,
                            Math.max(
                                n.primaryLightIntensity.x,
                                Math.max(n.primaryLightIntensity.y, n.primaryLightIntensity.z),
                            ),
                        );
                        this.xrLight.directionalLight.color.setRGB(
                            n.primaryLightIntensity.x / t,
                            n.primaryLightIntensity.y / t,
                            n.primaryLightIntensity.z / t,
                        ),
                            (this.xrLight.directionalLight.intensity = t),
                            this.xrLight.directionalLight.position.copy(n.primaryLightDirection),
                            this.estimationStartCallback &&
                                (this.estimationStartCallback(), (this.estimationStartCallback = null));
                    }
                }
                dispose() {
                    (this.xrLight = null),
                        (this.renderer = null),
                        (this.lightProbe = null),
                        (this.xrWebGLBinding = null);
                }
            }
            class Tu extends Hs {
                constructor(t, e = !0) {
                    super(),
                        (this.lightProbe = new Nl()),
                        (this.lightProbe.intensity = 0),
                        this.add(this.lightProbe),
                        (this.directionalLight = new Il()),
                        (this.directionalLight.intensity = 0),
                        this.add(this.directionalLight),
                        (this.environment = null);
                    let n = null,
                        i = !1;
                    t.xr.addEventListener('sessionstart', () => {
                        const r = t.xr.getSession();
                        'requestLightProbe' in r &&
                            r.requestLightProbe({ reflectionFormat: r.preferredReflectionFormat }).then((r) => {
                                n = new Su(this, t, r, e, () => {
                                    (i = !0), this.dispatchEvent({ type: 'estimationstart' });
                                });
                            });
                    }),
                        t.xr.addEventListener('sessionend', () => {
                            n && (n.dispose(), (n = null)), i && this.dispatchEvent({ type: 'estimationend' });
                        }),
                        (this.dispose = () => {
                            n && (n.dispose(), (n = null)),
                                this.remove(this.lightProbe),
                                (this.lightProbe = null),
                                this.remove(this.directionalLight),
                                (this.directionalLight = null),
                                (this.environment = null);
                        });
                }
            }
            const Eu = Math.PI / 24,
                Au = new Rt(),
                Lu = (t, e, n) => {
                    let i = e > 0 ? (n > 0 ? 0 : -Math.PI / 2) : n > 0 ? Math.PI / 2 : Math.PI;
                    for (let r = 0; r <= 12; ++r)
                        t.push(
                            e + 0.17 * Math.cos(i),
                            n + 0.17 * Math.sin(i),
                            0,
                            e + 0.2 * Math.cos(i),
                            n + 0.2 * Math.sin(i),
                            0,
                        ),
                            (i += Eu);
                };
            class Ru extends Wn {
                constructor(t, e) {
                    const n = new En(),
                        i = [],
                        r = [],
                        { size: s, boundingBox: a } = t,
                        o = s.x / 2,
                        l = ('back' === e ? s.y : s.z) / 2;
                    Lu(r, o, l), Lu(r, -o, l), Lu(r, -o, -l), Lu(r, o, -l);
                    const c = r.length / 3;
                    for (let t = 0; t < c - 2; t += 2) i.push(t, t + 1, t + 3, t, t + 3, t + 2);
                    const h = c - 2;
                    i.push(h, h + 1, 1, h, 1, 0),
                        n.setAttribute('position', new yn(r, 3)),
                        n.setIndex(i),
                        super(n),
                        (this.side = e);
                    const u = this.material;
                    switch (
                        ((u.side = 2),
                        (u.transparent = !0),
                        (u.opacity = 0),
                        (this.goalOpacity = 0),
                        (this.opacityDamper = new zh()),
                        (this.hitPlane = new Wn(new ui(2 * (o + 0.2), 2 * (l + 0.2)))),
                        (this.hitPlane.visible = !1),
                        this.add(this.hitPlane),
                        a.getCenter(this.position),
                        e)
                    ) {
                        case 'bottom':
                            this.rotateX(-Math.PI / 2),
                                (this.shadowHeight = a.min.y),
                                (this.position.y = this.shadowHeight);
                            break;
                        case 'back':
                            (this.shadowHeight = a.min.z), (this.position.z = this.shadowHeight);
                    }
                    t.target.add(this);
                }
                getHit(t, e, n) {
                    Au.set(e, -n), (this.hitPlane.visible = !0);
                    const i = t.positionAndNormalFromPoint(Au, this.hitPlane);
                    return (this.hitPlane.visible = !1), null == i ? null : i.position;
                }
                getExpandedHit(t, e, n) {
                    this.hitPlane.scale.set(1e3, 1e3, 1e3);
                    const i = this.getHit(t, e, n);
                    return this.hitPlane.scale.set(1, 1, 1), i;
                }
                set offsetHeight(t) {
                    'back' === this.side
                        ? (this.position.z = this.shadowHeight + t)
                        : (this.position.y = this.shadowHeight + t);
                }
                get offsetHeight() {
                    return 'back' === this.side
                        ? this.position.z - this.shadowHeight
                        : this.position.y - this.shadowHeight;
                }
                set show(t) {
                    this.goalOpacity = t ? 0.75 : 0;
                }
                updateOpacity(t) {
                    const e = this.material;
                    (e.opacity = this.opacityDamper.update(e.opacity, this.goalOpacity, t, 1)),
                        (this.visible = e.opacity > 0);
                }
                dispose() {
                    var t;
                    const { geometry: e, material: n } = this.hitPlane;
                    e.dispose(),
                        n.dispose(),
                        this.geometry.dispose(),
                        this.material.dispose(),
                        null === (t = this.parent) || void 0 === t || t.remove(this);
                }
            }
            const Cu = 'not-presenting',
                Pu = 'session-started',
                Iu = 'tracking',
                Du = new Gt(),
                Nu = new xe(),
                Fu = new Gt(),
                Ou = new Kn(45, 1, 0.1, 100);
            class Uu extends ft {
                constructor(t) {
                    super(),
                        (this.renderer = t),
                        (this.currentSession = null),
                        (this.placeOnWall = !1),
                        (this.placementBox = null),
                        (this.lastTick = null),
                        (this.turntableRotation = null),
                        (this.oldShadowIntensity = null),
                        (this.oldBackground = null),
                        (this.oldEnvironment = null),
                        (this.frame = null),
                        (this.initialHitSource = null),
                        (this.transientHitTestSource = null),
                        (this.inputSource = null),
                        (this._presentedScene = null),
                        (this.resolveCleanup = null),
                        (this.exitWebXRButtonContainer = null),
                        (this.overlay = null),
                        (this.xrLight = null),
                        (this.tracking = !0),
                        (this.frames = 0),
                        (this.initialized = !1),
                        (this.oldTarget = new Gt()),
                        (this.oldFramedFieldOfView = 45),
                        (this.placementComplete = !1),
                        (this.isTranslating = !1),
                        (this.isRotating = !1),
                        (this.isTwoFingering = !1),
                        (this.lastDragPosition = new Gt()),
                        (this.firstRatio = 0),
                        (this.lastAngle = 0),
                        (this.goalPosition = new Gt()),
                        (this.goalYaw = 0),
                        (this.goalScale = 1),
                        (this.xDamper = new zh()),
                        (this.yDamper = new zh()),
                        (this.zDamper = new zh()),
                        (this.yawDamper = new zh()),
                        (this.scaleDamper = new zh()),
                        (this.onExitWebXRButtonContainerClick = () => this.stopPresenting()),
                        (this.onUpdateScene = () => {
                            null != this.placementBox &&
                                this.isPresenting &&
                                (this.placementBox.dispose(),
                                (this.placementBox = new Ru(
                                    this.presentedScene,
                                    this.placeOnWall ? 'back' : 'bottom',
                                )));
                        }),
                        (this.onSelectStart = (t) => {
                            const e = this.transientHitTestSource;
                            if (null == e) return;
                            const n = this.frame.getHitTestResultsForTransientInput(e),
                                i = this.presentedScene,
                                r = this.placementBox;
                            if (1 === n.length) {
                                this.inputSource = t.inputSource;
                                const { axes: e } = this.inputSource.gamepad,
                                    n = r.getHit(this.presentedScene, e[0], e[1]);
                                (r.show = !0),
                                    null != n
                                        ? ((this.isTranslating = !0), this.lastDragPosition.copy(n))
                                        : !1 === this.placeOnWall &&
                                          ((this.isRotating = !0), (this.lastAngle = 1.5 * e[0]));
                            } else if (2 === n.length) {
                                (r.show = !0), (this.isTwoFingering = !0);
                                const { separation: t } = this.fingerPolar(n);
                                this.firstRatio = t / i.scale.x;
                            }
                        }),
                        (this.onSelectEnd = () => {
                            (this.isTranslating = !1),
                                (this.isRotating = !1),
                                (this.isTwoFingering = !1),
                                (this.inputSource = null),
                                (this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x),
                                (this.placementBox.show = !1);
                        }),
                        (this.threeRenderer = t.threeRenderer),
                        (this.threeRenderer.xr.enabled = !0);
                }
                async resolveARSession() {
                    Ih();
                    const t = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test'],
                        optionalFeatures: ['dom-overlay', 'light-estimation'],
                        domOverlay: { root: this.overlay },
                    });
                    return (
                        this.threeRenderer.xr.setReferenceSpaceType('local'),
                        await this.threeRenderer.xr.setSession(t),
                        (this.threeRenderer.xr.cameraAutoUpdate = !1),
                        t
                    );
                }
                get presentedScene() {
                    return this._presentedScene;
                }
                async supportsPresentation() {
                    try {
                        return Ih(), await navigator.xr.isSessionSupported('immersive-ar');
                    } catch (t) {
                        return (
                            console.warn('Request to present in WebXR denied:'),
                            console.warn(t),
                            console.warn('Falling back to next ar-mode'),
                            !1
                        );
                    }
                }
                async present(t, e = !1) {
                    this.isPresenting && console.warn('Cannot present while a model is already presenting');
                    let n = new Promise((t, e) => {
                        requestAnimationFrame(() => t());
                    });
                    t.setHotspotsVisibility(!1),
                        t.queueRender(),
                        await n,
                        (this._presentedScene = t),
                        (this.overlay = t.element.shadowRoot.querySelector('div.default')),
                        !0 === e &&
                            ((this.xrLight = new Tu(this.threeRenderer)),
                            this.xrLight.addEventListener('estimationstart', () => {
                                if (!this.isPresenting || null == this.xrLight) return;
                                const t = this.presentedScene;
                                t.add(this.xrLight),
                                    (this.oldEnvironment = t.environment),
                                    (t.environment = this.xrLight.environment);
                            }));
                    const i = await this.resolveARSession();
                    i.addEventListener(
                        'end',
                        () => {
                            this.postSessionCleanup();
                        },
                        { once: !0 },
                    );
                    const r = t.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button');
                    r.classList.add('enabled'),
                        r.addEventListener('click', this.onExitWebXRButtonContainerClick),
                        (this.exitWebXRButtonContainer = r);
                    const s = await i.requestReferenceSpace('viewer');
                    (this.tracking = !0),
                        (this.frames = 0),
                        (this.initialized = !1),
                        (this.turntableRotation = t.yaw),
                        (this.goalYaw = t.yaw),
                        (this.goalScale = 1),
                        (this.oldBackground = t.background),
                        (t.background = null),
                        (this.oldShadowIntensity = t.shadowIntensity),
                        t.setShadowIntensity(0),
                        this.oldTarget.copy(t.getTarget()),
                        (this.oldFramedFieldOfView = t.framedFieldOfView),
                        t.addEventListener('model-load', this.onUpdateScene);
                    const a = (20 * Math.PI) / 180,
                        o =
                            !0 === this.placeOnWall
                                ? void 0
                                : new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(a), z: -Math.cos(a) });
                    i.requestHitTestSource({ space: s, offsetRay: o }).then((t) => {
                        this.initialHitSource = t;
                    }),
                        (this.currentSession = i),
                        (this.placementBox = new Ru(t, this.placeOnWall ? 'back' : 'bottom')),
                        (this.placementComplete = !1),
                        (this.lastTick = performance.now()),
                        this.dispatchEvent({ type: 'status', status: Pu });
                }
                async stopPresenting() {
                    if (!this.isPresenting) return;
                    const t = new Promise((t) => {
                        this.resolveCleanup = t;
                    });
                    try {
                        await this.currentSession.end(), await t;
                    } catch (t) {
                        console.warn('Error while trying to end WebXR AR session'),
                            console.warn(t),
                            this.postSessionCleanup();
                    }
                }
                get isPresenting() {
                    return null != this.presentedScene;
                }
                get target() {
                    return this.oldTarget;
                }
                updateTarget() {
                    const t = this.presentedScene;
                    if (null != t) {
                        const e = t.getTarget();
                        this.oldTarget.copy(e),
                            this.placeOnWall ? (e.z = t.boundingBox.min.z) : (e.y = t.boundingBox.min.y),
                            t.setTarget(e.x, e.y, e.z);
                    }
                }
                postSessionCleanup() {
                    const t = this.currentSession;
                    null != t &&
                        (t.removeEventListener('selectstart', this.onSelectStart),
                        t.removeEventListener('selectend', this.onSelectEnd),
                        (this.currentSession = null));
                    const e = this.presentedScene;
                    if (null != e) {
                        const { element: t } = e;
                        null != this.xrLight &&
                            (e.remove(this.xrLight),
                            null != this.oldEnvironment &&
                                ((e.environment = this.oldEnvironment), (this.oldEnvironment = null)),
                            this.xrLight.dispose(),
                            (this.xrLight = null)),
                            e.position.set(0, 0, 0),
                            e.scale.set(1, 1, 1),
                            e.setShadowScaleAndOffset(1, 0);
                        const n = this.turntableRotation;
                        null != n && (e.yaw = n);
                        const i = this.oldShadowIntensity;
                        null != i && e.setShadowIntensity(i);
                        const r = this.oldBackground;
                        null != r && (e.background = r);
                        const s = this.oldTarget;
                        e.setTarget(s.x, s.y, s.z),
                            (e.framedFieldOfView = this.oldFramedFieldOfView),
                            (e.xrCamera = null),
                            e.removeEventListener('model-load', this.onUpdateScene),
                            e.orientHotspots(0),
                            t.requestUpdate('cameraTarget'),
                            t.requestUpdate('maxCameraOrbit'),
                            t[Kd](t.getBoundingClientRect());
                    }
                    this.renderer.height = 0;
                    const n = this.exitWebXRButtonContainer;
                    null != n &&
                        (n.classList.remove('enabled'),
                        n.removeEventListener('click', this.onExitWebXRButtonContainerClick),
                        (this.exitWebXRButtonContainer = null));
                    const i = this.transientHitTestSource;
                    null != i && (i.cancel(), (this.transientHitTestSource = null));
                    const r = this.initialHitSource;
                    null != r && (r.cancel(), (this.initialHitSource = null)),
                        null != this.placementBox && (this.placementBox.dispose(), (this.placementBox = null)),
                        (this.lastTick = null),
                        (this.turntableRotation = null),
                        (this.oldShadowIntensity = null),
                        (this.oldBackground = null),
                        (this._presentedScene = null),
                        (this.frame = null),
                        (this.inputSource = null),
                        (this.overlay = null),
                        null != this.resolveCleanup && this.resolveCleanup(),
                        this.dispatchEvent({ type: 'status', status: Cu });
                }
                updateView(t) {
                    const e = this.presentedScene,
                        n = this.threeRenderer.xr;
                    n.updateCamera(Ou), (e.xrCamera = n.getCamera());
                    const { elements: i } = e.getCamera().matrixWorld;
                    if (
                        (e.orientHotspots(Math.atan2(i[1], i[5])),
                        this.initialized || (this.placeInitially(), (this.initialized = !0)),
                        t.requestViewportScale && t.recommendedViewportScale)
                    ) {
                        const e = t.recommendedViewportScale;
                        t.requestViewportScale(Math.max(e, 0.25));
                    }
                    const r = this.currentSession.renderState.baseLayer.getViewport(t);
                    this.threeRenderer.setViewport(r.x, r.y, r.width, r.height);
                }
                placeInitially() {
                    const t = this.presentedScene,
                        { position: e, element: n } = t,
                        i = t.getCamera(),
                        { width: r, height: s } = this.overlay.getBoundingClientRect();
                    t.setSize(r, s), i.projectionMatrixInverse.copy(i.projectionMatrix).invert();
                    const { theta: a, radius: o } = n.getCameraOrbit(),
                        l = i.getWorldDirection(Du);
                    (t.yaw = Math.atan2(-l.x, -l.z) - a),
                        (this.goalYaw = t.yaw),
                        e.copy(i.position).add(l.multiplyScalar(o)),
                        this.updateTarget();
                    const c = t.getTarget();
                    e.add(c).sub(this.oldTarget), this.goalPosition.copy(e), t.setHotspotsVisibility(!0);
                    const { session: h } = this.frame;
                    h.addEventListener('selectstart', this.onSelectStart),
                        h.addEventListener('selectend', this.onSelectEnd),
                        h.requestHitTestSourceForTransientInput({ profile: 'generic-touchscreen' }).then((t) => {
                            this.transientHitTestSource = t;
                        });
                }
                getTouchLocation() {
                    const { axes: t } = this.inputSource.gamepad;
                    let e = this.placementBox.getExpandedHit(this.presentedScene, t[0], t[1]);
                    return null != e && (Du.copy(e).sub(this.presentedScene.getCamera().position), Du.length() > 10)
                        ? null
                        : e;
                }
                getHitPoint(t) {
                    const e = this.threeRenderer.xr.getReferenceSpace(),
                        n = t.getPose(e);
                    if (null == n) return null;
                    const i = Nu.fromArray(n.transform.matrix);
                    return (
                        !0 === this.placeOnWall && (this.goalYaw = Math.atan2(i.elements[4], i.elements[6])),
                        i.elements[5] > 0.75 !== this.placeOnWall ? Fu.setFromMatrixPosition(i) : null
                    );
                }
                moveToFloor(t) {
                    const e = this.initialHitSource;
                    if (null == e) return;
                    const n = t.getHitTestResults(e);
                    if (0 == n.length) return;
                    const i = n[0],
                        r = this.getHitPoint(i);
                    null != r &&
                        ((this.placementBox.show = !0),
                        this.isTranslating ||
                            (this.placeOnWall ? this.goalPosition.copy(r) : (this.goalPosition.y = r.y)),
                        e.cancel(),
                        (this.initialHitSource = null),
                        this.dispatchEvent({ type: 'status', status: 'object-placed' }));
                }
                fingerPolar(t) {
                    const e = t[0].inputSource.gamepad.axes,
                        n = t[1].inputSource.gamepad.axes,
                        i = n[0] - e[0],
                        r = n[1] - e[1],
                        s = Math.atan2(r, i);
                    let a = this.lastAngle - s;
                    return (
                        a > Math.PI ? (a -= 2 * Math.PI) : a < -Math.PI && (a += 2 * Math.PI),
                        (this.lastAngle = s),
                        { separation: Math.sqrt(i * i + r * r), deltaYaw: a }
                    );
                }
                processInput(t) {
                    const e = this.transientHitTestSource;
                    if (null == e) return;
                    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
                    const n = t.getHitTestResultsForTransientInput(e),
                        i = this.presentedScene,
                        r = i.scale.x;
                    if (this.isTwoFingering)
                        if (n.length < 2) this.isTwoFingering = !1;
                        else {
                            const { separation: t, deltaYaw: e } = this.fingerPolar(n);
                            if ((!1 === this.placeOnWall && (this.goalYaw += e), i.canScale)) {
                                const e = t / this.firstRatio;
                                this.goalScale = e < 1.3 && e > 0.7692307692307692 ? 1 : e;
                            }
                        }
                    else if (2 !== n.length)
                        if (this.isRotating) {
                            const t = 1.5 * this.inputSource.gamepad.axes[0];
                            (this.goalYaw += t - this.lastAngle), (this.lastAngle = t);
                        } else
                            this.isTranslating &&
                                n.forEach((t) => {
                                    if (t.inputSource !== this.inputSource) return;
                                    let e = null;
                                    if (
                                        (t.results.length > 0 && (e = this.getHitPoint(t.results[0])),
                                        null == e && (e = this.getTouchLocation()),
                                        null != e)
                                    ) {
                                        if ((this.goalPosition.sub(this.lastDragPosition), !1 === this.placeOnWall)) {
                                            const t = e.y - this.lastDragPosition.y;
                                            if (t < 0) {
                                                (this.placementBox.offsetHeight = t / r),
                                                    this.presentedScene.setShadowScaleAndOffset(r, t);
                                                const n = Du.copy(i.getCamera().position),
                                                    s = -t / (n.y - e.y);
                                                n.multiplyScalar(s), e.multiplyScalar(1 - s).add(n);
                                            }
                                        }
                                        this.goalPosition.add(e), this.lastDragPosition.copy(e);
                                    }
                                });
                    else {
                        (this.isTranslating = !1), (this.isRotating = !1), (this.isTwoFingering = !0);
                        const { separation: t } = this.fingerPolar(n);
                        this.firstRatio = t / r;
                    }
                }
                moveScene(t) {
                    const e = this.presentedScene,
                        { position: n, yaw: i, idealCameraDistance: r } = e,
                        s = this.goalPosition,
                        a = e.scale.x,
                        o = this.placementBox;
                    if (!s.equals(n) || this.goalScale !== a) {
                        let { x: i, y: l, z: c } = n;
                        (i = this.xDamper.update(i, s.x, t, r)),
                            (l = this.yDamper.update(l, s.y, t, r)),
                            (c = this.zDamper.update(c, s.z, t, r)),
                            n.set(i, l, c);
                        const h = this.scaleDamper.update(a, this.goalScale, t, 1);
                        if ((e.scale.set(h, h, h), !this.isTranslating)) {
                            const t = s.y - l;
                            this.placementComplete && !1 === this.placeOnWall
                                ? ((o.offsetHeight = t / h), e.setShadowScaleAndOffset(h, t))
                                : 0 === t && ((this.placementComplete = !0), (o.show = !1), e.setShadowIntensity(0.3));
                        }
                    }
                    o.updateOpacity(t), e.updateTarget(t), (e.yaw = this.yawDamper.update(i, this.goalYaw, t, Math.PI));
                }
                onWebXRFrame(t, e) {
                    (this.frame = e), ++this.frames;
                    const n = this.threeRenderer.xr.getReferenceSpace(),
                        i = e.getViewerPose(n);
                    null == i &&
                        !0 === this.tracking &&
                        this.frames > 30 &&
                        ((this.tracking = !1), this.dispatchEvent({ type: 'tracking', status: 'not-tracking' }));
                    const r = this.presentedScene;
                    if (null == i || null == r || !r.element[rp]()) return void this.threeRenderer.clear();
                    !1 === this.tracking &&
                        ((this.tracking = !0), this.dispatchEvent({ type: 'tracking', status: Iu }));
                    let s = !0;
                    for (const n of i.views) {
                        if ((this.updateView(n), s)) {
                            this.moveToFloor(e), this.processInput(e);
                            const n = t - this.lastTick;
                            this.moveScene(n), this.renderer.preRender(r, t, n), (this.lastTick = t);
                        }
                        const i = this.threeRenderer.getContext();
                        i.depthMask(!1),
                            i.clear(i.DEPTH_BUFFER_BIT),
                            i.depthMask(!0),
                            this.threeRenderer.render(r, r.getCamera()),
                            (s = !1);
                    }
                }
            }
            class ku {
                constructor(t) {
                    (t.threeRenderer.debug = { checkShaderErrors: !0 }),
                        Promise.resolve().then(() => {
                            self.dispatchEvent(
                                new CustomEvent('model-viewer-renderer-debug', {
                                    detail: {
                                        renderer: t,
                                        THREE: {
                                            ShaderMaterial: Jn,
                                            Texture: Ot,
                                            Mesh: Wn,
                                            Scene: Xs,
                                            PlaneBufferGeometry: ui,
                                            OrthographicCamera: wi,
                                            WebGLRenderTarget: zt,
                                        },
                                    },
                                }),
                            );
                        });
                }
                addScene(t) {
                    self.dispatchEvent(new CustomEvent('model-viewer-scene-added-debug', { detail: { scene: t } }));
                }
                removeScene(t) {
                    self.dispatchEvent(new CustomEvent('model-viewer-scene-removed-debug', { detail: { scene: t } }));
                }
            }
            function zu(t) {
                const e = new Map(),
                    n = new Map(),
                    i = t.clone();
                return (
                    Bu(t, i, function (t, i) {
                        e.set(i, t), n.set(t, i);
                    }),
                    i.traverse(function (t) {
                        if (!t.isSkinnedMesh) return;
                        const i = t,
                            r = e.get(t),
                            s = r.skeleton.bones;
                        (i.skeleton = r.skeleton.clone()),
                            i.bindMatrix.copy(r.bindMatrix),
                            (i.skeleton.bones = s.map(function (t) {
                                return n.get(t);
                            })),
                            i.bind(i.skeleton, i.bindMatrix);
                    }),
                    i
                );
            }
            function Bu(t, e, n) {
                n(t, e);
                for (let i = 0; i < t.children.length; i++) Bu(t.children[i], e.children[i], n);
            }
            const Hu = Symbol('prepared'),
                Gu = Symbol('prepare'),
                Vu = Symbol('preparedGLTF'),
                Wu = Symbol('clone');
            class ju {
                constructor(t) {
                    this[Vu] = t;
                }
                static prepare(t) {
                    if (null == t.scene) throw new Error('Model does not have a scene');
                    if (t[Hu]) return t;
                    const e = this[Gu](t);
                    return (e[Hu] = !0), e;
                }
                static [Gu](t) {
                    const { scene: e } = t,
                        n = [e];
                    return Object.assign(Object.assign({}, t), { scene: e, scenes: n });
                }
                get parser() {
                    return this[Vu].parser;
                }
                get animations() {
                    return this[Vu].animations;
                }
                get scene() {
                    return this[Vu].scene;
                }
                get scenes() {
                    return this[Vu].scenes;
                }
                get cameras() {
                    return this[Vu].cameras;
                }
                get asset() {
                    return this[Vu].asset;
                }
                get userData() {
                    return this[Vu].userData;
                }
                clone() {
                    return new (0, this.constructor)(this[Wu]());
                }
                dispose() {
                    this.scenes.forEach((t) => {
                        t.traverse((t) => {
                            if (!t.isMesh) return;
                            const e = t;
                            (Array.isArray(e.material) ? e.material : [e.material]).forEach((t) => {
                                for (const e in t) {
                                    const n = t[e];
                                    n instanceof Ot && n.dispose();
                                }
                                t.dispose();
                            }),
                                e.geometry.dispose();
                        });
                    });
                }
                [Wu]() {
                    const t = this[Vu],
                        e = zu(this.scene);
                    qu(e, this.scene);
                    const n = [e],
                        i = t.userData ? Object.assign({}, t.userData) : {};
                    return Object.assign(Object.assign({}, t), { scene: e, scenes: n, userData: i });
                }
            }
            const qu = (t, e) => {
                    Xu(t, e, (t, e) => {
                        void 0 !== e.userData.variantMaterials &&
                            (t.userData.variantMaterials = new Map(e.userData.variantMaterials)),
                            void 0 !== e.userData.originalMaterial &&
                                (t.userData.originalMaterial = e.userData.originalMaterial);
                    });
                },
                Xu = (t, e, n) => {
                    n(t, e);
                    for (let i = 0; i < t.children.length; i++) Xu(t.children[i], e.children[i], n);
                },
                Yu = Symbol('threeGLTF'),
                Zu = Symbol('gltf'),
                Ju = Symbol('gltfElementMap'),
                $u = Symbol('threeObjectMap'),
                Ku = Symbol('parallelTraverseThreeScene'),
                Qu = Symbol('correlateOriginalThreeGLTF'),
                td = Symbol('correlateCloneThreeGLTF');
            class ed {
                constructor(t, e, n, i) {
                    (this[Yu] = t), (this[Zu] = e), (this[Ju] = i), (this[$u] = n);
                }
                static from(t, e) {
                    return null != e ? this[td](t, e) : this[Qu](t);
                }
                static [Qu](t) {
                    const e = t.parser.json,
                        n = t.parser.associations,
                        i = new Map(),
                        r = { name: 'Default' },
                        s = { type: 'materials', index: -1 };
                    for (const t of n.keys())
                        t instanceof rn &&
                            null == n.get(t) &&
                            (s.index < 0 &&
                                (null == e.materials && (e.materials = []),
                                (s.index = e.materials.length),
                                e.materials.push(r)),
                            (t.name = r.name),
                            n.set(t, { materials: s.index }));
                    for (const [t, r] of n) {
                        if (r) {
                            const e = t;
                            (e.userData = e.userData || {}), (e.userData.associations = r);
                        }
                        for (const n in r)
                            if (null != n && 'primitives' !== n) {
                                const s = n,
                                    a = (e[s] || [])[r[s]];
                                if (null == a) continue;
                                let o = i.get(a);
                                null == o && ((o = new Set()), i.set(a, o)), o.add(t);
                            }
                    }
                    return new ed(t, e, n, i);
                }
                static [td](t, e) {
                    const n = e.threeGLTF,
                        i = e.gltf,
                        r = JSON.parse(JSON.stringify(i)),
                        s = new Map(),
                        a = new Map();
                    for (let i = 0; i < n.scenes.length; i++)
                        this[Ku](n.scenes[i], t.scenes[i], (t, n) => {
                            const i = e.threeObjectMap.get(t);
                            if (null != i)
                                for (const t in i)
                                    if (null != t && 'primitives' !== t) {
                                        const e = t,
                                            o = i[e],
                                            l = r[e][o],
                                            c = s.get(n) || {};
                                        (c[e] = o), s.set(n, c);
                                        const h = a.get(l) || new Set();
                                        h.add(n), a.set(l, h);
                                    }
                        });
                    return new ed(t, r, s, a);
                }
                static [Ku](t, e, n) {
                    const i = (t, e) => {
                        if ((n(t, e), t.isObject3D)) {
                            if (t.isMesh)
                                if (Array.isArray(t.material))
                                    for (let n = 0; n < t.material.length; ++n) i(t.material[n], e.material[n]);
                                else i(t.material, e.material);
                            for (let n = 0; n < t.children.length; ++n) i(t.children[n], e.children[n]);
                        }
                    };
                    i(t, e);
                }
                get threeGLTF() {
                    return this[Yu];
                }
                get gltf() {
                    return this[Zu];
                }
                get gltfElementMap() {
                    return this[Ju];
                }
                get threeObjectMap() {
                    return this[$u];
                }
            }
            const nd = Symbol('cloneAndPatchMaterial'),
                id = Symbol('correlatedSceneGraph');
            class rd extends ju {
                static [Gu](t) {
                    const e = super[Gu](t);
                    null == e[id] && (e[id] = ed.from(e));
                    const { scene: n } = e,
                        i = new he(void 0, 1 / 0);
                    return (
                        n.traverse((t) => {
                            (t.renderOrder = 1e3), (t.frustumCulled = !1), t.name || (t.name = t.uuid);
                            const e = t;
                            e.isMesh &&
                                ((e.castShadow = !0),
                                e.isSkinnedMesh && ((e.geometry.boundingSphere = i), (e.geometry.boundingBox = null)));
                        }),
                        e
                    );
                }
                get correlatedSceneGraph() {
                    return this[Vu][id];
                }
                [Wu]() {
                    const t = super[Wu](),
                        e = new Map();
                    return (
                        t.scene.traverse((t) => {
                            if (t.isMesh) {
                                const n = t;
                                Array.isArray(n.material)
                                    ? (n.material = n.material.map((t) => this[nd](t, e)))
                                    : null != n.material && (n.material = this[nd](n.material, e));
                            }
                        }),
                        (t[id] = ed.from(t, this.correlatedSceneGraph)),
                        t
                    );
                }
                [nd](t, e) {
                    if (e.has(t.uuid)) return e.get(t.uuid);
                    const n = t.clone();
                    null != t.map && ((n.map = t.map.clone()), (n.map.needsUpdate = !0)),
                        null != t.normalMap && ((n.normalMap = t.normalMap.clone()), (n.normalMap.needsUpdate = !0)),
                        null != t.emissiveMap &&
                            ((n.emissiveMap = t.emissiveMap.clone()), (n.emissiveMap.needsUpdate = !0));
                    let i = null;
                    if ((null != t.roughnessMap && (i = t.roughnessMap.clone()), null != i)) {
                        (i.needsUpdate = !0), (n.roughnessMap = i);
                        const { threeRenderer: t, roughnessMipmapper: e } = dd.singleton,
                            { enabled: r } = t.xr;
                        t.xr.enabled = !1;
                        const { image: s } = n.roughnessMap;
                        e.generateMipmaps(n), (n.roughnessMap.image = s), (t.xr.enabled = r);
                    }
                    return (
                        t.roughnessMap === t.metalnessMap
                            ? (n.metalnessMap = i)
                            : null != t.metalnessMap &&
                              ((n.metalnessMap = t.metalnessMap.clone()), (n.metalnessMap.needsUpdate = !0)),
                        t.roughnessMap === t.aoMap
                            ? (n.aoMap = i)
                            : null != t.aoMap && ((n.aoMap = t.aoMap.clone()), (n.aoMap.needsUpdate = !0)),
                        (n.shadowSide = 0),
                        e.set(t.uuid, n),
                        n
                    );
                }
            }
            class sd extends Xs {
                constructor() {
                    super(), (this.position.y = -3.5);
                    const t = new qn();
                    t.deleteAttribute('uv');
                    const e = new Xo({ metalness: 0, side: 1 }),
                        n = new Xo({ metalness: 0 }),
                        i = new Cl(16777215, 500, 28, 2);
                    i.position.set(0.418, 16.199, 0.3), this.add(i);
                    const r = new Wn(t, e);
                    r.position.set(-0.757, 13.219, 0.717), r.scale.set(31.713, 28.305, 28.591), this.add(r);
                    const s = new Wn(t, n);
                    s.position.set(-10.906, 2.009, 1.846),
                        s.rotation.set(0, -0.195, 0),
                        s.scale.set(2.328, 7.905, 4.651),
                        this.add(s);
                    const a = new Wn(t, n);
                    a.position.set(-5.607, -0.754, -0.758),
                        a.rotation.set(0, 0.994, 0),
                        a.scale.set(1.97, 1.534, 3.955),
                        this.add(a);
                    const o = new Wn(t, n);
                    o.position.set(6.167, 0.857, 7.803),
                        o.rotation.set(0, 0.561, 0),
                        o.scale.set(3.927, 6.285, 3.687),
                        this.add(o);
                    const l = new Wn(t, n);
                    l.position.set(-2.017, 0.018, 6.124),
                        l.rotation.set(0, 0.333, 0),
                        l.scale.set(2.002, 4.566, 2.064),
                        this.add(l);
                    const c = new Wn(t, n);
                    c.position.set(2.291, -0.756, -2.621),
                        c.rotation.set(0, -0.286, 0),
                        c.scale.set(1.546, 1.552, 1.496),
                        this.add(c);
                    const h = new Wn(t, n);
                    h.position.set(-2.193, -0.369, -5.547),
                        h.rotation.set(0, 0.516, 0),
                        h.scale.set(3.875, 3.487, 2.986),
                        this.add(h);
                    const u = new Wn(t, this.createAreaLightMaterial(50));
                    u.position.set(-16.116, 14.37, 8.208), u.scale.set(0.1, 2.428, 2.739), this.add(u);
                    const d = new Wn(t, this.createAreaLightMaterial(50));
                    d.position.set(-16.109, 18.021, -8.207), d.scale.set(0.1, 2.425, 2.751), this.add(d);
                    const p = new Wn(t, this.createAreaLightMaterial(17));
                    p.position.set(14.904, 12.198, -1.832), p.scale.set(0.15, 4.265, 6.331), this.add(p);
                    const m = new Wn(t, this.createAreaLightMaterial(43));
                    m.position.set(-0.462, 8.89, 14.52), m.scale.set(4.38, 5.441, 0.088), this.add(m);
                    const f = new Wn(t, this.createAreaLightMaterial(20));
                    f.position.set(3.235, 11.486, -12.541), f.scale.set(2.5, 2, 0.1), this.add(f);
                    const g = new Wn(t, this.createAreaLightMaterial(100));
                    g.position.set(0, 20, 0), g.scale.set(1, 0.1, 1), this.add(g);
                }
                createAreaLightMaterial(t) {
                    const e = new dn();
                    return e.color.setScalar(t), e;
                }
            }
            class ad extends Xs {
                constructor() {
                    super(), (this.position.y = -3.5);
                    const t = new qn();
                    t.deleteAttribute('uv');
                    const e = new Xo({ metalness: 0, side: 1 }),
                        n = new Xo({ metalness: 0 }),
                        i = new Cl(16777215, 400, 28, 2);
                    i.position.set(0.5, 14, 0.5), this.add(i);
                    const r = new Wn(t, e);
                    r.position.set(0, 13.2, 0), r.scale.set(31.5, 28.5, 31.5), this.add(r);
                    const s = new Wn(t, n);
                    s.position.set(-10.906, -1, 1.846),
                        s.rotation.set(0, -0.195, 0),
                        s.scale.set(2.328, 7.905, 4.651),
                        this.add(s);
                    const a = new Wn(t, n);
                    a.position.set(-5.607, -0.754, -0.758),
                        a.rotation.set(0, 0.994, 0),
                        a.scale.set(1.97, 1.534, 3.955),
                        this.add(a);
                    const o = new Wn(t, n);
                    o.position.set(6.167, -0.16, 7.803),
                        o.rotation.set(0, 0.561, 0),
                        o.scale.set(3.927, 6.285, 3.687),
                        this.add(o);
                    const l = new Wn(t, n);
                    l.position.set(-2.017, 0.018, 6.124),
                        l.rotation.set(0, 0.333, 0),
                        l.scale.set(2.002, 4.566, 2.064),
                        this.add(l);
                    const c = new Wn(t, n);
                    c.position.set(2.291, -0.756, -2.621),
                        c.rotation.set(0, -0.286, 0),
                        c.scale.set(1.546, 1.552, 1.496),
                        this.add(c);
                    const h = new Wn(t, n);
                    h.position.set(-2.193, -0.369, -5.547),
                        h.rotation.set(0, 0.516, 0),
                        h.scale.set(3.875, 3.487, 2.986),
                        this.add(h);
                    const u = new Wn(t, this.createAreaLightMaterial(80));
                    u.position.set(-14, 10, 8), u.scale.set(0.1, 2.5, 2.5), this.add(u);
                    const d = new Wn(t, this.createAreaLightMaterial(80));
                    d.position.set(-14, 14, -4), d.scale.set(0.1, 2.5, 2.5), this.add(d);
                    const p = new Wn(t, this.createAreaLightMaterial(23));
                    p.position.set(14, 12, 0), p.scale.set(0.1, 5, 5), this.add(p);
                    const m = new Wn(t, this.createAreaLightMaterial(16));
                    m.position.set(0, 9, 14), m.scale.set(5, 5, 0.1), this.add(m);
                    const f = new Wn(t, this.createAreaLightMaterial(80));
                    f.position.set(7, 8, -14), f.scale.set(2.5, 2.5, 0.1), this.add(f);
                    const g = new Wn(t, this.createAreaLightMaterial(80));
                    g.position.set(-7, 16, -14), g.scale.set(2.5, 2.5, 0.1), this.add(g);
                    const v = new Wn(t, this.createAreaLightMaterial(1));
                    v.position.set(0, 20, 0), v.scale.set(0.1, 0.1, 0.1), this.add(v);
                }
                createAreaLightMaterial(t) {
                    const e = new dn();
                    return e.color.setScalar(t), e;
                }
            }
            const od = /\.hdr(\.js)?$/,
                ld = new yl(),
                cd = new (class extends vl {
                    constructor(t) {
                        super(t), (this.type = 1016);
                    }
                    parse(t) {
                        const e = function (t, e) {
                                switch (t) {
                                    case 1:
                                        console.error('THREE.RGBELoader Read Error: ' + (e || ''));
                                        break;
                                    case 2:
                                        console.error('THREE.RGBELoader Write Error: ' + (e || ''));
                                        break;
                                    case 3:
                                        console.error('THREE.RGBELoader Bad File Format: ' + (e || ''));
                                        break;
                                    default:
                                        console.error('THREE.RGBELoader: Error: ' + (e || ''));
                                }
                                return -1;
                            },
                            n = function (t, e, n) {
                                e = e || 1024;
                                let i = t.pos,
                                    r = -1,
                                    s = 0,
                                    a = '',
                                    o = String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));
                                for (; 0 > (r = o.indexOf('\n')) && s < e && i < t.byteLength; )
                                    (a += o),
                                        (s += o.length),
                                        (i += 128),
                                        (o += String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128))));
                                return -1 < r && (!1 !== n && (t.pos += s + r + 1), a + o.slice(0, r));
                            },
                            i = function (t, e, n, i) {
                                const r = t[e + 3],
                                    s = Math.pow(2, r - 128) / 255;
                                (n[i + 0] = t[e + 0] * s), (n[i + 1] = t[e + 1] * s), (n[i + 2] = t[e + 2] * s);
                            },
                            r = function (t, e, n, i) {
                                const r = t[e + 3],
                                    s = Math.pow(2, r - 128) / 255;
                                (n[i + 0] = ac.toHalfFloat(Math.min(t[e + 0] * s, 65504))),
                                    (n[i + 1] = ac.toHalfFloat(Math.min(t[e + 1] * s, 65504))),
                                    (n[i + 2] = ac.toHalfFloat(Math.min(t[e + 2] * s, 65504)));
                            },
                            s = new Uint8Array(t);
                        s.pos = 0;
                        const a = (function (t) {
                            const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                                r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                                s = /^\s*FORMAT=(\S+)\s*$/,
                                a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                                o = {
                                    valid: 0,
                                    string: '',
                                    comments: '',
                                    programtype: 'RGBE',
                                    format: '',
                                    gamma: 1,
                                    exposure: 1,
                                    width: 0,
                                    height: 0,
                                };
                            let l, c;
                            if (t.pos >= t.byteLength || !(l = n(t))) return e(1, 'no header found');
                            if (!(c = l.match(/^#\?(\S+)/))) return e(3, 'bad initial token');
                            for (o.valid |= 1, o.programtype = c[1], o.string += l + '\n'; (l = n(t)), !1 !== l; )
                                if (((o.string += l + '\n'), '#' !== l.charAt(0))) {
                                    if (
                                        ((c = l.match(i)) && (o.gamma = parseFloat(c[1], 10)),
                                        (c = l.match(r)) && (o.exposure = parseFloat(c[1], 10)),
                                        (c = l.match(s)) && ((o.valid |= 2), (o.format = c[1])),
                                        (c = l.match(a)) &&
                                            ((o.valid |= 4),
                                            (o.height = parseInt(c[1], 10)),
                                            (o.width = parseInt(c[2], 10))),
                                        2 & o.valid && 4 & o.valid)
                                    )
                                        break;
                                } else o.comments += l + '\n';
                            return 2 & o.valid
                                ? 4 & o.valid
                                    ? o
                                    : e(3, 'missing image size specifier')
                                : e(3, 'missing format specifier');
                        })(s);
                        if (-1 !== a) {
                            const t = a.width,
                                n = a.height,
                                o = (function (t, n, i) {
                                    const r = n;
                                    if (r < 8 || r > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2])
                                        return new Uint8Array(t);
                                    if (r !== ((t[2] << 8) | t[3])) return e(3, 'wrong scanline width');
                                    const s = new Uint8Array(4 * n * i);
                                    if (!s.length) return e(4, 'unable to allocate buffer space');
                                    let a = 0,
                                        o = 0;
                                    const l = 4 * r,
                                        c = new Uint8Array(4),
                                        h = new Uint8Array(l);
                                    let u = i;
                                    for (; u > 0 && o < t.byteLength; ) {
                                        if (o + 4 > t.byteLength) return e(1);
                                        if (
                                            ((c[0] = t[o++]),
                                            (c[1] = t[o++]),
                                            (c[2] = t[o++]),
                                            (c[3] = t[o++]),
                                            2 != c[0] || 2 != c[1] || ((c[2] << 8) | c[3]) != r)
                                        )
                                            return e(3, 'bad rgbe scanline format');
                                        let n,
                                            i = 0;
                                        for (; i < l && o < t.byteLength; ) {
                                            n = t[o++];
                                            const r = n > 128;
                                            if ((r && (n -= 128), 0 === n || i + n > l))
                                                return e(3, 'bad scanline data');
                                            if (r) {
                                                const e = t[o++];
                                                for (let t = 0; t < n; t++) h[i++] = e;
                                            } else h.set(t.subarray(o, o + n), i), (i += n), (o += n);
                                        }
                                        const d = r;
                                        for (let t = 0; t < d; t++) {
                                            let e = 0;
                                            (s[a] = h[t + e]),
                                                (e += r),
                                                (s[a + 1] = h[t + e]),
                                                (e += r),
                                                (s[a + 2] = h[t + e]),
                                                (e += r),
                                                (s[a + 3] = h[t + e]),
                                                (a += 4);
                                        }
                                        u--;
                                    }
                                    return s;
                                })(s.subarray(s.pos), t, n);
                            if (-1 !== o) {
                                let e, s, l, c;
                                switch (this.type) {
                                    case 1009:
                                        (e = o), (s = 1023), (l = 1009);
                                        break;
                                    case 1015:
                                        c = o.length / 4;
                                        const t = new Float32Array(3 * c);
                                        for (let e = 0; e < c; e++) i(o, 4 * e, t, 3 * e);
                                        (e = t), (s = 1022), (l = 1015);
                                        break;
                                    case 1016:
                                        c = o.length / 4;
                                        const n = new Uint16Array(3 * c);
                                        for (let t = 0; t < c; t++) r(o, 4 * t, n, 3 * t);
                                        (e = n), (s = 1022), (l = 1016);
                                        break;
                                    default:
                                        console.error('THREE.RGBELoader: unsupported type: ', this.type);
                                }
                                return {
                                    width: t,
                                    height: n,
                                    data: e,
                                    header: a.string,
                                    gamma: a.gamma,
                                    exposure: a.exposure,
                                    format: s,
                                    type: l,
                                };
                            }
                        }
                        return null;
                    }
                    setDataType(t) {
                        return (this.type = t), this;
                    }
                    load(t, e, n, i) {
                        return super.load(
                            t,
                            function (t, n) {
                                switch (t.type) {
                                    case 1009:
                                        (t.encoding = 3002),
                                            (t.minFilter = 1003),
                                            (t.magFilter = 1003),
                                            (t.generateMipmaps = !1),
                                            (t.flipY = !0);
                                        break;
                                    case 1015:
                                    case 1016:
                                        (t.encoding = 3e3),
                                            (t.minFilter = 1006),
                                            (t.magFilter = 1006),
                                            (t.generateMipmaps = !1),
                                            (t.flipY = !0);
                                }
                                e && e(t, n);
                            },
                            n,
                            i,
                        );
                    }
                })();
            cd.setDataType(1016);
            class hd extends ft {
                constructor(t) {
                    super(),
                        (this.threeRenderer = t),
                        (this.generatedEnvironmentMap = null),
                        (this.generatedEnvironmentMapAlt = null),
                        (this.skyboxCache = new Map()),
                        (this.blurMaterial = null),
                        (this.blurScene = null);
                }
                async load(t, e = () => {}) {
                    try {
                        const n = od.test(t),
                            i = n ? cd : ld,
                            r = await new Promise((n, r) =>
                                i.load(
                                    t,
                                    n,
                                    (t) => {
                                        e((t.loaded / t.total) * 0.9);
                                    },
                                    r,
                                ),
                            );
                        return e(1), (r.name = t), (r.mapping = 303), n || (r.encoding = 3007), r;
                    } finally {
                        e && e(1);
                    }
                }
                async generateEnvironmentMapAndSkybox(t = null, e = null, n = {}) {
                    const { progressTracker: i } = n,
                        r = null != i ? i.beginActivity() : () => {},
                        s = 'neutral' === e;
                    !0 === s && (e = null);
                    const a = Ph(e);
                    try {
                        let e,
                            n = Promise.resolve(null);
                        t && (n = this.loadEquirectFromUrl(t, i)),
                            (e = a
                                ? this.loadEquirectFromUrl(a, i)
                                : t
                                ? this.loadEquirectFromUrl(t, i)
                                : !0 === s
                                ? this.loadGeneratedEnvironmentMapAlt()
                                : this.loadGeneratedEnvironmentMap());
                        let [o, l] = await Promise.all([e, n]);
                        if (null == o) throw new Error('Failed to load environment map.');
                        return { environmentMap: o, skybox: l };
                    } finally {
                        r(1);
                    }
                }
                async loadEquirectFromUrl(t, e) {
                    if (!this.skyboxCache.has(t)) {
                        const n = e ? e.beginActivity() : () => {},
                            i = this.load(t, n);
                        this.skyboxCache.set(t, i);
                    }
                    return this.skyboxCache.get(t);
                }
                async GenerateEnvironmentMap(t, e) {
                    await kh();
                    const n = this.threeRenderer,
                        i = new ei(256, {
                            generateMipmaps: !1,
                            type: 1016,
                            format: 1023,
                            encoding: 3e3,
                            depthBuffer: !0,
                        }),
                        r = new Qn(0.1, 100, i),
                        s = r.renderTarget.texture;
                    (s.name = e),
                        (s.isRenderTargetTexture = !1),
                        (s.images = [1, 1, 1, 1, 1, 1]),
                        t.scale.setComponent(0, -1);
                    const a = n.outputEncoding,
                        o = n.toneMapping;
                    return (
                        (n.toneMapping = 0),
                        (n.outputEncoding = 3e3),
                        r.update(n, t),
                        await this.blurCubemap(i, 0.04),
                        (n.toneMapping = o),
                        (n.outputEncoding = a),
                        s
                    );
                }
                async loadGeneratedEnvironmentMap() {
                    return (
                        null == this.generatedEnvironmentMap &&
                            (this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new sd(), 'default')),
                        this.generatedEnvironmentMap
                    );
                }
                async loadGeneratedEnvironmentMapAlt() {
                    return (
                        null == this.generatedEnvironmentMapAlt &&
                            (this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new ad(), 'neutral')),
                        this.generatedEnvironmentMapAlt
                    );
                }
                async blurCubemap(t, e) {
                    if (null == this.blurMaterial) {
                        this.blurMaterial = this.getBlurShader(20);
                        const t = new qn(),
                            e = new Wn(t, this.blurMaterial);
                        (this.blurScene = new Xs()), this.blurScene.add(e);
                    }
                    const n = t.clone();
                    this.halfblur(t, n, e, 'latitudinal'), this.halfblur(n, t, e, 'longitudinal');
                }
                async halfblur(t, e, n, i) {
                    const r = t.width,
                        s = isFinite(n) ? Math.PI / (2 * r) : (2 * Math.PI) / 39,
                        a = n / s,
                        o = isFinite(n) ? 1 + Math.floor(3 * a) : 20;
                    o > 20 &&
                        console.warn(
                            `sigmaRadians, ${n}, is too large and will clip, as it requested ${o} samples when the maximum is set to 20`,
                        );
                    const l = [];
                    let c = 0;
                    for (let t = 0; t < 20; ++t) {
                        const e = t / a,
                            n = Math.exp((-e * e) / 2);
                        l.push(n), 0 == t ? (c += n) : t < o && (c += 2 * n);
                    }
                    for (let t = 0; t < l.length; t++) l[t] = l[t] / c;
                    const h = this.blurMaterial.uniforms;
                    (h.envMap.value = t.texture),
                        (h.samples.value = o),
                        (h.weights.value = l),
                        (h.latitudinal.value = 'latitudinal' === i),
                        (h.dTheta.value = s),
                        new Qn(0.1, 100, e).update(this.threeRenderer, this.blurScene);
                }
                getBlurShader(t) {
                    const e = new Float32Array(t),
                        n = new Gt(0, 1, 0);
                    return new Jn({
                        name: 'SphericalGaussianBlur',
                        defines: { n: t },
                        uniforms: {
                            envMap: { value: null },
                            samples: { value: 1 },
                            weights: { value: e },
                            latitudinal: { value: !1 },
                            dTheta: { value: 0 },
                            poleAxis: { value: n },
                        },
                        vertexShader:
                            '\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    ',
                        fragmentShader:
                            "\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      ",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        side: 1,
                    });
                }
                async dispose() {
                    for (const [, t] of this.skyboxCache) (await t).dispose();
                    null != this.generatedEnvironmentMap &&
                        ((await this.generatedEnvironmentMap).dispose(), (this.generatedEnvironmentMap = null)),
                        null != this.generatedEnvironmentMapAlt &&
                            ((await this.generatedEnvironmentMapAlt).dispose(),
                            (this.generatedEnvironmentMapAlt = null)),
                        null != this.blurMaterial && this.blurMaterial.dispose();
                }
            }
            const ud = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];
            class dd extends ft {
                constructor(t) {
                    super(),
                        (this.loader = new Mh(rd)),
                        (this.width = 0),
                        (this.height = 0),
                        (this.dpr = 1),
                        (this.debugger = null),
                        (this.scenes = new Set()),
                        (this.multipleScenesVisible = !1),
                        (this.scaleStep = 0),
                        (this.lastStep = 3),
                        (this.avgFrameDuration = 22),
                        (this.onWebGLContextLost = (t) => {
                            this.dispatchEvent({ type: 'contextlost', sourceEvent: t });
                        }),
                        (this.onWebGLContextRestored = () => {
                            var t;
                            null === (t = this.textureUtils) || void 0 === t || t.dispose(),
                                (this.textureUtils = new hd(this.threeRenderer)),
                                (this.roughnessMipmapper = new vu(this.threeRenderer));
                            for (const t of this.scenes) t.element[wu]();
                            this.threeRenderer.shadowMap.needsUpdate = !0;
                        }),
                        (this.dpr = Oh()),
                        (this.canvas3D = document.createElement('canvas')),
                        (this.canvas3D.id = 'webgl-canvas');
                    try {
                        (this.threeRenderer = new qs({
                            canvas: this.canvas3D,
                            alpha: !0,
                            antialias: !0,
                            powerPreference: t.powerPreference,
                            preserveDrawingBuffer: !0,
                        })),
                            (this.threeRenderer.autoClear = !0),
                            (this.threeRenderer.outputEncoding = 3007),
                            (this.threeRenderer.physicallyCorrectLights = !0),
                            this.threeRenderer.setPixelRatio(1),
                            (this.threeRenderer.shadowMap.enabled = !0),
                            (this.threeRenderer.shadowMap.type = 2),
                            (this.threeRenderer.shadowMap.autoUpdate = !1),
                            (this.debugger = t.debug ? new ku(this) : null),
                            (this.threeRenderer.debug = { checkShaderErrors: !!this.debugger }),
                            (this.threeRenderer.toneMapping = 4);
                    } catch (t) {
                        console.warn(t);
                    }
                    (this.arRenderer = new Uu(this)),
                        (this.textureUtils = this.canRender ? new hd(this.threeRenderer) : null),
                        (this.roughnessMipmapper = new vu(this.threeRenderer)),
                        Mh.initializeKTX2Loader(this.threeRenderer),
                        this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost),
                        this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored),
                        this.updateRendererSize(),
                        (this.lastTick = performance.now()),
                        (this.avgFrameDuration = 0);
                }
                static get singleton() {
                    return this._singleton;
                }
                static resetSingleton() {
                    const t = this._singleton.dispose();
                    for (const e of t) e.disconnectedCallback();
                    this._singleton = new dd({
                        powerPreference: (self.ModelViewerElement || {}).powerPreference || 'high-performance',
                        debug: Uh(),
                    });
                    for (const e of t) e.connectedCallback();
                }
                get canRender() {
                    return null != this.threeRenderer;
                }
                get scaleFactor() {
                    return ud[this.scaleStep];
                }
                set minScale(t) {
                    let e = 1;
                    for (; e < ud.length && !(ud[e] < t); ) ++e;
                    this.lastStep = e - 1;
                }
                updateRendererSize() {
                    const t = Oh();
                    if (t !== this.dpr)
                        for (const t of this.scenes) {
                            const { element: e } = t;
                            e[Ud](e.getBoundingClientRect());
                        }
                    let e = 0,
                        n = 0;
                    for (const t of this.scenes) (e = Math.max(e, t.width)), (n = Math.max(n, t.height));
                    if (e === this.width && n === this.height && t === this.dpr) return;
                    (this.width = e),
                        (this.height = n),
                        (this.dpr = t),
                        this.canRender && this.threeRenderer.setSize(e * t, n * t, !1);
                    const i = this.scaleFactor,
                        r = e / i,
                        s = n / i;
                    (this.canvas3D.style.width = `${r}px`), (this.canvas3D.style.height = `${s}px`);
                    for (const i of this.scenes) {
                        const { canvas: a } = i;
                        (a.width = Math.round(e * t)),
                            (a.height = Math.round(n * t)),
                            (a.style.width = `${r}px`),
                            (a.style.height = `${s}px`),
                            i.queueRender();
                    }
                }
                updateRendererScale() {
                    const t = this.scaleStep;
                    if (
                        (this.avgFrameDuration > 26
                            ? ++this.scaleStep
                            : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep,
                        (this.scaleStep = Math.min(this.scaleStep, this.lastStep)),
                        t == this.scaleStep)
                    )
                        return;
                    const e = this.scaleFactor;
                    this.avgFrameDuration = 22;
                    const n = this.width / e,
                        i = this.height / e;
                    (this.canvas3D.style.width = `${n}px`), (this.canvas3D.style.height = `${i}px`);
                    for (const t of this.scenes) {
                        const { style: e } = t.canvas;
                        (e.width = `${n}px`), (e.height = `${i}px`), t.queueRender();
                    }
                }
                registerScene(t) {
                    this.scenes.add(t);
                    const { canvas: e } = t,
                        n = this.scaleFactor;
                    (e.width = Math.round(this.width * this.dpr)),
                        (e.height = Math.round(this.height * this.dpr)),
                        (e.style.width = this.width / n + 'px'),
                        (e.style.height = this.height / n + 'px'),
                        this.multipleScenesVisible && e.classList.add('show'),
                        t.queueRender(),
                        this.canRender &&
                            this.scenes.size > 0 &&
                            this.threeRenderer.setAnimationLoop((t, e) => this.render(t, e)),
                        null != this.debugger && this.debugger.addScene(t);
                }
                unregisterScene(t) {
                    this.scenes.delete(t),
                        this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null),
                        null != this.debugger && this.debugger.removeScene(t);
                }
                displayCanvas(t) {
                    return this.multipleScenesVisible ? t.element[Xd] : this.canvas3D;
                }
                selectCanvas() {
                    let t = 0,
                        e = null;
                    for (const n of this.scenes) {
                        const { element: i } = n;
                        i.modelIsVisible && null == n.externalRenderer && (++t, (e = n.canvas));
                    }
                    if (null == e) return;
                    const n = t > 1,
                        { canvas3D: i } = this;
                    if (n !== this.multipleScenesVisible || (!n && i.parentElement !== e.parentElement)) {
                        (this.multipleScenesVisible = n), n && i.classList.remove('show');
                        for (const t of this.scenes) {
                            if (null != t.externalRenderer) continue;
                            const r = t.element[Xd];
                            n
                                ? (r.classList.add('show'), t.queueRender())
                                : t.canvas === e &&
                                  (t.canvas.parentElement.appendChild(i),
                                  i.classList.add('show'),
                                  r.classList.remove('show'),
                                  t.queueRender());
                        }
                    }
                }
                orderedScenes() {
                    const t = [];
                    for (const e of [!1, !0]) for (const n of this.scenes) n.element.modelIsVisible === e && t.push(n);
                    return t;
                }
                get isPresenting() {
                    return this.arRenderer.isPresenting;
                }
                preRender(t, e, n) {
                    const { element: i, exposure: r } = t;
                    i[Jd](e, n);
                    const s = 'number' == typeof r && !self.isNaN(r);
                    (this.threeRenderer.toneMappingExposure = s ? r : 1),
                        t.isShadowDirty() && (this.threeRenderer.shadowMap.needsUpdate = !0);
                }
                render(t, e) {
                    if (null != e) return void this.arRenderer.onWebXRFrame(t, e);
                    const n = t - this.lastTick;
                    if (((this.lastTick = t), !this.canRender || this.isPresenting)) return;
                    (this.avgFrameDuration += Fh(0.2 * (n - this.avgFrameDuration), -2, 2)),
                        this.selectCanvas(),
                        this.updateRendererSize(),
                        this.updateRendererScale();
                    const { dpr: i, scaleFactor: r } = this;
                    for (const e of this.orderedScenes()) {
                        const { element: s } = e;
                        if (!s.modelIsVisible && e.renderCount > 0) continue;
                        if ((this.preRender(e, t, n), !e.shouldRender())) continue;
                        if (null != e.externalRenderer) {
                            const t = e.getCamera();
                            t.updateMatrix();
                            const { matrix: n, projectionMatrix: i } = t,
                                r = n.elements.slice(),
                                s = e.getTarget();
                            (r[12] += s.x),
                                (r[13] += s.y),
                                (r[14] += s.z),
                                e.externalRenderer.render({ viewMatrix: r, projectionMatrix: i.elements });
                            continue;
                        }
                        if (!s.modelIsVisible && !this.multipleScenesVisible)
                            for (const t of this.scenes) t.element.modelIsVisible && t.queueRender();
                        const a = Math.min(Math.ceil(e.width * r * i), this.canvas3D.width),
                            o = Math.min(Math.ceil(e.height * r * i), this.canvas3D.height);
                        if (
                            (this.threeRenderer.setRenderTarget(null),
                            this.threeRenderer.setViewport(0, Math.floor(this.height * i) - o, a, o),
                            this.threeRenderer.render(e, e.camera),
                            this.multipleScenesVisible)
                        ) {
                            null == e.context && e.createContext();
                            const t = e.context;
                            t.clearRect(0, 0, a, o), t.drawImage(this.canvas3D, 0, 0, a, o, 0, 0, a, o);
                        }
                        e.hasRendered(), s.loaded && ++e.renderCount;
                    }
                }
                dispose() {
                    null != this.textureUtils && this.textureUtils.dispose(),
                        null != this.roughnessMipmapper && this.roughnessMipmapper.dispose(),
                        null != this.threeRenderer && this.threeRenderer.dispose(),
                        (this.textureUtils = null),
                        (this.threeRenderer = null);
                    const t = [];
                    for (const e of this.scenes) t.push(e.element);
                    return (
                        this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost),
                        this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored),
                        t
                    );
                }
            }
            var pd, md;
            dd._singleton = new dd({
                powerPreference: (self.ModelViewerElement || {}).powerPreference || 'high-performance',
                debug: Uh(),
            });
            const fd = Symbol('ongoingActivities'),
                gd = Symbol('announceTotalProgress'),
                vd = Symbol('eventDelegate');
            class yd {
                constructor() {
                    (this[pd] = document.createDocumentFragment()),
                        (this.addEventListener = (...t) => this[vd].addEventListener(...t)),
                        (this.removeEventListener = (...t) => this[vd].removeEventListener(...t)),
                        (this.dispatchEvent = (...t) => this[vd].dispatchEvent(...t)),
                        (this[md] = new Set());
                }
                get ongoingActivityCount() {
                    return this[fd].size;
                }
                beginActivity() {
                    const t = { progress: 0 };
                    return (
                        this[fd].add(t),
                        1 === this.ongoingActivityCount && this[gd](),
                        (e) => {
                            let n;
                            return (
                                (n = Math.max(Fh(e, 0, 1), t.progress)),
                                n !== t.progress && ((t.progress = n), this[gd]()),
                                t.progress
                            );
                        }
                    );
                }
                [((pd = vd), (md = fd), gd)]() {
                    let t = 0,
                        e = 0,
                        n = 0;
                    for (const i of this[fd]) {
                        const { progress: r } = i;
                        (t += r * (0.5 / Math.pow(2, e++))), 1 === r && n++;
                    }
                    n === this.ongoingActivityCount && ((t = 1), this[fd].clear()),
                        this.dispatchEvent(new CustomEvent('progress', { detail: { totalProgress: t } }));
                }
            }
            var xd,
                bd,
                wd,
                _d,
                Md,
                Sd,
                Td,
                Ed,
                Ad,
                Ld,
                Rd = function (t, e, n, i) {
                    for (
                        var r,
                            s = arguments.length,
                            a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                            o = t.length - 1;
                        o >= 0;
                        o--
                    )
                        (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                    return s > 3 && a && Object.defineProperty(e, n, a), a;
                };
            const Cd = document.createElement('canvas'),
                Pd = Symbol('fallbackResizeHandler'),
                Id = Symbol('defaultAriaLabel'),
                Dd = Symbol('resizeObserver'),
                Nd = Symbol('clearModelTimeout'),
                Fd = Symbol('onContextLost'),
                Od = Symbol('loaded'),
                Ud = Symbol('updateSize'),
                kd = Symbol('intersectionObserver'),
                zd = Symbol('isElementInViewport'),
                Bd = Symbol('announceModelVisibility'),
                Hd = Symbol('ariaLabel'),
                Gd = Symbol('loadedTime'),
                Vd = Symbol('updateSource'),
                Wd = Symbol('markLoaded'),
                jd = Symbol('container'),
                qd = Symbol('input'),
                Xd = Symbol('canvas'),
                Yd = Symbol('scene'),
                Zd = Symbol('needsRender'),
                Jd = Symbol('tick'),
                $d = Symbol('onModelLoad'),
                Kd = Symbol('onResize'),
                Qd = Symbol('renderer'),
                tp = Symbol('progressTracker'),
                ep = Symbol('getLoaded'),
                np = Symbol('getModelIsVisible'),
                ip = Symbol('shouldAttemptPreload'),
                rp = Symbol('sceneIsReady'),
                sp = Symbol('hasTransitioned'),
                ap = (t) => ({
                    x: t.x,
                    y: t.y,
                    z: t.z,
                    toString() {
                        return `${this.x}m ${this.y}m ${this.z}m`;
                    },
                });
            class op extends Z {
                constructor() {
                    super(),
                        (this.alt = null),
                        (this.src = null),
                        (this[xd] = !1),
                        (this[bd] = !1),
                        (this[wd] = 0),
                        (this[_d] = null),
                        (this[Md] = Nh(() => {
                            const t = this.getBoundingClientRect();
                            this[Ud](t);
                        }, 50)),
                        (this[Sd] = Nh((t) => {
                            const e = this.modelIsVisible;
                            e !== t &&
                                this.dispatchEvent(new CustomEvent('model-visibility', { detail: { visible: e } }));
                        }, 0)),
                        (this[Td] = null),
                        (this[Ed] = null),
                        (this[Ad] = new yd()),
                        (this[Ld] = (t) => {
                            this.dispatchEvent(
                                new CustomEvent('error', {
                                    detail: { type: 'webglcontextlost', sourceError: t.sourceEvent },
                                }),
                            );
                        }),
                        this.attachShadow({ mode: 'open' });
                    const t = this.shadowRoot;
                    let e, n;
                    if (
                        (((t) => {
                            k(mt, t);
                        })(t),
                        (this[jd] = t.querySelector('.container')),
                        (this[qd] = t.querySelector('.userInput')),
                        (this[Xd] = t.querySelector('canvas')),
                        (this[Id] = this[qd].getAttribute('aria-label')),
                        this.isConnected)
                    ) {
                        const t = this.getBoundingClientRect();
                        (e = t.width), (n = t.height);
                    } else (e = 300), (n = 150);
                    (this[Yd] = new uu({ canvas: this[Xd], element: this, width: e, height: n })),
                        this[Yd].addEventListener('model-load', async (t) => {
                            this[Wd](),
                                this[$d](),
                                await kh(),
                                this.dispatchEvent(new CustomEvent('load', { detail: { url: t.url } }));
                        }),
                        Promise.resolve().then(() => {
                            this[Ud](this.getBoundingClientRect());
                        }),
                        st &&
                            (this[Dd] = new ResizeObserver((t) => {
                                if (!this[Qd].isPresenting)
                                    for (let e of t) e.target === this && this[Ud](e.contentRect);
                            })),
                        at
                            ? (this[kd] = new IntersectionObserver(
                                  (t) => {
                                      for (let e of t)
                                          if (e.target === this) {
                                              const t = this.modelIsVisible;
                                              (this[zd] = e.isIntersecting),
                                                  this[Bd](t),
                                                  this[zd] && !this[rp]() && this[Vd]();
                                          }
                                  },
                                  { root: null, rootMargin: '0px', threshold: 0 },
                              ))
                            : (this[zd] = !0);
                }
                static get is() {
                    return 'model-viewer';
                }
                static set modelCacheSize(t) {
                    Mh[wh].evictionThreshold = t;
                }
                static get modelCacheSize() {
                    return Mh[wh].evictionThreshold;
                }
                static set minimumRenderScale(t) {
                    t > 1 &&
                        console.warn('<model-viewer> minimumRenderScale has been clamped to a maximum value of 1.'),
                        t <= 0 &&
                            console.warn(
                                '<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25.',
                            ),
                        (dd.singleton.minScale = t);
                }
                static get minimumRenderScale() {
                    return dd.singleton.minScale;
                }
                get loaded() {
                    return this[ep]();
                }
                get [((xd = zd),
                (bd = Od),
                (wd = Gd),
                (_d = Nd),
                (Md = Pd),
                (Sd = Bd),
                (Td = Dd),
                (Ed = kd),
                (Ad = tp),
                Qd)]() {
                    return dd.singleton;
                }
                get modelIsVisible() {
                    return this[np]();
                }
                connectedCallback() {
                    super.connectedCallback && super.connectedCallback(),
                        st ? this[Dd].observe(this) : self.addEventListener('resize', this[Pd]),
                        at && this[kd].observe(this);
                    const t = this[Qd];
                    t.addEventListener('contextlost', this[Fd]),
                        t.registerScene(this[Yd]),
                        null != this[Nd] &&
                            (self.clearTimeout(this[Nd]), (this[Nd] = null), this.requestUpdate('src', null));
                }
                disconnectedCallback() {
                    super.disconnectedCallback && super.disconnectedCallback(),
                        st ? this[Dd].unobserve(this) : self.removeEventListener('resize', this[Pd]),
                        at && this[kd].unobserve(this);
                    const t = this[Qd];
                    t.removeEventListener('contextlost', this[Fd]),
                        t.unregisterScene(this[Yd]),
                        (this[Nd] = self.setTimeout(() => {
                            this[Yd].reset();
                        }, 1e3));
                }
                updated(t) {
                    if (
                        (super.updated(t),
                        t.has('src') &&
                            (null == this.src
                                ? ((this[Od] = !1), (this[Gd] = 0), this[Yd].reset())
                                : this.src !== this[Yd].url && ((this[Od] = !1), (this[Gd] = 0), this[Vd]())),
                        t.has('alt'))
                    ) {
                        const t = null == this.alt ? this[Id] : this.alt;
                        this[qd].setAttribute('aria-label', t);
                    }
                }
                toDataURL(t, e) {
                    return this[Qd].displayCanvas(this[Yd]).toDataURL(t, e);
                }
                async toBlob(t) {
                    const e = t ? t.mimeType : void 0,
                        n = t ? t.qualityArgument : void 0,
                        i = t ? t.idealAspect : void 0,
                        { width: r, height: s, fieldOfViewAspect: a, aspect: o } = this[Yd],
                        { dpr: l, scaleFactor: c } = this[Qd];
                    let h = r * c * l,
                        u = s * c * l,
                        d = 0,
                        p = 0;
                    if (!0 === i)
                        if (a > o) {
                            const t = u;
                            (u = Math.round(h / a)), (p = (t - u) / 2);
                        } else {
                            const t = h;
                            (h = Math.round(u * a)), (d = (t - h) / 2);
                        }
                    (Cd.width = h), (Cd.height = u);
                    try {
                        return new Promise(
                            async (t, i) => (
                                Cd.getContext('2d').drawImage(this[Qd].displayCanvas(this[Yd]), d, p, h, u, 0, 0, h, u),
                                !Cd.msToBlob || (e && 'image/png' !== e)
                                    ? Cd.toBlob
                                        ? void Cd.toBlob(
                                              (e) => {
                                                  if (!e) return i(new Error('Unable to retrieve canvas blob'));
                                                  t(e);
                                              },
                                              e,
                                              n,
                                          )
                                        : t(
                                              await (async (t) =>
                                                  new Promise((e, n) => {
                                                      const i = t.match(/data:(.*);/);
                                                      if (!i) return n(new Error(`${t} is not a valid data Url`));
                                                      const r = i[1],
                                                          s = t.replace(/data:image\/\w+;base64,/, ''),
                                                          a = atob(s),
                                                          o = [];
                                                      for (let t = 0; t < a.length; t += 512) {
                                                          const e = a.slice(t, t + 512),
                                                              n = new Array(e.length);
                                                          for (let t = 0; t < e.length; t++) n[t] = e.charCodeAt(t);
                                                          const i = new Uint8Array(n);
                                                          o.push(i);
                                                      }
                                                      e(new Blob(o, { type: r }));
                                                  }))(Cd.toDataURL(e, n)),
                                          )
                                    : t(Cd.msToBlob())
                            ),
                        );
                    } finally {
                        this[Ud]({ width: r, height: s });
                    }
                }
                registerRenderer(t) {
                    this[Yd].externalRenderer = t;
                }
                unregisterRenderer() {
                    this[Yd].externalRenderer = null;
                }
                get [Hd]() {
                    return null == this.alt || 'null' === this.alt ? this[Id] : this.alt;
                }
                [ep]() {
                    return this[Od];
                }
                [np]() {
                    return this.loaded && this[zd];
                }
                [sp]() {
                    return this.modelIsVisible;
                }
                [ip]() {
                    return !!this.src && this[zd];
                }
                [rp]() {
                    return this[Od];
                }
                [Ud]({ width: t, height: e }) {
                    (this[jd].style.width = `${t}px`),
                        (this[jd].style.height = `${e}px`),
                        this[Kd]({ width: parseFloat(t), height: parseFloat(e) });
                }
                [Jd](t, e) {}
                [Wd]() {
                    this[Od] || ((this[Od] = !0), (this[Gd] = performance.now()));
                }
                [Zd]() {
                    this[Yd].queueRender();
                }
                [$d]() {}
                [Kd](t) {
                    this[Yd].setSize(t.width, t.height);
                }
                async [((Ld = Fd), Vd)]() {
                    if (this.loaded || !this[ip]()) return;
                    const t = this[tp].beginActivity(),
                        e = this.src;
                    try {
                        await this[Yd].setSource(e, (e) => t(0.8 * e));
                        const n = { url: e };
                        this.dispatchEvent(new CustomEvent('preload', { detail: n }));
                    } catch (t) {
                        this.dispatchEvent(new CustomEvent('error', { detail: t }));
                    } finally {
                        t(0.9),
                            requestAnimationFrame(() => {
                                requestAnimationFrame(() => {
                                    t(1);
                                });
                            });
                    }
                }
            }
            Rd([$({ type: String })], op.prototype, 'alt', void 0),
                Rd([$({ type: String })], op.prototype, 'src', void 0);
            var lp = function (t, e, n, i) {
                for (
                    var r,
                        s = arguments.length,
                        a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                        o = t.length - 1;
                    o >= 0;
                    o--
                )
                    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                return s > 3 && a && Object.defineProperty(e, n, a), a;
            };
            const cp = Symbol('changeAnimation'),
                hp = Symbol('paused'),
                up = Symbol('hotspotMap'),
                dp = Symbol('mutationCallback'),
                pp = Symbol('observer'),
                mp = Symbol('addHotspot'),
                fp = Symbol('removeHotspot'),
                gp = new xe(),
                vp = new Ct();
            var yp = function (t) {
                return URL.createObjectURL(new Blob([t], { type: 'text/javascript' }));
            };
            try {
                URL.revokeObjectURL(yp(''));
            } catch (i) {
                yp = function (t) {
                    return 'data:application/javascript;charset=UTF-8,' + encodeURI(t);
                };
            }
            var xp = Uint8Array,
                bp = Uint16Array,
                wp = Uint32Array,
                _p = new xp([
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
                ]),
                Mp = new xp([
                    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0,
                    0,
                ]),
                Sp = new xp([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                Tp = function (t, e) {
                    for (var n = new bp(31), i = 0; i < 31; ++i) n[i] = e += 1 << t[i - 1];
                    var r = new wp(n[30]);
                    for (i = 1; i < 30; ++i) for (var s = n[i]; s < n[i + 1]; ++s) r[s] = ((s - n[i]) << 5) | i;
                    return [n, r];
                },
                Ep = Tp(_p, 2),
                Ap = Ep[0],
                Lp = Ep[1];
            (Ap[28] = 258), (Lp[258] = 28);
            for (var Rp = Tp(Mp, 0)[1], Cp = new bp(32768), Pp = 0; Pp < 32768; ++Pp) {
                var Ip = ((43690 & Pp) >>> 1) | ((21845 & Pp) << 1);
                (Ip = ((61680 & (Ip = ((52428 & Ip) >>> 2) | ((13107 & Ip) << 2))) >>> 4) | ((3855 & Ip) << 4)),
                    (Cp[Pp] = (((65280 & Ip) >>> 8) | ((255 & Ip) << 8)) >>> 1);
            }
            var Dp = function (t, e, n) {
                    for (var i = t.length, r = 0, s = new bp(e); r < i; ++r) ++s[t[r] - 1];
                    var a,
                        o = new bp(e);
                    for (r = 0; r < e; ++r) o[r] = (o[r - 1] + s[r - 1]) << 1;
                    if (n) {
                        a = new bp(1 << e);
                        var l = 15 - e;
                        for (r = 0; r < i; ++r)
                            if (t[r])
                                for (
                                    var c = (r << 4) | t[r],
                                        h = e - t[r],
                                        u = o[t[r] - 1]++ << h,
                                        d = u | ((1 << h) - 1);
                                    u <= d;
                                    ++u
                                )
                                    a[Cp[u] >>> l] = c;
                    } else for (a = new bp(i), r = 0; r < i; ++r) t[r] && (a[r] = Cp[o[t[r] - 1]++] >>> (15 - t[r]));
                    return a;
                },
                Np = new xp(288);
            for (Pp = 0; Pp < 144; ++Pp) Np[Pp] = 8;
            for (Pp = 144; Pp < 256; ++Pp) Np[Pp] = 9;
            for (Pp = 256; Pp < 280; ++Pp) Np[Pp] = 7;
            for (Pp = 280; Pp < 288; ++Pp) Np[Pp] = 8;
            var Fp = new xp(32);
            for (Pp = 0; Pp < 32; ++Pp) Fp[Pp] = 5;
            var Op = Dp(Np, 9, 0),
                Up = Dp(Fp, 5, 0),
                kp = function (t) {
                    return ((t / 8) | 0) + (7 & t && 1);
                },
                zp = function (t, e, n) {
                    (null == e || e < 0) && (e = 0), (null == n || n > t.length) && (n = t.length);
                    var i = new (t instanceof bp ? bp : t instanceof wp ? wp : xp)(n - e);
                    return i.set(t.subarray(e, n)), i;
                },
                Bp = function (t, e, n) {
                    n <<= 7 & e;
                    var i = (e / 8) | 0;
                    (t[i] |= n), (t[i + 1] |= n >>> 8);
                },
                Hp = function (t, e, n) {
                    n <<= 7 & e;
                    var i = (e / 8) | 0;
                    (t[i] |= n), (t[i + 1] |= n >>> 8), (t[i + 2] |= n >>> 16);
                },
                Gp = function (t, e) {
                    for (var n = [], i = 0; i < t.length; ++i) t[i] && n.push({ s: i, f: t[i] });
                    var r = n.length,
                        s = n.slice();
                    if (!r) return [Zp, 0];
                    if (1 == r) {
                        var a = new xp(n[0].s + 1);
                        return (a[n[0].s] = 1), [a, 1];
                    }
                    n.sort(function (t, e) {
                        return t.f - e.f;
                    }),
                        n.push({ s: -1, f: 25001 });
                    var o = n[0],
                        l = n[1],
                        c = 0,
                        h = 1,
                        u = 2;
                    for (n[0] = { s: -1, f: o.f + l.f, l: o, r: l }; h != r - 1; )
                        (o = n[n[c].f < n[u].f ? c++ : u++]),
                            (l = n[c != h && n[c].f < n[u].f ? c++ : u++]),
                            (n[h++] = { s: -1, f: o.f + l.f, l: o, r: l });
                    var d = s[0].s;
                    for (i = 1; i < r; ++i) s[i].s > d && (d = s[i].s);
                    var p = new bp(d + 1),
                        m = Vp(n[h - 1], p, 0);
                    if (m > e) {
                        i = 0;
                        var f = 0,
                            g = m - e,
                            v = 1 << g;
                        for (
                            s.sort(function (t, e) {
                                return p[e.s] - p[t.s] || t.f - e.f;
                            });
                            i < r;
                            ++i
                        ) {
                            var y = s[i].s;
                            if (!(p[y] > e)) break;
                            (f += v - (1 << (m - p[y]))), (p[y] = e);
                        }
                        for (f >>>= g; f > 0; ) {
                            var x = s[i].s;
                            p[x] < e ? (f -= 1 << (e - p[x]++ - 1)) : ++i;
                        }
                        for (; i >= 0 && f; --i) {
                            var b = s[i].s;
                            p[b] == e && (--p[b], ++f);
                        }
                        m = e;
                    }
                    return [new xp(p), m];
                },
                Vp = function (t, e, n) {
                    return -1 == t.s ? Math.max(Vp(t.l, e, n + 1), Vp(t.r, e, n + 1)) : (e[t.s] = n);
                },
                Wp = function (t) {
                    for (var e = t.length; e && !t[--e]; );
                    for (
                        var n = new bp(++e),
                            i = 0,
                            r = t[0],
                            s = 1,
                            a = function (t) {
                                n[i++] = t;
                            },
                            o = 1;
                        o <= e;
                        ++o
                    )
                        if (t[o] == r && o != e) ++s;
                        else {
                            if (!r && s > 2) {
                                for (; s > 138; s -= 138) a(32754);
                                s > 2 && (a(s > 10 ? ((s - 11) << 5) | 28690 : ((s - 3) << 5) | 12305), (s = 0));
                            } else if (s > 3) {
                                for (a(r), --s; s > 6; s -= 6) a(8304);
                                s > 2 && (a(((s - 3) << 5) | 8208), (s = 0));
                            }
                            for (; s--; ) a(r);
                            (s = 1), (r = t[o]);
                        }
                    return [n.subarray(0, i), e];
                },
                jp = function (t, e) {
                    for (var n = 0, i = 0; i < e.length; ++i) n += t[i] * e[i];
                    return n;
                },
                qp = function (t, e, n) {
                    var i = n.length,
                        r = kp(e + 2);
                    (t[r] = 255 & i), (t[r + 1] = i >>> 8), (t[r + 2] = 255 ^ t[r]), (t[r + 3] = 255 ^ t[r + 1]);
                    for (var s = 0; s < i; ++s) t[r + s + 4] = n[s];
                    return 8 * (r + 4 + i);
                },
                Xp = function (t, e, n, i, r, s, a, o, l, c, h) {
                    Bp(e, h++, n), ++r[256];
                    for (
                        var u = Gp(r, 15),
                            d = u[0],
                            p = u[1],
                            m = Gp(s, 15),
                            f = m[0],
                            g = m[1],
                            v = Wp(d),
                            y = v[0],
                            x = v[1],
                            b = Wp(f),
                            w = b[0],
                            _ = b[1],
                            M = new bp(19),
                            S = 0;
                        S < y.length;
                        ++S
                    )
                        M[31 & y[S]]++;
                    for (S = 0; S < w.length; ++S) M[31 & w[S]]++;
                    for (var T = Gp(M, 7), E = T[0], A = T[1], L = 19; L > 4 && !E[Sp[L - 1]]; --L);
                    var R,
                        C,
                        P,
                        I,
                        D = (c + 5) << 3,
                        N = jp(r, Np) + jp(s, Fp) + a,
                        F = jp(r, d) + jp(s, f) + a + 14 + 3 * L + jp(M, E) + (2 * M[16] + 3 * M[17] + 7 * M[18]);
                    if (D <= N && D <= F) return qp(e, h, t.subarray(l, l + c));
                    if ((Bp(e, h, 1 + (F < N)), (h += 2), F < N)) {
                        (R = Dp(d, p, 0)), (C = d), (P = Dp(f, g, 0)), (I = f);
                        var O = Dp(E, A, 0);
                        for (Bp(e, h, x - 257), Bp(e, h + 5, _ - 1), Bp(e, h + 10, L - 4), h += 14, S = 0; S < L; ++S)
                            Bp(e, h + 3 * S, E[Sp[S]]);
                        h += 3 * L;
                        for (var U = [y, w], k = 0; k < 2; ++k) {
                            var z = U[k];
                            for (S = 0; S < z.length; ++S) {
                                var B = 31 & z[S];
                                Bp(e, h, O[B]),
                                    (h += E[B]),
                                    B > 15 && (Bp(e, h, (z[S] >>> 5) & 127), (h += z[S] >>> 12));
                            }
                        }
                    } else (R = Op), (C = Np), (P = Up), (I = Fp);
                    for (S = 0; S < o; ++S)
                        if (i[S] > 255) {
                            (B = (i[S] >>> 18) & 31),
                                Hp(e, h, R[B + 257]),
                                (h += C[B + 257]),
                                B > 7 && (Bp(e, h, (i[S] >>> 23) & 31), (h += _p[B]));
                            var H = 31 & i[S];
                            Hp(e, h, P[H]), (h += I[H]), H > 3 && (Hp(e, h, (i[S] >>> 5) & 8191), (h += Mp[H]));
                        } else Hp(e, h, R[i[S]]), (h += C[i[S]]);
                    return Hp(e, h, R[256]), h + C[256];
                },
                Yp = new wp([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
                Zp = new xp(0),
                Jp = (function () {
                    for (var t = new wp(256), e = 0; e < 256; ++e) {
                        for (var n = e, i = 9; --i; ) n = (1 & n && 3988292384) ^ (n >>> 1);
                        t[e] = n;
                    }
                    return t;
                })(),
                $p = function () {
                    var t = -1;
                    return {
                        p: function (e) {
                            for (var n = t, i = 0; i < e.length; ++i) n = Jp[(255 & n) ^ e[i]] ^ (n >>> 8);
                            t = n;
                        },
                        d: function () {
                            return ~t;
                        },
                    };
                },
                Kp = function (t, e) {
                    var n = {};
                    for (var i in t) n[i] = t[i];
                    for (var i in e) n[i] = e[i];
                    return n;
                },
                Qp = function (t, e, n) {
                    for (; n; ++e) (t[e] = n), (n >>>= 8);
                };
            function tm(t, e) {
                return (function (t, e, n, i, r) {
                    return (function (t, e, n, i, r, s) {
                        var a = t.length,
                            o = new xp(0 + a + 5 * (1 + Math.ceil(a / 7e3)) + 0),
                            l = o.subarray(0, o.length - 0),
                            c = 0;
                        if (!e || a < 8)
                            for (var h = 0; h <= a; h += 65535) {
                                var u = h + 65535;
                                u < a
                                    ? (c = qp(l, c, t.subarray(h, u)))
                                    : ((l[h] = s), (c = qp(l, c, t.subarray(h, a))));
                            }
                        else {
                            for (
                                var d = Yp[e - 1],
                                    p = d >>> 13,
                                    m = 8191 & d,
                                    f = (1 << n) - 1,
                                    g = new bp(32768),
                                    v = new bp(f + 1),
                                    y = Math.ceil(n / 3),
                                    x = 2 * y,
                                    b = function (e) {
                                        return (t[e] ^ (t[e + 1] << y) ^ (t[e + 2] << x)) & f;
                                    },
                                    w = new wp(25e3),
                                    _ = new bp(288),
                                    M = new bp(32),
                                    S = 0,
                                    T = 0,
                                    E = ((h = 0), 0),
                                    A = 0,
                                    L = 0;
                                h < a;
                                ++h
                            ) {
                                var R = b(h),
                                    C = 32767 & h,
                                    P = v[R];
                                if (((g[C] = P), (v[R] = C), A <= h)) {
                                    var I = a - h;
                                    if ((S > 7e3 || E > 24576) && I > 423) {
                                        (c = Xp(t, l, 0, w, _, M, T, E, L, h - L, c)), (E = S = T = 0), (L = h);
                                        for (var D = 0; D < 286; ++D) _[D] = 0;
                                        for (D = 0; D < 30; ++D) M[D] = 0;
                                    }
                                    var N = 2,
                                        F = 0,
                                        O = m,
                                        U = (C - P) & 32767;
                                    if (I > 2 && R == b(h - U))
                                        for (
                                            var k = Math.min(p, I) - 1, z = Math.min(32767, h), B = Math.min(258, I);
                                            U <= z && --O && C != P;

                                        ) {
                                            if (t[h + N] == t[h + N - U]) {
                                                for (var H = 0; H < B && t[h + H] == t[h + H - U]; ++H);
                                                if (H > N) {
                                                    if (((N = H), (F = U), H > k)) break;
                                                    var G = Math.min(U, H - 2),
                                                        V = 0;
                                                    for (D = 0; D < G; ++D) {
                                                        var W = (h - U + D + 32768) & 32767,
                                                            j = (W - g[W] + 32768) & 32767;
                                                        j > V && ((V = j), (P = W));
                                                    }
                                                }
                                            }
                                            U += ((C = P) - (P = g[C]) + 32768) & 32767;
                                        }
                                    if (F) {
                                        w[E++] = 268435456 | (Lp[N] << 18) | Rp[F];
                                        var q = 31 & Lp[N],
                                            X = 31 & Rp[F];
                                        (T += _p[q] + Mp[X]), ++_[257 + q], ++M[X], (A = h + N), ++S;
                                    } else (w[E++] = t[h]), ++_[t[h]];
                                }
                            }
                            c = Xp(t, l, s, w, _, M, T, E, L, h - L, c);
                        }
                        return zp(o, 0, 0 + kp(c) + 0);
                    })(
                        t,
                        null == e.level ? 6 : e.level,
                        null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem,
                        0,
                        0,
                        !0,
                    );
                })(t, e || {});
            }
            var em = function (t, e, n, i) {
                    for (var r in t) {
                        var s = t[r],
                            a = e + r;
                        s instanceof xp
                            ? (n[a] = [s, i])
                            : Array.isArray(s)
                            ? (n[a] = [s[0], Kp(i, s[1])])
                            : em(s, a + '/', n, i);
                    }
                },
                nm = 'undefined' != typeof TextEncoder && new TextEncoder(),
                im = 'undefined' != typeof TextDecoder && new TextDecoder();
            try {
                im.decode(Zp, { stream: !0 });
            } catch (i) {}
            function rm(t, e) {
                if (e) {
                    for (var n = new xp(t.length), i = 0; i < t.length; ++i) n[i] = t.charCodeAt(i);
                    return n;
                }
                if (nm) return nm.encode(t);
                var r = t.length,
                    s = new xp(t.length + (t.length >> 1)),
                    a = 0,
                    o = function (t) {
                        s[a++] = t;
                    };
                for (i = 0; i < r; ++i) {
                    if (a + 5 > s.length) {
                        var l = new xp(a + 8 + ((r - i) << 1));
                        l.set(s), (s = l);
                    }
                    var c = t.charCodeAt(i);
                    c < 128 || e
                        ? o(c)
                        : c < 2048
                        ? (o(192 | (c >> 6)), o(128 | (63 & c)))
                        : c > 55295 && c < 57344
                        ? (o(240 | ((c = (65536 + (1047552 & c)) | (1023 & t.charCodeAt(++i))) >> 18)),
                          o(128 | ((c >> 12) & 63)),
                          o(128 | ((c >> 6) & 63)),
                          o(128 | (63 & c)))
                        : (o(224 | (c >> 12)), o(128 | ((c >> 6) & 63)), o(128 | (63 & c)));
                }
                return zp(s, 0, a);
            }
            var sm = function (t) {
                    var e = 0;
                    if (t)
                        for (var n in t) {
                            var i = t[n].length;
                            if (i > 65535) throw 'extra field too long';
                            e += i + 4;
                        }
                    return e;
                },
                am = function (t, e, n, i, r, s, a, o) {
                    var l = i.length,
                        c = n.extra,
                        h = o && o.length,
                        u = sm(c);
                    Qp(t, e, null != a ? 33639248 : 67324752),
                        (e += 4),
                        null != a && ((t[e++] = 20), (t[e++] = n.os)),
                        (t[e] = 20),
                        (e += 2),
                        (t[e++] = (n.flag << 1) | (null == s && 8)),
                        (t[e++] = r && 8),
                        (t[e++] = 255 & n.compression),
                        (t[e++] = n.compression >> 8);
                    var d = new Date(null == n.mtime ? Date.now() : n.mtime),
                        p = d.getFullYear() - 1980;
                    if (p < 0 || p > 119) throw 'date not in range 1980-2099';
                    if (
                        (Qp(
                            t,
                            e,
                            (p << 25) |
                                ((d.getMonth() + 1) << 21) |
                                (d.getDate() << 16) |
                                (d.getHours() << 11) |
                                (d.getMinutes() << 5) |
                                (d.getSeconds() >>> 1),
                        ),
                        (e += 4),
                        null != s && (Qp(t, e, n.crc), Qp(t, e + 4, s), Qp(t, e + 8, n.size)),
                        Qp(t, e + 12, l),
                        Qp(t, e + 14, u),
                        (e += 16),
                        null != a && (Qp(t, e, h), Qp(t, e + 6, n.attrs), Qp(t, e + 10, a), (e += 14)),
                        t.set(i, e),
                        (e += l),
                        u)
                    )
                        for (var m in c) {
                            var f = c[m],
                                g = f.length;
                            Qp(t, e, +m), Qp(t, e + 2, g), t.set(f, e + 4), (e += 4 + g);
                        }
                    return h && (t.set(o, e), (e += h)), e;
                };
            class om {
                async parse(t) {
                    const e = { 'model.usda': null };
                    let n =
                        '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
                    const i = {},
                        r = {};
                    t.traverseVisible((t) => {
                        if (t.isMesh && t.material.isMeshStandardMaterial) {
                            const r = t.geometry,
                                s = t.material,
                                a = 'geometries/Geometry_' + r.id + '.usd';
                            if (!(a in e)) {
                                const t = (function (t) {
                                    return `\ndef "Geometry"\n{\n  ${(function (t) {
                                        const e = t.attributes,
                                            n = e.position.count;
                                        return `\n    def Mesh "Geometry"\n    {\n        int[] faceVertexCounts = [${(function (
                                            t,
                                        ) {
                                            const e =
                                                null !== t.index ? t.index.array.length : t.attributes.position.count;
                                            return Array(e / 3)
                                                .fill(3)
                                                .join(', ');
                                        })(t)}]\n        int[] faceVertexIndices = [${(function (t) {
                                            if (null !== t.index) return t.index.array.join(', ');
                                            const e = [],
                                                n = t.attributes.position.count;
                                            for (let t = 0; t < n; t++) e.push(t);
                                            return e.join(', ');
                                        })(t)}]\n        normal3f[] normals = [${hm(
                                            e.normal,
                                            n,
                                        )}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${hm(
                                            e.position,
                                            n,
                                        )}]\n        float2[] primvars:st = [${(function (t, e) {
                                            if (void 0 === t)
                                                return (
                                                    console.warn('USDZExporter: UVs missing.'),
                                                    Array(e).fill('(0, 0)').join(', ')
                                                );
                                            const n = [],
                                                i = t.array;
                                            for (let t = 0; t < i.length; t += 2)
                                                n.push(`(${i[t + 0].toPrecision(7)}, ${1 - i[t + 1].toPrecision(7)})`);
                                            return n.join(', ');
                                        })(
                                            e.uv,
                                            n,
                                        )}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`;
                                    })(t)}\n}\n`;
                                })(r);
                                e[a] = (function (t) {
                                    let e =
                                        '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
                                    return (e += t), rm(e);
                                })(t);
                            }
                            s.uuid in i || (i[s.uuid] = s),
                                (n += (function (t, e, n) {
                                    const i = 'Object_' + t.id,
                                        r = (function (t) {
                                            const e = t.elements;
                                            return `( ${cm(e, 0)}, ${cm(e, 4)}, ${cm(e, 8)}, ${cm(e, 12)} )`;
                                        })(t.matrixWorld);
                                    return (
                                        t.matrixWorld.determinant() < 0 &&
                                            console.warn(
                                                'THREE.USDZExporter: USDZ does not support negative scales',
                                                t,
                                            ),
                                        `def Xform "${i}" (\n    prepend references = @./geometries/Geometry_${e.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${r}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${n.id}>\n}\n\n`
                                    );
                                })(t, r, s));
                        }
                    }),
                        (n += (function (t, e) {
                            const n = [];
                            for (const i in t) {
                                const r = t[i];
                                n.push(um(r, e));
                            }
                            return `def "Materials"\n{\n${n.join('')}\n}\n\n`;
                        })(i, r)),
                        (e['model.usda'] = rm(n)),
                        (n = null);
                    for (const t in r) {
                        const n = r[t],
                            i = t.split('_')[1],
                            s = 1023 === n.format,
                            a = lm(n.image, i),
                            o = await new Promise((t) => a.toBlob(t, s ? 'image/png' : 'image/jpeg', 1));
                        e[`textures/Texture_${t}.${s ? 'png' : 'jpg'}`] = new Uint8Array(await o.arrayBuffer());
                    }
                    let s = 0;
                    for (const t in e) {
                        const n = e[t];
                        s += 34 + t.length;
                        const i = 63 & s;
                        if (4 !== i) {
                            const r = new Uint8Array(64 - i);
                            e[t] = [n, { extra: { 12345: r } }];
                        }
                        s = n.length;
                    }
                    return (function (t, e) {
                        e || (e = {});
                        var n = {},
                            i = [];
                        em(t, '', n, e);
                        var r = 0,
                            s = 0;
                        for (var a in n) {
                            var o = n[a],
                                l = o[0],
                                c = o[1],
                                h = 0 == c.level ? 0 : 8,
                                u = (M = rm(a)).length,
                                d = c.comment,
                                p = d && rm(d),
                                m = p && p.length,
                                f = sm(c.extra);
                            if (u > 65535) throw 'filename too long';
                            var g = h ? tm(l, c) : l,
                                v = g.length,
                                y = $p();
                            y.p(l),
                                i.push(
                                    Kp(c, {
                                        size: l.length,
                                        crc: y.d(),
                                        c: g,
                                        f: M,
                                        m: p,
                                        u: u != a.length || (p && d.length != m),
                                        o: r,
                                        compression: h,
                                    }),
                                ),
                                (r += 30 + u + f + v),
                                (s += 76 + 2 * (u + f) + (m || 0) + v);
                        }
                        for (var x = new xp(s + 22), b = r, w = s - r, _ = 0; _ < i.length; ++_) {
                            var M = i[_];
                            am(x, M.o, M, M.f, M.u, M.c.length);
                            var S = 30 + M.f.length + sm(M.extra);
                            x.set(M.c, M.o + S),
                                am(x, r, M, M.f, M.u, M.c.length, M.o, M.m),
                                (r += 16 + S + (M.m ? M.m.length : 0));
                        }
                        return (
                            (function (t, e, n, i, r) {
                                Qp(t, e, 101010256),
                                    Qp(t, e + 8, n),
                                    Qp(t, e + 10, n),
                                    Qp(t, e + 12, i),
                                    Qp(t, e + 16, r);
                            })(x, r, i.length, w, b),
                            x
                        );
                    })(e, { level: 0 });
                }
            }
            function lm(t, e) {
                if (
                    ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                    ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                    ('undefined' != typeof OffscreenCanvas && t instanceof OffscreenCanvas) ||
                    ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
                ) {
                    const n = 1024 / Math.max(t.width, t.height),
                        i = document.createElement('canvas');
                    (i.width = t.width * Math.min(1, n)), (i.height = t.height * Math.min(1, n));
                    const r = i.getContext('2d');
                    if ((r.drawImage(t, 0, 0, i.width, i.height), void 0 !== e)) {
                        const t = parseInt(e, 16),
                            n = ((t >> 16) & 255) / 255,
                            s = ((t >> 8) & 255) / 255,
                            a = (255 & t) / 255,
                            o = r.getImageData(0, 0, i.width, i.height),
                            l = o.data;
                        for (let t = 0; t < l.length; t += 4)
                            (l[t + 0] = l[t + 0] * n), (l[t + 1] = l[t + 1] * s), (l[t + 2] = l[t + 2] * a);
                        r.putImageData(o, 0, 0);
                    }
                    return i;
                }
            }
            function cm(t, e) {
                return `(${t[e + 0]}, ${t[e + 1]}, ${t[e + 2]}, ${t[e + 3]})`;
            }
            function hm(t, e) {
                if (void 0 === t)
                    return console.warn('USDZExporter: Normals missing.'), Array(e).fill('(0, 0, 0)').join(', ');
                const n = [],
                    i = t.array;
                for (let t = 0; t < i.length; t += 3)
                    n.push(`(${i[t + 0].toPrecision(7)}, ${i[t + 1].toPrecision(7)}, ${i[t + 2].toPrecision(7)})`);
                return n.join(', ');
            }
            function um(t, e) {
                const n = '            ',
                    i = [],
                    r = [];
                function s(n, i, r) {
                    const s = n.id + (r ? '_' + r.getHexString() : ''),
                        a = 1023 === n.format;
                    return (
                        (e[s] = n),
                        `\n        def Shader "Transform2d_${i}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${
                            t.id
                        }/uvReader_st.outputs:result>\n            float2 inputs:scale = ${pm(
                            n.repeat,
                        )}\n            float2 inputs:translation = ${pm(
                            n.offset,
                        )}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${
                            n.id
                        }_${i}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${s}.${
                            a ? 'png' : 'jpg'
                        }@\n            float2 inputs:st.connect = </Materials/Material_${
                            t.id
                        }/Transform2d_${i}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`
                    );
                }
                return (
                    null !== t.map
                        ? (i.push(
                              `${n}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`,
                          ),
                          r.push(s(t.map, 'diffuse', t.color)))
                        : i.push(`${n}color3f inputs:diffuseColor = ${dm(t.color)}`),
                    null !== t.emissiveMap
                        ? (i.push(
                              `${n}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`,
                          ),
                          r.push(s(t.emissiveMap, 'emissive')))
                        : t.emissive.getHex() > 0 && i.push(`${n}color3f inputs:emissiveColor = ${dm(t.emissive)}`),
                    null !== t.normalMap &&
                        (i.push(
                            `${n}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`,
                        ),
                        r.push(s(t.normalMap, 'normal'))),
                    null !== t.aoMap &&
                        (i.push(
                            `${n}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`,
                        ),
                        r.push(s(t.aoMap, 'occlusion'))),
                    null !== t.roughnessMap && 1 === t.roughness
                        ? (i.push(
                              `${n}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`,
                          ),
                          r.push(s(t.roughnessMap, 'roughness')))
                        : i.push(`${n}float inputs:roughness = ${t.roughness}`),
                    null !== t.metalnessMap && 1 === t.metalness
                        ? (i.push(
                              `${n}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`,
                          ),
                          r.push(s(t.metalnessMap, 'metallic')))
                        : i.push(`${n}float inputs:metallic = ${t.metalness}`),
                    null !== t.alphaMap
                        ? (i.push(
                              `${n}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`,
                          ),
                          i.push(`${n}float inputs:opacityThreshold = 0.0001`),
                          r.push(s(t.alphaMap, 'opacity')))
                        : i.push(`${n}float inputs:opacity = ${t.opacity}`),
                    t.isMeshPhysicalMaterial &&
                        (i.push(`${n}float inputs:clearcoat = ${t.clearcoat}`),
                        i.push(`${n}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),
                        i.push(`${n}float inputs:ior = ${t.ior}`)),
                    `\n    def Material "Material_${
                        t.id
                    }"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${i.join(
                        '\n',
                    )}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${
                        t.id
                    }/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${
                        t.id
                    }.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${r.join(
                        '\n',
                    )}\n\n    }\n`
                );
            }
            function dm(t) {
                return `(${t.r}, ${t.g}, ${t.b})`;
            }
            function pm(t) {
                return `(${t.x}, ${t.y})`;
            }
            var mm = function (t, e, n, i) {
                for (
                    var r,
                        s = arguments.length,
                        a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                        o = t.length - 1;
                    o >= 0;
                    o--
                )
                    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                return s > 3 && a && Object.defineProperty(e, n, a), a;
            };
            let fm = !1,
                gm = !1;
            const vm =
                ((ym = ['quick-look', 'scene-viewer', 'webxr', 'none']),
                (t) => {
                    try {
                        const e = Hh(t),
                            n = (e.length ? e[0].terms : [])
                                .filter((t) => t && 'ident' === t.type)
                                .map((t) => t.value)
                                .filter((t) => ym.indexOf(t) > -1),
                            i = new Set();
                        for (const t of n) i.add(t);
                        return i;
                    } catch (t) {}
                    return new Set();
                });
            var ym;
            const xm = 'quick-look',
                bm = 'scene-viewer',
                wm = 'webxr',
                _m = 'none',
                Mm = Symbol('arButtonContainer'),
                Sm = Symbol('enterARWithWebXR'),
                Tm = Symbol('openSceneViewer'),
                Em = Symbol('openIOSARQuickLook'),
                Am = Symbol('canActivateAR'),
                Lm = Symbol('arMode'),
                Rm = Symbol('arModes'),
                Cm = Symbol('arAnchor'),
                Pm = Symbol('preload'),
                Im = Symbol('onARButtonContainerClick'),
                Dm = Symbol('onARStatus'),
                Nm = Symbol('onARTracking'),
                Fm = Symbol('onARTap'),
                Om = Symbol('selectARMode'),
                Um = Symbol('triggerLoad');
            var km, zm, Bm;
            const Hm = Symbol('evaluate'),
                Gm = Symbol('lastValue');
            class Vm {
                constructor() {
                    this[km] = null;
                }
                static evaluatableFor(t, e = Zh) {
                    if (t instanceof Vm) return t;
                    if ('number' === t.type) return '%' === t.unit ? new qm(t, e) : t;
                    switch (t.name.value) {
                        case 'calc':
                            return new $m(t, e);
                        case 'env':
                            return new Ym(t);
                    }
                    return Zh;
                }
                static evaluate(t) {
                    return t instanceof Vm ? t.evaluate() : t;
                }
                static isConstant(t) {
                    return !(t instanceof Vm) || t.isConstant;
                }
                static applyIntrinsics(t, e) {
                    const { basis: n, keywords: i } = e,
                        { auto: r } = i;
                    return n.map((e, n) => {
                        const s = null == r[n] ? e : r[n];
                        let a = t[n] ? t[n] : s;
                        if ('ident' === a.type) {
                            const t = a.value;
                            t in i && (a = i[t][n]);
                        }
                        return (
                            (null != a && 'ident' !== a.type) || (a = s),
                            '%' === a.unit
                                ? Bh((a.number / 100) * e.number, e.unit)
                                : ((a = Kh(a, e)), a.unit !== e.unit ? e : a)
                        );
                    });
                }
                get isConstant() {
                    return !1;
                }
                evaluate() {
                    return (this.isConstant && null != this[Gm]) || (this[Gm] = this[Hm]()), this[Gm];
                }
            }
            km = Gm;
            const Wm = Symbol('percentage'),
                jm = Symbol('basis');
            class qm extends Vm {
                constructor(t, e) {
                    super(), (this[Wm] = t), (this[jm] = e);
                }
                get isConstant() {
                    return !0;
                }
                [Hm]() {
                    return Bh((this[Wm].number / 100) * this[jm].number, this[jm].unit);
                }
            }
            const Xm = Symbol('identNode');
            class Ym extends Vm {
                constructor(t) {
                    super(), (this[zm] = null);
                    const e = t.arguments.length ? t.arguments[0].terms[0] : null;
                    null != e && 'ident' === e.type && (this[Xm] = e);
                }
                get isConstant() {
                    return !1;
                }
                [((zm = Xm), Hm)]() {
                    return null != this[Xm] && 'window-scroll-y' === this[Xm].value
                        ? {
                              type: 'number',
                              number:
                                  window.pageYOffset /
                                      (Math.max(
                                          document.body.scrollHeight,
                                          document.body.offsetHeight,
                                          document.documentElement.clientHeight,
                                          document.documentElement.scrollHeight,
                                          document.documentElement.offsetHeight,
                                      ) -
                                          window.innerHeight) || 0,
                              unit: null,
                          }
                        : Zh;
                }
            }
            const Zm = /[\*\/]/,
                Jm = Symbol('evalutor');
            class $m extends Vm {
                constructor(t, e = Zh) {
                    if ((super(), (this[Bm] = null), 1 !== t.arguments.length)) return;
                    const n = t.arguments[0].terms.slice(),
                        i = [];
                    for (; n.length; ) {
                        const t = n.shift();
                        if (i.length > 0) {
                            const n = i[i.length - 1];
                            if ('operator' === n.type && Zm.test(n.value)) {
                                const n = i.pop(),
                                    r = i.pop();
                                if (null == r) return;
                                i.push(new ef(n, Vm.evaluatableFor(r, e), Vm.evaluatableFor(t, e)));
                                continue;
                            }
                        }
                        i.push('operator' === t.type ? t : Vm.evaluatableFor(t, e));
                    }
                    for (; i.length > 2; ) {
                        const [t, n, r] = i.splice(0, 3);
                        if ('operator' !== n.type) return;
                        i.unshift(new ef(n, Vm.evaluatableFor(t, e), Vm.evaluatableFor(r, e)));
                    }
                    1 === i.length && (this[Jm] = i[0]);
                }
                get isConstant() {
                    return null == this[Jm] || Vm.isConstant(this[Jm]);
                }
                [((Bm = Jm), Hm)]() {
                    return null != this[Jm] ? Vm.evaluate(this[Jm]) : Zh;
                }
            }
            const Km = Symbol('operator'),
                Qm = Symbol('left'),
                tf = Symbol('right');
            class ef extends Vm {
                constructor(t, e, n) {
                    super(), (this[Km] = t), (this[Qm] = e), (this[tf] = n);
                }
                get isConstant() {
                    return Vm.isConstant(this[Qm]) && Vm.isConstant(this[tf]);
                }
                [Hm]() {
                    const t = Kh(Vm.evaluate(this[Qm])),
                        e = Kh(Vm.evaluate(this[tf])),
                        { number: n, unit: i } = t,
                        { number: r, unit: s } = e;
                    if (null != s && null != i && s != i) return Zh;
                    const a = i || s;
                    let o;
                    switch (this[Km].value) {
                        case '+':
                            o = n + r;
                            break;
                        case '-':
                            o = n - r;
                            break;
                        case '/':
                            o = n / r;
                            break;
                        case '*':
                            o = n * r;
                            break;
                        default:
                            return Zh;
                    }
                    return { type: 'number', number: o, unit: a };
                }
            }
            const nf = Symbol('evaluatables'),
                rf = Symbol('intrinsics');
            class sf extends Vm {
                constructor(t, e) {
                    super(), (this[rf] = e);
                    const n = t[0],
                        i = null != n ? n.terms : [];
                    this[nf] = e.basis.map((t, e) => {
                        const n = i[e];
                        return null == n
                            ? { type: 'ident', value: 'auto' }
                            : 'ident' === n.type
                            ? n
                            : Vm.evaluatableFor(n, t);
                    });
                }
                get isConstant() {
                    for (const t of this[nf]) if (!Vm.isConstant(t)) return !1;
                    return !0;
                }
                [Hm]() {
                    const t = this[nf].map((t) => Vm.evaluate(t));
                    return Vm.applyIntrinsics(t, this[rf]).map((t) => t.number);
                }
            }
            var af, of, lf, cf;
            const hf = Symbol('instances'),
                uf = Symbol('activateListener'),
                df = Symbol('deactivateListener'),
                pf = Symbol('notifyInstances'),
                mf = Symbol('notify'),
                ff = Symbol('callback');
            class gf {
                constructor(t) {
                    this[ff] = t;
                }
                static [pf]() {
                    for (const t of gf[hf]) t[mf]();
                }
                static [((af = hf), uf)]() {
                    window.addEventListener('scroll', this[pf], { passive: !0 });
                }
                static [df]() {
                    window.removeEventListener('scroll', this[pf]);
                }
                observe() {
                    0 === gf[hf].size && gf[uf](), gf[hf].add(this);
                }
                disconnect() {
                    gf[hf].delete(this), 0 === gf[hf].size && gf[df]();
                }
                [mf]() {
                    this[ff]();
                }
            }
            gf[af] = new Set();
            const vf = Symbol('computeStyleCallback'),
                yf = Symbol('astWalker'),
                xf = Symbol('dependencies'),
                bf = Symbol('onScroll');
            class wf {
                constructor(t) {
                    (this[of] = {}),
                        (this[lf] = new Yh(['function'])),
                        (this[cf] = () => {
                            this[vf]({ relatedState: 'window-scroll' });
                        }),
                        (this[vf] = t);
                }
                observeEffectsFor(t) {
                    const e = {},
                        n = this[xf];
                    this[yf].walk(t, (t) => {
                        const { name: i } = t,
                            r = t.arguments[0].terms[0];
                        if (
                            'env' === i.value &&
                            null != r &&
                            'ident' === r.type &&
                            'window-scroll-y' === r.value &&
                            null == e['window-scroll']
                        ) {
                            const t = 'window-scroll' in n ? n['window-scroll'] : new gf(this[bf]);
                            t.observe(), delete n['window-scroll'], (e['window-scroll'] = t);
                        }
                    });
                    for (const t in n) n[t].disconnect();
                    this[xf] = e;
                }
                dispose() {
                    for (const t in this[xf]) this[xf][t].disconnect();
                }
            }
            (of = xf), (lf = yf), (cf = bf);
            const _f = (t) => {
                    const e = t.observeEffects || !1,
                        n = t.intrinsics instanceof Function ? t.intrinsics : () => t.intrinsics;
                    return (i, r) => {
                        const s = i.updated,
                            a = i.connectedCallback,
                            o = i.disconnectedCallback,
                            l = Symbol(`${r}StyleEffector`),
                            c = Symbol(`${r}StyleEvaluator`),
                            h = Symbol(`${r}UpdateEvaluator`),
                            u = Symbol(`${r}EvaluateAndSync`);
                        Object.defineProperties(i, {
                            [l]: { value: null, writable: !0 },
                            [c]: { value: null, writable: !0 },
                            [h]: {
                                value: function () {
                                    const t = Hh(this[r]);
                                    (this[c] = new sf(t, n(this))),
                                        null == this[l] && e && (this[l] = new wf(() => this[u]())),
                                        null != this[l] && this[l].observeEffectsFor(t);
                                },
                            },
                            [u]: {
                                value: function () {
                                    if (null == this[c]) return;
                                    const e = this[c].evaluate();
                                    this[t.updateHandler](e);
                                },
                            },
                            updated: {
                                value: function (t) {
                                    t.has(r) && (this[h](), this[u]()), s.call(this, t);
                                },
                            },
                            connectedCallback: {
                                value: function () {
                                    a.call(this), this.requestUpdate(r, this[r]);
                                },
                            },
                            disconnectedCallback: {
                                value: function () {
                                    o.call(this), null != this[l] && (this[l].dispose(), (this[l] = null));
                                },
                            },
                        });
                    };
                },
                Mf = Object.freeze({
                    minimumRadius: 0,
                    maximumRadius: 1 / 0,
                    minimumPolarAngle: Math.PI / 8,
                    maximumPolarAngle: Math.PI - Math.PI / 8,
                    minimumAzimuthalAngle: -1 / 0,
                    maximumAzimuthalAngle: 1 / 0,
                    minimumFieldOfView: 10,
                    maximumFieldOfView: 45,
                    interactionPolicy: 'always-allow',
                    touchAction: 'pan-y',
                }),
                Sf = Math.PI / 8,
                Tf = 'user-interaction';
            class Ef extends ft {
                constructor(t, e) {
                    super(),
                        (this.camera = t),
                        (this.element = e),
                        (this.sensitivity = 1),
                        (this._interactionEnabled = !1),
                        (this._disableZoom = !1),
                        (this.isUserChange = !1),
                        (this.isUserPointing = !1),
                        (this.spherical = new Ql()),
                        (this.goalSpherical = new Ql()),
                        (this.thetaDamper = new zh()),
                        (this.phiDamper = new zh()),
                        (this.radiusDamper = new zh()),
                        (this.logFov = Math.log(Mf.maximumFieldOfView)),
                        (this.goalLogFov = this.logFov),
                        (this.fovDamper = new zh()),
                        (this.touchMode = null),
                        (this.lastPointerPosition = { clientX: 0, clientY: 0 }),
                        (this.touchDecided = !1),
                        (this.onMouseMove = (t) => {
                            this.handleSinglePointerMove(t), t.cancelable && t.preventDefault();
                        }),
                        (this.onTouchMove = (t) => {
                            null !== this.touchMode &&
                                (this.touchMode(t), null !== this.touchMode && t.cancelable && t.preventDefault());
                        }),
                        (this.touchModeZoom = (t) => {
                            const { targetTouches: e } = t;
                            if (this.lastTouches.length > 1 && e.length > 1) {
                                const t =
                                    (0.04 *
                                        (this.twoTouchDistance(this.lastTouches[0], this.lastTouches[1]) -
                                            this.twoTouchDistance(e[0], e[1]))) /
                                    10;
                                this.userAdjustOrbit(0, 0, t), (this.lastTouches = e);
                            }
                        }),
                        (this.touchModeRotate = (t) => {
                            const { targetTouches: e } = t,
                                { touchAction: n } = this._options;
                            if (!this.touchDecided && 'none' !== n) {
                                this.touchDecided = !0;
                                const { clientX: t, clientY: i } = e[0],
                                    r = Math.abs(t - this.lastPointerPosition.clientX),
                                    s = Math.abs(i - this.lastPointerPosition.clientY);
                                if (('pan-y' === n && s > r) || ('pan-x' === n && r > s))
                                    return void (this.touchMode = null);
                            }
                            this.handleSinglePointerMove(e[0]), (this.lastTouches = e);
                        }),
                        (this.onMouseDown = (t) => {
                            this.onPointerDown(() => {
                                self.addEventListener('mousemove', this.onMouseMove),
                                    self.addEventListener('mouseup', this.onMouseUp, { once: !0 }),
                                    this.handleSinglePointerDown(t);
                            });
                        }),
                        (this.onTouchStart = (t) => {
                            this.onPointerDown(() => {
                                const { targetTouches: e, changedTouches: n, touches: i } = t;
                                e.length === n.length && ((this.touchMode = null), (this.touchDecided = !1)),
                                    e.length === i.length && this.onTouchChange(t);
                            });
                        }),
                        (this.onMouseUp = (t) => {
                            self.removeEventListener('mousemove', this.onMouseMove), this.onPointerUp();
                        }),
                        (this.onTouchEnd = (t) => {
                            t.targetTouches.length > 0 && null !== this.touchMode && this.onTouchChange(t),
                                this.onPointerUp();
                        }),
                        (this.onWheel = (t) => {
                            if (!this.canInteract) return;
                            const e = (t.deltaY * (1 == t.deltaMode ? 18 : 1) * 0.04) / 30;
                            this.userAdjustOrbit(0, 0, e), t.cancelable && t.preventDefault();
                        }),
                        (this.onKeyDown = (t) => {
                            let e = !1;
                            switch (t.keyCode) {
                                case 33:
                                    (e = !0), this.userAdjustOrbit(0, 0, 0.04);
                                    break;
                                case 34:
                                    (e = !0), this.userAdjustOrbit(0, 0, -0.04);
                                    break;
                                case 38:
                                    (e = !0), this.userAdjustOrbit(0, -Sf, 0);
                                    break;
                                case 40:
                                    (e = !0), this.userAdjustOrbit(0, Sf, 0);
                                    break;
                                case 37:
                                    (e = !0), this.userAdjustOrbit(-Sf, 0, 0);
                                    break;
                                case 39:
                                    (e = !0), this.userAdjustOrbit(Sf, 0, 0);
                            }
                            e && t.cancelable && t.preventDefault();
                        }),
                        (this._options = Object.assign({}, Mf)),
                        this.setOrbit(0, Math.PI / 2, 1),
                        this.setFieldOfView(100),
                        this.jumpToGoal();
                }
                get interactionEnabled() {
                    return this._interactionEnabled;
                }
                enableInteraction() {
                    if (!1 === this._interactionEnabled) {
                        const { element: t } = this;
                        t.addEventListener('mousedown', this.onMouseDown),
                            this._disableZoom || t.addEventListener('wheel', this.onWheel),
                            t.addEventListener('keydown', this.onKeyDown),
                            t.addEventListener('touchstart', this.onTouchStart, { passive: !0 }),
                            t.addEventListener('touchmove', this.onTouchMove, { passive: !1 }),
                            t.addEventListener('touchend', this.onTouchEnd),
                            (this.element.style.cursor = 'grab'),
                            (this._interactionEnabled = !0),
                            this.updateTouchActionStyle();
                    }
                }
                disableInteraction() {
                    if (!0 === this._interactionEnabled) {
                        const { element: t } = this;
                        self.removeEventListener('mousemove', this.onMouseMove),
                            t.removeEventListener('mousedown', this.onMouseDown),
                            this._disableZoom || t.removeEventListener('wheel', this.onWheel),
                            t.removeEventListener('keydown', this.onKeyDown),
                            t.removeEventListener('touchstart', this.onTouchStart),
                            t.removeEventListener('touchmove', this.onTouchMove),
                            self.removeEventListener('mouseup', this.onMouseUp),
                            t.removeEventListener('touchend', this.onTouchEnd),
                            (t.style.cursor = ''),
                            (this.touchMode = null),
                            (this._interactionEnabled = !1),
                            this.updateTouchActionStyle();
                    }
                }
                get options() {
                    return this._options;
                }
                set disableZoom(t) {
                    this._disableZoom != t &&
                        ((this._disableZoom = t),
                        !0 === t
                            ? this.element.removeEventListener('wheel', this.onWheel)
                            : this.element.addEventListener('wheel', this.onWheel),
                        this.updateTouchActionStyle());
                }
                getCameraSpherical(t = new Ql()) {
                    return t.copy(this.spherical);
                }
                getFieldOfView() {
                    return this.camera.fov;
                }
                applyOptions(t) {
                    Object.assign(this._options, t), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov));
                }
                updateNearFar(t, e) {
                    (this.camera.near = Math.max(t, e / 1e3)),
                        (this.camera.far = e),
                        this.camera.updateProjectionMatrix();
                }
                updateAspect(t) {
                    (this.camera.aspect = t), this.camera.updateProjectionMatrix();
                }
                setOrbit(t = this.goalSpherical.theta, e = this.goalSpherical.phi, n = this.goalSpherical.radius) {
                    const {
                            minimumAzimuthalAngle: i,
                            maximumAzimuthalAngle: r,
                            minimumPolarAngle: s,
                            maximumPolarAngle: a,
                            minimumRadius: o,
                            maximumRadius: l,
                        } = this._options,
                        { theta: c, phi: h, radius: u } = this.goalSpherical,
                        d = Fh(t, i, r);
                    isFinite(i) || isFinite(r) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d) + d);
                    const p = Fh(e, s, a),
                        m = Fh(n, o, l);
                    return (
                        (d !== c || p !== h || m !== u) &&
                        ((this.goalSpherical.theta = d),
                        (this.goalSpherical.phi = p),
                        (this.goalSpherical.radius = m),
                        this.goalSpherical.makeSafe(),
                        (this.isUserChange = !1),
                        !0)
                    );
                }
                setRadius(t) {
                    (this.goalSpherical.radius = t), this.setOrbit();
                }
                setFieldOfView(t) {
                    const { minimumFieldOfView: e, maximumFieldOfView: n } = this._options;
                    (t = Fh(t, e, n)), (this.goalLogFov = Math.log(t));
                }
                setDamperDecayTime(t) {
                    this.thetaDamper.setDecayTime(t),
                        this.phiDamper.setDecayTime(t),
                        this.radiusDamper.setDecayTime(t),
                        this.fovDamper.setDecayTime(t);
                }
                adjustOrbit(t, e, n) {
                    const { theta: i, phi: r, radius: s } = this.goalSpherical,
                        {
                            minimumRadius: a,
                            maximumRadius: o,
                            minimumFieldOfView: l,
                            maximumFieldOfView: c,
                        } = this._options,
                        h = this.spherical.theta - i,
                        u = Math.PI - 0.001,
                        d = i - Fh(t, -u - h, u - h),
                        p = r - e,
                        m = 0 === n ? 0 : ((n > 0 ? o : a) - s) / (Math.log(n > 0 ? c : l) - this.goalLogFov),
                        f = s + n * Math.min(isFinite(m) ? m : 1 / 0, o - a);
                    if ((this.setOrbit(d, p, f), 0 !== n)) {
                        const t = this.goalLogFov + n;
                        this.setFieldOfView(Math.exp(t));
                    }
                }
                jumpToGoal() {
                    this.update(0, 1e4);
                }
                update(t, e) {
                    if (this.isStationary()) return;
                    const { maximumPolarAngle: n, maximumRadius: i } = this._options,
                        r = this.spherical.theta - this.goalSpherical.theta;
                    Math.abs(r) > Math.PI &&
                        !isFinite(this._options.minimumAzimuthalAngle) &&
                        !isFinite(this._options.maximumAzimuthalAngle) &&
                        (this.spherical.theta -= 2 * Math.sign(r) * Math.PI),
                        (this.spherical.theta = this.thetaDamper.update(
                            this.spherical.theta,
                            this.goalSpherical.theta,
                            e,
                            Math.PI,
                        )),
                        (this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e, n)),
                        (this.spherical.radius = this.radiusDamper.update(
                            this.spherical.radius,
                            this.goalSpherical.radius,
                            e,
                            i,
                        )),
                        (this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e, 1)),
                        this.moveCamera();
                }
                updateTouchActionStyle() {
                    const { style: t } = this.element;
                    if (this._interactionEnabled) {
                        const { touchAction: e } = this._options;
                        this._disableZoom && 'none' !== e ? (t.touchAction = 'manipulation') : (t.touchAction = e);
                    } else t.touchAction = '';
                }
                isStationary() {
                    return (
                        this.goalSpherical.theta === this.spherical.theta &&
                        this.goalSpherical.phi === this.spherical.phi &&
                        this.goalSpherical.radius === this.spherical.radius &&
                        this.goalLogFov === this.logFov
                    );
                }
                moveCamera() {
                    this.spherical.makeSafe(),
                        this.camera.position.setFromSpherical(this.spherical),
                        this.camera.setRotationFromEuler(
                            new Re(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'),
                        ),
                        this.camera.fov !== Math.exp(this.logFov) &&
                            ((this.camera.fov = Math.exp(this.logFov)), this.camera.updateProjectionMatrix());
                    const t = this.isUserChange ? Tf : 'none';
                    this.dispatchEvent({ type: 'change', source: t });
                }
                get canInteract() {
                    return 'allow-when-focused' == this._options.interactionPolicy
                        ? this.element.getRootNode().activeElement === this.element
                        : 'always-allow' === this._options.interactionPolicy;
                }
                userAdjustOrbit(t, e, n) {
                    this.adjustOrbit(t * this.sensitivity, e * this.sensitivity, n),
                        (this.isUserChange = !0),
                        this.dispatchEvent({ type: 'change', source: Tf });
                }
                wrapAngle(t) {
                    const e = (t + Math.PI) / (2 * Math.PI);
                    return 2 * (e - Math.floor(e)) * Math.PI - Math.PI;
                }
                pixelLengthToSphericalAngle(t) {
                    return (2 * Math.PI * t) / this.element.clientHeight;
                }
                twoTouchDistance(t, e) {
                    const { clientX: n, clientY: i } = t,
                        { clientX: r, clientY: s } = e,
                        a = r - n,
                        o = s - i;
                    return Math.sqrt(a * a + o * o);
                }
                handleSinglePointerMove(t) {
                    const { clientX: e, clientY: n } = t,
                        i = this.pixelLengthToSphericalAngle(e - this.lastPointerPosition.clientX),
                        r = this.pixelLengthToSphericalAngle(n - this.lastPointerPosition.clientY);
                    (this.lastPointerPosition.clientX = e),
                        (this.lastPointerPosition.clientY = n),
                        !1 === this.isUserPointing &&
                            ((this.isUserPointing = !0),
                            this.dispatchEvent({ type: 'pointer-change-start', pointer: Object.assign({}, t) })),
                        this.userAdjustOrbit(i, r, 0);
                }
                onPointerDown(t) {
                    this.canInteract && ((this.isUserPointing = !1), t());
                }
                onTouchChange(t) {
                    const { targetTouches: e } = t;
                    2 === e.length
                        ? ((this.touchMode =
                              this._disableZoom || (this.touchDecided && null === this.touchMode)
                                  ? null
                                  : this.touchModeZoom),
                          (this.touchDecided = !0))
                        : ((this.touchMode = this.touchModeRotate), this.handleSinglePointerDown(e[0])),
                        (this.lastTouches = e);
                }
                handleSinglePointerDown(t) {
                    (this.lastPointerPosition.clientX = t.clientX),
                        (this.lastPointerPosition.clientY = t.clientY),
                        (this.element.style.cursor = 'grabbing');
                }
                onPointerUp() {
                    (this.element.style.cursor = 'grab'),
                        this.isUserPointing &&
                            this.dispatchEvent({
                                type: 'pointer-change-end',
                                pointer: Object.assign({}, this.lastPointerPosition),
                            });
                }
            }
            const Af = (t) => (t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1),
                Lf =
                    (t, e, n = Af) =>
                    (i) =>
                        t + (e - t) * n(i),
                Rf = (t, e) => {
                    const n = [],
                        i = [];
                    let r = t;
                    for (let t = 0; t < e.length; ++t) {
                        const s = e[t],
                            { value: a, frames: o } = s,
                            l = s.ease || Af,
                            c = Lf(r, a, l);
                        n.push(c), i.push(o), (r = a);
                    }
                    return ((t, e) => {
                        const n = e.reduce((t, e) => t + e, 0),
                            i = e.map((t) => t / n);
                        return (e) => {
                            let n = 0,
                                r = 1 / 0,
                                s = () => 0;
                            for (let a = 0; a < i.length && ((r = i[a]), (s = t[a]), !(e <= n + r)); ++a) n += r;
                            return s((e - n) / r);
                        };
                    })(n, i);
                };
            var Cf = function (t, e, n, i) {
                for (
                    var r,
                        s = arguments.length,
                        a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                        o = t.length - 1;
                    o >= 0;
                    o--
                )
                    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                return s > 3 && a && Object.defineProperty(e, n, a), a;
            };
            const Pf = Rf(0, [
                    { frames: 5, value: -1 },
                    { frames: 1, value: -1 },
                    { frames: 8, value: 1 },
                    { frames: 1, value: 1 },
                    { frames: 5, value: 0 },
                    { frames: 18, value: 0 },
                ]),
                If = Rf(0, [
                    { frames: 1, value: 1 },
                    { frames: 5, value: 1 },
                    { frames: 1, value: 0 },
                    { frames: 6, value: 0 },
                ]),
                Df = 1.1 * iu,
                Nf = ['front', 'right', 'back', 'left'],
                Ff = ['upper-', '', 'lower-'],
                Of = 'auto',
                Uf = 'when-focused',
                kf = 'wiggle',
                zf = (t) => ({ basis: [Bh((t[ug] * Math.PI) / 180, 'rad')], keywords: { auto: [null] } }),
                Bf = { basis: [Jh(Bh(25, 'deg'))], keywords: { auto: [null] } },
                Hf = (t) => {
                    const e = t[Yd];
                    return { basis: [Jh(Bh(45, 'deg'))], keywords: { auto: [Bh(e.framedFieldOfView, 'deg')] } };
                },
                Gf = (() => {
                    const t = Hh('0deg 75deg 105%')[0].terms,
                        e = Kh(t[0]),
                        n = Kh(t[1]);
                    return (t) => {
                        const i = t[Yd].idealCameraDistance;
                        return { basis: [e, n, Bh(i, 'm')], keywords: { auto: [null, null, Bh(105, '%')] } };
                    };
                })(),
                Vf = (t) => {
                    const e = Df * t[Yd].idealCameraDistance;
                    return {
                        basis: [Bh(-1 / 0, 'rad'), Bh(Math.PI / 8, 'rad'), Bh(e, 'm')],
                        keywords: { auto: [null, null, null] },
                    };
                },
                Wf = (t) => {
                    const e = Gf(t),
                        n = new sf([], e).evaluate()[2];
                    return {
                        basis: [Bh(1 / 0, 'rad'), Bh(Math.PI - Math.PI / 8, 'rad'), Bh(n, 'm')],
                        keywords: { auto: [null, null, null] },
                    };
                },
                jf = (t) => {
                    const e = t[Yd].boundingBox.getCenter(new Gt());
                    return {
                        basis: [Bh(e.x, 'm'), Bh(e.y, 'm'), Bh(e.z, 'm')],
                        keywords: { auto: [null, null, null] },
                    };
                },
                qf = Math.PI / 2,
                Xf = Math.PI / 3,
                Yf = qf / 2,
                Zf = 2 * Math.PI,
                Jf = Symbol('controls'),
                $f = Symbol('promptElement'),
                Kf = Symbol('promptAnimatedContainer'),
                Qf = Symbol('deferInteractionPrompt'),
                tg = Symbol('updateAria'),
                eg = Symbol('updateCameraForRadius'),
                ng = Symbol('onBlur'),
                ig = Symbol('onFocus'),
                rg = Symbol('onChange'),
                sg = Symbol('onPointerChange'),
                ag = Symbol('waitingToPromptUser'),
                og = Symbol('userHasInteracted'),
                lg = Symbol('promptElementVisibleTime'),
                cg = Symbol('lastPromptOffset'),
                hg = Symbol('focusedTime'),
                ug = Symbol('zoomAdjustedFieldOfView'),
                dg = Symbol('lastSpherical'),
                pg = Symbol('jumpCamera'),
                mg = Symbol('initialized'),
                fg = Symbol('maintainThetaPhi'),
                gg = Symbol('syncCameraOrbit'),
                vg = Symbol('syncFieldOfView'),
                yg = Symbol('syncCameraTarget'),
                xg = Symbol('syncMinCameraOrbit'),
                bg = Symbol('syncMaxCameraOrbit'),
                wg = Symbol('syncMinFieldOfView'),
                _g = Symbol('syncMaxFieldOfView');
            var Mg, Sg;
            const Tg = Symbol('modelViewerStatusInstance'),
                Eg = Symbol('updateStatus');
            (Mg = Tg), (Sg = Eg);
            var Ag = function (t, e, n, i) {
                for (
                    var r,
                        s = arguments.length,
                        a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                        o = t.length - 1;
                    o >= 0;
                    o--
                )
                    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                return s > 3 && a && Object.defineProperty(e, n, a), a;
            };
            const Lg = 'auto',
                Rg = 'manual',
                Cg = new (class extends ft {
                    constructor() {
                        super(),
                            (this[Mg] = null),
                            (this.registeredInstanceStatuses = new Map()),
                            (this.loadingPromises = []),
                            (this.statusElement = document.createElement('p')),
                            (this.statusUpdateInProgress = !1),
                            (this[Sg] = Nh(() => this.updateStatus(), 100));
                        const { statusElement: t } = this,
                            { style: e } = t;
                        t.setAttribute('role', 'status'),
                            t.classList.add('screen-reader-only'),
                            (e.top = e.left = '0'),
                            (e.pointerEvents = 'none');
                    }
                    registerInstance(t) {
                        if (this.registeredInstanceStatuses.has(t)) return;
                        let e = () => {};
                        const n = !1 === t.loaded && !!t.src,
                            i = new Promise((i) => {
                                if (!n) return void i();
                                const r = () => {
                                    i(), t.removeEventListener('load', r), t.removeEventListener('error', r);
                                };
                                t.addEventListener('load', r), t.addEventListener('error', r), (e = r);
                            });
                        this.registeredInstanceStatuses.set(t, { onUnregistered: e }),
                            this.loadingPromises.push(i),
                            null == this.modelViewerStatusInstance && (this.modelViewerStatusInstance = t);
                    }
                    unregisterInstance(t) {
                        if (!this.registeredInstanceStatuses.has(t)) return;
                        const e = this.registeredInstanceStatuses,
                            n = e.get(t);
                        e.delete(t),
                            n.onUnregistered(),
                            this.modelViewerStatusInstance === t &&
                                (this.modelViewerStatusInstance =
                                    e.size > 0
                                        ? ((t) => {
                                              if (null != t.keys) return t.keys().next().value || null;
                                              let e = null;
                                              try {
                                                  t.forEach((t, n, i) => {
                                                      throw ((e = n), new Error());
                                                  });
                                              } catch (t) {}
                                              return e;
                                          })(e)
                                        : null);
                    }
                    get modelViewerStatusInstance() {
                        return this[Tg];
                    }
                    set modelViewerStatusInstance(t) {
                        if (this[Tg] === t) return;
                        const { statusElement: e } = this;
                        null != t && null != t.shadowRoot
                            ? t.shadowRoot.appendChild(e)
                            : null != e.parentNode && e.parentNode.removeChild(e),
                            (this[Tg] = t),
                            this[Eg]();
                    }
                    async updateStatus() {
                        if (!this.statusUpdateInProgress && 0 !== this.loadingPromises.length) {
                            for (
                                this.statusElement.textContent =
                                    'This page includes one or more 3D models that are loading',
                                    this.statusUpdateInProgress = !0,
                                    this.dispatchEvent({ type: 'initial-status-announced' });
                                this.loadingPromises.length;

                            ) {
                                const { loadingPromises: t } = this;
                                (this.loadingPromises = []), await Promise.all(t);
                            }
                            (this.statusElement.textContent = 'All 3D models in the page have loaded'),
                                (this.statusUpdateInProgress = !1),
                                this.dispatchEvent({ type: 'finished-loading-announced' });
                        }
                    }
                })(),
                Pg = Symbol('defaultProgressBarElement'),
                Ig = Symbol('defaultProgressMaskElement'),
                Dg = Symbol('posterContainerElement'),
                Ng = Symbol('defaultPosterElement'),
                Fg = Symbol('posterDismissalSource'),
                Og = Symbol('hidePoster'),
                Ug = Symbol('modelIsRevealed'),
                kg = Symbol('updateProgressBar'),
                zg = Symbol('lastReportedProgress'),
                Bg = Symbol('transitioned'),
                Hg = Symbol('onTransitionEnd'),
                Gg = Symbol('ariaLabelCallToAction'),
                Vg = Symbol('onClick'),
                Wg = Symbol('onKeydown'),
                jg = Symbol('onProgress');
            class qg {
                constructor() {
                    (this.pluginCallbacks = []),
                        this.register(function (t) {
                            return new nv(t);
                        }),
                        this.register(function (t) {
                            return new iv(t);
                        }),
                        this.register(function (t) {
                            return new rv(t);
                        }),
                        this.register(function (t) {
                            return new sv(t);
                        }),
                        this.register(function (t) {
                            return new av(t);
                        });
                }
                register(t) {
                    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
                }
                unregister(t) {
                    return (
                        -1 !== this.pluginCallbacks.indexOf(t) &&
                            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                        this
                    );
                }
                parse(t, e, n) {
                    const i = new ev(),
                        r = [];
                    for (let t = 0, e = this.pluginCallbacks.length; t < e; t++) r.push(this.pluginCallbacks[t](i));
                    i.setPlugins(r), i.write(t, e, n);
                }
            }
            const Xg = 5121,
                Yg = 5123,
                Zg = {
                    1003: 9728,
                    1004: 9984,
                    1005: 9986,
                    1006: 9729,
                    1007: 9985,
                    1008: 9987,
                    1001: 33071,
                    1e3: 10497,
                    1002: 33648,
                },
                Jg = {
                    scale: 'scale',
                    position: 'translation',
                    quaternion: 'rotation',
                    morphTargetInfluences: 'weights',
                };
            function $g(t, e) {
                return (
                    t.length === e.length &&
                    t.every(function (t, n) {
                        return t === e[n];
                    })
                );
            }
            function Kg(t) {
                return 4 * Math.ceil(t / 4);
            }
            function Qg(t, e = 0) {
                const n = Kg(t.byteLength);
                if (n !== t.byteLength) {
                    const i = new Uint8Array(n);
                    if ((i.set(new Uint8Array(t)), 0 !== e)) for (let r = t.byteLength; r < n; r++) i[r] = e;
                    return i.buffer;
                }
                return t;
            }
            let tv = null;
            class ev {
                constructor() {
                    (this.plugins = []),
                        (this.options = {}),
                        (this.pending = []),
                        (this.buffers = []),
                        (this.byteOffset = 0),
                        (this.buffers = []),
                        (this.nodeMap = new Map()),
                        (this.skins = []),
                        (this.extensionsUsed = {}),
                        (this.uids = new Map()),
                        (this.uid = 0),
                        (this.json = { asset: { version: '2.0', generator: 'THREE.GLTFExporter' } }),
                        (this.cache = {
                            meshes: new Map(),
                            attributes: new Map(),
                            attributesNormalized: new Map(),
                            materials: new Map(),
                            textures: new Map(),
                            images: new Map(),
                        });
                }
                setPlugins(t) {
                    this.plugins = t;
                }
                write(t, e, n) {
                    (this.options = Object.assign(
                        {},
                        {
                            binary: !1,
                            trs: !1,
                            onlyVisible: !0,
                            truncateDrawRange: !0,
                            embedImages: !0,
                            maxTextureSize: 1 / 0,
                            animations: [],
                            includeCustomExtensions: !1,
                        },
                        n,
                    )),
                        this.options.animations.length > 0 && (this.options.trs = !0),
                        this.processInput(t);
                    const i = this;
                    Promise.all(this.pending).then(function () {
                        const t = i.buffers,
                            n = i.json,
                            r = i.options,
                            s = i.extensionsUsed,
                            a = new Blob(t, { type: 'application/octet-stream' }),
                            o = Object.keys(s);
                        if (
                            (o.length > 0 && (n.extensionsUsed = o),
                            n.buffers && n.buffers.length > 0 && (n.buffers[0].byteLength = a.size),
                            !0 === r.binary)
                        ) {
                            const t = new window.FileReader();
                            t.readAsArrayBuffer(a),
                                (t.onloadend = function () {
                                    const i = Qg(t.result),
                                        r = new DataView(new ArrayBuffer(8));
                                    r.setUint32(0, i.byteLength, !0), r.setUint32(4, 5130562, !0);
                                    const s = Qg(
                                            (function (t) {
                                                if (void 0 !== window.TextEncoder)
                                                    return new TextEncoder().encode(t).buffer;
                                                const e = new Uint8Array(new ArrayBuffer(t.length));
                                                for (let n = 0, i = t.length; n < i; n++) {
                                                    const i = t.charCodeAt(n);
                                                    e[n] = i > 255 ? 32 : i;
                                                }
                                                return e.buffer;
                                            })(JSON.stringify(n)),
                                            32,
                                        ),
                                        a = new DataView(new ArrayBuffer(8));
                                    a.setUint32(0, s.byteLength, !0), a.setUint32(4, 1313821514, !0);
                                    const o = new ArrayBuffer(12),
                                        l = new DataView(o);
                                    l.setUint32(0, 1179937895, !0), l.setUint32(4, 2, !0);
                                    const c = 12 + a.byteLength + s.byteLength + r.byteLength + i.byteLength;
                                    l.setUint32(8, c, !0);
                                    const h = new Blob([o, a, s, r, i], { type: 'application/octet-stream' }),
                                        u = new window.FileReader();
                                    u.readAsArrayBuffer(h),
                                        (u.onloadend = function () {
                                            e(u.result);
                                        });
                                });
                        } else if (n.buffers && n.buffers.length > 0) {
                            const t = new window.FileReader();
                            t.readAsDataURL(a),
                                (t.onloadend = function () {
                                    const i = t.result;
                                    (n.buffers[0].uri = i), e(n);
                                });
                        } else e(n);
                    });
                }
                serializeUserData(t, e) {
                    if (0 === Object.keys(t.userData).length) return;
                    const n = this.options,
                        i = this.extensionsUsed;
                    try {
                        const r = JSON.parse(JSON.stringify(t.userData));
                        if (n.includeCustomExtensions && r.gltfExtensions) {
                            void 0 === e.extensions && (e.extensions = {});
                            for (const t in r.gltfExtensions) (e.extensions[t] = r.gltfExtensions[t]), (i[t] = !0);
                            delete r.gltfExtensions;
                        }
                        Object.keys(r).length > 0 && (e.extras = r);
                    } catch (e) {
                        console.warn(
                            "THREE.GLTFExporter: userData of '" +
                                t.name +
                                "' won't be serialized because of JSON.stringify error - " +
                                e.message,
                        );
                    }
                }
                getUID(t) {
                    return this.uids.has(t) || this.uids.set(t, this.uid++), this.uids.get(t);
                }
                isNormalizedNormalAttribute(t) {
                    if (this.cache.attributesNormalized.has(t)) return !1;
                    const e = new Gt();
                    for (let n = 0, i = t.count; n < i; n++)
                        if (Math.abs(e.fromBufferAttribute(t, n).length() - 1) > 5e-4) return !1;
                    return !0;
                }
                createNormalizedNormalAttribute(t) {
                    const e = this.cache;
                    if (e.attributesNormalized.has(t)) return e.attributesNormalized.get(t);
                    const n = t.clone(),
                        i = new Gt();
                    for (let t = 0, e = n.count; t < e; t++)
                        i.fromBufferAttribute(n, t),
                            0 === i.x && 0 === i.y && 0 === i.z ? i.setX(1) : i.normalize(),
                            n.setXYZ(t, i.x, i.y, i.z);
                    return e.attributesNormalized.set(t, n), n;
                }
                applyTextureTransform(t, e) {
                    let n = !1;
                    const i = {};
                    (0 === e.offset.x && 0 === e.offset.y) || ((i.offset = e.offset.toArray()), (n = !0)),
                        0 !== e.rotation && ((i.rotation = e.rotation), (n = !0)),
                        (1 === e.repeat.x && 1 === e.repeat.y) || ((i.scale = e.repeat.toArray()), (n = !0)),
                        n &&
                            ((t.extensions = t.extensions || {}),
                            (t.extensions.KHR_texture_transform = i),
                            (this.extensionsUsed.KHR_texture_transform = !0));
                }
                processBuffer(t) {
                    const e = this.json,
                        n = this.buffers;
                    return e.buffers || (e.buffers = [{ byteLength: 0 }]), n.push(t), 0;
                }
                processBufferView(t, e, n, i, r) {
                    const s = this.json;
                    let a;
                    s.bufferViews || (s.bufferViews = []), (a = e === Xg ? 1 : e === Yg ? 2 : 4);
                    const o = Kg(i * t.itemSize * a),
                        l = new DataView(new ArrayBuffer(o));
                    let c = 0;
                    for (let r = n; r < n + i; r++)
                        for (let n = 0; n < t.itemSize; n++) {
                            let i;
                            t.itemSize > 4
                                ? (i = t.array[r * t.itemSize + n])
                                : 0 === n
                                ? (i = t.getX(r))
                                : 1 === n
                                ? (i = t.getY(r))
                                : 2 === n
                                ? (i = t.getZ(r))
                                : 3 === n && (i = t.getW(r)),
                                5126 === e
                                    ? l.setFloat32(c, i, !0)
                                    : 5125 === e
                                    ? l.setUint32(c, i, !0)
                                    : e === Yg
                                    ? l.setUint16(c, i, !0)
                                    : e === Xg && l.setUint8(c, i),
                                (c += a);
                        }
                    const h = { buffer: this.processBuffer(l.buffer), byteOffset: this.byteOffset, byteLength: o };
                    return (
                        void 0 !== r && (h.target = r),
                        34962 === r && (h.byteStride = t.itemSize * a),
                        (this.byteOffset += o),
                        s.bufferViews.push(h),
                        { id: s.bufferViews.length - 1, byteLength: 0 }
                    );
                }
                processBufferViewImage(t) {
                    const e = this,
                        n = e.json;
                    return (
                        n.bufferViews || (n.bufferViews = []),
                        new Promise(function (i) {
                            const r = new window.FileReader();
                            r.readAsArrayBuffer(t),
                                (r.onloadend = function () {
                                    const t = Qg(r.result),
                                        s = {
                                            buffer: e.processBuffer(t),
                                            byteOffset: e.byteOffset,
                                            byteLength: t.byteLength,
                                        };
                                    (e.byteOffset += t.byteLength), i(n.bufferViews.push(s) - 1);
                                });
                        })
                    );
                }
                processAccessor(t, e, n, i) {
                    const r = this.options,
                        s = this.json;
                    let a;
                    if (t.array.constructor === Float32Array) a = 5126;
                    else if (t.array.constructor === Uint32Array) a = 5125;
                    else if (t.array.constructor === Uint16Array) a = Yg;
                    else {
                        if (t.array.constructor !== Uint8Array)
                            throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');
                        a = Xg;
                    }
                    if (
                        (void 0 === n && (n = 0),
                        void 0 === i && (i = t.count),
                        r.truncateDrawRange && void 0 !== e && null === e.index)
                    ) {
                        const r = n + i,
                            s = e.drawRange.count === 1 / 0 ? t.count : e.drawRange.start + e.drawRange.count;
                        (n = Math.max(n, e.drawRange.start)), (i = Math.min(r, s) - n) < 0 && (i = 0);
                    }
                    if (0 === i) return null;
                    const o = (function (t, e, n) {
                        const i = {
                            min: new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),
                            max: new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY),
                        };
                        for (let r = e; r < e + n; r++)
                            for (let e = 0; e < t.itemSize; e++) {
                                let n;
                                t.itemSize > 4
                                    ? (n = t.array[r * t.itemSize + e])
                                    : 0 === e
                                    ? (n = t.getX(r))
                                    : 1 === e
                                    ? (n = t.getY(r))
                                    : 2 === e
                                    ? (n = t.getZ(r))
                                    : 3 === e && (n = t.getW(r)),
                                    (i.min[e] = Math.min(i.min[e], n)),
                                    (i.max[e] = Math.max(i.max[e], n));
                            }
                        return i;
                    })(t, n, i);
                    let l;
                    void 0 !== e && (l = t === e.index ? 34963 : 34962);
                    const c = this.processBufferView(t, a, n, i, l),
                        h = {
                            bufferView: c.id,
                            byteOffset: c.byteOffset,
                            componentType: a,
                            count: i,
                            max: o.max,
                            min: o.min,
                            type: { 1: 'SCALAR', 2: 'VEC2', 3: 'VEC3', 4: 'VEC4', 16: 'MAT4' }[t.itemSize],
                        };
                    return (
                        !0 === t.normalized && (h.normalized = !0),
                        s.accessors || (s.accessors = []),
                        s.accessors.push(h) - 1
                    );
                }
                processImage(t, e, n) {
                    const i = this,
                        r = i.cache,
                        s = i.json,
                        a = i.options,
                        o = i.pending;
                    r.images.has(t) || r.images.set(t, {});
                    const l = r.images.get(t),
                        c = 1023 === e ? 'image/png' : 'image/jpeg',
                        h = c + ':flipY/' + n.toString();
                    if (void 0 !== l[h]) return l[h];
                    s.images || (s.images = []);
                    const u = { mimeType: c };
                    if (a.embedImages) {
                        const r = (tv = tv || document.createElement('canvas'));
                        (r.width = Math.min(t.width, a.maxTextureSize)),
                            (r.height = Math.min(t.height, a.maxTextureSize));
                        const s = r.getContext('2d');
                        if (
                            (!0 === n && (s.translate(0, r.height), s.scale(1, -1)),
                            ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                                ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                                ('undefined' != typeof OffscreenCanvas && t instanceof OffscreenCanvas) ||
                                ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap))
                        )
                            s.drawImage(t, 0, 0, r.width, r.height);
                        else {
                            1023 !== e &&
                                1022 !== e &&
                                console.error('GLTFExporter: Only RGB and RGBA formats are supported.'),
                                (t.width > a.maxTextureSize || t.height > a.maxTextureSize) &&
                                    console.warn('GLTFExporter: Image size is bigger than maxTextureSize', t);
                            const n = new Uint8ClampedArray(t.height * t.width * 4);
                            if (1023 === e)
                                for (let e = 0; e < n.length; e += 4)
                                    (n[e + 0] = t.data[e + 0]),
                                        (n[e + 1] = t.data[e + 1]),
                                        (n[e + 2] = t.data[e + 2]),
                                        (n[e + 3] = t.data[e + 3]);
                            else
                                for (let e = 0, i = 0; e < n.length; e += 4, i += 3)
                                    (n[e + 0] = t.data[i + 0]),
                                        (n[e + 1] = t.data[i + 1]),
                                        (n[e + 2] = t.data[i + 2]),
                                        (n[e + 3] = 255);
                            s.putImageData(new ImageData(n, t.width, t.height), 0, 0);
                        }
                        !0 === a.binary
                            ? o.push(
                                  new Promise(function (t) {
                                      r.toBlob(function (e) {
                                          i.processBufferViewImage(e).then(function (e) {
                                              (u.bufferView = e), t();
                                          });
                                      }, c);
                                  }),
                              )
                            : (u.uri = r.toDataURL(c));
                    } else u.uri = t.src;
                    const d = s.images.push(u) - 1;
                    return (l[h] = d), d;
                }
                processSampler(t) {
                    const e = this.json;
                    e.samplers || (e.samplers = []);
                    const n = {
                        magFilter: Zg[t.magFilter],
                        minFilter: Zg[t.minFilter],
                        wrapS: Zg[t.wrapS],
                        wrapT: Zg[t.wrapT],
                    };
                    return e.samplers.push(n) - 1;
                }
                processTexture(t) {
                    const e = this.cache,
                        n = this.json;
                    if (e.textures.has(t)) return e.textures.get(t);
                    n.textures || (n.textures = []);
                    const i = {
                        sampler: this.processSampler(t),
                        source: this.processImage(t.image, t.format, t.flipY),
                    };
                    t.name && (i.name = t.name),
                        this._invokeAll(function (e) {
                            e.writeTexture && e.writeTexture(t, i);
                        });
                    const r = n.textures.push(i) - 1;
                    return e.textures.set(t, r), r;
                }
                processMaterial(t) {
                    const e = this.cache,
                        n = this.json;
                    if (e.materials.has(t)) return e.materials.get(t);
                    if (t.isShaderMaterial)
                        return console.warn('GLTFExporter: THREE.ShaderMaterial not supported.'), null;
                    n.materials || (n.materials = []);
                    const i = { pbrMetallicRoughness: {} };
                    !0 !== t.isMeshStandardMaterial &&
                        !0 !== t.isMeshBasicMaterial &&
                        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');
                    const r = t.color.toArray().concat([t.opacity]);
                    if (
                        ($g(r, [1, 1, 1, 1]) || (i.pbrMetallicRoughness.baseColorFactor = r),
                        t.isMeshStandardMaterial
                            ? ((i.pbrMetallicRoughness.metallicFactor = t.metalness),
                              (i.pbrMetallicRoughness.roughnessFactor = t.roughness))
                            : ((i.pbrMetallicRoughness.metallicFactor = 0.5),
                              (i.pbrMetallicRoughness.roughnessFactor = 0.5)),
                        t.metalnessMap || t.roughnessMap)
                    )
                        if (t.metalnessMap === t.roughnessMap) {
                            const e = { index: this.processTexture(t.metalnessMap) };
                            this.applyTextureTransform(e, t.metalnessMap),
                                (i.pbrMetallicRoughness.metallicRoughnessTexture = e);
                        } else
                            console.warn(
                                'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.',
                            );
                    if (t.map) {
                        const e = { index: this.processTexture(t.map) };
                        this.applyTextureTransform(e, t.map), (i.pbrMetallicRoughness.baseColorTexture = e);
                    }
                    if (t.emissive) {
                        const e = t.emissive.clone().multiplyScalar(t.emissiveIntensity),
                            n = Math.max(e.r, e.g, e.b);
                        if (
                            (n > 1 &&
                                (e.multiplyScalar(1 / n),
                                console.warn(
                                    'THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited',
                                )),
                            n > 0 && (i.emissiveFactor = e.toArray()),
                            t.emissiveMap)
                        ) {
                            const e = { index: this.processTexture(t.emissiveMap) };
                            this.applyTextureTransform(e, t.emissiveMap), (i.emissiveTexture = e);
                        }
                    }
                    if (t.normalMap) {
                        const e = { index: this.processTexture(t.normalMap) };
                        t.normalScale && 1 !== t.normalScale.x && (e.scale = t.normalScale.x),
                            this.applyTextureTransform(e, t.normalMap),
                            (i.normalTexture = e);
                    }
                    if (t.aoMap) {
                        const e = { index: this.processTexture(t.aoMap), texCoord: 1 };
                        1 !== t.aoMapIntensity && (e.strength = t.aoMapIntensity),
                            this.applyTextureTransform(e, t.aoMap),
                            (i.occlusionTexture = e);
                    }
                    t.transparent
                        ? (i.alphaMode = 'BLEND')
                        : t.alphaTest > 0 && ((i.alphaMode = 'MASK'), (i.alphaCutoff = t.alphaTest)),
                        2 === t.side && (i.doubleSided = !0),
                        '' !== t.name && (i.name = t.name),
                        this.serializeUserData(t, i),
                        this._invokeAll(function (e) {
                            e.writeMaterial && e.writeMaterial(t, i);
                        });
                    const s = n.materials.push(i) - 1;
                    return e.materials.set(t, s), s;
                }
                processMesh(t) {
                    const e = this.cache,
                        n = this.json,
                        i = [t.geometry.uuid];
                    if (Array.isArray(t.material))
                        for (let e = 0, n = t.material.length; e < n; e++) i.push(t.material[e].uuid);
                    else i.push(t.material.uuid);
                    const r = i.join(':');
                    if (e.meshes.has(r)) return e.meshes.get(r);
                    const s = t.geometry;
                    let a;
                    if (
                        ((a = t.isLineSegments
                            ? 1
                            : t.isLineLoop
                            ? 2
                            : t.isLine
                            ? 3
                            : t.isPoints
                            ? 0
                            : t.material.wireframe
                            ? 1
                            : 4),
                        !0 !== s.isBufferGeometry)
                    )
                        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');
                    const o = {},
                        l = {},
                        c = [],
                        h = [],
                        u = {
                            uv: 'TEXCOORD_0',
                            uv2: 'TEXCOORD_1',
                            color: 'COLOR_0',
                            skinWeight: 'WEIGHTS_0',
                            skinIndex: 'JOINTS_0',
                        },
                        d = s.getAttribute('normal');
                    void 0 === d ||
                        this.isNormalizedNormalAttribute(d) ||
                        (console.warn(
                            'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.',
                        ),
                        s.setAttribute('normal', this.createNormalizedNormalAttribute(d)));
                    let p = null;
                    for (let t in s.attributes) {
                        if ('morph' === t.substr(0, 5)) continue;
                        const n = s.attributes[t];
                        if (
                            ((t = u[t] || t.toUpperCase()),
                            /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t) ||
                                (t = '_' + t),
                            e.attributes.has(this.getUID(n)))
                        ) {
                            l[t] = e.attributes.get(this.getUID(n));
                            continue;
                        }
                        p = null;
                        const i = n.array;
                        'JOINTS_0' !== t ||
                            i instanceof Uint16Array ||
                            i instanceof Uint8Array ||
                            (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),
                            (p = new fn(new Uint16Array(i), n.itemSize, n.normalized)));
                        const r = this.processAccessor(p || n, s);
                        null !== r && ((l[t] = r), e.attributes.set(this.getUID(n), r));
                    }
                    if ((void 0 !== d && s.setAttribute('normal', d), 0 === Object.keys(l).length)) return null;
                    if (void 0 !== t.morphTargetInfluences && t.morphTargetInfluences.length > 0) {
                        const n = [],
                            i = [],
                            r = {};
                        if (void 0 !== t.morphTargetDictionary)
                            for (const e in t.morphTargetDictionary) r[t.morphTargetDictionary[e]] = e;
                        for (let a = 0; a < t.morphTargetInfluences.length; ++a) {
                            const o = {};
                            let l = !1;
                            for (const t in s.morphAttributes) {
                                if ('position' !== t && 'normal' !== t) {
                                    l ||
                                        (console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.'),
                                        (l = !0));
                                    continue;
                                }
                                const n = s.morphAttributes[t][a],
                                    i = t.toUpperCase(),
                                    r = s.attributes[t];
                                if (e.attributes.has(this.getUID(n))) {
                                    o[i] = e.attributes.get(this.getUID(n));
                                    continue;
                                }
                                const c = n.clone();
                                if (!s.morphTargetsRelative)
                                    for (let t = 0, e = n.count; t < e; t++)
                                        c.setXYZ(
                                            t,
                                            n.getX(t) - r.getX(t),
                                            n.getY(t) - r.getY(t),
                                            n.getZ(t) - r.getZ(t),
                                        );
                                (o[i] = this.processAccessor(c, s)), e.attributes.set(this.getUID(r), o[i]);
                            }
                            h.push(o),
                                n.push(t.morphTargetInfluences[a]),
                                void 0 !== t.morphTargetDictionary && i.push(r[a]);
                        }
                        (o.weights = n), i.length > 0 && ((o.extras = {}), (o.extras.targetNames = i));
                    }
                    const m = Array.isArray(t.material);
                    if (m && 0 === s.groups.length) return null;
                    const f = m ? t.material : [t.material],
                        g = m ? s.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
                    for (let t = 0, n = g.length; t < n; t++) {
                        const n = { mode: a, attributes: l };
                        if ((this.serializeUserData(s, n), h.length > 0 && (n.targets = h), null !== s.index)) {
                            let i = this.getUID(s.index);
                            (void 0 === g[t].start && void 0 === g[t].count) ||
                                (i += ':' + g[t].start + ':' + g[t].count),
                                e.attributes.has(i)
                                    ? (n.indices = e.attributes.get(i))
                                    : ((n.indices = this.processAccessor(s.index, s, g[t].start, g[t].count)),
                                      e.attributes.set(i, n.indices)),
                                null === n.indices && delete n.indices;
                        }
                        const i = this.processMaterial(f[g[t].materialIndex]);
                        null !== i && (n.material = i), c.push(n);
                    }
                    (o.primitives = c),
                        n.meshes || (n.meshes = []),
                        this._invokeAll(function (e) {
                            e.writeMesh && e.writeMesh(t, o);
                        });
                    const v = n.meshes.push(o) - 1;
                    return e.meshes.set(r, v), v;
                }
                processCamera(t) {
                    const e = this.json;
                    e.cameras || (e.cameras = []);
                    const n = t.isOrthographicCamera,
                        i = { type: n ? 'orthographic' : 'perspective' };
                    return (
                        n
                            ? (i.orthographic = {
                                  xmag: 2 * t.right,
                                  ymag: 2 * t.top,
                                  zfar: t.far <= 0 ? 0.001 : t.far,
                                  znear: t.near < 0 ? 0 : t.near,
                              })
                            : (i.perspective = {
                                  aspectRatio: t.aspect,
                                  yfov: Lt.degToRad(t.fov),
                                  zfar: t.far <= 0 ? 0.001 : t.far,
                                  znear: t.near < 0 ? 0 : t.near,
                              }),
                        '' !== t.name && (i.name = t.type),
                        e.cameras.push(i) - 1
                    );
                }
                processAnimation(t, e) {
                    const n = this.json,
                        i = this.nodeMap;
                    n.animations || (n.animations = []);
                    const r = (t = qg.Utils.mergeMorphTargetTracks(t.clone(), e)).tracks,
                        s = [],
                        a = [];
                    for (let t = 0; t < r.length; ++t) {
                        const n = r[t],
                            o = Yl.parseTrackName(n.name);
                        let l = Yl.findNode(e, o.nodeName);
                        const c = Jg[o.propertyName];
                        if (
                            ('bones' === o.objectName &&
                                (l = !0 === l.isSkinnedMesh ? l.skeleton.getBoneByName(o.objectIndex) : void 0),
                            !l || !c)
                        )
                            return (
                                console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n.name), null
                            );
                        const h = 1;
                        let u,
                            d = n.values.length / n.times.length;
                        c === Jg.morphTargetInfluences && (d /= l.morphTargetInfluences.length),
                            !0 === n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline
                                ? ((u = 'CUBICSPLINE'), (d /= 3))
                                : (u = 2300 === n.getInterpolation() ? 'STEP' : 'LINEAR'),
                            a.push({
                                input: this.processAccessor(new fn(n.times, h)),
                                output: this.processAccessor(new fn(n.values, d)),
                                interpolation: u,
                            }),
                            s.push({ sampler: a.length - 1, target: { node: i.get(l), path: c } });
                    }
                    return (
                        n.animations.push({ name: t.name || 'clip_' + n.animations.length, samplers: a, channels: s }),
                        n.animations.length - 1
                    );
                }
                processSkin(t) {
                    const e = this.json,
                        n = this.nodeMap,
                        i = e.nodes[n.get(t)],
                        r = t.skeleton;
                    if (void 0 === r) return null;
                    const s = t.skeleton.bones[0];
                    if (void 0 === s) return null;
                    const a = [],
                        o = new Float32Array(16 * r.bones.length),
                        l = new xe();
                    for (let e = 0; e < r.bones.length; ++e)
                        a.push(n.get(r.bones[e])),
                            l.copy(r.boneInverses[e]),
                            l.multiply(t.bindMatrix).toArray(o, 16 * e);
                    return (
                        void 0 === e.skins && (e.skins = []),
                        e.skins.push({
                            inverseBindMatrices: this.processAccessor(new fn(o, 16)),
                            joints: a,
                            skeleton: n.get(s),
                        }),
                        (i.skin = e.skins.length - 1)
                    );
                }
                processNode(t) {
                    const e = this.json,
                        n = this.options,
                        i = this.nodeMap;
                    e.nodes || (e.nodes = []);
                    const r = {};
                    if (n.trs) {
                        const e = t.quaternion.toArray(),
                            n = t.position.toArray(),
                            i = t.scale.toArray();
                        $g(e, [0, 0, 0, 1]) || (r.rotation = e),
                            $g(n, [0, 0, 0]) || (r.translation = n),
                            $g(i, [1, 1, 1]) || (r.scale = i);
                    } else
                        t.matrixAutoUpdate && t.updateMatrix(),
                            !1 === $g(t.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) &&
                                (r.matrix = t.matrix.elements);
                    if (
                        ('' !== t.name && (r.name = String(t.name)),
                        this.serializeUserData(t, r),
                        t.isMesh || t.isLine || t.isPoints)
                    ) {
                        const e = this.processMesh(t);
                        null !== e && (r.mesh = e);
                    } else t.isCamera && (r.camera = this.processCamera(t));
                    if ((t.isSkinnedMesh && this.skins.push(t), t.children.length > 0)) {
                        const e = [];
                        for (let i = 0, r = t.children.length; i < r; i++) {
                            const r = t.children[i];
                            if (r.visible || !1 === n.onlyVisible) {
                                const t = this.processNode(r);
                                null !== t && e.push(t);
                            }
                        }
                        e.length > 0 && (r.children = e);
                    }
                    this._invokeAll(function (e) {
                        e.writeNode && e.writeNode(t, r);
                    });
                    const s = e.nodes.push(r) - 1;
                    return i.set(t, s), s;
                }
                processScene(t) {
                    const e = this.json,
                        n = this.options;
                    e.scenes || ((e.scenes = []), (e.scene = 0));
                    const i = {};
                    '' !== t.name && (i.name = t.name), e.scenes.push(i);
                    const r = [];
                    for (let e = 0, i = t.children.length; e < i; e++) {
                        const i = t.children[e];
                        if (i.visible || !1 === n.onlyVisible) {
                            const t = this.processNode(i);
                            null !== t && r.push(t);
                        }
                    }
                    r.length > 0 && (i.nodes = r), this.serializeUserData(t, i);
                }
                processObjects(t) {
                    const e = new Xs();
                    e.name = 'AuxScene';
                    for (let n = 0; n < t.length; n++) e.children.push(t[n]);
                    this.processScene(e);
                }
                processInput(t) {
                    const e = this.options;
                    (t = t instanceof Array ? t : [t]),
                        this._invokeAll(function (e) {
                            e.beforeParse && e.beforeParse(t);
                        });
                    const n = [];
                    for (let e = 0; e < t.length; e++) t[e] instanceof Xs ? this.processScene(t[e]) : n.push(t[e]);
                    n.length > 0 && this.processObjects(n);
                    for (let t = 0; t < this.skins.length; ++t) this.processSkin(this.skins[t]);
                    for (let n = 0; n < e.animations.length; ++n) this.processAnimation(e.animations[n], t[0]);
                    this._invokeAll(function (e) {
                        e.afterParse && e.afterParse(t);
                    });
                }
                _invokeAll(t) {
                    for (let e = 0, n = this.plugins.length; e < n; e++) t(this.plugins[e]);
                }
            }
            class nv {
                constructor(t) {
                    (this.writer = t), (this.name = 'KHR_lights_punctual');
                }
                writeNode(t, e) {
                    if (!t.isLight) return;
                    if (!t.isDirectionalLight && !t.isPointLight && !t.isSpotLight)
                        return void console.warn(
                            'THREE.GLTFExporter: Only directional, point, and spot lights are supported.',
                            t,
                        );
                    const n = this.writer,
                        i = n.json,
                        r = n.extensionsUsed,
                        s = {};
                    t.name && (s.name = t.name),
                        (s.color = t.color.toArray()),
                        (s.intensity = t.intensity),
                        t.isDirectionalLight
                            ? (s.type = 'directional')
                            : t.isPointLight
                            ? ((s.type = 'point'), t.distance > 0 && (s.range = t.distance))
                            : t.isSpotLight &&
                              ((s.type = 'spot'),
                              t.distance > 0 && (s.range = t.distance),
                              (s.spot = {}),
                              (s.spot.innerConeAngle = (t.penumbra - 1) * t.angle * -1),
                              (s.spot.outerConeAngle = t.angle)),
                        void 0 !== t.decay &&
                            2 !== t.decay &&
                            console.warn(
                                'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.',
                            ),
                        !t.target ||
                            (t.target.parent === t &&
                                0 === t.target.position.x &&
                                0 === t.target.position.y &&
                                -1 === t.target.position.z) ||
                            console.warn(
                                'THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.',
                            ),
                        r[this.name] ||
                            ((i.extensions = i.extensions || {}),
                            (i.extensions[this.name] = { lights: [] }),
                            (r[this.name] = !0));
                    const a = i.extensions[this.name].lights;
                    a.push(s), (e.extensions = e.extensions || {}), (e.extensions[this.name] = { light: a.length - 1 });
                }
            }
            class iv {
                constructor(t) {
                    (this.writer = t), (this.name = 'KHR_materials_unlit');
                }
                writeMaterial(t, e) {
                    if (!t.isMeshBasicMaterial) return;
                    const n = this.writer.extensionsUsed;
                    (e.extensions = e.extensions || {}),
                        (e.extensions[this.name] = {}),
                        (n[this.name] = !0),
                        (e.pbrMetallicRoughness.metallicFactor = 0),
                        (e.pbrMetallicRoughness.roughnessFactor = 0.9);
                }
            }
            class rv {
                constructor(t) {
                    (this.writer = t), (this.name = 'KHR_materials_pbrSpecularGlossiness');
                }
                writeMaterial(t, e) {
                    if (!t.isGLTFSpecularGlossinessMaterial) return;
                    const n = this.writer,
                        i = n.extensionsUsed,
                        r = {};
                    e.pbrMetallicRoughness.baseColorFactor &&
                        (r.diffuseFactor = e.pbrMetallicRoughness.baseColorFactor);
                    const s = [1, 1, 1];
                    if (
                        (t.specular.toArray(s, 0),
                        (r.specularFactor = s),
                        (r.glossinessFactor = t.glossiness),
                        e.pbrMetallicRoughness.baseColorTexture &&
                            (r.diffuseTexture = e.pbrMetallicRoughness.baseColorTexture),
                        t.specularMap)
                    ) {
                        const e = { index: n.processTexture(t.specularMap) };
                        n.applyTextureTransform(e, t.specularMap), (r.specularGlossinessTexture = e);
                    }
                    (e.extensions = e.extensions || {}), (e.extensions[this.name] = r), (i[this.name] = !0);
                }
            }
            class sv {
                constructor(t) {
                    (this.writer = t), (this.name = 'KHR_materials_transmission');
                }
                writeMaterial(t, e) {
                    if (!t.isMeshPhysicalMaterial || 0 === t.transmission) return;
                    const n = this.writer,
                        i = n.extensionsUsed,
                        r = {};
                    if (((r.transmissionFactor = t.transmission), t.transmissionMap)) {
                        const e = { index: n.processTexture(t.transmissionMap) };
                        n.applyTextureTransform(e, t.transmissionMap), (r.transmissionTexture = e);
                    }
                    (e.extensions = e.extensions || {}), (e.extensions[this.name] = r), (i[this.name] = !0);
                }
            }
            class av {
                constructor(t) {
                    (this.writer = t), (this.name = 'KHR_materials_volume');
                }
                writeMaterial(t, e) {
                    if (!t.isMeshPhysicalMaterial || 0 === t.thickness) return;
                    const n = this.writer,
                        i = n.extensionsUsed,
                        r = {};
                    if (((r.thicknessFactor = t.thickness), t.thicknessMap)) {
                        const e = { index: n.processTexture(t.thicknessMap) };
                        n.applyTextureTransform(e, t.thicknessMap), (r.thicknessTexture = e);
                    }
                    (r.attenuationDistance = t.attenuationDistance),
                        (r.attenuationColor = t.attenuationTint.toArray()),
                        (e.extensions = e.extensions || {}),
                        (e.extensions[this.name] = r),
                        (i[this.name] = !0);
                }
            }
            qg.Utils = {
                insertKeyframe: function (t, e) {
                    const n = 0.001,
                        i = t.getValueSize(),
                        r = new t.TimeBufferType(t.times.length + 1),
                        s = new t.ValueBufferType(t.values.length + i),
                        a = t.createInterpolant(new t.ValueBufferType(i));
                    let o;
                    if (0 === t.times.length) {
                        r[0] = e;
                        for (let t = 0; t < i; t++) s[t] = 0;
                        o = 0;
                    } else if (e < t.times[0]) {
                        if (Math.abs(t.times[0] - e) < n) return 0;
                        (r[0] = e), r.set(t.times, 1), s.set(a.evaluate(e), 0), s.set(t.values, i), (o = 0);
                    } else if (e > t.times[t.times.length - 1]) {
                        if (Math.abs(t.times[t.times.length - 1] - e) < n) return t.times.length - 1;
                        (r[r.length - 1] = e),
                            r.set(t.times, 0),
                            s.set(t.values, 0),
                            s.set(a.evaluate(e), t.values.length),
                            (o = r.length - 1);
                    } else
                        for (let l = 0; l < t.times.length; l++) {
                            if (Math.abs(t.times[l] - e) < n) return l;
                            if (t.times[l] < e && t.times[l + 1] > e) {
                                r.set(t.times.slice(0, l + 1), 0),
                                    (r[l + 1] = e),
                                    r.set(t.times.slice(l + 1), l + 2),
                                    s.set(t.values.slice(0, (l + 1) * i), 0),
                                    s.set(a.evaluate(e), (l + 1) * i),
                                    s.set(t.values.slice((l + 1) * i), (l + 2) * i),
                                    (o = l + 1);
                                break;
                            }
                        }
                    return (t.times = r), (t.values = s), o;
                },
                mergeMorphTargetTracks: function (t, e) {
                    const n = [],
                        i = {},
                        r = t.tracks;
                    for (let t = 0; t < r.length; ++t) {
                        let s = r[t];
                        const a = Yl.parseTrackName(s.name),
                            o = Yl.findNode(e, a.nodeName);
                        if ('morphTargetInfluences' !== a.propertyName || void 0 === a.propertyIndex) {
                            n.push(s);
                            continue;
                        }
                        if (
                            s.createInterpolant !== s.InterpolantFactoryMethodDiscrete &&
                            s.createInterpolant !== s.InterpolantFactoryMethodLinear
                        ) {
                            if (s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
                                throw new Error(
                                    'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.',
                                );
                            console.warn(
                                'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.',
                            ),
                                (s = s.clone()),
                                s.setInterpolation(2301);
                        }
                        const l = o.morphTargetInfluences.length,
                            c = o.morphTargetDictionary[a.propertyIndex];
                        if (void 0 === c)
                            throw new Error('THREE.GLTFExporter: Morph target name not found: ' + a.propertyIndex);
                        let h;
                        if (void 0 === i[o.uuid]) {
                            h = s.clone();
                            const t = new h.ValueBufferType(l * h.times.length);
                            for (let e = 0; e < h.times.length; e++) t[e * l + c] = h.values[e];
                            (h.name = (a.nodeName || '') + '.morphTargetInfluences'),
                                (h.values = t),
                                (i[o.uuid] = h),
                                n.push(h);
                            continue;
                        }
                        const u = s.createInterpolant(new s.ValueBufferType(1));
                        h = i[o.uuid];
                        for (let t = 0; t < h.times.length; t++) h.values[t * l + c] = u.evaluate(h.times[t]);
                        for (let t = 0; t < s.times.length; t++) {
                            const e = this.insertKeyframe(h, s.times[t]);
                            h.values[e * l + c] = s.values[t];
                        }
                    }
                    return (t.tracks = n), t;
                },
            };
            const ov = (t) =>
                    void 0 !== t.material &&
                    t.userData &&
                    t.userData.variantMaterials &&
                    !!Array.from(t.userData.variantMaterials.values()).filter((t) => lv(t.material)),
                lv = (t) => t && t.isMaterial && !Array.isArray(t);
            class cv {
                constructor(t) {
                    (this.writer = t), (this.name = 'KHR_materials_variants'), (this.variantNames = []);
                }
                beforeParse(t) {
                    const e = new Set();
                    for (const n of t)
                        n.traverse((t) => {
                            if (!ov(t)) return;
                            const n = t.userData.variantMaterials;
                            for (const t of n.keys()) {
                                const i = n.get(t);
                                lv(i.material) && e.add(t);
                            }
                        });
                    e.forEach((t) => this.variantNames.push(t));
                }
                writeMesh(t, e) {
                    if (!ov(t)) return;
                    const n = t.userData,
                        i = n.variantMaterials,
                        r = new Map();
                    for (const t of i.keys()) {
                        const e = i.get(t).material;
                        if (!lv(e)) continue;
                        const n = this.variantNames.indexOf(t),
                            s = this.writer.processMaterial(e);
                        r.has(s) || r.set(s, { material: s, variants: [] }), r.get(s).variants.push(n);
                    }
                    const s = Array.from(r.values())
                        .map((t) => t.variants.sort((t, e) => t - e) && t)
                        .sort((t, e) => t.material - e.material);
                    if (0 === s.length) return;
                    const a = lv(n.originalMaterial) ? this.writer.processMaterial(n.originalMaterial) : -1;
                    for (const t of e.primitives)
                        a >= 0 && (t.material = a),
                            (t.extensions = t.extensions || {}),
                            (t.extensions[this.name] = { mappings: s });
                }
                afterParse() {
                    if (0 === this.variantNames.length) return;
                    const t = this.writer.json;
                    t.extensions = t.extensions || {};
                    const e = this.variantNames.map((t) => ({ name: t }));
                    (t.extensions[this.name] = { variants: e }), (this.writer.extensionsUsed[this.name] = !0);
                }
            }
            const hv = Symbol('correlatedObjects'),
                uv = Symbol('sourceObject'),
                dv = Symbol('onUpdate');
            class pv {
                constructor(t, e, n = null) {
                    (this[dv] = t), (this[uv] = e), (this[hv] = n);
                }
            }
            const mv = new fl(),
                fv = new dn(),
                gv = new ui(2, 2),
                vv = Symbol('threeTexture');
            class yv extends pv {
                get [vv]() {
                    var t;
                    return (
                        console.assert(null != this[hv] && this[hv].size > 0, 'Image correlated object is undefined'),
                        null === (t = this[hv]) || void 0 === t ? void 0 : t.values().next().value
                    );
                }
                constructor(t, e, n) {
                    super(
                        t,
                        (n = null != n ? n : { name: 'adhoc_image', uri: e && e.image ? e.image.src : 'adhoc_image' }),
                        new Set(e ? [e] : []),
                    );
                }
                get name() {
                    return this[uv].name || '';
                }
                get uri() {
                    return this[uv].uri;
                }
                get bufferView() {
                    return this[uv].bufferView;
                }
                get type() {
                    return null != this.uri ? 'external' : 'embedded';
                }
                async setURI(t) {
                    this[uv].uri = t;
                    const e = await new Promise((e, n) => {
                            mv.load(t, e, void 0, n);
                        }),
                        n = this[vv];
                    (n.image = e), (n.needsUpdate = !0), this[dv]();
                }
                async createThumbnail(t, e) {
                    const n = new Xs();
                    fv.map = this[vv];
                    const i = new Wn(gv, fv);
                    n.add(i);
                    const r = new wi(-1, 1, 1, -1, 0, 1),
                        { threeRenderer: s } = dd.singleton,
                        a = new zt(t, e);
                    s.setRenderTarget(a), s.render(n, r), s.setRenderTarget(null);
                    const o = new Uint8Array(t * e * 4);
                    s.readRenderTargetPixels(a, 0, 0, t, e, o), (Cd.width = t), (Cd.height = e);
                    const l = Cd.getContext('2d'),
                        c = l.createImageData(t, e);
                    return (
                        c.data.set(o),
                        l.putImageData(c, 0, 0),
                        new Promise(async (t, e) => {
                            Cd.toBlob((n) => {
                                if (!n) return e('Failed to capture thumbnail.');
                                t(URL.createObjectURL(n));
                            }, 'image/png');
                        })
                    );
                }
            }
            var xv, bv;
            !(function (t) {
                (t[(t.Nearest = 9728)] = 'Nearest'),
                    (t[(t.Linear = 9729)] = 'Linear'),
                    (t[(t.NearestMipmapNearest = 9984)] = 'NearestMipmapNearest'),
                    (t[(t.LinearMipmapNearest = 9985)] = 'LinearMipmapNearest'),
                    (t[(t.NearestMipmapLinear = 9986)] = 'NearestMipmapLinear'),
                    (t[(t.LinearMipmapLinear = 9987)] = 'LinearMipmapLinear');
            })(xv || (xv = {})),
                (function (t) {
                    (t[(t.ClampToEdge = 33071)] = 'ClampToEdge'),
                        (t[(t.MirroredRepeat = 33648)] = 'MirroredRepeat'),
                        (t[(t.Repeat = 10497)] = 'Repeat');
                })(bv || (bv = {}));
            const wv = (() => {
                    const t = [
                        xv.Nearest,
                        xv.Linear,
                        xv.NearestMipmapNearest,
                        xv.LinearMipmapLinear,
                        xv.NearestMipmapLinear,
                        xv.LinearMipmapLinear,
                    ];
                    return (e) => t.indexOf(e) > -1;
                })(),
                _v = (() => {
                    const t = [xv.Nearest, xv.Linear];
                    return (e) => t.indexOf(e) > -1;
                })(),
                Mv = (() => {
                    const t = [bv.ClampToEdge, bv.MirroredRepeat, bv.Repeat];
                    return (e) => t.indexOf(e) > -1;
                })(),
                Sv = Symbol('threeTextures'),
                Tv = Symbol('setProperty'),
                Ev = Symbol('sourceSampler');
            class Av extends pv {
                get [Sv]() {
                    return (
                        console.assert(null != this[hv] && this[hv].size > 0, 'Sampler correlated object is undefined'),
                        this[hv]
                    );
                }
                get [Ev]() {
                    return console.assert(null != this[uv], 'Sampler source is undefined'), this[uv];
                }
                constructor(t, e, n) {
                    null == (n = null != n ? n : {}).minFilter &&
                        (n.minFilter = e ? e.minFilter : xv.LinearMipmapLinear),
                        null == n.magFilter && (n.magFilter = e ? e.magFilter : xv.Linear),
                        null == n.wrapS && (n.wrapS = e ? e.wrapS : bv.Repeat),
                        null == n.wrapT && (n.wrapT = e ? e.wrapT : bv.Repeat),
                        super(t, n, new Set(e ? [e] : []));
                }
                get name() {
                    return this[uv].name || '';
                }
                get minFilter() {
                    return this[Ev].minFilter;
                }
                get magFilter() {
                    return this[Ev].magFilter;
                }
                get wrapS() {
                    return this[Ev].wrapS;
                }
                get wrapT() {
                    return this[Ev].wrapT;
                }
                setMinFilter(t) {
                    this[Tv]('minFilter', t);
                }
                setMagFilter(t) {
                    this[Tv]('magFilter', t);
                }
                setWrapS(t) {
                    this[Tv]('wrapS', t);
                }
                setWrapT(t) {
                    this[Tv]('wrapT', t);
                }
                [Tv](t, e) {
                    const n = this[Ev];
                    if (null != n) {
                        if (
                            ((t, e) => {
                                switch (t) {
                                    case 'minFilter':
                                        return wv(e);
                                    case 'magFilter':
                                        return _v(e);
                                    case 'wrapS':
                                    case 'wrapT':
                                        return Mv(e);
                                    default:
                                        throw new Error(`Cannot configure property "${t}" on Sampler`);
                                }
                            })(t, e)
                        ) {
                            n[t] = e;
                            for (const n of this[Sv]) (n[t] = e), (n.needsUpdate = !0);
                        }
                        this[dv]();
                    }
                }
            }
            const Lv = Symbol('image'),
                Rv = Symbol('sampler');
            class Cv extends pv {
                constructor(t, e, n = null, i = null, r = null) {
                    super(t, n || {}, new Set(e ? [e] : [])),
                        (this[Rv] = new Av(t, e, i)),
                        (this[Lv] = new yv(t, e, r));
                }
                get name() {
                    return this[uv].name || '';
                }
                get sampler() {
                    return this[Rv];
                }
                get source() {
                    return this[Lv];
                }
            }
            var Pv;
            const Iv = Symbol('texture'),
                Dv = Symbol('materials'),
                Nv = Symbol('usage');
            var Fv;
            !(function (t) {
                (t[(t.Base = 0)] = 'Base'),
                    (t[(t.MetallicRoughness = 1)] = 'MetallicRoughness'),
                    (t[(t.Normal = 2)] = 'Normal'),
                    (t[(t.Occlusion = 3)] = 'Occlusion'),
                    (t[(t.Emissive = 4)] = 'Emissive');
            })(Fv || (Fv = {}));
            class Ov {
                constructor(t, e, n, i, r, s) {
                    if (((this[Pv] = null), s)) {
                        const e = r.textures ? r.textures[s.index] : null,
                            i = e && r.samplers ? r.samplers[e.sampler] : null,
                            a = e && r.images ? r.images[e.source] : null;
                        this[Iv] = new Cv(t, n, e, i, a);
                    }
                    (this.onUpdate = t), (this[Dv] = i), (this[Nv] = e);
                }
                get texture() {
                    return this[Iv];
                }
                setTexture(t) {
                    const e = null != t ? t.source[vv] : null;
                    let n = 3001;
                    if (((this[Iv] = t), this[Dv]))
                        for (const t of this[Dv]) {
                            switch (this[Nv]) {
                                case Fv.Base:
                                    t.map = e;
                                    break;
                                case Fv.MetallicRoughness:
                                    (n = 3e3), (t.metalnessMap = e), (t.roughnessMap = e);
                                    break;
                                case Fv.Normal:
                                    (n = 3e3), (t.normalMap = e);
                                    break;
                                case Fv.Occlusion:
                                    (n = 3e3), (t.aoMap = e);
                                    break;
                                case Fv.Emissive:
                                    t.emissiveMap = e;
                            }
                            t.needsUpdate = !0;
                        }
                    e && (e.encoding = n), this.onUpdate();
                }
            }
            Pv = Iv;
            const Uv = Symbol('threeMaterials'),
                kv = Symbol('baseColorTexture'),
                zv = Symbol('metallicRoughnessTexture');
            class Bv extends pv {
                constructor(t, e, n, i) {
                    super(t, n, i),
                        null == n.baseColorFactor && (n.baseColorFactor = [1, 1, 1, 1]),
                        null == n.roughnessFactor && (n.roughnessFactor = 1),
                        null == n.metallicFactor && (n.metallicFactor = 1);
                    const { baseColorTexture: r, metallicRoughnessTexture: s } = n,
                        { map: a, metalnessMap: o } = i.values().next().value;
                    (this[kv] = new Ov(t, Fv.Base, a, i, e, r || null)),
                        (this[zv] = new Ov(t, Fv.MetallicRoughness, o, i, e, s || null));
                }
                get [Uv]() {
                    return this[hv];
                }
                get baseColorFactor() {
                    return this[uv].baseColorFactor;
                }
                get metallicFactor() {
                    return this[uv].metallicFactor;
                }
                get roughnessFactor() {
                    return this[uv].roughnessFactor;
                }
                get baseColorTexture() {
                    return this[kv];
                }
                get metallicRoughnessTexture() {
                    return this[zv];
                }
                setBaseColorFactor(t) {
                    for (const e of this[Uv]) e.color.fromArray(t), (e.opacity = t[3]);
                    (this[uv].baseColorFactor = t), this[dv]();
                }
                setMetallicFactor(t) {
                    for (const e of this[Uv]) e.metalness = t;
                    (this[uv].metallicFactor = t), this[dv]();
                }
                setRoughnessFactor(t) {
                    for (const e of this[Uv]) e.roughness = t;
                    (this[uv].roughnessFactor = t), this[dv]();
                }
            }
            const Hv = Symbol('pbrMetallicRoughness'),
                Gv = Symbol('normalTexture'),
                Vv = Symbol('occlusionTexture'),
                Wv = Symbol('emissiveTexture'),
                jv = Symbol('backingThreeMaterial'),
                qv = Symbol('applyAlphaCutoff'),
                Xv = Symbol('lazyLoadGLTFInfo'),
                Yv = Symbol('initialize'),
                Zv = Symbol('getLoadedMaterial'),
                Jv = Symbol('ensureMaterialIsLoaded');
            class $v extends pv {
                constructor(t, e, n, i, r) {
                    super(t, n, i), null == r ? this[Yv](e) : (this[Xv] = r);
                }
                get [jv]() {
                    return this[hv].values().next().value;
                }
                [Yv](t) {
                    const e = this[dv],
                        n = this[uv],
                        i = this[hv];
                    n.extensions &&
                        n.extensions.KHR_materials_pbrSpecularGlossiness &&
                        console.warn(
                            `Material ${n.name} uses a deprecated extension\n          "KHR_materials_pbrSpecularGlossiness", please use\n          "pbrMetallicRoughness" instead. Specular Glossiness materials are\n          currently supported for rendering, but not for our scene-graph API,\n          nor for auto-generation of USDZ for Quick Look.`,
                        ),
                        null == n.pbrMetallicRoughness && (n.pbrMetallicRoughness = {}),
                        (this[Hv] = new Bv(e, t, n.pbrMetallicRoughness, i)),
                        null == n.emissiveFactor && (n.emissiveFactor = [0, 0, 0]),
                        null == n.doubleSided && (n.doubleSided = !1),
                        null == n.alphaMode && (n.alphaMode = 'OPAQUE'),
                        null == n.alphaCutoff && (n.alphaCutoff = 0.5);
                    const { normalTexture: r, occlusionTexture: s, emissiveTexture: a } = n,
                        { normalMap: o, aoMap: l, emissiveMap: c } = i.values().next().value;
                    (this[Gv] = new Ov(e, Fv.Normal, o, i, t, r || null)),
                        (this[Vv] = new Ov(e, Fv.Occlusion, l, i, t, s || null)),
                        (this[Wv] = new Ov(e, Fv.Emissive, c, i, t, a || null));
                }
                async [Zv]() {
                    if (null != this[Xv]) {
                        const { set: t, material: e } = await this[Xv].doLazyLoad();
                        return (
                            (this[hv] = t),
                            this[Yv](this[Xv].gltf),
                            (this[Xv] = void 0),
                            (this.ensureLoaded = async () => {}),
                            e
                        );
                    }
                    return this[hv].values().next().value;
                }
                [Jv]() {
                    if (null != this[Xv])
                        throw new Error(
                            `Material "${this.name}" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`,
                        );
                }
                async ensureLoaded() {
                    await this[Zv]();
                }
                get isLoaded() {
                    return null == this[Xv];
                }
                get name() {
                    return this[uv].name || '';
                }
                get pbrMetallicRoughness() {
                    return this[Jv](), this[Hv];
                }
                get normalTexture() {
                    return this[Jv](), this[Gv];
                }
                get occlusionTexture() {
                    return this[Jv](), this[Vv];
                }
                get emissiveTexture() {
                    return this[Jv](), this[Wv];
                }
                get emissiveFactor() {
                    return this[Jv](), this[uv].emissiveFactor;
                }
                setEmissiveFactor(t) {
                    this[Jv]();
                    for (const e of this[hv]) e.emissive.fromArray(t);
                    (this[uv].emissiveFactor = t), this[dv]();
                }
                [qv]() {
                    this[Jv]();
                    const t = this[uv];
                    for (const e of this[hv]) (e.alphaTest = t.alphaCutoff), (e.needsUpdate = !0);
                }
                setAlphaCutoff(t) {
                    this[Jv](), (this[uv].alphaCutoff = t), this[qv](), this[dv]();
                }
                getAlphaCutoff() {
                    return this[Jv](), this[uv].alphaCutoff;
                }
                setDoubleSided(t) {
                    this[Jv]();
                    for (const e of this[hv]) (e.side = t ? 2 : 0), (e.needsUpdate = !0);
                    (this[uv].doubleSided = t), this[dv]();
                }
                getDoubleSided() {
                    return this[Jv](), this[uv].doubleSided;
                }
                setAlphaMode(t) {
                    this[Jv]();
                    const e = (t, e) => {
                        (t.transparent = e), (t.depthWrite = !e);
                    };
                    this[uv].alphaMode = t;
                    for (const n of this[hv]) e(n, 'OPAQUE' !== t), this[qv](), (n.needsUpdate = !0);
                    this[dv]();
                }
                getAlphaMode() {
                    return this[Jv](), this[uv].alphaMode;
                }
            }
            var Kv, Qv;
            const ty = Symbol('materials'),
                ey = Symbol('variantInfo'),
                ny = Symbol('mesh'),
                iy = Symbol('children'),
                ry = Symbol('initialMaterialIdx'),
                sy = Symbol('activeMaterialIdx');
            class ay {
                constructor(t) {
                    (this.name = ''), (this[Kv] = new Array()), (this.name = t);
                }
            }
            Kv = iy;
            class oy extends ay {
                constructor(t, e, n) {
                    super(t.name), (this[Qv] = new Map()), (this[ny] = t);
                    const { gltf: i, threeGLTF: r, threeObjectMap: s } = n,
                        a = s.get(t.material);
                    null != a.materials
                        ? (this[ry] = this[sy] = a.materials)
                        : console.error(`Primitive (${t.name}) missing initial material reference.`);
                    const o = s.get(t).meshes,
                        l = (i.meshes || [])[o].primitives || [];
                    for (const t of l) {
                        if (null != t.material) this[ty].set(t.material, e[t.material]);
                        else {
                            const t = e.findIndex((t) => 'Default' === t.name);
                            t >= 0 ? this[ty].set(t, e[t]) : console.warn('Primitive has no material!');
                        }
                        if (t.extensions && t.extensions.KHR_materials_variants) {
                            const n = t.extensions.KHR_materials_variants,
                                i = r.parser.json.extensions.KHR_materials_variants.variants;
                            this[ey] = new Map();
                            for (const t of n.mappings) {
                                this[ty].set(t.material, e[t.material]);
                                for (const n of t.variants) {
                                    const { name: r } = i[n];
                                    this[ey].set(r, { material: e[t.material], index: t.material });
                                }
                            }
                        }
                    }
                }
                get mesh() {
                    return this[ny];
                }
                async setActiveMaterial(t) {
                    const e = this[ty].get(t);
                    return null != e && ((this.mesh.material = await e[Zv]()), (this[sy] = t)), this.mesh.material;
                }
                getActiveMaterial() {
                    return this[ty].get(this[sy]);
                }
                async enableVariant(t) {
                    if (null == t) return this.setActiveMaterial(this[ry]);
                    if (null != this[ey]) {
                        const e = this[ey].get(t);
                        if (null != e) return this.setActiveMaterial(e.index);
                    }
                    return null;
                }
                async instantiateVariants() {
                    if (null != this[ey])
                        for (const t of this[ey].keys()) {
                            if (null != this.mesh.userData.variantMaterials.get(t).material) continue;
                            const e = await this.enableVariant(t);
                            null != e && (this.mesh.userData.variantMaterials.get(t).material = e);
                        }
                }
                get variantInfo() {
                    return this[ey];
                }
            }
            var ly, cy, hy, uy;
            Qv = ty;
            const dy = Symbol('materials'),
                py = Symbol('hierarchy'),
                my = Symbol('roots'),
                fy = Symbol('primitives'),
                gy = Symbol('prepareVariantsForExport'),
                vy = Symbol('switchVariant'),
                yy = Symbol('threeScene'),
                xy = Symbol('materialsFromPoint'),
                by = Symbol('materialFromPoint');
            class wy {
                constructor(t, e, n, i) {
                    (this.gltf = t), (this.gltfElementMap = e), (this.mapKey = n), (this.doLazyLoad = i);
                }
            }
            class _y {
                constructor(t, e = () => {}) {
                    (this[ly] = new Array()),
                        (this[cy] = new Array()),
                        (this[hy] = new Array()),
                        (this[uy] = new Array());
                    const { gltf: n, threeGLTF: i, gltfElementMap: r } = t;
                    this[yy] = i.scene;
                    for (const [t, s] of n.materials.entries()) {
                        const a = r.get(s);
                        if (null != a) this[dy].push(new $v(e, n, s, a));
                        else {
                            const s = (n.materials || [])[t],
                                o = t,
                                l = async () => {
                                    const t = await i.parser.getDependency('material', o),
                                        e = new Set();
                                    return r.set(s, e), e.add(t), { set: e, material: t };
                                };
                            this[dy].push(new $v(e, n, s, a, new wy(n, r, s, l)));
                        }
                    }
                    const s = new Map(),
                        a = new Array();
                    for (const t of i.scene.children) a.push(t);
                    for (; a.length > 0; ) {
                        const e = a.pop();
                        let n = null;
                        e instanceof Wn ? ((n = new oy(e, this.materials, t)), this[fy].push(n)) : (n = new ay(e.name));
                        const i = s.get(e);
                        null != i ? i[iy].push(n) : this[my].push(n), this[py].push(n);
                        for (const t of e.children) a.push(t), s.set(e, n);
                    }
                }
                get materials() {
                    return this[dy];
                }
                getMaterialByName(t) {
                    const e = this[dy].filter((e) => e.name === t);
                    return e.length > 0 ? e[0] : null;
                }
                [((ly = dy), (cy = py), (hy = my), (uy = fy), xy)](t) {
                    return t.intersectObject(this[yy], !0).map((t) => {
                        const e = this[py].find((e) => e instanceof oy && e.mesh === t.object);
                        return null != e ? e.getActiveMaterial() : null;
                    });
                }
                [by](t) {
                    const e = this[xy](t);
                    return e.length > 0 ? e[0] : null;
                }
                async [vy](t) {
                    const e = new Array();
                    for (const n of this[fy]) e.push(n.enableVariant(t));
                    await Promise.all(e);
                }
                async [gy]() {
                    const t = new Array();
                    for (const e of this[fy]) t.push(e.instantiateVariants());
                    await Promise.all(t);
                }
            }
            var My = function (t, e, n, i) {
                for (
                    var r,
                        s = arguments.length,
                        a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                        o = t.length - 1;
                    o >= 0;
                    o--
                )
                    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                return s > 3 && a && Object.defineProperty(e, n, a), a;
            };
            const Sy = Symbol('currentGLTF'),
                Ty = Symbol('model'),
                Ey = Symbol('variants'),
                Ay = Symbol('getOnUpdateMethod'),
                Ly = Symbol('textureLoader'),
                Ry = Symbol('originalGltfJson');
            var Cy = function (t, e, n, i) {
                for (
                    var r,
                        s = arguments.length,
                        a = s < 3 ? e : null === i ? (i = Object.getOwnPropertyDescriptor(e, n)) : i,
                        o = t.length - 1;
                    o >= 0;
                    o--
                )
                    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
                return s > 3 && a && Object.defineProperty(e, n, a), a;
            };
            const Py = Math.PI / 32,
                Iy = { basis: [Jh(Bh(Py, 'rad'))], keywords: { auto: [null] } },
                Dy = Symbol('autoRotateStartTime'),
                Ny = Symbol('radiansPerSecond'),
                Fy = Symbol('syncRotationRate'),
                Oy = Symbol('onCameraChange'),
                Uy = ((t) => {
                    var e, n, i;
                    class r extends t {
                        constructor() {
                            super(...arguments),
                                (this[e] = new Map()),
                                (this[n] = (t) => {
                                    t.forEach((t) => {
                                        (t instanceof MutationRecord && 'childList' !== t.type) ||
                                            (t.addedNodes.forEach((t) => {
                                                this[mp](t);
                                            }),
                                            t.removedNodes.forEach((t) => {
                                                this[fp](t);
                                            }),
                                            this[Zd]());
                                    });
                                }),
                                (this[i] = new MutationObserver(this[dp]));
                        }
                        connectedCallback() {
                            super.connectedCallback();
                            for (let t = 0; t < this.children.length; ++t) this[mp](this.children[t]);
                            const { ShadyDOM: t } = self;
                            null == t
                                ? this[pp].observe(this, { childList: !0 })
                                : (this[pp] = t.observeChildren(this, this[dp]));
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback();
                            const { ShadyDOM: t } = self;
                            null == t ? this[pp].disconnect() : t.unobserveChildren(this[pp]);
                        }
                        [((e = up), (n = dp), (i = pp), Jd)](t, e) {
                            super[Jd](t, e);
                            const n = this[Yd],
                                { annotationRenderer: i } = n,
                                r = n.getCamera();
                            n.shouldRender() &&
                                (n.updateHotspots(r.position), (i.domElement.style.display = ''), i.render(n, r));
                        }
                        updateHotspot(t) {
                            const e = this[up].get(t.name);
                            null != e && (e.updatePosition(t.position), e.updateNormal(t.normal), this[Zd]());
                        }
                        positionAndNormalFromPoint(t, e) {
                            const n = this[Yd],
                                i = n.getNDC(t, e),
                                r = n.positionAndNormalFromPoint(i);
                            if (null == r) return null;
                            gp.copy(n.target.matrixWorld).invert();
                            const s = ap(r.position.applyMatrix4(gp));
                            return vp.getNormalMatrix(gp), { position: s, normal: ap(r.normal.applyNormalMatrix(vp)) };
                        }
                        [mp](t) {
                            if (!(t instanceof HTMLElement && 0 === t.slot.indexOf('hotspot'))) return;
                            let e = this[up].get(t.slot);
                            null != e
                                ? e.increment()
                                : ((e = new Qh({
                                      name: t.slot,
                                      position: t.dataset.position,
                                      normal: t.dataset.normal,
                                  })),
                                  this[up].set(t.slot, e),
                                  this[Yd].addHotspot(e)),
                                this[Yd].queueRender();
                        }
                        [fp](t) {
                            if (!(t instanceof HTMLElement)) return;
                            const e = this[up].get(t.slot);
                            e &&
                                (e.decrement() && (this[Yd].removeHotspot(e), this[up].delete(t.slot)),
                                this[Yd].queueRender());
                        }
                    }
                    return r;
                })(
                    ((t) => {
                        var e, n, i, r, s;
                        class a extends t {
                            constructor() {
                                super(...arguments),
                                    (this[e] = void 0),
                                    (this[n] = null),
                                    (this[i] = []),
                                    (this[r] = new yl()),
                                    (this[s] = null),
                                    (this.variantName = null),
                                    (this.orientation = '0 0 0'),
                                    (this.scale = '1 1 1');
                            }
                            get model() {
                                return this[Ty];
                            }
                            get availableVariants() {
                                return this[Ey];
                            }
                            get originalGltfJson() {
                                return this[Ry];
                            }
                            [((e = Ty), (n = Sy), (i = Ey), (r = Ly), (s = Ry), Ay)]() {
                                return () => {
                                    this[Zd]();
                                };
                            }
                            async createTexture(t, e = 'image/png') {
                                const n = this[Sy],
                                    i = await new Promise((e) => this[Ly].load(t, e));
                                return n && i
                                    ? ((i.encoding = 3001),
                                      (i.wrapS = 1e3),
                                      (i.wrapT = 1e3),
                                      (i.flipY = !1),
                                      'image/jpeg' === e && (i.format = 1022),
                                      new Cv(this[Ay](), i))
                                    : null;
                            }
                            async updated(t) {
                                if ((super.updated(t), t.has('variantName'))) {
                                    const t = this[Sy],
                                        { variantName: e } = this;
                                    null != t &&
                                        (await this[Ty][vy](e),
                                        this[Zd](),
                                        this.dispatchEvent(new CustomEvent('variant-applied')));
                                }
                                if (t.has('orientation') || t.has('scale')) {
                                    const { modelContainer: t } = this[Yd],
                                        e = Hh(this.orientation)[0].terms,
                                        n = Kh(e[0]).number,
                                        i = Kh(e[1]).number,
                                        r = Kh(e[2]).number;
                                    t.quaternion.setFromEuler(new Re(i, r, n, 'YXZ'));
                                    const s = Hh(this.scale)[0].terms;
                                    t.scale.set(s[0].number, s[1].number, s[2].number),
                                        this[Yd].updateBoundingBox(),
                                        this[Yd].updateShadow(),
                                        this[Qd].arRenderer.onUpdateScene(),
                                        this[Zd]();
                                }
                            }
                            [$d]() {
                                super[$d](), (this[Ey] = []);
                                const { currentGLTF: t } = this[Yd];
                                if (null != t) {
                                    const { correlatedSceneGraph: e } = t;
                                    null != e &&
                                        t !== this[Sy] &&
                                        ((this[Ty] = new _y(e, this[Ay]())),
                                        (this[Ry] = JSON.parse(JSON.stringify(e.gltf)))),
                                        'variants' in t.userData &&
                                            ((this[Ey] = t.userData.variants.slice()),
                                            this.requestUpdate('variantName'));
                                }
                                (this[Sy] = t), this.dispatchEvent(new CustomEvent('scene-graph-ready'));
                            }
                            async exportScene(t) {
                                const e = this[Yd];
                                return new Promise(async (n) => {
                                    const i = {
                                        binary: !0,
                                        onlyVisible: !0,
                                        maxTextureSize: 1 / 0,
                                        forcePowerOfTwoTextures: !1,
                                        includeCustomExtensions: !1,
                                        embedImages: !0,
                                    };
                                    Object.assign(i, t), (i.animations = e.animations), (i.truncateDrawRange = !0);
                                    const r = e.shadow;
                                    let s = !1;
                                    null != r && ((s = r.visible), (r.visible = !1)),
                                        await this[Ty][gy](),
                                        new qg()
                                            .register((t) => new cv(t))
                                            .parse(
                                                e.modelContainer.children[0],
                                                (t) =>
                                                    n(
                                                        new Blob([i.binary ? t : JSON.stringify(t)], {
                                                            type: i.binary
                                                                ? 'application/octet-stream'
                                                                : 'application/json',
                                                        }),
                                                    ),
                                                i,
                                            ),
                                        null != r && (r.visible = s);
                                });
                            }
                            materialFromPoint(t, e) {
                                const n = this[Yd],
                                    i = n.getNDC(t, e);
                                return n.raycaster.setFromCamera(i, n.getCamera()), this[Ty][by](n.raycaster);
                            }
                        }
                        return (
                            My([$({ type: String, attribute: 'variant-name' })], a.prototype, 'variantName', void 0),
                            My([$({ type: String, attribute: 'orientation' })], a.prototype, 'orientation', void 0),
                            My([$({ type: String, attribute: 'scale' })], a.prototype, 'scale', void 0),
                            a
                        );
                    })(
                        ((t) => {
                            var e, n, i;
                            class r extends t {
                                constructor() {
                                    super(...arguments),
                                        (this.autoRotate = !1),
                                        (this.autoRotateDelay = 3e3),
                                        (this.rotationPerSecond = 'auto'),
                                        (this[e] = performance.now()),
                                        (this[n] = 0),
                                        (this[i] = (t) => {
                                            this.autoRotate &&
                                                'user-interaction' === t.detail.source &&
                                                (this[Dy] = performance.now());
                                        });
                                }
                                connectedCallback() {
                                    super.connectedCallback(),
                                        this.addEventListener('camera-change', this[Oy]),
                                        (this[Dy] = performance.now());
                                }
                                disconnectedCallback() {
                                    super.disconnectedCallback(),
                                        this.removeEventListener('camera-change', this[Oy]),
                                        (this[Dy] = performance.now());
                                }
                                updated(t) {
                                    super.updated(t), t.has('autoRotate') && (this[Dy] = performance.now());
                                }
                                [((e = Dy), (n = Ny), Fy)](t) {
                                    this[Ny] = t[0];
                                }
                                [Jd](t, e) {
                                    if ((super[Jd](t, e), !this.autoRotate || !this[sp]() || this[Qd].isPresenting))
                                        return;
                                    const n = Math.min(e, t - this[Dy] - this.autoRotateDelay);
                                    n > 0 && (this[Yd].yaw = this.turntableRotation + this[Ny] * n * 0.001);
                                }
                                get turntableRotation() {
                                    return this[Yd].yaw;
                                }
                                resetTurntableRotation(t = 0) {
                                    this[Yd].yaw = t;
                                }
                            }
                            return (
                                (i = Oy),
                                Cy([$({ type: Boolean, attribute: 'auto-rotate' })], r.prototype, 'autoRotate', void 0),
                                Cy(
                                    [$({ type: Number, attribute: 'auto-rotate-delay' })],
                                    r.prototype,
                                    'autoRotateDelay',
                                    void 0,
                                ),
                                Cy(
                                    [
                                        _f({ intrinsics: Iy, updateHandler: Fy }),
                                        $({ type: String, attribute: 'rotation-per-second' }),
                                    ],
                                    r.prototype,
                                    'rotationPerSecond',
                                    void 0,
                                ),
                                r
                            );
                        })(
                            ((t) => {
                                var e, n, i;
                                class r extends t {
                                    constructor() {
                                        super(...arguments),
                                            (this.environmentImage = null),
                                            (this.skyboxImage = null),
                                            (this.shadowIntensity = 0),
                                            (this.shadowSoftness = 1),
                                            (this.exposure = 1),
                                            (this[e] = null),
                                            (this[n] = null),
                                            (this[i] = (t) => {
                                                t.element === this && this[wu]();
                                            });
                                    }
                                    connectedCallback() {
                                        super.connectedCallback(),
                                            this[Qd].loader.addEventListener('preload', this[Mu]);
                                    }
                                    disconnectedCallback() {
                                        super.disconnectedCallback(),
                                            this[Qd].loader.removeEventListener('preload', this[Mu]);
                                    }
                                    updated(t) {
                                        super.updated(t),
                                            t.has('shadowIntensity') &&
                                                (this[Yd].setShadowIntensity(0.1 * this.shadowIntensity), this[Zd]()),
                                            t.has('shadowSoftness') &&
                                                (this[Yd].setShadowSoftness(this.shadowSoftness), this[Zd]()),
                                            t.has('exposure') && ((this[Yd].exposure = this.exposure), this[Zd]()),
                                            (t.has('environmentImage') || t.has('skyboxImage')) &&
                                                this[ip]() &&
                                                this[wu]();
                                    }
                                    [((e = xu), (n = _u), (i = Mu), $d)]() {
                                        super[$d](), null != this[xu] && this[bu](this[xu]);
                                    }
                                    async [wu]() {
                                        const { skyboxImage: t, environmentImage: e } = this;
                                        null != this[_u] && (this[_u](), (this[_u] = null));
                                        const { textureUtils: n } = this[Qd];
                                        if (null != n)
                                            try {
                                                const { environmentMap: i, skybox: r } = await new Promise(
                                                    async (i, r) => {
                                                        const s = n.generateEnvironmentMapAndSkybox(Ph(t), e, {
                                                            progressTracker: this[tp],
                                                        });
                                                        (this[_u] = () => r(s)), i(await s);
                                                    },
                                                );
                                                (this[Yd].background = null != r ? (r.name === i.name ? i : r) : null),
                                                    this[bu](i),
                                                    this[Yd].dispatchEvent({ type: 'envmap-update' });
                                            } catch (t) {
                                                if (t instanceof Error) throw (this[bu](null), t);
                                            }
                                    }
                                    [bu](t) {
                                        this[Yd].environment !== t &&
                                            ((this[xu] = t),
                                            (this[Yd].environment = this[xu]),
                                            this.dispatchEvent(new CustomEvent('environment-change')),
                                            this[Zd]());
                                    }
                                }
                                return (
                                    yu(
                                        [$({ type: String, attribute: 'environment-image' })],
                                        r.prototype,
                                        'environmentImage',
                                        void 0,
                                    ),
                                    yu(
                                        [$({ type: String, attribute: 'skybox-image' })],
                                        r.prototype,
                                        'skyboxImage',
                                        void 0,
                                    ),
                                    yu(
                                        [$({ type: Number, attribute: 'shadow-intensity' })],
                                        r.prototype,
                                        'shadowIntensity',
                                        void 0,
                                    ),
                                    yu(
                                        [$({ type: Number, attribute: 'shadow-softness' })],
                                        r.prototype,
                                        'shadowSoftness',
                                        void 0,
                                    ),
                                    yu([$({ type: Number })], r.prototype, 'exposure', void 0),
                                    r
                                );
                            })(
                                ((t) => {
                                    var e, n, i, r, s, a, o, l, c, h, u, d, p, m, f, g, v;
                                    class y extends t {
                                        constructor() {
                                            super(...arguments),
                                                (this.cameraControls = !1),
                                                (this.cameraOrbit = '0deg 75deg 105%'),
                                                (this.cameraTarget = 'auto auto auto'),
                                                (this.fieldOfView = 'auto'),
                                                (this.minCameraOrbit = 'auto'),
                                                (this.maxCameraOrbit = 'auto'),
                                                (this.minFieldOfView = 'auto'),
                                                (this.maxFieldOfView = 'auto'),
                                                (this.interactionPromptThreshold = 3e3),
                                                (this.interactionPromptStyle = kf),
                                                (this.interactionPrompt = Of),
                                                (this.interactionPolicy = 'always-allow'),
                                                (this.orbitSensitivity = 1),
                                                (this.touchAction = 'pan-y'),
                                                (this.disableZoom = !1),
                                                (this.interpolationDecay = 50),
                                                (this.bounds = 'legacy'),
                                                (this[e] = this.shadowRoot.querySelector('.interaction-prompt')),
                                                (this[n] = this.shadowRoot.querySelector(
                                                    '.interaction-prompt > .animated-container',
                                                )),
                                                (this[i] = 1 / 0),
                                                (this[r] = 0),
                                                (this[s] = 1 / 0),
                                                (this[a] = !1),
                                                (this[o] = !1),
                                                (this[l] = new Ef(this[Yd].camera, this[qd])),
                                                (this[c] = 0),
                                                (this[h] = new Ql()),
                                                (this[u] = !1),
                                                (this[d] = !1),
                                                (this[p] = !1),
                                                (this[m] = () => {
                                                    const t = this[qd];
                                                    isFinite(this[hg]) || (this[hg] = performance.now());
                                                    const e = this[Hd];
                                                    t.getAttribute('aria-label') !== e &&
                                                        t.setAttribute('aria-label', e),
                                                        this.interactionPrompt !== Uf || this[og] || (this[ag] = !0);
                                                }),
                                                (this[f] = () => {
                                                    this.interactionPrompt === Uf &&
                                                        ((this[ag] = !1),
                                                        this[$f].classList.remove('visible'),
                                                        (this[lg] = 1 / 0),
                                                        (this[hg] = 1 / 0));
                                                }),
                                                (this[g] = ({ source: t }) => {
                                                    this[tg](),
                                                        this[Zd](),
                                                        t === Tf && ((this[og] = !0), this[Qf]()),
                                                        this.dispatchEvent(
                                                            new CustomEvent('camera-change', { detail: { source: t } }),
                                                        );
                                                }),
                                                (this[v] = (t) => {
                                                    'pointer-change-start' === t.type
                                                        ? this[jd].classList.add('pointer-tumbling')
                                                        : this[jd].classList.remove('pointer-tumbling');
                                                });
                                        }
                                        getCameraOrbit() {
                                            const { theta: t, phi: e, radius: n } = this[dg];
                                            return {
                                                theta: t,
                                                phi: e,
                                                radius: n,
                                                toString() {
                                                    return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
                                                },
                                            };
                                        }
                                        getCameraTarget() {
                                            return ap(
                                                this[Qd].isPresenting
                                                    ? this[Qd].arRenderer.target
                                                    : this[Yd].getTarget(),
                                            );
                                        }
                                        getFieldOfView() {
                                            return this[Jf].getFieldOfView();
                                        }
                                        getMinimumFieldOfView() {
                                            return this[Jf].options.minimumFieldOfView;
                                        }
                                        getMaximumFieldOfView() {
                                            return this[Jf].options.maximumFieldOfView;
                                        }
                                        jumpCameraToGoal() {
                                            (this[pg] = !0), this.requestUpdate(pg, !1);
                                        }
                                        resetInteractionPrompt() {
                                            (this[cg] = 0),
                                                (this[lg] = 1 / 0),
                                                (this[og] = !1),
                                                (this[ag] = this.interactionPrompt === Of && this.cameraControls);
                                        }
                                        connectedCallback() {
                                            super.connectedCallback(),
                                                this[Jf].addEventListener('change', this[rg]),
                                                this[Jf].addEventListener('pointer-change-start', this[sg]),
                                                this[Jf].addEventListener('pointer-change-end', this[sg]);
                                        }
                                        disconnectedCallback() {
                                            super.disconnectedCallback(),
                                                this[Jf].removeEventListener('change', this[rg]),
                                                this[Jf].removeEventListener('pointer-change-start', this[sg]),
                                                this[Jf].removeEventListener('pointer-change-end', this[sg]);
                                        }
                                        updated(t) {
                                            super.updated(t);
                                            const e = this[Jf],
                                                n = this[qd];
                                            if (
                                                (t.has('cameraControls') &&
                                                    (this.cameraControls
                                                        ? (e.enableInteraction(),
                                                          this.interactionPrompt === Of && (this[ag] = !0),
                                                          n.addEventListener('focus', this[ig]),
                                                          n.addEventListener('blur', this[ng]))
                                                        : (n.removeEventListener('focus', this[ig]),
                                                          n.removeEventListener('blur', this[ng]),
                                                          e.disableInteraction(),
                                                          this[Qf]())),
                                                t.has('disableZoom') && (e.disableZoom = this.disableZoom),
                                                t.has('bounds') && (this[Yd].tightBounds = 'tight' === this.bounds),
                                                (t.has('interactionPrompt') ||
                                                    t.has('cameraControls') ||
                                                    t.has('src')) &&
                                                    (this.interactionPrompt === Of && this.cameraControls && !this[og]
                                                        ? (this[ag] = !0)
                                                        : this[Qf]()),
                                                t.has('interactionPromptStyle') &&
                                                    this[$f].classList.toggle(
                                                        'wiggle',
                                                        this.interactionPromptStyle === kf,
                                                    ),
                                                t.has('interactionPolicy'))
                                            ) {
                                                const t = this.interactionPolicy;
                                                e.applyOptions({ interactionPolicy: t });
                                            }
                                            if (t.has('touchAction')) {
                                                const t = this.touchAction;
                                                e.applyOptions({ touchAction: t }), e.updateTouchActionStyle();
                                            }
                                            t.has('orbitSensitivity') && (e.sensitivity = this.orbitSensitivity),
                                                t.has('interpolationDecay') &&
                                                    (e.setDamperDecayTime(this.interpolationDecay),
                                                    this[Yd].setTargetDamperDecayTime(this.interpolationDecay)),
                                                !0 === this[pg] &&
                                                    Promise.resolve().then(() => {
                                                        e.jumpToGoal(), this[Yd].jumpToGoal(), (this[pg] = !1);
                                                    });
                                        }
                                        async updateFraming() {
                                            const t = this[Yd],
                                                e = t.framedFieldOfView;
                                            await this.requestUpdate('cameraTarget'),
                                                t.updateFraming('tight' === this.bounds ? t.getTarget() : void 0),
                                                t.frameModel();
                                            const n = t.framedFieldOfView,
                                                i = this[Jf].getFieldOfView() / e;
                                            (this[ug] = n * i),
                                                (this[fg] = !0),
                                                this.requestUpdate('maxFieldOfView'),
                                                this.requestUpdate('fieldOfView'),
                                                this.requestUpdate('minCameraOrbit'),
                                                this.requestUpdate('maxCameraOrbit'),
                                                await this.requestUpdate('cameraOrbit');
                                        }
                                        [((e = $f),
                                        (n = Kf),
                                        (i = hg),
                                        (r = cg),
                                        (s = lg),
                                        (a = og),
                                        (o = ag),
                                        (l = Jf),
                                        (c = ug),
                                        (h = dg),
                                        (u = pg),
                                        (d = mg),
                                        (p = fg),
                                        vg)](t) {
                                            this[Jf].setFieldOfView((180 * t[0]) / Math.PI);
                                        }
                                        [gg](t) {
                                            if (this[fg]) {
                                                const { theta: e, phi: n } = this.getCameraOrbit();
                                                (t[0] = e), (t[1] = n), (this[fg] = !1);
                                            }
                                            this[Jf].setOrbit(t[0], t[1], t[2]);
                                        }
                                        [xg](t) {
                                            this[Jf].applyOptions({
                                                minimumAzimuthalAngle: t[0],
                                                minimumPolarAngle: t[1],
                                                minimumRadius: t[2],
                                            }),
                                                this.jumpCameraToGoal();
                                        }
                                        [bg](t) {
                                            this[Jf].applyOptions({
                                                maximumAzimuthalAngle: t[0],
                                                maximumPolarAngle: t[1],
                                                maximumRadius: t[2],
                                            }),
                                                this[eg](t[2]),
                                                this.jumpCameraToGoal();
                                        }
                                        [wg](t) {
                                            this[Jf].applyOptions({ minimumFieldOfView: (180 * t[0]) / Math.PI }),
                                                this.jumpCameraToGoal();
                                        }
                                        [_g](t) {
                                            this[Jf].applyOptions({ maximumFieldOfView: (180 * t[0]) / Math.PI }),
                                                this.jumpCameraToGoal();
                                        }
                                        [yg](t) {
                                            const [e, n, i] = t;
                                            this[Yd].setTarget(e, n, i), this[Qd].arRenderer.updateTarget();
                                        }
                                        [Jd](t, e) {
                                            if ((super[Jd](t, e), this[Qd].isPresenting || !this[sp]())) return;
                                            const n = performance.now();
                                            if (this[ag]) {
                                                const t = this.interactionPrompt === Of ? this[Gd] : this[hg];
                                                this.loaded &&
                                                    n > t + this.interactionPromptThreshold &&
                                                    (this[qd].setAttribute(
                                                        'aria-label',
                                                        'Use mouse, touch or arrow keys to control the camera!',
                                                    ),
                                                    (this[ag] = !1),
                                                    (this[lg] = n),
                                                    this[$f].classList.add('visible'));
                                            }
                                            if (isFinite(this[lg]) && this.interactionPromptStyle === kf) {
                                                const t = this[Yd],
                                                    e = ((n - this[lg]) / 5e3) % 1,
                                                    i = Pf(e),
                                                    r = If(e);
                                                if (((this[Kf].style.opacity = `${r}`), i !== this[cg])) {
                                                    const e = i * t.width * 0.05,
                                                        n = ((i - this[cg]) * Math.PI) / 16;
                                                    (this[Kf].style.transform = `translateX(${e}px)`),
                                                        this[Jf].adjustOrbit(n, 0, 0),
                                                        (this[cg] = i);
                                                }
                                            }
                                            this[Jf].update(t, e), this[Yd].updateTarget(e);
                                        }
                                        [Qf]() {
                                            (this[ag] = !1), this[$f].classList.remove('visible'), (this[lg] = 1 / 0);
                                        }
                                        [eg](t) {
                                            const { idealCameraDistance: e } = this[Yd],
                                                n = 2 * Math.max(e, t);
                                            this[Jf].updateNearFar(0, n);
                                        }
                                        [tg]() {
                                            const { theta: t, phi: e } = this[dg],
                                                { theta: n, phi: i } = this[Jf].getCameraSpherical(this[dg]),
                                                r = this.getRootNode();
                                            if (null != r && r.activeElement === this) {
                                                const r = (4 + Math.floor(((t % Zf) + Yf) / qf)) % 4,
                                                    s = (4 + Math.floor(((n % Zf) + Yf) / qf)) % 4,
                                                    a = Math.floor(e / Xf),
                                                    o = Math.floor(i / Xf);
                                                if (s !== r || o !== a) {
                                                    const t = `View from stage ${Ff[o]}${Nf[s]}`;
                                                    this[qd].setAttribute('aria-label', t);
                                                }
                                            }
                                        }
                                        [Kd](t) {
                                            const e = this[Jf],
                                                n = this[Yd].framedFieldOfView;
                                            super[Kd](t);
                                            const i = this[Yd].framedFieldOfView,
                                                r = e.getFieldOfView() / n;
                                            (this[ug] = i * r),
                                                e.updateAspect(this[Yd].aspect),
                                                this.requestUpdate('maxFieldOfView', this.maxFieldOfView),
                                                this.requestUpdate('fieldOfView', this.fieldOfView),
                                                this.jumpCameraToGoal();
                                        }
                                        [$d]() {
                                            super[$d]();
                                            const { framedFieldOfView: t } = this[Yd];
                                            (this[ug] = t),
                                                this[mg] ? (this[fg] = !0) : (this[mg] = !0),
                                                this.requestUpdate('maxFieldOfView', this.maxFieldOfView),
                                                this.requestUpdate('fieldOfView', this.fieldOfView),
                                                this.requestUpdate('minCameraOrbit', this.minCameraOrbit),
                                                this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit),
                                                this.requestUpdate('cameraOrbit', this.cameraOrbit),
                                                this.requestUpdate('cameraTarget', this.cameraTarget),
                                                this.jumpCameraToGoal();
                                        }
                                    }
                                    return (
                                        (m = ig),
                                        (f = ng),
                                        (g = rg),
                                        (v = sg),
                                        Cf(
                                            [$({ type: Boolean, attribute: 'camera-controls' })],
                                            y.prototype,
                                            'cameraControls',
                                            void 0,
                                        ),
                                        Cf(
                                            [
                                                _f({ intrinsics: Gf, observeEffects: !0, updateHandler: gg }),
                                                $({ type: String, attribute: 'camera-orbit', hasChanged: () => !0 }),
                                            ],
                                            y.prototype,
                                            'cameraOrbit',
                                            void 0,
                                        ),
                                        Cf(
                                            [
                                                _f({ intrinsics: jf, observeEffects: !0, updateHandler: yg }),
                                                $({ type: String, attribute: 'camera-target', hasChanged: () => !0 }),
                                            ],
                                            y.prototype,
                                            'cameraTarget',
                                            void 0,
                                        ),
                                        Cf(
                                            [
                                                _f({ intrinsics: zf, observeEffects: !0, updateHandler: vg }),
                                                $({ type: String, attribute: 'field-of-view', hasChanged: () => !0 }),
                                            ],
                                            y.prototype,
                                            'fieldOfView',
                                            void 0,
                                        ),
                                        Cf(
                                            [
                                                _f({ intrinsics: Vf, updateHandler: xg }),
                                                $({
                                                    type: String,
                                                    attribute: 'min-camera-orbit',
                                                    hasChanged: () => !0,
                                                }),
                                            ],
                                            y.prototype,
                                            'minCameraOrbit',
                                            void 0,
                                        ),
                                        Cf(
                                            [
                                                _f({ intrinsics: Wf, updateHandler: bg }),
                                                $({
                                                    type: String,
                                                    attribute: 'max-camera-orbit',
                                                    hasChanged: () => !0,
                                                }),
                                            ],
                                            y.prototype,
                                            'maxCameraOrbit',
                                            void 0,
                                        ),
                                        Cf(
                                            [
                                                _f({ intrinsics: Bf, updateHandler: wg }),
                                                $({
                                                    type: String,
                                                    attribute: 'min-field-of-view',
                                                    hasChanged: () => !0,
                                                }),
                                            ],
                                            y.prototype,
                                            'minFieldOfView',
                                            void 0,
                                        ),
                                        Cf(
                                            [
                                                _f({ intrinsics: Hf, updateHandler: _g }),
                                                $({
                                                    type: String,
                                                    attribute: 'max-field-of-view',
                                                    hasChanged: () => !0,
                                                }),
                                            ],
                                            y.prototype,
                                            'maxFieldOfView',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: Number, attribute: 'interaction-prompt-threshold' })],
                                            y.prototype,
                                            'interactionPromptThreshold',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: String, attribute: 'interaction-prompt-style' })],
                                            y.prototype,
                                            'interactionPromptStyle',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: String, attribute: 'interaction-prompt' })],
                                            y.prototype,
                                            'interactionPrompt',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: String, attribute: 'interaction-policy' })],
                                            y.prototype,
                                            'interactionPolicy',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: Number, attribute: 'orbit-sensitivity' })],
                                            y.prototype,
                                            'orbitSensitivity',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: String, attribute: 'touch-action' })],
                                            y.prototype,
                                            'touchAction',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: Boolean, attribute: 'disable-zoom' })],
                                            y.prototype,
                                            'disableZoom',
                                            void 0,
                                        ),
                                        Cf(
                                            [$({ type: Number, attribute: 'interpolation-decay' })],
                                            y.prototype,
                                            'interpolationDecay',
                                            void 0,
                                        ),
                                        Cf([$({ type: String, attribute: 'bounds' })], y.prototype, 'bounds', void 0),
                                        y
                                    );
                                })(
                                    ((t) => {
                                        var e, n, i, r, s, a, o, l, c, h;
                                        class u extends t {
                                            constructor() {
                                                super(...arguments),
                                                    (this.ar = !1),
                                                    (this.arScale = 'auto'),
                                                    (this.arPlacement = 'floor'),
                                                    (this.arModes = 'webxr scene-viewer'),
                                                    (this.iosSrc = null),
                                                    (this.xrEnvironment = !1),
                                                    (this[e] = !1),
                                                    (this[n] = this.shadowRoot.querySelector('.ar-button')),
                                                    (this[i] = document.createElement('a')),
                                                    (this[r] = new Set()),
                                                    (this[s] = _m),
                                                    (this[a] = !1),
                                                    (this[o] = (t) => {
                                                        t.preventDefault(), this.activateAR();
                                                    }),
                                                    (this[l] = ({ status: t }) => {
                                                        (t !== Cu && this[Qd].arRenderer.presentedScene !== this[Yd]) ||
                                                            (this.setAttribute('ar-status', t),
                                                            this.dispatchEvent(
                                                                new CustomEvent('ar-status', { detail: { status: t } }),
                                                            ),
                                                            t === Cu
                                                                ? this.removeAttribute('ar-tracking')
                                                                : t === Pu && this.setAttribute('ar-tracking', Iu));
                                                    }),
                                                    (this[c] = ({ status: t }) => {
                                                        this.setAttribute('ar-tracking', t),
                                                            this.dispatchEvent(
                                                                new CustomEvent('ar-tracking', {
                                                                    detail: { status: t },
                                                                }),
                                                            );
                                                    }),
                                                    (this[h] = (t) => {
                                                        '_apple_ar_quicklook_button_tapped' == t.data &&
                                                            this.dispatchEvent(
                                                                new CustomEvent('quick-look-button-tapped'),
                                                            );
                                                    });
                                            }
                                            get canActivateAR() {
                                                return this[Lm] !== _m;
                                            }
                                            connectedCallback() {
                                                super.connectedCallback(),
                                                    this[Qd].arRenderer.addEventListener('status', this[Dm]),
                                                    this.setAttribute('ar-status', Cu),
                                                    this[Qd].arRenderer.addEventListener('tracking', this[Nm]),
                                                    this[Cm].addEventListener('message', this[Fm]);
                                            }
                                            disconnectedCallback() {
                                                super.disconnectedCallback(),
                                                    this[Qd].arRenderer.removeEventListener('status', this[Dm]),
                                                    this[Qd].arRenderer.removeEventListener('tracking', this[Nm]),
                                                    this[Cm].removeEventListener('message', this[Fm]);
                                            }
                                            async update(t) {
                                                super.update(t),
                                                    t.has('arScale') && (this[Yd].canScale = 'fixed' !== this.arScale),
                                                    t.has('arPlacement') && (this[Yd].updateShadow(), this[Zd]()),
                                                    (t.has('ar') || t.has('arModes') || t.has('iosSrc')) &&
                                                        (t.has('arModes') && (this[Rm] = vm(this.arModes)), this[Om]());
                                            }
                                            async activateAR() {
                                                switch (this[Lm]) {
                                                    case xm:
                                                        this[Em]();
                                                        break;
                                                    case wm:
                                                        await this[Sm]();
                                                        break;
                                                    case bm:
                                                        this[Tm]();
                                                        break;
                                                    default:
                                                        console.warn(
                                                            'No AR Mode can be activated. This is probably due to missing configuration or device capabilities',
                                                        );
                                                }
                                            }
                                            async [((e = Am),
                                            (n = Mm),
                                            (i = Cm),
                                            (r = Rm),
                                            (s = Lm),
                                            (a = Pm),
                                            (o = Im),
                                            (l = Dm),
                                            (c = Nm),
                                            (h = Fm),
                                            Om)]() {
                                                if (((this[Lm] = _m), this.ar)) {
                                                    if (null != this.src)
                                                        for (const t of this[Rm]) {
                                                            if (
                                                                'webxr' === t &&
                                                                ot &&
                                                                !fm &&
                                                                (await this[Qd].arRenderer.supportsPresentation())
                                                            ) {
                                                                this[Lm] = wm;
                                                                break;
                                                            }
                                                            if ('scene-viewer' === t && pt && !gm) {
                                                                this[Lm] = bm;
                                                                break;
                                                            }
                                                            if ('quick-look' === t && ht) {
                                                                this[Lm] = xm;
                                                                break;
                                                            }
                                                        }
                                                    !this.canActivateAR && null != this.iosSrc && ht && (this[Lm] = xm);
                                                }
                                                if (this.canActivateAR)
                                                    this[Mm].classList.add('enabled'),
                                                        this[Mm].addEventListener('click', this[Im]);
                                                else if (this[Mm].classList.contains('enabled')) {
                                                    this[Mm].removeEventListener('click', this[Im]),
                                                        this[Mm].classList.remove('enabled');
                                                    const t = 'failed';
                                                    this.setAttribute('ar-status', t),
                                                        this.dispatchEvent(
                                                            new CustomEvent('ar-status', { detail: { status: t } }),
                                                        );
                                                }
                                            }
                                            async [Sm]() {
                                                console.log('Attempting to present in AR with WebXR...'),
                                                    await this[Um]();
                                                try {
                                                    this[Mm].removeEventListener('click', this[Im]);
                                                    const { arRenderer: t } = this[Qd];
                                                    (t.placeOnWall = 'wall' === this.arPlacement),
                                                        await t.present(this[Yd], this.xrEnvironment);
                                                } catch (t) {
                                                    console.warn('Error while trying to present in AR with WebXR'),
                                                        console.error(t),
                                                        await this[Qd].arRenderer.stopPresenting(),
                                                        (fm = !0),
                                                        console.warn('Falling back to next ar-mode'),
                                                        await this[Om](),
                                                        this.activateAR();
                                                } finally {
                                                    this[Om]();
                                                }
                                            }
                                            async [Um]() {
                                                this.loaded ||
                                                    ((this[Pm] = !0),
                                                    this[Vd](),
                                                    await ((t, e, n = null) =>
                                                        new Promise((i) => {
                                                            t.addEventListener(e, function r(s) {
                                                                (n && !n(s)) || (i(s), t.removeEventListener(e, r));
                                                            });
                                                        }))(this, 'load'),
                                                    (this[Pm] = !1));
                                            }
                                            [ip]() {
                                                return super[ip]() || this[Pm];
                                            }
                                            [Tm]() {
                                                const t = self.location.toString(),
                                                    e = new URL(t),
                                                    n = new URL(this.src, t),
                                                    i = new URLSearchParams(n.search);
                                                if (
                                                    ((e.hash = '#model-viewer-no-ar-fallback'),
                                                    i.set('mode', 'ar_preferred'),
                                                    i.has('disable_occlusion') || i.set('disable_occlusion', 'true'),
                                                    'fixed' === this.arScale && i.set('resizable', 'false'),
                                                    'wall' === this.arPlacement &&
                                                        i.set('enable_vertical_placement', 'true'),
                                                    i.has('sound'))
                                                ) {
                                                    const e = new URL(i.get('sound'), t);
                                                    i.set('sound', e.toString());
                                                }
                                                if (i.has('link')) {
                                                    const e = new URL(i.get('link'), t);
                                                    i.set('link', e.toString());
                                                }
                                                const r = `intent://arvr.google.com/scene-viewer/1.0?${
                                                    i.toString() + '&file=' + encodeURIComponent(n.toString())
                                                }#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(
                                                    e.toString(),
                                                )};end;`;
                                                self.addEventListener(
                                                    'hashchange',
                                                    () => {
                                                        '#model-viewer-no-ar-fallback' === self.location.hash &&
                                                            ((gm = !0),
                                                            self.history.back(),
                                                            console.warn(
                                                                'Error while trying to present in AR with Scene Viewer',
                                                            ),
                                                            console.warn('Falling back to next ar-mode'),
                                                            this[Om]());
                                                    },
                                                    { once: !0 },
                                                ),
                                                    this[Cm].setAttribute('href', r),
                                                    console.log('Attempting to present in AR with Scene Viewer...'),
                                                    this[Cm].click();
                                            }
                                            async [Em]() {
                                                const t = !this.iosSrc;
                                                this[Mm].classList.remove('enabled');
                                                const e = t ? await this.prepareUSDZ() : this.iosSrc,
                                                    n = new URL(e, self.location.toString());
                                                'fixed' === this.arScale &&
                                                    (n.hash && (n.hash += '&'), (n.hash += 'allowsContentScaling=0'));
                                                const i = this[Cm];
                                                i.setAttribute('rel', 'ar');
                                                const r = document.createElement('img');
                                                i.appendChild(r),
                                                    i.setAttribute('href', n.toString()),
                                                    t && i.setAttribute('download', 'model.usdz'),
                                                    console.log('Attempting to present in AR with Quick Look...'),
                                                    i.click(),
                                                    i.removeChild(r),
                                                    t && URL.revokeObjectURL(e),
                                                    this[Mm].classList.add('enabled');
                                            }
                                            async prepareUSDZ() {
                                                const t = this[tp].beginActivity();
                                                await this[Um]();
                                                const e = this[Yd],
                                                    n = e.shadow;
                                                let i = !1;
                                                null != n && ((i = n.visible), (n.visible = !1)), t(0.2);
                                                const r = new om(),
                                                    s = await r.parse(e.modelContainer),
                                                    a = new Blob([s], { type: 'model/vnd.usdz+zip' }),
                                                    o = URL.createObjectURL(a);
                                                return t(1), null != n && (n.visible = i), o;
                                            }
                                        }
                                        return (
                                            mm([$({ type: Boolean, attribute: 'ar' })], u.prototype, 'ar', void 0),
                                            mm(
                                                [$({ type: String, attribute: 'ar-scale' })],
                                                u.prototype,
                                                'arScale',
                                                void 0,
                                            ),
                                            mm(
                                                [$({ type: String, attribute: 'ar-placement' })],
                                                u.prototype,
                                                'arPlacement',
                                                void 0,
                                            ),
                                            mm(
                                                [$({ type: String, attribute: 'ar-modes' })],
                                                u.prototype,
                                                'arModes',
                                                void 0,
                                            ),
                                            mm(
                                                [$({ type: String, attribute: 'ios-src' })],
                                                u.prototype,
                                                'iosSrc',
                                                void 0,
                                            ),
                                            mm(
                                                [$({ type: Boolean, attribute: 'xr-environment' })],
                                                u.prototype,
                                                'xrEnvironment',
                                                void 0,
                                            ),
                                            u
                                        );
                                    })(
                                        ((t) => {
                                            var e, n, i, r, s, a, o, l, c, h, u, d, p, m;
                                            class f extends t {
                                                constructor(...t) {
                                                    super(...t),
                                                        (this.poster = null),
                                                        (this.reveal = Lg),
                                                        (this.loading = 'auto'),
                                                        (this.generateSchema = !1),
                                                        (this.seamlessPoster = !1),
                                                        (this[e] = !1),
                                                        (this[n] = !1),
                                                        (this[i] = 0),
                                                        (this[r] = null),
                                                        (this[s] = this.shadowRoot.querySelector('.slot.poster')),
                                                        (this[a] = this.shadowRoot.querySelector('#default-poster')),
                                                        (this[o] =
                                                            this.shadowRoot.querySelector(
                                                                '#default-progress-bar > .bar',
                                                            )),
                                                        (this[l] = this.shadowRoot.querySelector(
                                                            '#default-progress-bar > .mask',
                                                        )),
                                                        (this[c] = this[Ng].getAttribute('aria-label')),
                                                        (this[h] = ((t, e) => {
                                                            let n = null;
                                                            const i = (...e) => {
                                                                null == n &&
                                                                    (t(...e),
                                                                    (n = self.setTimeout(() => (n = null), 100)));
                                                            };
                                                            return (
                                                                (i.flush = () => {
                                                                    null != n && (self.clearTimeout(n), (n = null));
                                                                }),
                                                                i
                                                            );
                                                        })((t) => {
                                                            const e = this[Pg].parentNode;
                                                            requestAnimationFrame(() => {
                                                                (this[Ig].style.opacity = '' + 0.2 * (1 - t)),
                                                                    (this[Pg].style.transform = `scaleX(${t})`),
                                                                    0 === t &&
                                                                        (e.removeChild(this[Pg]),
                                                                        e.appendChild(this[Pg])),
                                                                    1 === t
                                                                        ? this[Pg].classList.add('hide')
                                                                        : this[Pg].classList.remove('hide');
                                                            });
                                                        })),
                                                        (this[u] = () => {
                                                            this.reveal !== Rg && this.dismissPoster();
                                                        }),
                                                        (this[d] = (t) => {
                                                            if (this.reveal !== Rg)
                                                                switch (t.keyCode) {
                                                                    case 32:
                                                                    case 13:
                                                                        this.dismissPoster();
                                                                }
                                                        }),
                                                        (this[p] = (t) => {
                                                            const e = t.detail.totalProgress;
                                                            (this[zg] = Math.max(e, this[zg])),
                                                                1 === e &&
                                                                    (this[kg].flush(),
                                                                    !this[rp]() ||
                                                                        (null == this[Fg] && this.reveal !== Lg) ||
                                                                        this[Og]()),
                                                                this[kg](e),
                                                                this.dispatchEvent(
                                                                    new CustomEvent('progress', {
                                                                        detail: { totalProgress: e },
                                                                    }),
                                                                );
                                                        }),
                                                        (this[m] = () => {
                                                            this[Bg] = !0;
                                                            const t = this.getRootNode();
                                                            t && t.activeElement === this && this[qd].focus();
                                                            const e = this[Ng];
                                                            e.setAttribute('aria-hidden', 'true'),
                                                                (e.tabIndex = -1),
                                                                this.dispatchEvent(new CustomEvent('poster-dismissed'));
                                                        });
                                                    const f = self.ModelViewerElement || {},
                                                        g =
                                                            f.dracoDecoderLocation ||
                                                            'https://www.gstatic.com/draco/versioned/decoders/1.4.1/';
                                                    Mh.setDRACODecoderLocation(g);
                                                    const v =
                                                        f.ktx2TranscoderLocation ||
                                                        'https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/';
                                                    Mh.setKTX2TranscoderLocation(v),
                                                        f.meshoptDecoderLocation &&
                                                            Mh.setMeshoptDecoderLocation(f.meshoptDecoderLocation);
                                                }
                                                static set dracoDecoderLocation(t) {
                                                    Mh.setDRACODecoderLocation(t);
                                                }
                                                static get dracoDecoderLocation() {
                                                    return Mh.getDRACODecoderLocation();
                                                }
                                                static set ktx2TranscoderLocation(t) {
                                                    Mh.setKTX2TranscoderLocation(t);
                                                }
                                                static get ktx2TranscoderLocation() {
                                                    return Mh.getKTX2TranscoderLocation();
                                                }
                                                static set meshoptDecoderLocation(t) {
                                                    Mh.setMeshoptDecoderLocation(t);
                                                }
                                                static get meshoptDecoderLocation() {
                                                    return Mh.getMeshoptDecoderLocation();
                                                }
                                                static mapURLs(t) {
                                                    dd.singleton.loader[bh].manager.setURLModifier(t);
                                                }
                                                dismissPoster() {
                                                    this[rp]() ? this[Og]() : ((this[Fg] = 'interaction'), this[Vd]());
                                                }
                                                showPoster() {
                                                    const t = this[Dg],
                                                        e = this[Ng];
                                                    e.removeAttribute('tabindex'),
                                                        e.removeAttribute('aria-hidden'),
                                                        t.classList.add('show');
                                                    const n = this.modelIsVisible;
                                                    (this[Ug] = !1), this[Bd](n), (this[Bg] = !1);
                                                }
                                                getDimensions() {
                                                    return ap(this[Yd].size);
                                                }
                                                connectedCallback() {
                                                    super.connectedCallback(),
                                                        this[Dg].addEventListener('click', this[Vg]),
                                                        this[Dg].addEventListener('keydown', this[Wg]),
                                                        this[tp].addEventListener('progress', this[jg]),
                                                        Cg.registerInstance(this);
                                                }
                                                disconnectedCallback() {
                                                    super.disconnectedCallback(),
                                                        this[Dg].removeEventListener('click', this[Vg]),
                                                        this[Dg].removeEventListener('keydown', this[Wg]),
                                                        this[tp].removeEventListener('progress', this[jg]),
                                                        Cg.unregisterInstance(this);
                                                }
                                                async updated(t) {
                                                    super.updated(t),
                                                        t.has('poster') &&
                                                            null != this.poster &&
                                                            (this[Ng].style.backgroundImage = `url(${this.poster})`),
                                                        t.has('alt') &&
                                                            this[Ng].setAttribute(
                                                                'aria-label',
                                                                `${this[Hd]}. ${this[Gg]}`,
                                                            ),
                                                        (t.has('reveal') || t.has('loading')) && this[Vd](),
                                                        t.has('generateSchema') &&
                                                            (!0 === this.generateSchema
                                                                ? this[Yd].updateSchema(this.src)
                                                                : this[Yd].updateSchema(null)),
                                                        t.has('seamlessPoster') &&
                                                            (!0 === this.seamlessPoster
                                                                ? this[Dg].classList.add('quick')
                                                                : this[Dg].classList.remove('quick'));
                                                }
                                                [((e = Ug),
                                                (n = Bg),
                                                (i = zg),
                                                (r = Fg),
                                                (s = Dg),
                                                (a = Ng),
                                                (o = Pg),
                                                (l = Ig),
                                                (c = Gg),
                                                (h = kg),
                                                (u = Vg),
                                                (d = Wg),
                                                (p = jg),
                                                ip)]() {
                                                    return (
                                                        !!this.src &&
                                                        (null != this[Fg] ||
                                                            'eager' === this.loading ||
                                                            (this.reveal === Lg && this[zd]))
                                                    );
                                                }
                                                [rp]() {
                                                    const { src: t } = this;
                                                    return !!t && super[rp]() && 1 === this[zg];
                                                }
                                                [((m = Hg), Og)]() {
                                                    this[Fg] = null;
                                                    const t = this[Dg];
                                                    if (t.classList.contains('show')) {
                                                        const e = this.modelIsVisible;
                                                        (this[Ug] = !0),
                                                            this[Bd](e),
                                                            requestAnimationFrame(() => {
                                                                t.classList.remove('show'),
                                                                    !0 === this.seamlessPoster
                                                                        ? this[Hg]()
                                                                        : t.addEventListener(
                                                                              'transitionend',
                                                                              this[Hg],
                                                                              { once: !0 },
                                                                          );
                                                            });
                                                    } else this[Bg] = !0;
                                                }
                                                [np]() {
                                                    return super[np]() && this[Ug];
                                                }
                                                [sp]() {
                                                    return super[sp]() && this[Bg];
                                                }
                                                async [Vd]() {
                                                    (this[zg] = 0),
                                                        !0 === this.generateSchema && this[Yd].updateSchema(this.src),
                                                        (null != this[Yd].currentGLTF &&
                                                            null != this.src &&
                                                            this[ip]()) ||
                                                            this.showPoster(),
                                                        await super[Vd]();
                                                }
                                            }
                                            return (
                                                Ag([$({ type: String })], f.prototype, 'poster', void 0),
                                                Ag([$({ type: String })], f.prototype, 'reveal', void 0),
                                                Ag([$({ type: String })], f.prototype, 'loading', void 0),
                                                Ag(
                                                    [$({ type: Boolean, attribute: 'generate-schema' })],
                                                    f.prototype,
                                                    'generateSchema',
                                                    void 0,
                                                ),
                                                Ag(
                                                    [$({ type: Boolean, attribute: 'seamless-poster' })],
                                                    f.prototype,
                                                    'seamlessPoster',
                                                    void 0,
                                                ),
                                                f
                                            );
                                        })(
                                            ((t) => {
                                                var e;
                                                class n extends t {
                                                    constructor() {
                                                        super(...arguments),
                                                            (this.autoplay = !1),
                                                            (this.animationName = void 0),
                                                            (this.animationCrossfadeDuration = 300),
                                                            (this[e] = !0);
                                                    }
                                                    get availableAnimations() {
                                                        return this.loaded ? this[Yd].animationNames : [];
                                                    }
                                                    get duration() {
                                                        return this[Yd].duration;
                                                    }
                                                    get paused() {
                                                        return this[hp];
                                                    }
                                                    get currentTime() {
                                                        return this[Yd].animationTime;
                                                    }
                                                    set currentTime(t) {
                                                        (this[Yd].animationTime = t),
                                                            (this[Qd].threeRenderer.shadowMap.needsUpdate = !0),
                                                            this[Zd]();
                                                    }
                                                    pause() {
                                                        this[hp] ||
                                                            ((this[hp] = !0),
                                                            (this[Qd].threeRenderer.shadowMap.autoUpdate = !1),
                                                            this.dispatchEvent(new CustomEvent('pause')));
                                                    }
                                                    play() {
                                                        this[hp] &&
                                                            this.availableAnimations.length > 0 &&
                                                            ((this[hp] = !1),
                                                            (this[Qd].threeRenderer.shadowMap.autoUpdate = !0),
                                                            this[Yd].hasActiveAnimation || this[cp](),
                                                            this.dispatchEvent(new CustomEvent('play')));
                                                    }
                                                    [((e = hp), $d)]() {
                                                        super[$d](),
                                                            (this[hp] = !0),
                                                            this.autoplay && (this[cp](), this.play());
                                                    }
                                                    [Jd](t, e) {
                                                        super[Jd](t, e),
                                                            this[hp] ||
                                                                (!this[sp]() && !this[Qd].isPresenting) ||
                                                                (this[Yd].updateAnimation(e / 1e3), this[Zd]());
                                                    }
                                                    updated(t) {
                                                        super.updated(t),
                                                            t.has('autoplay') && this.autoplay && this.play(),
                                                            t.has('animationName') && this[cp]();
                                                    }
                                                    async [Vd]() {
                                                        return this[Yd].stopAnimation(), super[Vd]();
                                                    }
                                                    [cp]() {
                                                        this[Yd].playAnimation(
                                                            this.animationName,
                                                            this.animationCrossfadeDuration / 1e3,
                                                        ),
                                                            this[hp] && (this[Yd].updateAnimation(0), this[Zd]());
                                                    }
                                                }
                                                return (
                                                    lp([$({ type: Boolean })], n.prototype, 'autoplay', void 0),
                                                    lp(
                                                        [$({ type: String, attribute: 'animation-name' })],
                                                        n.prototype,
                                                        'animationName',
                                                        void 0,
                                                    ),
                                                    lp(
                                                        [
                                                            $({
                                                                type: Number,
                                                                attribute: 'animation-crossfade-duration',
                                                            }),
                                                        ],
                                                        n.prototype,
                                                        'animationCrossfadeDuration',
                                                        void 0,
                                                    ),
                                                    n
                                                );
                                            })(
                                                ((t) => {
                                                    var e;
                                                    const n = Symbol('endPolyfillCoordination');
                                                    return (
                                                        (e = n),
                                                        class extends t {
                                                            constructor() {
                                                                super(...arguments), (this[e] = null);
                                                            }
                                                            connectedCallback() {
                                                                super.connectedCallback && super.connectedCallback(),
                                                                    null == this[n] &&
                                                                        (this[n] = ((t) => {
                                                                            if (
                                                                                null == t.shadowRoot ||
                                                                                t.hasAttribute('data-js-focus-visible')
                                                                            )
                                                                                return () => {};
                                                                            if (!self.applyFocusVisiblePolyfill) {
                                                                                const e = () => {
                                                                                    self.applyFocusVisiblePolyfill(
                                                                                        t.shadowRoot,
                                                                                    );
                                                                                };
                                                                                return (
                                                                                    self.addEventListener(
                                                                                        'focus-visible-polyfill-ready',
                                                                                        e,
                                                                                        { once: !0 },
                                                                                    ),
                                                                                    () => {
                                                                                        self.removeEventListener(
                                                                                            'focus-visible-polyfill-ready',
                                                                                            e,
                                                                                        );
                                                                                    }
                                                                                );
                                                                            }
                                                                            return (
                                                                                self.applyFocusVisiblePolyfill(
                                                                                    t.shadowRoot,
                                                                                ),
                                                                                () => {}
                                                                            );
                                                                        })(this));
                                                            }
                                                            disconnectedCallback() {
                                                                super.disconnectedCallback &&
                                                                    super.disconnectedCallback(),
                                                                    null != this[n] && (this[n](), (this[n] = null));
                                                            }
                                                        }
                                                    );
                                                })(op),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                );
            customElements.define('model-viewer', Uy);
        },
    },
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwtdmlld2VyLjU2Y2MzNzgyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwZkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjNwYXNzLy4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2Rpc3QvbW9kZWwtdmlld2VyLm1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5jb25zdCB0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJm51bGwhPXdpbmRvdy5jdXN0b21FbGVtZW50cyYmdm9pZCAwIT09d2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2ssZT0odCxlLG49bnVsbCk9Pntmb3IoO2UhPT1uOyl7Y29uc3Qgbj1lLm5leHRTaWJsaW5nO3QucmVtb3ZlQ2hpbGQoZSksZT1ufX0sbj1ge3tsaXQtJHtTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMil9fX1gLGk9YFxceDNjIS0tJHtufS0tXFx4M2VgLHI9bmV3IFJlZ0V4cChgJHtufXwke2l9YCk7Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMucGFydHM9W10sdGhpcy5lbGVtZW50PWU7Y29uc3QgaT1bXSxzPVtdLG89ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlLmNvbnRlbnQsMTMzLG51bGwsITEpO2xldCBoPTAsdT0tMSxkPTA7Y29uc3R7c3RyaW5nczpwLHZhbHVlczp7bGVuZ3RoOm19fT10O2Zvcig7ZDxtOyl7Y29uc3QgdD1vLm5leHROb2RlKCk7aWYobnVsbCE9PXQpe2lmKHUrKywxPT09dC5ub2RlVHlwZSl7aWYodC5oYXNBdHRyaWJ1dGVzKCkpe2NvbnN0IGU9dC5hdHRyaWJ1dGVzLHtsZW5ndGg6bn09ZTtsZXQgaT0wO2ZvcihsZXQgdD0wO3Q8bjt0KyspYShlW3RdLm5hbWUsXCIkbGl0JFwiKSYmaSsrO2Zvcig7aS0tID4wOyl7Y29uc3QgZT1wW2RdLG49Yy5leGVjKGUpWzJdLGk9bi50b0xvd2VyQ2FzZSgpK1wiJGxpdCRcIixzPXQuZ2V0QXR0cmlidXRlKGkpO3QucmVtb3ZlQXR0cmlidXRlKGkpO2NvbnN0IGE9cy5zcGxpdChyKTt0aGlzLnBhcnRzLnB1c2goe3R5cGU6XCJhdHRyaWJ1dGVcIixpbmRleDp1LG5hbWU6bixzdHJpbmdzOmF9KSxkKz1hLmxlbmd0aC0xfX1cIlRFTVBMQVRFXCI9PT10LnRhZ05hbWUmJihzLnB1c2godCksby5jdXJyZW50Tm9kZT10LmNvbnRlbnQpfWVsc2UgaWYoMz09PXQubm9kZVR5cGUpe2NvbnN0IGU9dC5kYXRhO2lmKGUuaW5kZXhPZihuKT49MCl7Y29uc3Qgbj10LnBhcmVudE5vZGUscz1lLnNwbGl0KHIpLG89cy5sZW5ndGgtMTtmb3IobGV0IGU9MDtlPG87ZSsrKXtsZXQgaSxyPXNbZV07aWYoXCJcIj09PXIpaT1sKCk7ZWxzZXtjb25zdCB0PWMuZXhlYyhyKTtudWxsIT09dCYmYSh0WzJdLFwiJGxpdCRcIikmJihyPXIuc2xpY2UoMCx0LmluZGV4KSt0WzFdK3RbMl0uc2xpY2UoMCwtXCIkbGl0JFwiLmxlbmd0aCkrdFszXSksaT1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyKX1uLmluc2VydEJlZm9yZShpLHQpLHRoaXMucGFydHMucHVzaCh7dHlwZTpcIm5vZGVcIixpbmRleDorK3V9KX1cIlwiPT09c1tvXT8obi5pbnNlcnRCZWZvcmUobCgpLHQpLGkucHVzaCh0KSk6dC5kYXRhPXNbb10sZCs9b319ZWxzZSBpZig4PT09dC5ub2RlVHlwZSlpZih0LmRhdGE9PT1uKXtjb25zdCBlPXQucGFyZW50Tm9kZTtudWxsIT09dC5wcmV2aW91c1NpYmxpbmcmJnUhPT1ofHwodSsrLGUuaW5zZXJ0QmVmb3JlKGwoKSx0KSksaD11LHRoaXMucGFydHMucHVzaCh7dHlwZTpcIm5vZGVcIixpbmRleDp1fSksbnVsbD09PXQubmV4dFNpYmxpbmc/dC5kYXRhPVwiXCI6KGkucHVzaCh0KSx1LS0pLGQrK31lbHNle2xldCBlPS0xO2Zvcig7LTEhPT0oZT10LmRhdGEuaW5kZXhPZihuLGUrMSkpOyl0aGlzLnBhcnRzLnB1c2goe3R5cGU6XCJub2RlXCIsaW5kZXg6LTF9KSxkKyt9fWVsc2Ugby5jdXJyZW50Tm9kZT1zLnBvcCgpfWZvcihjb25zdCB0IG9mIGkpdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpfX1jb25zdCBhPSh0LGUpPT57Y29uc3Qgbj10Lmxlbmd0aC1lLmxlbmd0aDtyZXR1cm4gbj49MCYmdC5zbGljZShuKT09PWV9LG89dD0+LTEhPT10LmluZGV4LGw9KCk9PmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIiksYz0vKFsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKShbXlxcMC1cXHgxRlxceDdGLVxceDlGIFwiJz49L10rKShbIFxceDA5XFx4MGFcXHgwY1xceDBkXSo9WyBcXHgwOVxceDBhXFx4MGNcXHgwZF0qKD86W14gXFx4MDlcXHgwYVxceDBjXFx4MGRcIidgPD49XSp8XCJbXlwiXSp8J1teJ10qKSkkLztmdW5jdGlvbiBoKHQsZSl7Y29uc3R7ZWxlbWVudDp7Y29udGVudDpufSxwYXJ0czppfT10LHI9ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihuLDEzMyxudWxsLCExKTtsZXQgcz1kKGkpLGE9aVtzXSxvPS0xLGw9MDtjb25zdCBjPVtdO2xldCBoPW51bGw7Zm9yKDtyLm5leHROb2RlKCk7KXtvKys7Y29uc3QgdD1yLmN1cnJlbnROb2RlO2Zvcih0LnByZXZpb3VzU2libGluZz09PWgmJihoPW51bGwpLGUuaGFzKHQpJiYoYy5wdXNoKHQpLG51bGw9PT1oJiYoaD10KSksbnVsbCE9PWgmJmwrKzt2b2lkIDAhPT1hJiZhLmluZGV4PT09bzspYS5pbmRleD1udWxsIT09aD8tMTphLmluZGV4LWwscz1kKGkscyksYT1pW3NdfWMuZm9yRWFjaCgodD0+dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpKSl9Y29uc3QgdT10PT57bGV0IGU9MTE9PT10Lm5vZGVUeXBlPzA6MTtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIodCwxMzMsbnVsbCwhMSk7Zm9yKDtuLm5leHROb2RlKCk7KWUrKztyZXR1cm4gZX0sZD0odCxlPS0xKT0+e2ZvcihsZXQgbj1lKzE7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IGU9dFtuXTtpZihvKGUpKXJldHVybiBufXJldHVybi0xfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmNvbnN0IHA9bmV3IFdlYWtNYXAsbT10PT5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZwLmhhcyh0KSxmPXt9LGc9e307XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5jbGFzcyB2e2NvbnN0cnVjdG9yKHQsZSxuKXt0aGlzLl9fcGFydHM9W10sdGhpcy50ZW1wbGF0ZT10LHRoaXMucHJvY2Vzc29yPWUsdGhpcy5vcHRpb25zPW59dXBkYXRlKHQpe2xldCBlPTA7Zm9yKGNvbnN0IG4gb2YgdGhpcy5fX3BhcnRzKXZvaWQgMCE9PW4mJm4uc2V0VmFsdWUodFtlXSksZSsrO2Zvcihjb25zdCB0IG9mIHRoaXMuX19wYXJ0cyl2b2lkIDAhPT10JiZ0LmNvbW1pdCgpfV9jbG9uZSgpe2NvbnN0IGU9dD90aGlzLnRlbXBsYXRlLmVsZW1lbnQuY29udGVudC5jbG9uZU5vZGUoITApOmRvY3VtZW50LmltcG9ydE5vZGUodGhpcy50ZW1wbGF0ZS5lbGVtZW50LmNvbnRlbnQsITApLG49W10saT10aGlzLnRlbXBsYXRlLnBhcnRzLHI9ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlLDEzMyxudWxsLCExKTtsZXQgcyxhPTAsbD0wLGM9ci5uZXh0Tm9kZSgpO2Zvcig7YTxpLmxlbmd0aDspaWYocz1pW2FdLG8ocykpe2Zvcig7bDxzLmluZGV4OylsKyssXCJURU1QTEFURVwiPT09Yy5ub2RlTmFtZSYmKG4ucHVzaChjKSxyLmN1cnJlbnROb2RlPWMuY29udGVudCksbnVsbD09PShjPXIubmV4dE5vZGUoKSkmJihyLmN1cnJlbnROb2RlPW4ucG9wKCksYz1yLm5leHROb2RlKCkpO2lmKFwibm9kZVwiPT09cy50eXBlKXtjb25zdCB0PXRoaXMucHJvY2Vzc29yLmhhbmRsZVRleHRFeHByZXNzaW9uKHRoaXMub3B0aW9ucyk7dC5pbnNlcnRBZnRlck5vZGUoYy5wcmV2aW91c1NpYmxpbmcpLHRoaXMuX19wYXJ0cy5wdXNoKHQpfWVsc2UgdGhpcy5fX3BhcnRzLnB1c2goLi4udGhpcy5wcm9jZXNzb3IuaGFuZGxlQXR0cmlidXRlRXhwcmVzc2lvbnMoYyxzLm5hbWUscy5zdHJpbmdzLHRoaXMub3B0aW9ucykpO2ErK31lbHNlIHRoaXMuX19wYXJ0cy5wdXNoKHZvaWQgMCksYSsrO3JldHVybiB0JiYoZG9jdW1lbnQuYWRvcHROb2RlKGUpLGN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoZSkpLGV9fVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL2NvbnN0IHk9d2luZG93LnRydXN0ZWRUeXBlcyYmdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcImxpdC1odG1sXCIse2NyZWF0ZUhUTUw6dD0+dH0pLHg9YCAke259IGA7Y2xhc3MgYntjb25zdHJ1Y3Rvcih0LGUsbixpKXt0aGlzLnN0cmluZ3M9dCx0aGlzLnZhbHVlcz1lLHRoaXMudHlwZT1uLHRoaXMucHJvY2Vzc29yPWl9Z2V0SFRNTCgpe2NvbnN0IHQ9dGhpcy5zdHJpbmdzLmxlbmd0aC0xO2xldCBlPVwiXCIscj0hMTtmb3IobGV0IHM9MDtzPHQ7cysrKXtjb25zdCB0PXRoaXMuc3RyaW5nc1tzXSxhPXQubGFzdEluZGV4T2YoXCJcXHgzYyEtLVwiKTtyPShhPi0xfHxyKSYmLTE9PT10LmluZGV4T2YoXCItLVxceDNlXCIsYSsxKTtjb25zdCBvPWMuZXhlYyh0KTtlKz1udWxsPT09bz90KyhyP3g6aSk6dC5zdWJzdHIoMCxvLmluZGV4KStvWzFdK29bMl0rXCIkbGl0JFwiK29bM10rbn1yZXR1cm4gZSs9dGhpcy5zdHJpbmdzW3RdLGV9Z2V0VGVtcGxhdGVFbGVtZW50KCl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7bGV0IGU9dGhpcy5nZXRIVE1MKCk7cmV0dXJuIHZvaWQgMCE9PXkmJihlPXkuY3JlYXRlSFRNTChlKSksdC5pbm5lckhUTUw9ZSx0fX1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9jb25zdCB3PXQ9Pm51bGw9PT10fHwhKFwib2JqZWN0XCI9PXR5cGVvZiB0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KSxfPXQ9PkFycmF5LmlzQXJyYXkodCl8fCEoIXR8fCF0W1N5bWJvbC5pdGVyYXRvcl0pO2NsYXNzIE17Y29uc3RydWN0b3IodCxlLG4pe3RoaXMuZGlydHk9ITAsdGhpcy5lbGVtZW50PXQsdGhpcy5uYW1lPWUsdGhpcy5zdHJpbmdzPW4sdGhpcy5wYXJ0cz1bXTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoLTE7dCsrKXRoaXMucGFydHNbdF09dGhpcy5fY3JlYXRlUGFydCgpfV9jcmVhdGVQYXJ0KCl7cmV0dXJuIG5ldyBTKHRoaXMpfV9nZXRWYWx1ZSgpe2NvbnN0IHQ9dGhpcy5zdHJpbmdzLGU9dC5sZW5ndGgtMSxuPXRoaXMucGFydHM7aWYoMT09PWUmJlwiXCI9PT10WzBdJiZcIlwiPT09dFsxXSl7Y29uc3QgdD1uWzBdLnZhbHVlO2lmKFwic3ltYm9sXCI9PXR5cGVvZiB0KXJldHVybiBTdHJpbmcodCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHR8fCFfKHQpKXJldHVybiB0fWxldCBpPVwiXCI7Zm9yKGxldCByPTA7cjxlO3IrKyl7aSs9dFtyXTtjb25zdCBlPW5bcl07aWYodm9pZCAwIT09ZSl7Y29uc3QgdD1lLnZhbHVlO2lmKHcodCl8fCFfKHQpKWkrPVwic3RyaW5nXCI9PXR5cGVvZiB0P3Q6U3RyaW5nKHQpO2Vsc2UgZm9yKGNvbnN0IGUgb2YgdClpKz1cInN0cmluZ1wiPT10eXBlb2YgZT9lOlN0cmluZyhlKX19cmV0dXJuIGkrPXRbZV0saX1jb21taXQoKXt0aGlzLmRpcnR5JiYodGhpcy5kaXJ0eT0hMSx0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSx0aGlzLl9nZXRWYWx1ZSgpKSl9fWNsYXNzIFN7Y29uc3RydWN0b3IodCl7dGhpcy52YWx1ZT12b2lkIDAsdGhpcy5jb21taXR0ZXI9dH1zZXRWYWx1ZSh0KXt0PT09Znx8dyh0KSYmdD09PXRoaXMudmFsdWV8fCh0aGlzLnZhbHVlPXQsbSh0KXx8KHRoaXMuY29tbWl0dGVyLmRpcnR5PSEwKSl9Y29tbWl0KCl7Zm9yKDttKHRoaXMudmFsdWUpOyl7Y29uc3QgdD10aGlzLnZhbHVlO3RoaXMudmFsdWU9Zix0KHRoaXMpfXRoaXMudmFsdWUhPT1mJiZ0aGlzLmNvbW1pdHRlci5jb21taXQoKX19Y2xhc3MgVHtjb25zdHJ1Y3Rvcih0KXt0aGlzLnZhbHVlPXZvaWQgMCx0aGlzLl9fcGVuZGluZ1ZhbHVlPXZvaWQgMCx0aGlzLm9wdGlvbnM9dH1hcHBlbmRJbnRvKHQpe3RoaXMuc3RhcnROb2RlPXQuYXBwZW5kQ2hpbGQobCgpKSx0aGlzLmVuZE5vZGU9dC5hcHBlbmRDaGlsZChsKCkpfWluc2VydEFmdGVyTm9kZSh0KXt0aGlzLnN0YXJ0Tm9kZT10LHRoaXMuZW5kTm9kZT10Lm5leHRTaWJsaW5nfWFwcGVuZEludG9QYXJ0KHQpe3QuX19pbnNlcnQodGhpcy5zdGFydE5vZGU9bCgpKSx0Ll9faW5zZXJ0KHRoaXMuZW5kTm9kZT1sKCkpfWluc2VydEFmdGVyUGFydCh0KXt0Ll9faW5zZXJ0KHRoaXMuc3RhcnROb2RlPWwoKSksdGhpcy5lbmROb2RlPXQuZW5kTm9kZSx0LmVuZE5vZGU9dGhpcy5zdGFydE5vZGV9c2V0VmFsdWUodCl7dGhpcy5fX3BlbmRpbmdWYWx1ZT10fWNvbW1pdCgpe2lmKG51bGw9PT10aGlzLnN0YXJ0Tm9kZS5wYXJlbnROb2RlKXJldHVybjtmb3IoO20odGhpcy5fX3BlbmRpbmdWYWx1ZSk7KXtjb25zdCB0PXRoaXMuX19wZW5kaW5nVmFsdWU7dGhpcy5fX3BlbmRpbmdWYWx1ZT1mLHQodGhpcyl9Y29uc3QgdD10aGlzLl9fcGVuZGluZ1ZhbHVlO3QhPT1mJiYodyh0KT90IT09dGhpcy52YWx1ZSYmdGhpcy5fX2NvbW1pdFRleHQodCk6dCBpbnN0YW5jZW9mIGI/dGhpcy5fX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHQpOnQgaW5zdGFuY2VvZiBOb2RlP3RoaXMuX19jb21taXROb2RlKHQpOl8odCk/dGhpcy5fX2NvbW1pdEl0ZXJhYmxlKHQpOnQ9PT1nPyh0aGlzLnZhbHVlPWcsdGhpcy5jbGVhcigpKTp0aGlzLl9fY29tbWl0VGV4dCh0KSl9X19pbnNlcnQodCl7dGhpcy5lbmROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsdGhpcy5lbmROb2RlKX1fX2NvbW1pdE5vZGUodCl7dGhpcy52YWx1ZSE9PXQmJih0aGlzLmNsZWFyKCksdGhpcy5fX2luc2VydCh0KSx0aGlzLnZhbHVlPXQpfV9fY29tbWl0VGV4dCh0KXtjb25zdCBlPXRoaXMuc3RhcnROb2RlLm5leHRTaWJsaW5nLG49XCJzdHJpbmdcIj09dHlwZW9mKHQ9bnVsbD09dD9cIlwiOnQpP3Q6U3RyaW5nKHQpO2U9PT10aGlzLmVuZE5vZGUucHJldmlvdXNTaWJsaW5nJiYzPT09ZS5ub2RlVHlwZT9lLmRhdGE9bjp0aGlzLl9fY29tbWl0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuKSksdGhpcy52YWx1ZT10fV9fY29tbWl0VGVtcGxhdGVSZXN1bHQodCl7Y29uc3QgZT10aGlzLm9wdGlvbnMudGVtcGxhdGVGYWN0b3J5KHQpO2lmKHRoaXMudmFsdWUgaW5zdGFuY2VvZiB2JiZ0aGlzLnZhbHVlLnRlbXBsYXRlPT09ZSl0aGlzLnZhbHVlLnVwZGF0ZSh0LnZhbHVlcyk7ZWxzZXtjb25zdCBuPW5ldyB2KGUsdC5wcm9jZXNzb3IsdGhpcy5vcHRpb25zKSxpPW4uX2Nsb25lKCk7bi51cGRhdGUodC52YWx1ZXMpLHRoaXMuX19jb21taXROb2RlKGkpLHRoaXMudmFsdWU9bn19X19jb21taXRJdGVyYWJsZSh0KXtBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpfHwodGhpcy52YWx1ZT1bXSx0aGlzLmNsZWFyKCkpO2NvbnN0IGU9dGhpcy52YWx1ZTtsZXQgbixpPTA7Zm9yKGNvbnN0IHIgb2YgdCluPWVbaV0sdm9pZCAwPT09biYmKG49bmV3IFQodGhpcy5vcHRpb25zKSxlLnB1c2gobiksMD09PWk/bi5hcHBlbmRJbnRvUGFydCh0aGlzKTpuLmluc2VydEFmdGVyUGFydChlW2ktMV0pKSxuLnNldFZhbHVlKHIpLG4uY29tbWl0KCksaSsrO2k8ZS5sZW5ndGgmJihlLmxlbmd0aD1pLHRoaXMuY2xlYXIobiYmbi5lbmROb2RlKSl9Y2xlYXIodD10aGlzLnN0YXJ0Tm9kZSl7ZSh0aGlzLnN0YXJ0Tm9kZS5wYXJlbnROb2RlLHQubmV4dFNpYmxpbmcsdGhpcy5lbmROb2RlKX19Y2xhc3MgRXtjb25zdHJ1Y3Rvcih0LGUsbil7aWYodGhpcy52YWx1ZT12b2lkIDAsdGhpcy5fX3BlbmRpbmdWYWx1ZT12b2lkIDAsMiE9PW4ubGVuZ3RofHxcIlwiIT09blswXXx8XCJcIiE9PW5bMV0pdGhyb3cgbmV3IEVycm9yKFwiQm9vbGVhbiBhdHRyaWJ1dGVzIGNhbiBvbmx5IGNvbnRhaW4gYSBzaW5nbGUgZXhwcmVzc2lvblwiKTt0aGlzLmVsZW1lbnQ9dCx0aGlzLm5hbWU9ZSx0aGlzLnN0cmluZ3M9bn1zZXRWYWx1ZSh0KXt0aGlzLl9fcGVuZGluZ1ZhbHVlPXR9Y29tbWl0KCl7Zm9yKDttKHRoaXMuX19wZW5kaW5nVmFsdWUpOyl7Y29uc3QgdD10aGlzLl9fcGVuZGluZ1ZhbHVlO3RoaXMuX19wZW5kaW5nVmFsdWU9Zix0KHRoaXMpfWlmKHRoaXMuX19wZW5kaW5nVmFsdWU9PT1mKXJldHVybjtjb25zdCB0PSEhdGhpcy5fX3BlbmRpbmdWYWx1ZTt0aGlzLnZhbHVlIT09dCYmKHQ/dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm5hbWUsXCJcIik6dGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0aGlzLm5hbWUpLHRoaXMudmFsdWU9dCksdGhpcy5fX3BlbmRpbmdWYWx1ZT1mfX1jbGFzcyBBIGV4dGVuZHMgTXtjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIodCxlLG4pLHRoaXMuc2luZ2xlPTI9PT1uLmxlbmd0aCYmXCJcIj09PW5bMF0mJlwiXCI9PT1uWzFdfV9jcmVhdGVQYXJ0KCl7cmV0dXJuIG5ldyBMKHRoaXMpfV9nZXRWYWx1ZSgpe3JldHVybiB0aGlzLnNpbmdsZT90aGlzLnBhcnRzWzBdLnZhbHVlOnN1cGVyLl9nZXRWYWx1ZSgpfWNvbW1pdCgpe3RoaXMuZGlydHkmJih0aGlzLmRpcnR5PSExLHRoaXMuZWxlbWVudFt0aGlzLm5hbWVdPXRoaXMuX2dldFZhbHVlKCkpfX1jbGFzcyBMIGV4dGVuZHMgU3t9bGV0IFI9ITE7KCgpPT57dHJ5e2NvbnN0IHQ9e2dldCBjYXB0dXJlKCl7cmV0dXJuIFI9ITAsITF9fTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIix0LHQpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLHQsdCl9Y2F0Y2godCl7fX0pKCk7Y2xhc3MgQ3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy52YWx1ZT12b2lkIDAsdGhpcy5fX3BlbmRpbmdWYWx1ZT12b2lkIDAsdGhpcy5lbGVtZW50PXQsdGhpcy5ldmVudE5hbWU9ZSx0aGlzLmV2ZW50Q29udGV4dD1uLHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50PXQ9PnRoaXMuaGFuZGxlRXZlbnQodCl9c2V0VmFsdWUodCl7dGhpcy5fX3BlbmRpbmdWYWx1ZT10fWNvbW1pdCgpe2Zvcig7bSh0aGlzLl9fcGVuZGluZ1ZhbHVlKTspe2NvbnN0IHQ9dGhpcy5fX3BlbmRpbmdWYWx1ZTt0aGlzLl9fcGVuZGluZ1ZhbHVlPWYsdCh0aGlzKX1pZih0aGlzLl9fcGVuZGluZ1ZhbHVlPT09ZilyZXR1cm47Y29uc3QgdD10aGlzLl9fcGVuZGluZ1ZhbHVlLGU9dGhpcy52YWx1ZSxuPW51bGw9PXR8fG51bGwhPWUmJih0LmNhcHR1cmUhPT1lLmNhcHR1cmV8fHQub25jZSE9PWUub25jZXx8dC5wYXNzaXZlIT09ZS5wYXNzaXZlKSxpPW51bGwhPXQmJihudWxsPT1lfHxuKTtuJiZ0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSx0aGlzLl9fYm91bmRIYW5kbGVFdmVudCx0aGlzLl9fb3B0aW9ucyksaSYmKHRoaXMuX19vcHRpb25zPVAodCksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQsdGhpcy5fX29wdGlvbnMpKSx0aGlzLnZhbHVlPXQsdGhpcy5fX3BlbmRpbmdWYWx1ZT1mfWhhbmRsZUV2ZW50KHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMudmFsdWU/dGhpcy52YWx1ZS5jYWxsKHRoaXMuZXZlbnRDb250ZXh0fHx0aGlzLmVsZW1lbnQsdCk6dGhpcy52YWx1ZS5oYW5kbGVFdmVudCh0KX19Y29uc3QgUD10PT50JiYoUj97Y2FwdHVyZTp0LmNhcHR1cmUscGFzc2l2ZTp0LnBhc3NpdmUsb25jZTp0Lm9uY2V9OnQuY2FwdHVyZSlcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi87ZnVuY3Rpb24gSSh0KXtsZXQgZT1ELmdldCh0LnR5cGUpO3ZvaWQgMD09PWUmJihlPXtzdHJpbmdzQXJyYXk6bmV3IFdlYWtNYXAsa2V5U3RyaW5nOm5ldyBNYXB9LEQuc2V0KHQudHlwZSxlKSk7bGV0IGk9ZS5zdHJpbmdzQXJyYXkuZ2V0KHQuc3RyaW5ncyk7aWYodm9pZCAwIT09aSlyZXR1cm4gaTtjb25zdCByPXQuc3RyaW5ncy5qb2luKG4pO3JldHVybiBpPWUua2V5U3RyaW5nLmdldChyKSx2b2lkIDA9PT1pJiYoaT1uZXcgcyh0LHQuZ2V0VGVtcGxhdGVFbGVtZW50KCkpLGUua2V5U3RyaW5nLnNldChyLGkpKSxlLnN0cmluZ3NBcnJheS5zZXQodC5zdHJpbmdzLGkpLGl9Y29uc3QgRD1uZXcgTWFwLE49bmV3IFdlYWtNYXAsRj0odCxuLGkpPT57bGV0IHI9Ti5nZXQobik7dm9pZCAwPT09ciYmKGUobixuLmZpcnN0Q2hpbGQpLE4uc2V0KG4scj1uZXcgVChPYmplY3QuYXNzaWduKHt0ZW1wbGF0ZUZhY3Rvcnk6SX0saSkpKSxyLmFwcGVuZEludG8obikpLHIuc2V0VmFsdWUodCksci5jb21taXQoKX07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovY29uc3QgTz1uZXdcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmNsYXNze2hhbmRsZUF0dHJpYnV0ZUV4cHJlc3Npb25zKHQsZSxuLGkpe2NvbnN0IHI9ZVswXTtpZihcIi5cIj09PXIpe3JldHVybiBuZXcgQSh0LGUuc2xpY2UoMSksbikucGFydHN9aWYoXCJAXCI9PT1yKXJldHVybltuZXcgQyh0LGUuc2xpY2UoMSksaS5ldmVudENvbnRleHQpXTtpZihcIj9cIj09PXIpcmV0dXJuW25ldyBFKHQsZS5zbGljZSgxKSxuKV07cmV0dXJuIG5ldyBNKHQsZSxuKS5wYXJ0c31oYW5kbGVUZXh0RXhwcmVzc2lvbih0KXtyZXR1cm4gbmV3IFQodCl9fTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93LmxpdEh0bWxWZXJzaW9uc3x8KHdpbmRvdy5saXRIdG1sVmVyc2lvbnM9W10pKS5wdXNoKFwiMS40LjFcIik7Y29uc3QgVT0odCwuLi5lKT0+bmV3IGIodCxlLFwiaHRtbFwiLE8pXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovLGs9KHQsZSk9PmAke3R9LS0ke2V9YDtsZXQgej0hMDt2b2lkIDA9PT13aW5kb3cuU2hhZHlDU1M/ej0hMTp2b2lkIDA9PT13aW5kb3cuU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlRG9tJiYoY29uc29sZS53YXJuKFwiSW5jb21wYXRpYmxlIFNoYWR5Q1NTIHZlcnNpb24gZGV0ZWN0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gYXQgbGVhc3QgQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzQDIuMC4yIGFuZCBAd2ViY29tcG9uZW50cy9zaGFkeWNzc0AxLjMuMS5cIiksej0hMSk7Y29uc3QgQj10PT5lPT57Y29uc3QgaT1rKGUudHlwZSx0KTtsZXQgcj1ELmdldChpKTt2b2lkIDA9PT1yJiYocj17c3RyaW5nc0FycmF5Om5ldyBXZWFrTWFwLGtleVN0cmluZzpuZXcgTWFwfSxELnNldChpLHIpKTtsZXQgYT1yLnN0cmluZ3NBcnJheS5nZXQoZS5zdHJpbmdzKTtpZih2b2lkIDAhPT1hKXJldHVybiBhO2NvbnN0IG89ZS5zdHJpbmdzLmpvaW4obik7aWYoYT1yLmtleVN0cmluZy5nZXQobyksdm9pZCAwPT09YSl7Y29uc3Qgbj1lLmdldFRlbXBsYXRlRWxlbWVudCgpO3omJndpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVEb20obix0KSxhPW5ldyBzKGUsbiksci5rZXlTdHJpbmcuc2V0KG8sYSl9cmV0dXJuIHIuc3RyaW5nc0FycmF5LnNldChlLnN0cmluZ3MsYSksYX0sSD1bXCJodG1sXCIsXCJzdmdcIl0sVj1uZXcgU2V0LEc9KHQsZSxuKT0+e1YuYWRkKHQpO2NvbnN0IGk9bj9uLmVsZW1lbnQ6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpLHI9ZS5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVcIikse2xlbmd0aDpzfT1yO2lmKDA9PT1zKXJldHVybiB2b2lkIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVTdHlsZXMoaSx0KTtjb25zdCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtmb3IobGV0IHQ9MDt0PHM7dCsrKXtjb25zdCBlPXJbdF07ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpLGEudGV4dENvbnRlbnQrPWUudGV4dENvbnRlbnR9KHQ9PntILmZvckVhY2goKGU9Pntjb25zdCBuPUQuZ2V0KGsoZSx0KSk7dm9pZCAwIT09biYmbi5rZXlTdHJpbmcuZm9yRWFjaCgodD0+e2NvbnN0e2VsZW1lbnQ6e2NvbnRlbnQ6ZX19PXQsbj1uZXcgU2V0O0FycmF5LmZyb20oZS5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVcIikpLmZvckVhY2goKHQ9PntuLmFkZCh0KX0pKSxoKHQsbil9KSl9KSl9KSh0KTtjb25zdCBvPWkuY29udGVudDtuP2Z1bmN0aW9uKHQsZSxuPW51bGwpe2NvbnN0e2VsZW1lbnQ6e2NvbnRlbnQ6aX0scGFydHM6cn09dDtpZihudWxsPT1uKXJldHVybiB2b2lkIGkuYXBwZW5kQ2hpbGQoZSk7Y29uc3Qgcz1kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGksMTMzLG51bGwsITEpO2xldCBhPWQociksbz0wLGw9LTE7Zm9yKDtzLm5leHROb2RlKCk7KWZvcihsKysscy5jdXJyZW50Tm9kZT09PW4mJihvPXUoZSksbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLG4pKTstMSE9PWEmJnJbYV0uaW5kZXg9PT1sOyl7aWYobz4wKXtmb3IoOy0xIT09YTspclthXS5pbmRleCs9byxhPWQocixhKTtyZXR1cm59YT1kKHIsYSl9fShuLGEsby5maXJzdENoaWxkKTpvLmluc2VydEJlZm9yZShhLG8uZmlyc3RDaGlsZCksd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZVN0eWxlcyhpLHQpO2NvbnN0IGw9by5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIik7aWYod2luZG93LlNoYWR5Q1NTLm5hdGl2ZVNoYWRvdyYmbnVsbCE9PWwpZS5pbnNlcnRCZWZvcmUobC5jbG9uZU5vZGUoITApLGUuZmlyc3RDaGlsZCk7ZWxzZSBpZihuKXtvLmluc2VydEJlZm9yZShhLG8uZmlyc3RDaGlsZCk7Y29uc3QgdD1uZXcgU2V0O3QuYWRkKGEpLGgobix0KX19O3dpbmRvdy5KU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5PSh0LGUpPT50O2NvbnN0IFc9e3RvQXR0cmlidXRlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgQm9vbGVhbjpyZXR1cm4gdD9cIlwiOm51bGw7Y2FzZSBPYmplY3Q6Y2FzZSBBcnJheTpyZXR1cm4gbnVsbD09dD90OkpTT04uc3RyaW5naWZ5KHQpfXJldHVybiB0fSxmcm9tQXR0cmlidXRlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgQm9vbGVhbjpyZXR1cm4gbnVsbCE9PXQ7Y2FzZSBOdW1iZXI6cmV0dXJuIG51bGw9PT10P251bGw6TnVtYmVyKHQpO2Nhc2UgT2JqZWN0OmNhc2UgQXJyYXk6cmV0dXJuIEpTT04ucGFyc2UodCl9cmV0dXJuIHR9fSxqPSh0LGUpPT5lIT09dCYmKGU9PWV8fHQ9PXQpLHE9e2F0dHJpYnV0ZTohMCx0eXBlOlN0cmluZyxjb252ZXJ0ZXI6VyxyZWZsZWN0OiExLGhhc0NoYW5nZWQ6an07Y2xhc3MgWCBleHRlbmRzIEhUTUxFbGVtZW50e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmluaXRpYWxpemUoKX1zdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpe3RoaXMuZmluYWxpemUoKTtjb25zdCB0PVtdO3JldHVybiB0aGlzLl9jbGFzc1Byb3BlcnRpZXMuZm9yRWFjaCgoKGUsbik9Pntjb25zdCBpPXRoaXMuX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShuLGUpO3ZvaWQgMCE9PWkmJih0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwLnNldChpLG4pLHQucHVzaChpKSl9KSksdH1zdGF0aWMgX2Vuc3VyZUNsYXNzUHJvcGVydGllcygpe2lmKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoXCJfY2xhc3NQcm9wZXJ0aWVzXCIsdGhpcykpKXt0aGlzLl9jbGFzc1Byb3BlcnRpZXM9bmV3IE1hcDtjb25zdCB0PU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fY2xhc3NQcm9wZXJ0aWVzO3ZvaWQgMCE9PXQmJnQuZm9yRWFjaCgoKHQsZSk9PnRoaXMuX2NsYXNzUHJvcGVydGllcy5zZXQoZSx0KSkpfX1zdGF0aWMgY3JlYXRlUHJvcGVydHkodCxlPXEpe2lmKHRoaXMuX2Vuc3VyZUNsYXNzUHJvcGVydGllcygpLHRoaXMuX2NsYXNzUHJvcGVydGllcy5zZXQodCxlKSxlLm5vQWNjZXNzb3J8fHRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KHQpKXJldHVybjtjb25zdCBuPVwic3ltYm9sXCI9PXR5cGVvZiB0P1N5bWJvbCgpOmBfXyR7dH1gLGk9dGhpcy5nZXRQcm9wZXJ0eURlc2NyaXB0b3IodCxuLGUpO3ZvaWQgMCE9PWkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSx0LGkpfXN0YXRpYyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IodCxlLG4pe3JldHVybntnZXQoKXtyZXR1cm4gdGhpc1tlXX0sc2V0KGkpe2NvbnN0IHI9dGhpc1t0XTt0aGlzW2VdPWksdGhpcy5yZXF1ZXN0VXBkYXRlSW50ZXJuYWwodCxyLG4pfSxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMH19c3RhdGljIGdldFByb3BlcnR5T3B0aW9ucyh0KXtyZXR1cm4gdGhpcy5fY2xhc3NQcm9wZXJ0aWVzJiZ0aGlzLl9jbGFzc1Byb3BlcnRpZXMuZ2V0KHQpfHxxfXN0YXRpYyBmaW5hbGl6ZSgpe2NvbnN0IHQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO2lmKHQuaGFzT3duUHJvcGVydHkoXCJmaW5hbGl6ZWRcIil8fHQuZmluYWxpemUoKSx0aGlzLmZpbmFsaXplZD0hMCx0aGlzLl9lbnN1cmVDbGFzc1Byb3BlcnRpZXMoKSx0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwPW5ldyBNYXAsdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KFwicHJvcGVydGllc1wiLHRoaXMpKSl7Y29uc3QgdD10aGlzLnByb3BlcnRpZXMsZT1bLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCksLi4uXCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scz9PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpOltdXTtmb3IoY29uc3QgbiBvZiBlKXRoaXMuY3JlYXRlUHJvcGVydHkobix0W25dKX19c3RhdGljIF9hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkodCxlKXtjb25zdCBuPWUuYXR0cmlidXRlO3JldHVybiExPT09bj92b2lkIDA6XCJzdHJpbmdcIj09dHlwZW9mIG4/bjpcInN0cmluZ1wiPT10eXBlb2YgdD90LnRvTG93ZXJDYXNlKCk6dm9pZCAwfXN0YXRpYyBfdmFsdWVIYXNDaGFuZ2VkKHQsZSxuPWope3JldHVybiBuKHQsZSl9c3RhdGljIF9wcm9wZXJ0eVZhbHVlRnJvbUF0dHJpYnV0ZSh0LGUpe2NvbnN0IG49ZS50eXBlLGk9ZS5jb252ZXJ0ZXJ8fFcscj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpP2k6aS5mcm9tQXR0cmlidXRlO3JldHVybiByP3IodCxuKTp0fXN0YXRpYyBfcHJvcGVydHlWYWx1ZVRvQXR0cmlidXRlKHQsZSl7aWYodm9pZCAwPT09ZS5yZWZsZWN0KXJldHVybjtjb25zdCBuPWUudHlwZSxpPWUuY29udmVydGVyO3JldHVybihpJiZpLnRvQXR0cmlidXRlfHxXLnRvQXR0cmlidXRlKSh0LG4pfWluaXRpYWxpemUoKXt0aGlzLl91cGRhdGVTdGF0ZT0wLHRoaXMuX3VwZGF0ZVByb21pc2U9bmV3IFByb21pc2UoKHQ9PnRoaXMuX2VuYWJsZVVwZGF0aW5nUmVzb2x2ZXI9dCkpLHRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzPW5ldyBNYXAsdGhpcy5fc2F2ZUluc3RhbmNlUHJvcGVydGllcygpLHRoaXMucmVxdWVzdFVwZGF0ZUludGVybmFsKCl9X3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKXt0aGlzLmNvbnN0cnVjdG9yLl9jbGFzc1Byb3BlcnRpZXMuZm9yRWFjaCgoKHQsZSk9PntpZih0aGlzLmhhc093blByb3BlcnR5KGUpKXtjb25zdCB0PXRoaXNbZV07ZGVsZXRlIHRoaXNbZV0sdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzfHwodGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzPW5ldyBNYXApLHRoaXMuX2luc3RhbmNlUHJvcGVydGllcy5zZXQoZSx0KX19KSl9X2FwcGx5SW5zdGFuY2VQcm9wZXJ0aWVzKCl7dGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzLmZvckVhY2goKCh0LGUpPT50aGlzW2VdPXQpKSx0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXM9dm9pZCAwfWNvbm5lY3RlZENhbGxiYWNrKCl7dGhpcy5lbmFibGVVcGRhdGluZygpfWVuYWJsZVVwZGF0aW5nKCl7dm9pZCAwIT09dGhpcy5fZW5hYmxlVXBkYXRpbmdSZXNvbHZlciYmKHRoaXMuX2VuYWJsZVVwZGF0aW5nUmVzb2x2ZXIoKSx0aGlzLl9lbmFibGVVcGRhdGluZ1Jlc29sdmVyPXZvaWQgMCl9ZGlzY29ubmVjdGVkQ2FsbGJhY2soKXt9YXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHQsZSxuKXtlIT09biYmdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eSh0LG4pfV9wcm9wZXJ0eVRvQXR0cmlidXRlKHQsZSxuPXEpe2NvbnN0IGk9dGhpcy5jb25zdHJ1Y3RvcixyPWkuX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eSh0LG4pO2lmKHZvaWQgMCE9PXIpe2NvbnN0IHQ9aS5fcHJvcGVydHlWYWx1ZVRvQXR0cmlidXRlKGUsbik7aWYodm9pZCAwPT09dClyZXR1cm47dGhpcy5fdXBkYXRlU3RhdGU9OHx0aGlzLl91cGRhdGVTdGF0ZSxudWxsPT10P3RoaXMucmVtb3ZlQXR0cmlidXRlKHIpOnRoaXMuc2V0QXR0cmlidXRlKHIsdCksdGhpcy5fdXBkYXRlU3RhdGU9LTkmdGhpcy5fdXBkYXRlU3RhdGV9fV9hdHRyaWJ1dGVUb1Byb3BlcnR5KHQsZSl7aWYoOCZ0aGlzLl91cGRhdGVTdGF0ZSlyZXR1cm47Y29uc3Qgbj10aGlzLmNvbnN0cnVjdG9yLGk9bi5fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcC5nZXQodCk7aWYodm9pZCAwIT09aSl7Y29uc3QgdD1uLmdldFByb3BlcnR5T3B0aW9ucyhpKTt0aGlzLl91cGRhdGVTdGF0ZT0xNnx0aGlzLl91cGRhdGVTdGF0ZSx0aGlzW2ldPW4uX3Byb3BlcnR5VmFsdWVGcm9tQXR0cmlidXRlKGUsdCksdGhpcy5fdXBkYXRlU3RhdGU9LTE3JnRoaXMuX3VwZGF0ZVN0YXRlfX1yZXF1ZXN0VXBkYXRlSW50ZXJuYWwodCxlLG4pe2xldCBpPSEwO2lmKHZvaWQgMCE9PXQpe2NvbnN0IHI9dGhpcy5jb25zdHJ1Y3RvcjtuPW58fHIuZ2V0UHJvcGVydHlPcHRpb25zKHQpLHIuX3ZhbHVlSGFzQ2hhbmdlZCh0aGlzW3RdLGUsbi5oYXNDaGFuZ2VkKT8odGhpcy5fY2hhbmdlZFByb3BlcnRpZXMuaGFzKHQpfHx0aGlzLl9jaGFuZ2VkUHJvcGVydGllcy5zZXQodCxlKSwhMCE9PW4ucmVmbGVjdHx8MTYmdGhpcy5fdXBkYXRlU3RhdGV8fCh2b2lkIDA9PT10aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyYmKHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzPW5ldyBNYXApLHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzLnNldCh0LG4pKSk6aT0hMX0hdGhpcy5faGFzUmVxdWVzdGVkVXBkYXRlJiZpJiYodGhpcy5fdXBkYXRlUHJvbWlzZT10aGlzLl9lbnF1ZXVlVXBkYXRlKCkpfXJlcXVlc3RVcGRhdGUodCxlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0VXBkYXRlSW50ZXJuYWwodCxlKSx0aGlzLnVwZGF0ZUNvbXBsZXRlfWFzeW5jIF9lbnF1ZXVlVXBkYXRlKCl7dGhpcy5fdXBkYXRlU3RhdGU9NHx0aGlzLl91cGRhdGVTdGF0ZTt0cnl7YXdhaXQgdGhpcy5fdXBkYXRlUHJvbWlzZX1jYXRjaCh0KXt9Y29uc3QgdD10aGlzLnBlcmZvcm1VcGRhdGUoKTtyZXR1cm4gbnVsbCE9dCYmYXdhaXQgdCwhdGhpcy5faGFzUmVxdWVzdGVkVXBkYXRlfWdldCBfaGFzUmVxdWVzdGVkVXBkYXRlKCl7cmV0dXJuIDQmdGhpcy5fdXBkYXRlU3RhdGV9Z2V0IGhhc1VwZGF0ZWQoKXtyZXR1cm4gMSZ0aGlzLl91cGRhdGVTdGF0ZX1wZXJmb3JtVXBkYXRlKCl7aWYoIXRoaXMuX2hhc1JlcXVlc3RlZFVwZGF0ZSlyZXR1cm47dGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzJiZ0aGlzLl9hcHBseUluc3RhbmNlUHJvcGVydGllcygpO2xldCB0PSExO2NvbnN0IGU9dGhpcy5fY2hhbmdlZFByb3BlcnRpZXM7dHJ5e3Q9dGhpcy5zaG91bGRVcGRhdGUoZSksdD90aGlzLnVwZGF0ZShlKTp0aGlzLl9tYXJrVXBkYXRlZCgpfWNhdGNoKGUpe3Rocm93IHQ9ITEsdGhpcy5fbWFya1VwZGF0ZWQoKSxlfXQmJigxJnRoaXMuX3VwZGF0ZVN0YXRlfHwodGhpcy5fdXBkYXRlU3RhdGU9MXx0aGlzLl91cGRhdGVTdGF0ZSx0aGlzLmZpcnN0VXBkYXRlZChlKSksdGhpcy51cGRhdGVkKGUpKX1fbWFya1VwZGF0ZWQoKXt0aGlzLl9jaGFuZ2VkUHJvcGVydGllcz1uZXcgTWFwLHRoaXMuX3VwZGF0ZVN0YXRlPS01JnRoaXMuX3VwZGF0ZVN0YXRlfWdldCB1cGRhdGVDb21wbGV0ZSgpe3JldHVybiB0aGlzLl9nZXRVcGRhdGVDb21wbGV0ZSgpfV9nZXRVcGRhdGVDb21wbGV0ZSgpe3JldHVybiB0aGlzLmdldFVwZGF0ZUNvbXBsZXRlKCl9Z2V0VXBkYXRlQ29tcGxldGUoKXtyZXR1cm4gdGhpcy5fdXBkYXRlUHJvbWlzZX1zaG91bGRVcGRhdGUodCl7cmV0dXJuITB9dXBkYXRlKHQpe3ZvaWQgMCE9PXRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzJiZ0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcy5zaXplPjAmJih0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcy5mb3JFYWNoKCgodCxlKT0+dGhpcy5fcHJvcGVydHlUb0F0dHJpYnV0ZShlLHRoaXNbZV0sdCkpKSx0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcz12b2lkIDApLHRoaXMuX21hcmtVcGRhdGVkKCl9dXBkYXRlZCh0KXt9Zmlyc3RVcGRhdGVkKHQpe319WC5maW5hbGl6ZWQ9ITA7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5jb25zdCBZPSh0LGUpPT5cIm1ldGhvZFwiPT09ZS5raW5kJiZlLmRlc2NyaXB0b3ImJiEoXCJ2YWx1ZVwiaW4gZS5kZXNjcmlwdG9yKT9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2ZpbmlzaGVyKG4pe24uY3JlYXRlUHJvcGVydHkoZS5rZXksdCl9fSk6e2tpbmQ6XCJmaWVsZFwiLGtleTpTeW1ib2woKSxwbGFjZW1lbnQ6XCJvd25cIixkZXNjcmlwdG9yOnt9LGluaXRpYWxpemVyKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgZS5pbml0aWFsaXplciYmKHRoaXNbZS5rZXldPWUuaW5pdGlhbGl6ZXIuY2FsbCh0aGlzKSl9LGZpbmlzaGVyKG4pe24uY3JlYXRlUHJvcGVydHkoZS5rZXksdCl9fTtmdW5jdGlvbiBaKHQpe3JldHVybihlLG4pPT52b2lkIDAhPT1uPygodCxlLG4pPT57ZS5jb25zdHJ1Y3Rvci5jcmVhdGVQcm9wZXJ0eShuLHQpfSkodCxlLG4pOlkodCxlKX1cbi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxOSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlXG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dCBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhc1xucGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudFxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL2NvbnN0IEo9d2luZG93LlNoYWRvd1Jvb3QmJih2b2lkIDA9PT13aW5kb3cuU2hhZHlDU1N8fHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVTaGFkb3cpJiZcImFkb3B0ZWRTdHlsZVNoZWV0c1wiaW4gRG9jdW1lbnQucHJvdG90eXBlJiZcInJlcGxhY2VcImluIENTU1N0eWxlU2hlZXQucHJvdG90eXBlLCQ9U3ltYm9sKCk7Y2xhc3MgS3tjb25zdHJ1Y3Rvcih0LGUpe2lmKGUhPT0kKXRocm93IG5ldyBFcnJvcihcIkNTU1Jlc3VsdCBpcyBub3QgY29uc3RydWN0YWJsZS4gVXNlIGB1bnNhZmVDU1NgIG9yIGBjc3NgIGluc3RlYWQuXCIpO3RoaXMuY3NzVGV4dD10fWdldCBzdHlsZVNoZWV0KCl7cmV0dXJuIHZvaWQgMD09PXRoaXMuX3N0eWxlU2hlZXQmJihKPyh0aGlzLl9zdHlsZVNoZWV0PW5ldyBDU1NTdHlsZVNoZWV0LHRoaXMuX3N0eWxlU2hlZXQucmVwbGFjZVN5bmModGhpcy5jc3NUZXh0KSk6dGhpcy5fc3R5bGVTaGVldD1udWxsKSx0aGlzLl9zdHlsZVNoZWV0fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY3NzVGV4dH19XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4od2luZG93LmxpdEVsZW1lbnRWZXJzaW9uc3x8KHdpbmRvdy5saXRFbGVtZW50VmVyc2lvbnM9W10pKS5wdXNoKFwiMi41LjFcIik7Y29uc3QgUT17fTtjbGFzcyB0dCBleHRlbmRzIFh7c3RhdGljIGdldFN0eWxlcygpe3JldHVybiB0aGlzLnN0eWxlc31zdGF0aWMgX2dldFVuaXF1ZVN0eWxlcygpe2lmKHRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eShcIl9zdHlsZXNcIix0aGlzKSkpcmV0dXJuO2NvbnN0IHQ9dGhpcy5nZXRTdHlsZXMoKTtpZihBcnJheS5pc0FycmF5KHQpKXtjb25zdCBlPSh0LG4pPT50LnJlZHVjZVJpZ2h0KCgodCxuKT0+QXJyYXkuaXNBcnJheShuKT9lKG4sdCk6KHQuYWRkKG4pLHQpKSxuKSxuPWUodCxuZXcgU2V0KSxpPVtdO24uZm9yRWFjaCgodD0+aS51bnNoaWZ0KHQpKSksdGhpcy5fc3R5bGVzPWl9ZWxzZSB0aGlzLl9zdHlsZXM9dm9pZCAwPT09dD9bXTpbdF07dGhpcy5fc3R5bGVzPXRoaXMuX3N0eWxlcy5tYXAoKHQ9PntpZih0IGluc3RhbmNlb2YgQ1NTU3R5bGVTaGVldCYmIUope2NvbnN0IGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodC5jc3NSdWxlcykucmVkdWNlKCgodCxlKT0+dCtlLmNzc1RleHQpLFwiXCIpO3JldHVybiBuZXcgSyhTdHJpbmcoZSksJCl9cmV0dXJuIHR9KSl9aW5pdGlhbGl6ZSgpe3N1cGVyLmluaXRpYWxpemUoKSx0aGlzLmNvbnN0cnVjdG9yLl9nZXRVbmlxdWVTdHlsZXMoKSx0aGlzLnJlbmRlclJvb3Q9dGhpcy5jcmVhdGVSZW5kZXJSb290KCksd2luZG93LlNoYWRvd1Jvb3QmJnRoaXMucmVuZGVyUm9vdCBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290JiZ0aGlzLmFkb3B0U3R5bGVzKCl9Y3JlYXRlUmVuZGVyUm9vdCgpe3JldHVybiB0aGlzLmF0dGFjaFNoYWRvdyh0aGlzLmNvbnN0cnVjdG9yLnNoYWRvd1Jvb3RPcHRpb25zKX1hZG9wdFN0eWxlcygpe2NvbnN0IHQ9dGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVzOzAhPT10Lmxlbmd0aCYmKHZvaWQgMD09PXdpbmRvdy5TaGFkeUNTU3x8d2luZG93LlNoYWR5Q1NTLm5hdGl2ZVNoYWRvdz9KP3RoaXMucmVuZGVyUm9vdC5hZG9wdGVkU3R5bGVTaGVldHM9dC5tYXAoKHQ9PnQgaW5zdGFuY2VvZiBDU1NTdHlsZVNoZWV0P3Q6dC5zdHlsZVNoZWV0KSk6dGhpcy5fbmVlZHNTaGltQWRvcHRlZFN0eWxlU2hlZXRzPSEwOndpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbS5wcmVwYXJlQWRvcHRlZENzc1RleHQodC5tYXAoKHQ9PnQuY3NzVGV4dCkpLHRoaXMubG9jYWxOYW1lKSl9Y29ubmVjdGVkQ2FsbGJhY2soKXtzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpLHRoaXMuaGFzVXBkYXRlZCYmdm9pZCAwIT09d2luZG93LlNoYWR5Q1NTJiZ3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KHRoaXMpfXVwZGF0ZSh0KXtjb25zdCBlPXRoaXMucmVuZGVyKCk7c3VwZXIudXBkYXRlKHQpLGUhPT1RJiZ0aGlzLmNvbnN0cnVjdG9yLnJlbmRlcihlLHRoaXMucmVuZGVyUm9vdCx7c2NvcGVOYW1lOnRoaXMubG9jYWxOYW1lLGV2ZW50Q29udGV4dDp0aGlzfSksdGhpcy5fbmVlZHNTaGltQWRvcHRlZFN0eWxlU2hlZXRzJiYodGhpcy5fbmVlZHNTaGltQWRvcHRlZFN0eWxlU2hlZXRzPSExLHRoaXMuY29uc3RydWN0b3IuX3N0eWxlcy5mb3JFYWNoKCh0PT57Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS50ZXh0Q29udGVudD10LmNzc1RleHQsdGhpcy5yZW5kZXJSb290LmFwcGVuZENoaWxkKGUpfSkpKX1yZW5kZXIoKXtyZXR1cm4gUX19dHQuZmluYWxpemVkPSEwLHR0LnJlbmRlcj0odCxuLGkpPT57aWYoIWl8fFwib2JqZWN0XCIhPXR5cGVvZiBpfHwhaS5zY29wZU5hbWUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBzY29wZU5hbWVgIG9wdGlvbiBpcyByZXF1aXJlZC5cIik7Y29uc3Qgcj1pLnNjb3BlTmFtZSxzPU4uaGFzKG4pLGE9eiYmMTE9PT1uLm5vZGVUeXBlJiYhIW4uaG9zdCxvPWEmJiFWLmhhcyhyKSxsPW8/ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOm47aWYoRih0LGwsT2JqZWN0LmFzc2lnbih7dGVtcGxhdGVGYWN0b3J5OkIocil9LGkpKSxvKXtjb25zdCB0PU4uZ2V0KGwpO04uZGVsZXRlKGwpO2NvbnN0IGk9dC52YWx1ZSBpbnN0YW5jZW9mIHY/dC52YWx1ZS50ZW1wbGF0ZTp2b2lkIDA7RyhyLGwsaSksZShuLG4uZmlyc3RDaGlsZCksbi5hcHBlbmRDaGlsZChsKSxOLnNldChuLHQpfSFzJiZhJiZ3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KG4uaG9zdCl9LHR0LnNoYWRvd1Jvb3RPcHRpb25zPXttb2RlOlwib3BlblwifTtcbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGV0PW51bGwhPW5hdmlnYXRvci54ciYmbnVsbCE9c2VsZi5YUlNlc3Npb24mJm51bGwhPW5hdmlnYXRvci54ci5pc1Nlc3Npb25TdXBwb3J0ZWQsbnQ9ZXQmJnNlbGYuWFJTZXNzaW9uLnByb3RvdHlwZS5yZXF1ZXN0SGl0VGVzdFNvdXJjZSxpdD1udWxsIT1zZWxmLlJlc2l6ZU9ic2VydmVyLHJ0PW51bGwhPXNlbGYuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsc3Q9bnQ7KCgpPT57Y29uc3QgdD1uYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHxzZWxmLm9wZXJhO2xldCBlPSExOygvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdCh0KXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdCh0LnN1YnN0cigwLDQpKSkmJihlPSEwKX0pKCksL1xcYkNyT1NcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7Y29uc3QgYXQ9L2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLG90PS9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhc2VsZi5NU1N0cmVhbXx8XCJNYWNJbnRlbFwiPT09bmF2aWdhdG9yLnBsYXRmb3JtJiZuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM+MSxsdD0oKCk9Pntjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO3JldHVybiBCb29sZWFuKHQucmVsTGlzdCYmdC5yZWxMaXN0LnN1cHBvcnRzJiZ0LnJlbExpc3Quc3VwcG9ydHMoXCJhclwiKSl9KSgpOy9TYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7Y29uc3QgY3Q9L2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLGh0PS9PY3VsdXNCcm93c2VyLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO290JiYvQ3JpT1NcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7Y29uc3QgdXQ9YXQmJiFjdCYmIWh0O1xuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZHQ9VWBcbjxzdHlsZT5cbjpob3N0IHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgY29udGFpbjogc3RyaWN0O1xuICB3aWR0aDogMzAwcHg7XG4gIGhlaWdodDogMTUwcHg7XG59XG5cbi8qIE5PVEU6IFRoaXMgcnVsZXNldCBpcyBvdXIgaW50ZWdyYXRpb24gc3VyZmFjZSBhcmVhIHdpdGggdGhlXG4gKiA6Zm9jdXMtdmlzaWJsZSBwb2x5ZmlsbC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUvcHVsbC8xOTYgKi9cbjpob3N0KFtkYXRhLWpzLWZvY3VzLXZpc2libGVdOmZvY3VzOm5vdCguZm9jdXMtdmlzaWJsZSkpLFxuOmhvc3QoW2RhdGEtanMtZm9jdXMtdmlzaWJsZV0pIDpmb2N1czpub3QoLmZvY3VzLXZpc2libGUpIHtcbiAgb3V0bGluZTogbm9uZTtcbn1cblxuLmNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLnVzZXJJbnB1dCB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbmNhbnZhcyB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIC8qIE5PVEUoY2RhdGEpOiBDaHJvbWUgNzYgYW5kIGJlbG93IGFwcGFyZW50bHkgaGF2ZSBhIGJ1Z1xuICAgKiB0aGF0IGNhdXNlcyBvdXIgY2FudmFzIG5vdCB0byBkaXNwbGF5IHBpeGVscyB1bmxlc3MgaXQgaXNcbiAgICogb24gaXRzIG93biByZW5kZXIgbGF5ZXJcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL21vZGVsLXZpZXdlci9wdWxsLzc1NSNpc3N1ZWNvbW1lbnQtNTM2NTk3ODkzXG4gICAqL1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG59XG5cbmNhbnZhcy5zaG93IHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi8qIEFkYXB0ZWQgZnJvbSBIVE1MNSBCb2lsZXJwbGF0ZVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2g1YnAvaHRtbDUtYm9pbGVycGxhdGUvYmxvYi9jZWI0NjIwYzc4ZmM4MmUxMzUzNGZjNDQyMDJhM2YxNjg3NTQ4NzNmL2Rpc3QvY3NzL21haW4uY3NzI0wxMjItTDEzMyAqL1xuLnNjcmVlbi1yZWFkZXItb25seSB7XG4gIGJvcmRlcjogMDtcbiAgY2xpcDogcmVjdCgwLCAwLCAwLCAwKTtcbiAgaGVpZ2h0OiAxcHg7XG4gIG1hcmdpbjogLTFweDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgcGFkZGluZzogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICB3aWR0aDogMXB4O1xufVxuXG4uc2xvdCB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbn1cblxuLnNsb3QgPiAqIHtcbiAgcG9pbnRlci1ldmVudHM6IGluaXRpYWw7XG59XG5cbi5hbm5vdGF0aW9uLXdyYXBwZXIgOjpzbG90dGVkKCopIHtcbiAgb3BhY2l0eTogdmFyKC0tbWF4LWhvdHNwb3Qtb3BhY2l0eSwgMSk7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcbn1cblxuLnBvaW50ZXItdHVtYmxpbmcgLmFubm90YXRpb24td3JhcHBlciA6OnNsb3R0ZWQoKikge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuLmFubm90YXRpb24td3JhcHBlciA6OnNsb3R0ZWQoKikge1xuICBwb2ludGVyLWV2ZW50czogaW5pdGlhbDtcbn1cblxuLmFubm90YXRpb24td3JhcHBlci5oaWRlIDo6c2xvdHRlZCgqKSB7XG4gIG9wYWNpdHk6IHZhcigtLW1pbi1ob3RzcG90LW9wYWNpdHksIDAuMjUpO1xufVxuXG4uc2xvdC5wb3N0ZXIge1xuICBvcGFjaXR5OiAwO1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgMC4zcztcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcbn1cblxuLnNsb3QucG9zdGVyLnNob3cge1xuICBvcGFjaXR5OiAxO1xuICB0cmFuc2l0aW9uOiBub25lO1xufVxuXG4uc2xvdC5wb3N0ZXIucXVpY2sge1xuICB0cmFuc2l0aW9uOiBub25lO1xufVxuXG4uc2xvdC5wb3N0ZXIgPiAqIHtcbiAgcG9pbnRlci1ldmVudHM6IGluaXRpYWw7XG59XG5cbi5zbG90LnBvc3Rlcjpub3QoLnNob3cpID4gKiB7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuXG4jZGVmYXVsdC1wb3N0ZXIge1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICAvKiBUaGUgZGVmYXVsdCBwb3N0ZXIgaXMgYSA8YnV0dG9uPiBzbyB3ZSBuZWVkIHRvIHNldCBkaXNwbGF5XG4gICAqIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZmZlY3RlZCBieSB0ZXh0LWFsaWduOiAqL1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBib3JkZXI6IG5vbmU7XG4gIHBhZGRpbmc6IDA7XG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wb3N0ZXItY29sb3IsICNmZmYpO1xuICBiYWNrZ3JvdW5kLWltYWdlOiB2YXIoLS1wb3N0ZXItaW1hZ2UsIG5vbmUpO1xufVxuXG4jZGVmYXVsdC1wcm9ncmVzcy1iYXIge1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuI2RlZmF1bHQtcHJvZ3Jlc3MtYmFyID4gLm1hc2sge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgYmFja2dyb3VuZDogdmFyKC0tcHJvZ3Jlc3MtbWFzaywgI2ZmZik7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcbiAgb3BhY2l0eTogMC4yO1xufVxuXG4jZGVmYXVsdC1wcm9ncmVzcy1iYXIgPiAuYmFyIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IHZhcigtLXByb2dyZXNzLWJhci1oZWlnaHQsIDVweCk7XG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXByb2dyZXNzLWJhci1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjQpKTtcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMDlzO1xuICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcbiAgdHJhbnNmb3JtOiBzY2FsZVgoMCk7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbiNkZWZhdWx0LXByb2dyZXNzLWJhciA+IC5iYXIuaGlkZSB7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyAxcztcbiAgb3BhY2l0eTogMDtcbn1cblxuLnNsb3QuaW50ZXJhY3Rpb24tcHJvbXB0IHtcbiAgZGlzcGxheTogdmFyKC0taW50ZXJhY3Rpb24tcHJvbXB0LWRpc3BsYXksIGZsZXgpO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXG4gIG9wYWNpdHk6IDA7XG4gIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XG59XG5cbi5zbG90LmludGVyYWN0aW9uLXByb21wdC52aXNpYmxlIHtcbiAgb3BhY2l0eTogMTtcbn1cblxuLnNsb3QuaW50ZXJhY3Rpb24tcHJvbXB0ID4gLmFuaW1hdGVkLWNvbnRhaW5lciB7XG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm0sIG9wYWNpdHk7XG59XG5cbi5zbG90LmludGVyYWN0aW9uLXByb21wdCA+ICoge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuLnNsb3QuYXItYnV0dG9uIHtcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG5cbiAgZGlzcGxheTogdmFyKC0tYXItYnV0dG9uLWRpc3BsYXksIGJsb2NrKTtcbn1cblxuLnNsb3QuYXItYnV0dG9uOm5vdCguZW5hYmxlZCkge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4uZmFiIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIHdpZHRoOiA0MHB4O1xuICBoZWlnaHQ6IDQwcHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgYm94LXNoYWRvdzogMHB4IDBweCA0cHggcmdiYSgwLCAwLCAwLCAwLjE1KTtcbiAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG59XG5cbi5mYWIgPiAqIHtcbiAgb3BhY2l0eTogMC44Nztcbn1cblxuI2RlZmF1bHQtYXItYnV0dG9uIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBib3R0b206IDE2cHg7XG4gIHJpZ2h0OiAxNnB4O1xuICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWFyLWJ1dHRvbi1zY2FsZSwgMSkpO1xuICB0cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gcmlnaHQ7XG59XG5cbi5zbG90LmRlZmF1bHQge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuLnNsb3QucHJvZ3Jlc3MtYmFyIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG5cbi5zbG90LmV4aXQtd2VieHItYXItYnV0dG9uIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG5cbi5zbG90LmV4aXQtd2VieHItYXItYnV0dG9uOm5vdCguZW5hYmxlZCkge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4jZGVmYXVsdC1leGl0LXdlYnhyLWFyLWJ1dHRvbiB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMTZweDtcbiAgcmlnaHQ6IDE2cHg7XG4gIHdpZHRoOiA0MHB4O1xuICBoZWlnaHQ6IDQwcHg7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG59XG5cbiNkZWZhdWx0LWV4aXQtd2VieHItYXItYnV0dG9uID4gc3ZnIHtcbiAgZmlsbDogI2ZmZjtcbn1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gIDxkaXYgY2xhc3M9XCJ1c2VySW5wdXRcIiB0YWJpbmRleD1cIjBcIiByb2xlPVwiaW1nXCJcbiAgICAgIGFyaWEtbGFiZWw9XCJBIGRlcGljdGlvbiBvZiBhIDNEIG1vZGVsXCJcbiAgICAgIGFyaWEtbGl2ZT1cInBvbGl0ZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInNsb3QgY2FudmFzXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJjYW52YXNcIj5cbiAgICAgICAgICA8Y2FudmFzPjwvY2FudmFzPlxuICAgICAgICA8L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPCEtLSBOT1RFKGNkYXRhKTogV2UgbmVlZCB0byB3cmFwIHNsb3RzIGJlY2F1c2UgYnJvd3NlcnMgd2l0aG91dCBTaGFkb3dET01cbiAgICAgICAgd2lsbCBoYXZlIHRoZWlyIDxzbG90PiBlbGVtZW50cyByZW1vdmVkIGJ5IFNoYWR5Q1NTIC0tPlxuICA8ZGl2IGNsYXNzPVwic2xvdCBwb3N0ZXJcIj5cbiAgICA8c2xvdCBuYW1lPVwicG9zdGVyXCI+XG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD1cImRlZmF1bHQtcG9zdGVyXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgYXJpYS1sYWJlbD1cIkFjdGl2YXRlIHRvIHZpZXcgaW4gM0QhXCI+PC9idXR0b24+XG4gICAgPC9zbG90PlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwic2xvdCBhci1idXR0b25cIj5cbiAgICA8c2xvdCBuYW1lPVwiYXItYnV0dG9uXCI+XG4gICAgICA8YSBpZD1cImRlZmF1bHQtYXItYnV0dG9uXCIgcGFydD1cImRlZmF1bHQtYXItYnV0dG9uXCIgY2xhc3M9XCJmYWJcIlxuICAgICAgICAgIHRhYmluZGV4PVwiMlwiXG4gICAgICAgICAgYXJpYS1sYWJlbD1cIlZpZXcgdGhpcyAzRCBtb2RlbCB1cCBjbG9zZVwiPlxuICAgICAgICAke1VgXG48c3ZnIHZlcnNpb249XCIxLjFcIiBpZD1cInZpZXdfeDVGX2luX3g1Rl9BUl94NUZfaWNvblwiXG5cdCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjI0cHhcIiBoZWlnaHQ9XCIyNHB4XCJcblx0IHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgMjQgMjRcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxuPHJlY3QgaWQ9XCJCb3VuZGluZ19Cb3hcIiB4PVwiMFwiIHk9XCIwXCIgZmlsbD1cIm5vbmVcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIi8+XG48ZyBpZD1cIkFydF9sYXllclwiPlxuXHQ8cGF0aCBkPVwiTTMsNGMwLTAuNTUsMC40NS0xLDEtMWgyVjFINEMyLjM1LDEsMSwyLjM1LDEsNHYyaDJWNHpcIi8+XG5cdDxwYXRoIGQ9XCJNMjAsM2MwLjU1LDAsMSwwLjQ1LDEsMXYyaDJWNGMwLTEuNjUtMS4zNS0zLTMtM2gtMnYySDIwelwiLz5cblx0PHBhdGggZD1cIk00LDIxYy0wLjU1LDAtMS0wLjQ1LTEtMXYtMkgxdjJjMCwxLjY1LDEuMzUsMywzLDNoMnYtMkg0elwiLz5cblx0PHBhdGggZD1cIk0yMCwyMWMwLjU1LDAsMS0wLjQ1LDEtMXYtMmgydjJjMCwxLjY1LTEuMzUsMy0zLDNoLTJ2LTJIMjB6XCIvPlxuXHQ8Zz5cblx0XHQ8cGF0aCBkPVwiTTE4LjI1LDcuNmwtNS41LTMuMThjLTAuNDYtMC4yNy0xLjA0LTAuMjctMS41LDBMNS43NSw3LjZDNS4yOSw3Ljg3LDUsOC4zNiw1LDguOXY2LjM1YzAsMC41NCwwLjI5LDEuMDMsMC43NSwxLjNcblx0XHRcdGw1LjUsMy4xOGMwLjQ2LDAuMjcsMS4wNCwwLjI3LDEuNSwwbDUuNS0zLjE4YzAuNDYtMC4yNywwLjc1LTAuNzYsMC43NS0xLjNWOC45QzE5LDguMzYsMTguNzEsNy44NywxOC4yNSw3LjZ6IE03LDE0Ljk2di00LjYyXG5cdFx0XHRsNCwyLjMydjQuNjFMNywxNC45NnogTTEyLDEwLjkzTDgsOC42MWw0LTIuMzFsNCwyLjMxTDEyLDEwLjkzeiBNMTMsMTcuMjd2LTQuNjFsNC0yLjMydjQuNjJMMTMsMTcuMjd6XCIvPlxuXHQ8L2c+XG48L2c+XG48L3N2Zz5gfVxuICAgICAgPC9hPlxuICAgIDwvc2xvdD5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cInNsb3QgaW50ZXJhY3Rpb24tcHJvbXB0XCI+XG4gICAgPGRpdiBjbGFzcz1cImFuaW1hdGVkLWNvbnRhaW5lclwiPlxuICAgICAgPHNsb3QgbmFtZT1cImludGVyYWN0aW9uLXByb21wdFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAke1VgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiMzZcIj5cbiAgICA8ZGVmcz5cbiAgICAgICAgPHBhdGggaWQ9XCJBXCIgZD1cIk0uMDAxLjIzMmgyNC45OTdWMzZILjAwMXpcIiAvPlxuICAgIDwvZGVmcz5cbiAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTExIC00KVwiIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICA8cGF0aCBmaWxsLW9wYWNpdHk9XCIwXCIgZmlsbD1cIiNmZmZcIiBkPVwiTTAgMGg0NHY0NEgwelwiIC8+XG4gICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMSAzKVwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk04LjczMyAxMS4xNjVjLjA0LTEuMTA4Ljc2Ni0yLjAyNyAxLjc0My0yLjMwN2EyLjU0IDIuNTQgMCAwIDEgLjYyOC0uMDg5Yy4xNiAwIC4zMTQuMDE3LjQ2My4wNDQgMS4wODguMiAxLjkgMS4wOTIgMS45IDIuMTZ2OC44OGgxLjI2YzIuOTQzLTEuMzkgNS00LjQ1IDUtOC4wMjVhOS4wMSA5LjAxIDAgMCAwLTEuOS01LjU2bC0uNDMtLjVjLS43NjUtLjgzOC0xLjY4My0xLjUyMi0yLjcxMi0yLTEuMDU3LS40OS0yLjIyNi0uNzctMy40Ni0uNzdzLTIuNC4yNzgtMy40Ni43N2MtMS4wMy40NzgtMS45NDcgMS4xNjItMi43MSAybC0uNDMuNWE5LjAxIDkuMDEgMCAwIDAtMS45IDUuNTYgOS4wNCA5LjA0IDAgMCAwIC4wOTQgMS4zMDVjLjAzLjIxLjA4OC40MS4xMy42MTdsLjEzNi42MjRjLjA4My4yODYuMTk2LjU2LjMwNS44MzJsLjEyNC4zMzNhOC43OCA4Ljc4IDAgMCAwIC41MDkuOTUzbC4wNjUuMTIyYTguNjkgOC42OSAwIDAgMCAzLjUyMSAzLjE5MWwxLjExLjUzN3YtOS4xNzh6XCIgZmlsbC1vcGFjaXR5PVwiLjVcIiBmaWxsPVwiI2U0ZTRlNFwiIC8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTIyLjk0IDI2LjIxOGwtMi43NiA3Ljc0Yy0uMTcyLjQ4NS0uNjc2LjgtMS4yNTMuOEgxMi4yNGMtMS42MDYgMC0zLjA5Mi0uNjgtMy45OC0xLjgyLTEuNTkyLTIuMDQ4LTMuNjQ3LTMuODIyLTYuMTEtNS4yNy0uMDk1LS4wNTUtLjE1LS4xMzctLjE1Mi0uMjMtLjAwNC0uMS4wNDYtLjE5Ni4xOTMtLjI5Ny41Ni0uMzkzIDEuMjM0LS42IDEuOTI2LS42YTMuNDMgMy40MyAwIDAgMSAuNjkxLjA2OWw0LjkyMi45OTRWMTAuOTcyYzAtLjY2My42MTUtMS4yMDMgMS4zNy0xLjIwM3MxLjM3My41NCAxLjM3MyAxLjIwM3Y5Ljg4MmgyLjk1M2MuMjczIDAgLjUzMy4wNzMuNzU3LjIxbDYuMjU3IDMuODc0Yy4wMjcuMDE3LjA0NS4wNDIuMDcuMDYuNDEuMjk2LjU4Ni43Ny40MjYgMS4yMk00LjEgMTYuNjE0Yy0uMDI0LS4wNC0uMDQyLS4wODMtLjA2NS0uMTIyYTguNjkgOC42OSAwIDAgMS0uNTA5LS45NTNjLS4wNDgtLjEwNy0uMDgtLjIyMy0uMTI0LS4zMzNsLS4zMDUtLjgzMmMtLjA1OC0uMjAyLS4wOS0uNDE2LS4xMzYtLjYyNGwtLjEzLS42MTdhOS4wMyA5LjAzIDAgMCAxLS4wOTQtMS4zMDVjMC0yLjEwNy43MTQtNC4wNCAxLjktNS41NmwuNDMtLjVjLjc2NC0uODQgMS42ODItMS41MjMgMi43MS0yIDEuMDU4LS40OSAyLjIyNi0uNzcgMy40Ni0uNzdzMi40MDIuMjggMy40Ni43N2MxLjAzLjQ3NyAxLjk0NyAxLjE2IDIuNzEyIDJsLjQyOC41YTkgOSAwIDAgMSAxLjkwMSA1LjU1OWMwIDMuNTc3LTIuMDU2IDYuNjM2LTUgOC4wMjZoLTEuMjZ2LTguODgyYzAtMS4wNjctLjgyMi0xLjk2LTEuOS0yLjE2LS4xNS0uMDI4LS4zMDQtLjA0NC0uNDYzLS4wNDQtLjIyIDAtLjQyNy4wMzctLjYyOC4wOS0uOTc3LjI4LTEuNzAzIDEuMTk4LTEuNzQzIDIuMzA2djkuMTc4bC0xLjExLS41MzdDNi4xOCAxOS4wOTggNC45NiAxOCA0LjEgMTYuNjE0TTIyLjk3IDI0LjA5bC02LjI1Ni0zLjg3NGMtLjEwMi0uMDYzLS4yMTgtLjA5OC0uMzMtLjE0NCAyLjY4My0xLjggNC4zNTQtNC44NTUgNC4zNTQtOC4yNDMgMC0uNDg2LS4wMzctLjk2NC0uMTA0LTEuNDNhOS45NyA5Ljk3IDAgMCAwLTEuNTctNC4xMjhsLS4yOTUtLjQwOC0uMDY2LS4wOTJhMTAuMDUgMTAuMDUgMCAwIDAtLjk0OS0xLjA3OGMtLjM0Mi0uMzM0LS43MDgtLjY0My0xLjA5NC0uOTIyLTEuMTU1LS44MzQtMi40OTItMS40MTItMy45NC0xLjY1bC0uNzMyLS4wODgtLjc0OC0uMDNhOS4yOSA5LjI5IDAgMCAwLTEuNDgyLjExOWMtMS40NDcuMjM4LTIuNzg2LjgxNi0zLjk0IDEuNjVhOS4zMyA5LjMzIDAgMCAwLS44MTMuNjg2IDkuNTkgOS41OSAwIDAgMC0uODQ1Ljg3N2wtLjM4NS40MzctLjM2LjUtLjI4OC40NjgtLjQxOC43NzgtLjA0LjA5Yy0uNTkzIDEuMjgtLjkzIDIuNzEtLjkzIDQuMjIyIDAgMy44MzIgMi4xODIgNy4zNDIgNS41NiA4LjkzOGwxLjQzNy42OHY0Ljk0Nkw1IDI1LjY0YTQuNDQgNC40NCAwIDAgMC0uODg4LS4wODZjLS4wMTcgMC0uMDM0LjAwMy0uMDUuMDAzLS4yNTIuMDA0LS41MDMuMDMzLS43NS4wOGE1LjA4IDUuMDggMCAwIDAtLjIzNy4wNTZjLS4xOTMuMDQ2LS4zODIuMTA3LS41NjguMTgtLjA3NS4wMy0uMTUuMDU3LS4yMjUuMS0uMjUuMTE0LS40OTQuMjQ0LS43MjMuNDA1YTEuMzEgMS4zMSAwIDAgMC0uNTY2IDEuMTIyIDEuMjggMS4yOCAwIDAgMCAuNjQ1IDEuMDUxQzQgMjkuOTI1IDUuOTYgMzEuNjE0IDcuNDczIDMzLjU2M2E1LjA2IDUuMDYgMCAwIDAgLjQzNC40OTFjMS4wODYgMS4wODIgMi42NTYgMS43MTMgNC4zMjYgMS43MTVoNi42OTdjLjc0OC0uMDAxIDEuNDMtLjMzMyAxLjg1OC0uODcyLjE0Mi0uMTguMjU2LS4zOC4zMzYtLjYwMmwyLjc1Ny03Ljc0Yy4wOTQtLjI2LjEzLS41My4xMTItLjc5NHMtLjA4OC0uNTItLjIwMy0uNzZhMi4xOSAyLjE5IDAgMCAwLS44MjEtLjkxXCIgZmlsbC1vcGFjaXR5PVwiLjZcIiBmaWxsPVwiIzAwMFwiIC8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTIyLjQ0NCAyNC45NGwtNi4yNTctMy44NzRhMS40NSAxLjQ1IDAgMCAwLS43NTctLjIxMWgtMi45NTN2LTkuODhjMC0uNjYzLS42MTYtMS4yMDMtMS4zNzMtMS4yMDNzLTEuMzcuNTQtMS4zNyAxLjIwM3YxNi42NDNsLTQuOTIyLS45OTRhMy40NCAzLjQ0IDAgMCAwLS42OTItLjA2OSAzLjM1IDMuMzUgMCAwIDAtMS45MjUuNTk4Yy0uMTQ3LjEwMi0uMTk4LjE5OC0uMTk0LjI5OC4wMDQuMDk0LjA1OC4xNzYuMTUzLjIzIDIuNDYyIDEuNDQ4IDQuNTE3IDMuMjIgNi4xMSA1LjI3Ljg4NyAxLjE0IDIuMzczIDEuODIgMy45OCAxLjgyaDYuNjg2Yy41NzcgMCAxLjA4LS4zMjYgMS4yNTMtLjhsMi43Ni03Ljc0Yy4xNi0uNDQ4LS4wMTctLjkyMy0uNDI2LTEuMjItLjAyNS0uMDItLjA0My0uMDQzLS4wNy0uMDZ6XCIgZmlsbD1cIiNmZmZcIiAvPlxuICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgLjc2OSlcIj5cbiAgICAgICAgICAgICAgICA8bWFzayBpZD1cIkJcIiBmaWxsPVwiI2ZmZlwiPlxuICAgICAgICAgICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9XCIjQVwiIC8+XG4gICAgICAgICAgICAgICAgPC9tYXNrPlxuICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjMuOTkzIDI0Ljk5MmExLjk2IDEuOTYgMCAwIDEtLjExMS43OTRsLTIuNzU4IDcuNzRjLS4wOC4yMi0uMTk0LjQyMy0uMzM2LjYwMi0uNDI3LjU0LTEuMTEuODctMS44NTcuODcyaC02LjY5OGMtMS42Ny0uMDAyLTMuMjQtLjYzMy00LjMyNi0xLjcxNS0uMTU0LS4xNTQtLjMtLjMxOC0uNDM0LS40OUM1Ljk2IDMwLjg0NiA0IDI5LjE1NyAxLjY0NiAyNy43NzNjLS4zODUtLjIyNS0uNjI2LS42MTgtLjY0NS0xLjA1YTEuMzEgMS4zMSAwIDAgMSAuNTY2LTEuMTIyIDQuNTYgNC41NiAwIDAgMSAuNzIzLS40MDVsLjIyNS0uMWE0LjMgNC4zIDAgMCAxIC41NjgtLjE4bC4yMzctLjA1NmMuMjQ4LS4wNDYuNS0uMDc1Ljc1LS4wOC4wMTggMCAuMDM0LS4wMDMuMDUtLjAwMy4zMDMtLjAwMS41OTcuMDI3Ljg5LjA4NmwzLjcyMi43NTJWMjAuNjhsLTEuNDM2LS42OGMtMy4zNzctMS41OTYtNS41Ni01LjEwNi01LjU2LTguOTM4IDAtMS41MS4zMzYtMi45NC45My00LjIyMi4wMTUtLjAzLjAyNS0uMDYuMDQtLjA5LjEyNy0uMjY3LjI2OC0uNTI1LjQxOC0uNzc4LjA5My0uMTYuMTg2LS4zMTYuMjg4LS40NjguMDYzLS4wOTUuMTMzLS4xODYuMi0uMjc3TDMuNzczIDVjLjExOC0uMTU1LjI2LS4yOS4zODUtLjQzNy4yNjYtLjMuNTQ0LS42MDQuODQ1LS44NzdhOS4zMyA5LjMzIDAgMCAxIC44MTMtLjY4NkM2Ljk3IDIuMTY3IDguMzEgMS41OSA5Ljc1NyAxLjM1YTkuMjcgOS4yNyAwIDAgMSAxLjQ4MS0uMTE5IDguODIgOC44MiAwIDAgMSAuNzQ4LjAzMWMuMjQ3LjAyLjQ5LjA1LjczMy4wODggMS40NDguMjM4IDIuNzg2LjgxNiAzLjk0IDEuNjUuMzg3LjI4Ljc1Mi41ODggMS4wOTQuOTIyYTkuOTQgOS45NCAwIDAgMSAuOTQ5IDEuMDc4bC4wNjYuMDkyYy4xMDIuMTMzLjIwMy4yNjguMjk1LjQwOGE5Ljk3IDkuOTcgMCAwIDEgMS41NzEgNC4xMjhjLjA2Ni40NjcuMTAzLjk0NS4xMDMgMS40MyAwIDMuMzg4LTEuNjcgNi40NTMtNC4zNTMgOC4yNDMuMTEuMDQ2LjIyNy4wOC4zMy4xNDRsNi4yNTYgMy44NzRjLjM3LjIzLjY0NS41NS44Mi45LjExNS4yNC4xODUuNDk4LjIwMy43Nm0uNjk3LTEuMTk1Yy0uMjY1LS41NS0uNjc3LTEuMDA3LTEuMTk0LTEuMzI2bC01LjMyMy0zLjI5N2MyLjI1NS0yLjAzNyAzLjU2NC00Ljk3IDMuNTY0LTguMTE0IDAtMi4xOS0uNjM3LTQuMzA0LTEuODQtNi4xMTQtLjEyNi0uMTg4LS4yNi0uMzctLjQtLjU1Mi0uNjQ1LS44NDgtMS40MDItMS42LTIuMjUyLTIuMjA0QzE1LjQ3Mi45MSAxMy4zOTMuMjMyIDExLjIzOC4yMzJBMTAuMjEgMTAuMjEgMCAwIDAgNS4yMyAyLjE5Yy0uODQ4LjYxNC0xLjYwNiAxLjM1Ni0yLjI1MyAyLjIwNS0uMTM2LjE4LS4yNzIuMzYzLS4zOTguNTVDMS4zNzQgNi43NTYuNzM3IDguODcuNzM3IDExLjA2YzAgNC4yMTggMi40MDcgOC4wOCA2LjEzMyA5Ljg0MmwuODYzLjQxdjMuMDkybC0yLjUyNS0uNTFjLS4zNTYtLjA3LS43MTctLjEwNi0xLjA3Ni0uMTA2YTUuNDUgNS40NSAwIDAgMC0zLjE0Ljk5NmMtLjY1My40Ni0xLjAyMiAxLjIwMi0uOTkgMS45ODNhMi4yOCAyLjI4IDAgMCAwIDEuMTM4IDEuODcyYzIuMjQgMS4zMTggNC4xMDYgMi45MjMgNS41NDMgNC43NzIgMS4yNiAxLjYyIDMuMzMzIDIuNTkgNS41NSAyLjU5Mmg2LjY5OGMxLjQyLS4wMDEgMi42OC0uODYgMy4xMzQtMi4xMzhsMi43Ni03Ljc0Yy4yNzItLjc1Ny4yMjQtMS41ODQtLjEzNC0yLjMyNVwiIGZpbGwtb3BhY2l0eT1cIi4wNVwiIGZpbGw9XCIjMDAwXCIgbWFzaz1cInVybCgjQilcIiAvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICA8L2c+XG4gICAgPC9nPlxuPC9zdmc+YFxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL31cbiAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cInNsb3QgZGVmYXVsdFwiPlxuICAgIDxzbG90Pjwvc2xvdD5cblxuICAgIDxkaXYgY2xhc3M9XCJzbG90IHByb2dyZXNzLWJhclwiPlxuICAgICAgPHNsb3QgbmFtZT1cInByb2dyZXNzLWJhclwiPlxuICAgICAgICA8ZGl2IGlkPVwiZGVmYXVsdC1wcm9ncmVzcy1iYXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWFza1wiIHBhcnQ9XCJkZWZhdWx0LXByb2dyZXNzLW1hc2tcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiYmFyXCIgcGFydD1cImRlZmF1bHQtcHJvZ3Jlc3MtYmFyXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJzbG90IGV4aXQtd2VieHItYXItYnV0dG9uXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiZXhpdC13ZWJ4ci1hci1idXR0b25cIj5cbiAgICAgICAgPGEgaWQ9XCJkZWZhdWx0LWV4aXQtd2VieHItYXItYnV0dG9uXCIgcGFydD1cImRlZmF1bHQtZXhpdC13ZWJ4ci1hci1idXR0b25cIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIzXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJFeGl0IEFSXCJcbiAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgICR7VWBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRweFwiIGhlaWdodD1cIjI0cHhcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIiMwMDAwMDBcIj5cbiAgICA8IS0tIE5PVEUoY2RhdGEpOiBUaGlzIFNWRyBmaWx0ZXIgaXMgYSBzdG9wLWdhcCB1bnRpbCB3ZSBjYW4gaW1wbGVtZW50XG4gICAgICAgICBzdXBwb3J0IGZvciBkeW5hbWljIHJlLWNvbG9yaW5nIG9mIFVJIGNvbXBvbmVudHMgLS0+XG4gICAgPGRlZnM+XG4gICAgICA8ZmlsdGVyIGlkPVwiZHJvcC1zaGFkb3dcIiB4PVwiLTEwMCVcIiB5PVwiLTEwMCVcIiB3aWR0aD1cIjMwMCVcIiBoZWlnaHQ9XCIzMDAlXCI+XG4gICAgICAgIDxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiMVwiLz5cbiAgICAgICAgPGZlT2Zmc2V0IGR4PVwiMFwiIGR5PVwiMFwiIHJlc3VsdD1cIm9mZnNldGJsdXJcIi8+XG4gICAgICAgIDxmZUZsb29kIGZsb29kLWNvbG9yPVwiIzAwMDAwMFwiLz5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cIm9mZnNldGJsdXJcIiBvcGVyYXRvcj1cImluXCIvPlxuICAgICAgICA8ZmVNZXJnZT5cbiAgICAgICAgICA8ZmVNZXJnZU5vZGUvPlxuICAgICAgICAgIDxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIi8+XG4gICAgICAgIDwvZmVNZXJnZT5cbiAgICAgIDwvZmlsdGVyPlxuICAgIDwvZGVmcz5cbiAgICA8cGF0aCBmaWx0ZXI9XCJ1cmwoI2Ryb3Atc2hhZG93KVwiIGQ9XCJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyelwiLz5cbiAgICA8cGF0aCBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuPC9zdmc+YFxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL31cbiAgICAgICAgPC9hPlxuICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PmA7Y2xhc3MgcHR7YWRkRXZlbnRMaXN0ZW5lcih0LGUpe3ZvaWQgMD09PXRoaXMuX2xpc3RlbmVycyYmKHRoaXMuX2xpc3RlbmVycz17fSk7Y29uc3Qgbj10aGlzLl9saXN0ZW5lcnM7dm9pZCAwPT09blt0XSYmKG5bdF09W10pLC0xPT09blt0XS5pbmRleE9mKGUpJiZuW3RdLnB1c2goZSl9aGFzRXZlbnRMaXN0ZW5lcih0LGUpe2lmKHZvaWQgMD09PXRoaXMuX2xpc3RlbmVycylyZXR1cm4hMTtjb25zdCBuPXRoaXMuX2xpc3RlbmVycztyZXR1cm4gdm9pZCAwIT09blt0XSYmLTEhPT1uW3RdLmluZGV4T2YoZSl9cmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUpe2lmKHZvaWQgMD09PXRoaXMuX2xpc3RlbmVycylyZXR1cm47Y29uc3Qgbj10aGlzLl9saXN0ZW5lcnNbdF07aWYodm9pZCAwIT09bil7Y29uc3QgdD1uLmluZGV4T2YoZSk7LTEhPT10JiZuLnNwbGljZSh0LDEpfX1kaXNwYXRjaEV2ZW50KHQpe2lmKHZvaWQgMD09PXRoaXMuX2xpc3RlbmVycylyZXR1cm47Y29uc3QgZT10aGlzLl9saXN0ZW5lcnNbdC50eXBlXTtpZih2b2lkIDAhPT1lKXt0LnRhcmdldD10aGlzO2NvbnN0IG49ZS5zbGljZSgwKTtmb3IobGV0IGU9MCxpPW4ubGVuZ3RoO2U8aTtlKyspbltlXS5jYWxsKHRoaXMsdCk7dC50YXJnZXQ9bnVsbH19fWxldCBtdD0xMjM0NTY3O2NvbnN0IGZ0PU1hdGguUEkvMTgwLGd0PTE4MC9NYXRoLlBJLHZ0PVtdO2ZvcihsZXQgdD0wO3Q8MjU2O3QrKyl2dFt0XT0odDwxNj9cIjBcIjpcIlwiKSt0LnRvU3RyaW5nKDE2KTtjb25zdCB5dD1cInVuZGVmaW5lZFwiIT10eXBlb2YgY3J5cHRvJiZcInJhbmRvbVVVSURcImluIGNyeXB0bztmdW5jdGlvbiB4dCgpe2lmKHl0KXJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpLnRvVXBwZXJDYXNlKCk7Y29uc3QgdD00Mjk0OTY3Mjk1Kk1hdGgucmFuZG9tKCl8MCxlPTQyOTQ5NjcyOTUqTWF0aC5yYW5kb20oKXwwLG49NDI5NDk2NzI5NSpNYXRoLnJhbmRvbSgpfDAsaT00Mjk0OTY3Mjk1Kk1hdGgucmFuZG9tKCl8MDtyZXR1cm4odnRbMjU1JnRdK3Z0W3Q+PjgmMjU1XSt2dFt0Pj4xNiYyNTVdK3Z0W3Q+PjI0JjI1NV0rXCItXCIrdnRbMjU1JmVdK3Z0W2U+PjgmMjU1XStcIi1cIit2dFtlPj4xNiYxNXw2NF0rdnRbZT4+MjQmMjU1XStcIi1cIit2dFs2MyZufDEyOF0rdnRbbj4+OCYyNTVdK1wiLVwiK3Z0W24+PjE2JjI1NV0rdnRbbj4+MjQmMjU1XSt2dFsyNTUmaV0rdnRbaT4+OCYyNTVdK3Z0W2k+PjE2JjI1NV0rdnRbaT4+MjQmMjU1XSkudG9VcHBlckNhc2UoKX1mdW5jdGlvbiBidCh0LGUsbil7cmV0dXJuIE1hdGgubWF4KGUsTWF0aC5taW4obix0KSl9ZnVuY3Rpb24gd3QodCxlKXtyZXR1cm4odCVlK2UpJWV9ZnVuY3Rpb24gX3QodCxlLG4pe3JldHVybigxLW4pKnQrbiplfWZ1bmN0aW9uIE10KHQpe3JldHVybiAwPT0odCZ0LTEpJiYwIT09dH1mdW5jdGlvbiBTdCh0KXtyZXR1cm4gTWF0aC5wb3coMixNYXRoLmNlaWwoTWF0aC5sb2codCkvTWF0aC5MTjIpKX1mdW5jdGlvbiBUdCh0KXtyZXR1cm4gTWF0aC5wb3coMixNYXRoLmZsb29yKE1hdGgubG9nKHQpL01hdGguTE4yKSl9dmFyIEV0PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERFRzJSQUQ6ZnQsUkFEMkRFRzpndCxnZW5lcmF0ZVVVSUQ6eHQsY2xhbXA6YnQsZXVjbGlkZWFuTW9kdWxvOnd0LG1hcExpbmVhcjpmdW5jdGlvbih0LGUsbixpLHIpe3JldHVybiBpKyh0LWUpKihyLWkpLyhuLWUpfSxpbnZlcnNlTGVycDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHQhPT1lPyhuLXQpLyhlLXQpOjB9LGxlcnA6X3QsZGFtcDpmdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gX3QodCxlLDEtTWF0aC5leHAoLW4qaSkpfSxwaW5ncG9uZzpmdW5jdGlvbih0LGU9MSl7cmV0dXJuIGUtTWF0aC5hYnMod3QodCwyKmUpLWUpfSxzbW9vdGhzdGVwOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdDw9ZT8wOnQ+PW4/MToodD0odC1lKS8obi1lKSkqdCooMy0yKnQpfSxzbW9vdGhlcnN0ZXA6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0PD1lPzA6dD49bj8xOih0PSh0LWUpLyhuLWUpKSp0KnQqKHQqKDYqdC0xNSkrMTApfSxyYW5kSW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihlLXQrMSkpfSxyYW5kRmxvYXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtNYXRoLnJhbmRvbSgpKihlLXQpfSxyYW5kRmxvYXRTcHJlYWQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQqKC41LU1hdGgucmFuZG9tKCkpfSxzZWVkZWRSYW5kb206ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQmJihtdD10JTIxNDc0ODM2NDcpLG10PTE2ODA3Km10JTIxNDc0ODM2NDcsKG10LTEpLzIxNDc0ODM2NDZ9LGRlZ1RvUmFkOmZ1bmN0aW9uKHQpe3JldHVybiB0KmZ0fSxyYWRUb0RlZzpmdW5jdGlvbih0KXtyZXR1cm4gdCpndH0saXNQb3dlck9mVHdvOk10LGNlaWxQb3dlck9mVHdvOlN0LGZsb29yUG93ZXJPZlR3bzpUdCxzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOmZ1bmN0aW9uKHQsZSxuLGkscil7Y29uc3Qgcz1NYXRoLmNvcyxhPU1hdGguc2luLG89cyhuLzIpLGw9YShuLzIpLGM9cygoZStpKS8yKSxoPWEoKGUraSkvMiksdT1zKChlLWkpLzIpLGQ9YSgoZS1pKS8yKSxwPXMoKGktZSkvMiksbT1hKChpLWUpLzIpO3N3aXRjaChyKXtjYXNlXCJYWVhcIjp0LnNldChvKmgsbCp1LGwqZCxvKmMpO2JyZWFrO2Nhc2VcIllaWVwiOnQuc2V0KGwqZCxvKmgsbCp1LG8qYyk7YnJlYWs7Y2FzZVwiWlhaXCI6dC5zZXQobCp1LGwqZCxvKmgsbypjKTticmVhaztjYXNlXCJYWlhcIjp0LnNldChvKmgsbCptLGwqcCxvKmMpO2JyZWFrO2Nhc2VcIllYWVwiOnQuc2V0KGwqcCxvKmgsbCptLG8qYyk7YnJlYWs7Y2FzZVwiWllaXCI6dC5zZXQobCptLGwqcCxvKmgsbypjKTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybihcIlRIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiBcIityKX19fSk7Y2xhc3MgQXR7Y29uc3RydWN0b3IodD0wLGU9MCl7dGhpcy54PXQsdGhpcy55PWV9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMueH1zZXQgd2lkdGgodCl7dGhpcy54PXR9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLnl9c2V0IGhlaWdodCh0KXt0aGlzLnk9dH1zZXQodCxlKXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PWUsdGhpc31zZXRTY2FsYXIodCl7cmV0dXJuIHRoaXMueD10LHRoaXMueT10LHRoaXN9c2V0WCh0KXtyZXR1cm4gdGhpcy54PXQsdGhpc31zZXRZKHQpe3JldHVybiB0aGlzLnk9dCx0aGlzfXNldENvbXBvbmVudCh0LGUpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy54PWU7YnJlYWs7Y2FzZSAxOnRoaXMueT1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIit0KX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQodCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIit0KX19Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LHRoaXMueSl9Y29weSh0KXtyZXR1cm4gdGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXN9YWRkKHQsZSl7cmV0dXJuIHZvaWQgMCE9PWU/KGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5hZGRWZWN0b3JzKHQsZSkpOih0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzKX1hZGRTY2FsYXIodCl7cmV0dXJuIHRoaXMueCs9dCx0aGlzLnkrPXQsdGhpc31hZGRWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngrZS54LHRoaXMueT10LnkrZS55LHRoaXN9YWRkU2NhbGVkVmVjdG9yKHQsZSl7cmV0dXJuIHRoaXMueCs9dC54KmUsdGhpcy55Kz10LnkqZSx0aGlzfXN1Yih0LGUpe3JldHVybiB2b2lkIDAhPT1lPyhjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMuc3ViVmVjdG9ycyh0LGUpKToodGhpcy54LT10LngsdGhpcy55LT10LnksdGhpcyl9c3ViU2NhbGFyKHQpe3JldHVybiB0aGlzLngtPXQsdGhpcy55LT10LHRoaXN9c3ViVmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54LWUueCx0aGlzLnk9dC55LWUueSx0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLngqPXQueCx0aGlzLnkqPXQueSx0aGlzfW11bHRpcGx5U2NhbGFyKHQpe3JldHVybiB0aGlzLngqPXQsdGhpcy55Kj10LHRoaXN9ZGl2aWRlKHQpe3JldHVybiB0aGlzLngvPXQueCx0aGlzLnkvPXQueSx0aGlzfWRpdmlkZVNjYWxhcih0KXtyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxL3QpfWFwcGx5TWF0cml4Myh0KXtjb25zdCBlPXRoaXMueCxuPXRoaXMueSxpPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMueD1pWzBdKmUraVszXSpuK2lbNl0sdGhpcy55PWlbMV0qZStpWzRdKm4raVs3XSx0aGlzfW1pbih0KXtyZXR1cm4gdGhpcy54PU1hdGgubWluKHRoaXMueCx0LngpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksdC55KSx0aGlzfW1heCh0KXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCx0LngpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksdC55KSx0aGlzfWNsYW1wKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LngsTWF0aC5taW4oZS54LHRoaXMueCkpLHRoaXMueT1NYXRoLm1heCh0LnksTWF0aC5taW4oZS55LHRoaXMueSkpLHRoaXN9Y2xhbXBTY2FsYXIodCxlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueSkpLHRoaXN9Y2xhbXBMZW5ndGgodCxlKXtjb25zdCBuPXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKG58fDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KHQsTWF0aC5taW4oZSxuKSkpfWZsb29yKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzfWNlaWwoKXtyZXR1cm4gdGhpcy54PU1hdGguY2VpbCh0aGlzLngpLHRoaXMueT1NYXRoLmNlaWwodGhpcy55KSx0aGlzfXJvdW5kKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzfXJvdW5kVG9aZXJvKCl7cmV0dXJuIHRoaXMueD10aGlzLng8MD9NYXRoLmNlaWwodGhpcy54KTpNYXRoLmZsb29yKHRoaXMueCksdGhpcy55PXRoaXMueTwwP01hdGguY2VpbCh0aGlzLnkpOk1hdGguZmxvb3IodGhpcy55KSx0aGlzfW5lZ2F0ZSgpe3JldHVybiB0aGlzLng9LXRoaXMueCx0aGlzLnk9LXRoaXMueSx0aGlzfWRvdCh0KXtyZXR1cm4gdGhpcy54KnQueCt0aGlzLnkqdC55fWNyb3NzKHQpe3JldHVybiB0aGlzLngqdC55LXRoaXMueSp0Lnh9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55KX1tYW5oYXR0YW5MZW5ndGgoKXtyZXR1cm4gTWF0aC5hYnModGhpcy54KStNYXRoLmFicyh0aGlzLnkpfW5vcm1hbGl6ZSgpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpfHwxKX1hbmdsZSgpe3JldHVybiBNYXRoLmF0YW4yKC10aGlzLnksLXRoaXMueCkrTWF0aC5QSX1kaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh0KSl9ZGlzdGFuY2VUb1NxdWFyZWQodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueTtyZXR1cm4gZSplK24qbn1tYW5oYXR0YW5EaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLmFicyh0aGlzLngtdC54KStNYXRoLmFicyh0aGlzLnktdC55KX1zZXRMZW5ndGgodCl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCl9bGVycCh0LGUpe3JldHVybiB0aGlzLngrPSh0LngtdGhpcy54KSplLHRoaXMueSs9KHQueS10aGlzLnkpKmUsdGhpc31sZXJwVmVjdG9ycyh0LGUsbil7cmV0dXJuIHRoaXMueD10LngrKGUueC10LngpKm4sdGhpcy55PXQueSsoZS55LXQueSkqbix0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC54PT09dGhpcy54JiZ0Lnk9PT10aGlzLnl9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy54PXRbZV0sdGhpcy55PXRbZSsxXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMueCx0W2UrMV09dGhpcy55LHR9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUsbil7cmV0dXJuIHZvaWQgMCE9PW4mJmNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjI6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS5cIiksdGhpcy54PXQuZ2V0WChlKSx0aGlzLnk9dC5nZXRZKGUpLHRoaXN9cm90YXRlQXJvdW5kKHQsZSl7Y29uc3Qgbj1NYXRoLmNvcyhlKSxpPU1hdGguc2luKGUpLHI9dGhpcy54LXQueCxzPXRoaXMueS10Lnk7cmV0dXJuIHRoaXMueD1yKm4tcyppK3QueCx0aGlzLnk9cippK3Mqbit0LnksdGhpc31yYW5kb20oKXtyZXR1cm4gdGhpcy54PU1hdGgucmFuZG9tKCksdGhpcy55PU1hdGgucmFuZG9tKCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55fX1BdC5wcm90b3R5cGUuaXNWZWN0b3IyPSEwO2NsYXNzIEx0e2NvbnN0cnVjdG9yKCl7dGhpcy5lbGVtZW50cz1bMSwwLDAsMCwxLDAsMCwwLDFdLGFyZ3VtZW50cy5sZW5ndGg+MCYmY29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuXCIpfXNldCh0LGUsbixpLHIscyxhLG8sbCl7Y29uc3QgYz10aGlzLmVsZW1lbnRzO3JldHVybiBjWzBdPXQsY1sxXT1pLGNbMl09YSxjWzNdPWUsY1s0XT1yLGNbNV09byxjWzZdPW4sY1s3XT1zLGNbOF09bCx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDEsMCwwLDAsMSwwLDAsMCwxKSx0aGlzfWNvcHkodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLG49dC5lbGVtZW50cztyZXR1cm4gZVswXT1uWzBdLGVbMV09blsxXSxlWzJdPW5bMl0sZVszXT1uWzNdLGVbNF09bls0XSxlWzVdPW5bNV0sZVs2XT1uWzZdLGVbN109bls3XSxlWzhdPW5bOF0sdGhpc31leHRyYWN0QmFzaXModCxlLG4pe3JldHVybiB0LnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsMCksZS5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLDEpLG4uc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywyKSx0aGlzfXNldEZyb21NYXRyaXg0KHQpe2NvbnN0IGU9dC5lbGVtZW50cztyZXR1cm4gdGhpcy5zZXQoZVswXSxlWzRdLGVbOF0sZVsxXSxlWzVdLGVbOV0sZVsyXSxlWzZdLGVbMTBdKSx0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcyx0KX1wcmVtdWx0aXBseSh0KXtyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsdGhpcyl9bXVsdGlwbHlNYXRyaWNlcyh0LGUpe2NvbnN0IG49dC5lbGVtZW50cyxpPWUuZWxlbWVudHMscj10aGlzLmVsZW1lbnRzLHM9blswXSxhPW5bM10sbz1uWzZdLGw9blsxXSxjPW5bNF0saD1uWzddLHU9blsyXSxkPW5bNV0scD1uWzhdLG09aVswXSxmPWlbM10sZz1pWzZdLHY9aVsxXSx5PWlbNF0seD1pWzddLGI9aVsyXSx3PWlbNV0sXz1pWzhdO3JldHVybiByWzBdPXMqbSthKnYrbypiLHJbM109cypmK2EqeStvKncscls2XT1zKmcrYSp4K28qXyxyWzFdPWwqbStjKnYraCpiLHJbNF09bCpmK2MqeStoKncscls3XT1sKmcrYyp4K2gqXyxyWzJdPXUqbStkKnYrcCpiLHJbNV09dSpmK2QqeStwKncscls4XT11KmcrZCp4K3AqXyx0aGlzfW11bHRpcGx5U2NhbGFyKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cztyZXR1cm4gZVswXSo9dCxlWzNdKj10LGVbNl0qPXQsZVsxXSo9dCxlWzRdKj10LGVbN10qPXQsZVsyXSo9dCxlWzVdKj10LGVbOF0qPXQsdGhpc31kZXRlcm1pbmFudCgpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxlPXRbMF0sbj10WzFdLGk9dFsyXSxyPXRbM10scz10WzRdLGE9dFs1XSxvPXRbNl0sbD10WzddLGM9dFs4XTtyZXR1cm4gZSpzKmMtZSphKmwtbipyKmMrbiphKm8raSpyKmwtaSpzKm99aW52ZXJ0KCl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGU9dFswXSxuPXRbMV0saT10WzJdLHI9dFszXSxzPXRbNF0sYT10WzVdLG89dFs2XSxsPXRbN10sYz10WzhdLGg9YypzLWEqbCx1PWEqby1jKnIsZD1sKnItcypvLHA9ZSpoK24qdStpKmQ7aWYoMD09PXApcmV0dXJuIHRoaXMuc2V0KDAsMCwwLDAsMCwwLDAsMCwwKTtjb25zdCBtPTEvcDtyZXR1cm4gdFswXT1oKm0sdFsxXT0oaSpsLWMqbikqbSx0WzJdPShhKm4taSpzKSptLHRbM109dSptLHRbNF09KGMqZS1pKm8pKm0sdFs1XT0oaSpyLWEqZSkqbSx0WzZdPWQqbSx0WzddPShuKm8tbCplKSptLHRbOF09KHMqZS1uKnIpKm0sdGhpc310cmFuc3Bvc2UoKXtsZXQgdDtjb25zdCBlPXRoaXMuZWxlbWVudHM7cmV0dXJuIHQ9ZVsxXSxlWzFdPWVbM10sZVszXT10LHQ9ZVsyXSxlWzJdPWVbNl0sZVs2XT10LHQ9ZVs1XSxlWzVdPWVbN10sZVs3XT10LHRoaXN9Z2V0Tm9ybWFsTWF0cml4KHQpe3JldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KHQpLmludmVydCgpLnRyYW5zcG9zZSgpfXRyYW5zcG9zZUludG9BcnJheSh0KXtjb25zdCBlPXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbM10sdFsyXT1lWzZdLHRbM109ZVsxXSx0WzRdPWVbNF0sdFs1XT1lWzddLHRbNl09ZVsyXSx0WzddPWVbNV0sdFs4XT1lWzhdLHRoaXN9c2V0VXZUcmFuc2Zvcm0odCxlLG4saSxyLHMsYSl7Y29uc3Qgbz1NYXRoLmNvcyhyKSxsPU1hdGguc2luKHIpO3JldHVybiB0aGlzLnNldChuKm8sbipsLC1uKihvKnMrbCphKStzK3QsLWkqbCxpKm8sLWkqKC1sKnMrbyphKSthK2UsMCwwLDEpLHRoaXN9c2NhbGUodCxlKXtjb25zdCBuPXRoaXMuZWxlbWVudHM7cmV0dXJuIG5bMF0qPXQsblszXSo9dCxuWzZdKj10LG5bMV0qPWUsbls0XSo9ZSxuWzddKj1lLHRoaXN9cm90YXRlKHQpe2NvbnN0IGU9TWF0aC5jb3ModCksbj1NYXRoLnNpbih0KSxpPXRoaXMuZWxlbWVudHMscj1pWzBdLHM9aVszXSxhPWlbNl0sbz1pWzFdLGw9aVs0XSxjPWlbN107cmV0dXJuIGlbMF09ZSpyK24qbyxpWzNdPWUqcytuKmwsaVs2XT1lKmErbipjLGlbMV09LW4qcitlKm8saVs0XT0tbipzK2UqbCxpWzddPS1uKmErZSpjLHRoaXN9dHJhbnNsYXRlKHQsZSl7Y29uc3Qgbj10aGlzLmVsZW1lbnRzO3JldHVybiBuWzBdKz10Km5bMl0sblszXSs9dCpuWzVdLG5bNl0rPXQqbls4XSxuWzFdKz1lKm5bMl0sbls0XSs9ZSpuWzVdLG5bN10rPWUqbls4XSx0aGlzfWVxdWFscyh0KXtjb25zdCBlPXRoaXMuZWxlbWVudHMsbj10LmVsZW1lbnRzO2ZvcihsZXQgdD0wO3Q8OTt0KyspaWYoZVt0XSE9PW5bdF0pcmV0dXJuITE7cmV0dXJuITB9ZnJvbUFycmF5KHQsZT0wKXtmb3IobGV0IG49MDtuPDk7bisrKXRoaXMuZWxlbWVudHNbbl09dFtuK2VdO3JldHVybiB0aGlzfXRvQXJyYXkodD1bXSxlPTApe2NvbnN0IG49dGhpcy5lbGVtZW50cztyZXR1cm4gdFtlXT1uWzBdLHRbZSsxXT1uWzFdLHRbZSsyXT1uWzJdLHRbZSszXT1uWzNdLHRbZSs0XT1uWzRdLHRbZSs1XT1uWzVdLHRbZSs2XT1uWzZdLHRbZSs3XT1uWzddLHRbZSs4XT1uWzhdLHR9Y2xvbmUoKXtyZXR1cm4obmV3IHRoaXMuY29uc3RydWN0b3IpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKX19ZnVuY3Rpb24gUnQodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybi0xLzA7bGV0IGU9dFswXTtmb3IobGV0IG49MSxpPXQubGVuZ3RoO248aTsrK24pdFtuXT5lJiYoZT10W25dKTtyZXR1cm4gZX1mdW5jdGlvbiBDdCh0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLHQpfWxldCBQdDtMdC5wcm90b3R5cGUuaXNNYXRyaXgzPSEwO2NsYXNzIEl0e3N0YXRpYyBnZXREYXRhVVJMKHQpe2lmKC9eZGF0YTovaS50ZXN0KHQuc3JjKSlyZXR1cm4gdC5zcmM7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50KXJldHVybiB0LnNyYztsZXQgZTtpZih0IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpZT10O2Vsc2V7dm9pZCAwPT09UHQmJihQdD1DdChcImNhbnZhc1wiKSksUHQud2lkdGg9dC53aWR0aCxQdC5oZWlnaHQ9dC5oZWlnaHQ7Y29uc3Qgbj1QdC5nZXRDb250ZXh0KFwiMmRcIik7dCBpbnN0YW5jZW9mIEltYWdlRGF0YT9uLnB1dEltYWdlRGF0YSh0LDAsMCk6bi5kcmF3SW1hZ2UodCwwLDAsdC53aWR0aCx0LmhlaWdodCksZT1QdH1yZXR1cm4gZS53aWR0aD4yMDQ4fHxlLmhlaWdodD4yMDQ4Pyhjb25zb2xlLndhcm4oXCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcIix0KSxlLnRvRGF0YVVSTChcImltYWdlL2pwZWdcIiwuNikpOmUudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpfX1sZXQgRHQ9MDtjbGFzcyBOdCBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKHQ9TnQuREVGQVVMVF9JTUFHRSxlPU50LkRFRkFVTFRfTUFQUElORyxuPTEwMDEsaT0xMDAxLHI9MTAwNixzPTEwMDgsYT0xMDIzLG89MTAwOSxsPTEsYz0zZTMpe3N1cGVyKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJpZFwiLHt2YWx1ZTpEdCsrfSksdGhpcy51dWlkPXh0KCksdGhpcy5uYW1lPVwiXCIsdGhpcy5pbWFnZT10LHRoaXMubWlwbWFwcz1bXSx0aGlzLm1hcHBpbmc9ZSx0aGlzLndyYXBTPW4sdGhpcy53cmFwVD1pLHRoaXMubWFnRmlsdGVyPXIsdGhpcy5taW5GaWx0ZXI9cyx0aGlzLmFuaXNvdHJvcHk9bCx0aGlzLmZvcm1hdD1hLHRoaXMuaW50ZXJuYWxGb3JtYXQ9bnVsbCx0aGlzLnR5cGU9byx0aGlzLm9mZnNldD1uZXcgQXQoMCwwKSx0aGlzLnJlcGVhdD1uZXcgQXQoMSwxKSx0aGlzLmNlbnRlcj1uZXcgQXQoMCwwKSx0aGlzLnJvdGF0aW9uPTAsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPSEwLHRoaXMubWF0cml4PW5ldyBMdCx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMCx0aGlzLnByZW11bHRpcGx5QWxwaGE9ITEsdGhpcy5mbGlwWT0hMCx0aGlzLnVucGFja0FsaWdubWVudD00LHRoaXMuZW5jb2Rpbmc9Yyx0aGlzLnZlcnNpb249MCx0aGlzLm9uVXBkYXRlPW51bGwsdGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmU9ITF9dXBkYXRlTWF0cml4KCl7dGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0odGhpcy5vZmZzZXQueCx0aGlzLm9mZnNldC55LHRoaXMucmVwZWF0LngsdGhpcy5yZXBlYXQueSx0aGlzLnJvdGF0aW9uLHRoaXMuY2VudGVyLngsdGhpcy5jZW50ZXIueSl9Y2xvbmUoKXtyZXR1cm4obmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcyl9Y29weSh0KXtyZXR1cm4gdGhpcy5uYW1lPXQubmFtZSx0aGlzLmltYWdlPXQuaW1hZ2UsdGhpcy5taXBtYXBzPXQubWlwbWFwcy5zbGljZSgwKSx0aGlzLm1hcHBpbmc9dC5tYXBwaW5nLHRoaXMud3JhcFM9dC53cmFwUyx0aGlzLndyYXBUPXQud3JhcFQsdGhpcy5tYWdGaWx0ZXI9dC5tYWdGaWx0ZXIsdGhpcy5taW5GaWx0ZXI9dC5taW5GaWx0ZXIsdGhpcy5hbmlzb3Ryb3B5PXQuYW5pc290cm9weSx0aGlzLmZvcm1hdD10LmZvcm1hdCx0aGlzLmludGVybmFsRm9ybWF0PXQuaW50ZXJuYWxGb3JtYXQsdGhpcy50eXBlPXQudHlwZSx0aGlzLm9mZnNldC5jb3B5KHQub2Zmc2V0KSx0aGlzLnJlcGVhdC5jb3B5KHQucmVwZWF0KSx0aGlzLmNlbnRlci5jb3B5KHQuY2VudGVyKSx0aGlzLnJvdGF0aW9uPXQucm90YXRpb24sdGhpcy5tYXRyaXhBdXRvVXBkYXRlPXQubWF0cml4QXV0b1VwZGF0ZSx0aGlzLm1hdHJpeC5jb3B5KHQubWF0cml4KSx0aGlzLmdlbmVyYXRlTWlwbWFwcz10LmdlbmVyYXRlTWlwbWFwcyx0aGlzLnByZW11bHRpcGx5QWxwaGE9dC5wcmVtdWx0aXBseUFscGhhLHRoaXMuZmxpcFk9dC5mbGlwWSx0aGlzLnVucGFja0FsaWdubWVudD10LnVucGFja0FsaWdubWVudCx0aGlzLmVuY29kaW5nPXQuZW5jb2RpbmcsdGhpc310b0pTT04odCl7Y29uc3QgZT12b2lkIDA9PT10fHxcInN0cmluZ1wiPT10eXBlb2YgdDtpZighZSYmdm9pZCAwIT09dC50ZXh0dXJlc1t0aGlzLnV1aWRdKXJldHVybiB0LnRleHR1cmVzW3RoaXMudXVpZF07Y29uc3Qgbj17bWV0YWRhdGE6e3ZlcnNpb246NC41LHR5cGU6XCJUZXh0dXJlXCIsZ2VuZXJhdG9yOlwiVGV4dHVyZS50b0pTT05cIn0sdXVpZDp0aGlzLnV1aWQsbmFtZTp0aGlzLm5hbWUsbWFwcGluZzp0aGlzLm1hcHBpbmcscmVwZWF0Olt0aGlzLnJlcGVhdC54LHRoaXMucmVwZWF0LnldLG9mZnNldDpbdGhpcy5vZmZzZXQueCx0aGlzLm9mZnNldC55XSxjZW50ZXI6W3RoaXMuY2VudGVyLngsdGhpcy5jZW50ZXIueV0scm90YXRpb246dGhpcy5yb3RhdGlvbix3cmFwOlt0aGlzLndyYXBTLHRoaXMud3JhcFRdLGZvcm1hdDp0aGlzLmZvcm1hdCx0eXBlOnRoaXMudHlwZSxlbmNvZGluZzp0aGlzLmVuY29kaW5nLG1pbkZpbHRlcjp0aGlzLm1pbkZpbHRlcixtYWdGaWx0ZXI6dGhpcy5tYWdGaWx0ZXIsYW5pc290cm9weTp0aGlzLmFuaXNvdHJvcHksZmxpcFk6dGhpcy5mbGlwWSxwcmVtdWx0aXBseUFscGhhOnRoaXMucHJlbXVsdGlwbHlBbHBoYSx1bnBhY2tBbGlnbm1lbnQ6dGhpcy51bnBhY2tBbGlnbm1lbnR9O2lmKHZvaWQgMCE9PXRoaXMuaW1hZ2Upe2NvbnN0IGk9dGhpcy5pbWFnZTtpZih2b2lkIDA9PT1pLnV1aWQmJihpLnV1aWQ9eHQoKSksIWUmJnZvaWQgMD09PXQuaW1hZ2VzW2kudXVpZF0pe2xldCBlO2lmKEFycmF5LmlzQXJyYXkoaSkpe2U9W107Zm9yKGxldCB0PTAsbj1pLmxlbmd0aDt0PG47dCsrKWlbdF0uaXNEYXRhVGV4dHVyZT9lLnB1c2goRnQoaVt0XS5pbWFnZSkpOmUucHVzaChGdChpW3RdKSl9ZWxzZSBlPUZ0KGkpO3QuaW1hZ2VzW2kudXVpZF09e3V1aWQ6aS51dWlkLHVybDplfX1uLmltYWdlPWkudXVpZH1yZXR1cm4gZXx8KHQudGV4dHVyZXNbdGhpcy51dWlkXT1uKSxufWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJkaXNwb3NlXCJ9KX10cmFuc2Zvcm1Vdih0KXtpZigzMDAhPT10aGlzLm1hcHBpbmcpcmV0dXJuIHQ7aWYodC5hcHBseU1hdHJpeDModGhpcy5tYXRyaXgpLHQueDwwfHx0Lng+MSlzd2l0Y2godGhpcy53cmFwUyl7Y2FzZSAxZTM6dC54PXQueC1NYXRoLmZsb29yKHQueCk7YnJlYWs7Y2FzZSAxMDAxOnQueD10Lng8MD8wOjE7YnJlYWs7Y2FzZSAxMDAyOjE9PT1NYXRoLmFicyhNYXRoLmZsb29yKHQueCklMik/dC54PU1hdGguY2VpbCh0LngpLXQueDp0Lng9dC54LU1hdGguZmxvb3IodC54KX1pZih0Lnk8MHx8dC55PjEpc3dpdGNoKHRoaXMud3JhcFQpe2Nhc2UgMWUzOnQueT10LnktTWF0aC5mbG9vcih0LnkpO2JyZWFrO2Nhc2UgMTAwMTp0Lnk9dC55PDA/MDoxO2JyZWFrO2Nhc2UgMTAwMjoxPT09TWF0aC5hYnMoTWF0aC5mbG9vcih0LnkpJTIpP3QueT1NYXRoLmNlaWwodC55KS10Lnk6dC55PXQueS1NYXRoLmZsb29yKHQueSl9cmV0dXJuIHRoaXMuZmxpcFkmJih0Lnk9MS10LnkpLHR9c2V0IG5lZWRzVXBkYXRlKHQpeyEwPT09dCYmdGhpcy52ZXJzaW9uKyt9fWZ1bmN0aW9uIEZ0KHQpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50JiZ0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50JiZ0IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBJbWFnZUJpdG1hcCYmdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwP0l0LmdldERhdGFVUkwodCk6dC5kYXRhP3tkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuZGF0YSksd2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHQsdHlwZTp0LmRhdGEuY29uc3RydWN0b3IubmFtZX06KGNvbnNvbGUud2FybihcIlRIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS5cIikse30pfU50LkRFRkFVTFRfSU1BR0U9dm9pZCAwLE50LkRFRkFVTFRfTUFQUElORz0zMDAsTnQucHJvdG90eXBlLmlzVGV4dHVyZT0hMDtjbGFzcyBPdHtjb25zdHJ1Y3Rvcih0PTAsZT0wLG49MCxpPTEpe3RoaXMueD10LHRoaXMueT1lLHRoaXMuej1uLHRoaXMudz1pfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnp9c2V0IHdpZHRoKHQpe3RoaXMuej10fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy53fXNldCBoZWlnaHQodCl7dGhpcy53PXR9c2V0KHQsZSxuLGkpe3JldHVybiB0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9bix0aGlzLnc9aSx0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PXQsdGhpcy56PXQsdGhpcy53PXQsdGhpc31zZXRYKHQpe3JldHVybiB0aGlzLng9dCx0aGlzfXNldFkodCl7cmV0dXJuIHRoaXMueT10LHRoaXN9c2V0Wih0KXtyZXR1cm4gdGhpcy56PXQsdGhpc31zZXRXKHQpe3JldHVybiB0aGlzLnc9dCx0aGlzfXNldENvbXBvbmVudCh0LGUpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy54PWU7YnJlYWs7Y2FzZSAxOnRoaXMueT1lO2JyZWFrO2Nhc2UgMjp0aGlzLno9ZTticmVhaztjYXNlIDM6dGhpcy53PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiK3QpfXJldHVybiB0aGlzfWdldENvbXBvbmVudCh0KXtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB0aGlzLng7Y2FzZSAxOnJldHVybiB0aGlzLnk7Y2FzZSAyOnJldHVybiB0aGlzLno7Y2FzZSAzOnJldHVybiB0aGlzLnc7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiK3QpfX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsdGhpcy55LHRoaXMueix0aGlzLncpfWNvcHkodCl7cmV0dXJuIHRoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56LHRoaXMudz12b2lkIDAhPT10Lnc/dC53OjEsdGhpc31hZGQodCxlKXtyZXR1cm4gdm9pZCAwIT09ZT8oY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLmFkZFZlY3RvcnModCxlKSk6KHRoaXMueCs9dC54LHRoaXMueSs9dC55LHRoaXMueis9dC56LHRoaXMudys9dC53LHRoaXMpfWFkZFNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kz10LHRoaXMueSs9dCx0aGlzLnorPXQsdGhpcy53Kz10LHRoaXN9YWRkVmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54K2UueCx0aGlzLnk9dC55K2UueSx0aGlzLno9dC56K2Uueix0aGlzLnc9dC53K2Uudyx0aGlzfWFkZFNjYWxlZFZlY3Rvcih0LGUpe3JldHVybiB0aGlzLngrPXQueCplLHRoaXMueSs9dC55KmUsdGhpcy56Kz10LnoqZSx0aGlzLncrPXQudyplLHRoaXN9c3ViKHQsZSl7cmV0dXJuIHZvaWQgMCE9PWU/KGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjQ6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5zdWJWZWN0b3JzKHQsZSkpOih0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzLnotPXQueix0aGlzLnctPXQudyx0aGlzKX1zdWJTY2FsYXIodCl7cmV0dXJuIHRoaXMueC09dCx0aGlzLnktPXQsdGhpcy56LT10LHRoaXMudy09dCx0aGlzfXN1YlZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueC1lLngsdGhpcy55PXQueS1lLnksdGhpcy56PXQuei1lLnosdGhpcy53PXQudy1lLncsdGhpc31tdWx0aXBseSh0KXtyZXR1cm4gdGhpcy54Kj10LngsdGhpcy55Kj10LnksdGhpcy56Kj10LnosdGhpcy53Kj10LncsdGhpc31tdWx0aXBseVNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXQsdGhpcy53Kj10LHRoaXN9YXBwbHlNYXRyaXg0KHQpe2NvbnN0IGU9dGhpcy54LG49dGhpcy55LGk9dGhpcy56LHI9dGhpcy53LHM9dC5lbGVtZW50cztyZXR1cm4gdGhpcy54PXNbMF0qZStzWzRdKm4rc1s4XSppK3NbMTJdKnIsdGhpcy55PXNbMV0qZStzWzVdKm4rc1s5XSppK3NbMTNdKnIsdGhpcy56PXNbMl0qZStzWzZdKm4rc1sxMF0qaStzWzE0XSpyLHRoaXMudz1zWzNdKmUrc1s3XSpuK3NbMTFdKmkrc1sxNV0qcix0aGlzfWRpdmlkZVNjYWxhcih0KXtyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxL3QpfXNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uKHQpe3RoaXMudz0yKk1hdGguYWNvcyh0LncpO2NvbnN0IGU9TWF0aC5zcXJ0KDEtdC53KnQudyk7cmV0dXJuIGU8MWUtND8odGhpcy54PTEsdGhpcy55PTAsdGhpcy56PTApOih0aGlzLng9dC54L2UsdGhpcy55PXQueS9lLHRoaXMuej10LnovZSksdGhpc31zZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXgodCl7bGV0IGUsbixpLHI7Y29uc3Qgcz0uMDEsYT0uMSxvPXQuZWxlbWVudHMsbD1vWzBdLGM9b1s0XSxoPW9bOF0sdT1vWzFdLGQ9b1s1XSxwPW9bOV0sbT1vWzJdLGY9b1s2XSxnPW9bMTBdO2lmKE1hdGguYWJzKGMtdSk8cyYmTWF0aC5hYnMoaC1tKTxzJiZNYXRoLmFicyhwLWYpPHMpe2lmKE1hdGguYWJzKGMrdSk8YSYmTWF0aC5hYnMoaCttKTxhJiZNYXRoLmFicyhwK2YpPGEmJk1hdGguYWJzKGwrZCtnLTMpPGEpcmV0dXJuIHRoaXMuc2V0KDEsMCwwLDApLHRoaXM7ZT1NYXRoLlBJO2NvbnN0IHQ9KGwrMSkvMixvPShkKzEpLzIsdj0oZysxKS8yLHk9KGMrdSkvNCx4PShoK20pLzQsYj0ocCtmKS80O3JldHVybiB0Pm8mJnQ+dj90PHM/KG49MCxpPS43MDcxMDY3ODEscj0uNzA3MTA2NzgxKToobj1NYXRoLnNxcnQodCksaT15L24scj14L24pOm8+dj9vPHM/KG49LjcwNzEwNjc4MSxpPTAscj0uNzA3MTA2NzgxKTooaT1NYXRoLnNxcnQobyksbj15L2kscj1iL2kpOnY8cz8obj0uNzA3MTA2NzgxLGk9LjcwNzEwNjc4MSxyPTApOihyPU1hdGguc3FydCh2KSxuPXgvcixpPWIvciksdGhpcy5zZXQobixpLHIsZSksdGhpc31sZXQgdj1NYXRoLnNxcnQoKGYtcCkqKGYtcCkrKGgtbSkqKGgtbSkrKHUtYykqKHUtYykpO3JldHVybiBNYXRoLmFicyh2KTwuMDAxJiYodj0xKSx0aGlzLng9KGYtcCkvdix0aGlzLnk9KGgtbSkvdix0aGlzLno9KHUtYykvdix0aGlzLnc9TWF0aC5hY29zKChsK2QrZy0xKS8yKSx0aGlzfW1pbih0KXtyZXR1cm4gdGhpcy54PU1hdGgubWluKHRoaXMueCx0LngpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksdC55KSx0aGlzLno9TWF0aC5taW4odGhpcy56LHQueiksdGhpcy53PU1hdGgubWluKHRoaXMudyx0LncpLHRoaXN9bWF4KHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LHQueCksdGhpcy55PU1hdGgubWF4KHRoaXMueSx0LnkpLHRoaXMuej1NYXRoLm1heCh0aGlzLnosdC56KSx0aGlzLnc9TWF0aC5tYXgodGhpcy53LHQudyksdGhpc31jbGFtcCh0LGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodC54LE1hdGgubWluKGUueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodC55LE1hdGgubWluKGUueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgodC56LE1hdGgubWluKGUueix0aGlzLnopKSx0aGlzLnc9TWF0aC5tYXgodC53LE1hdGgubWluKGUudyx0aGlzLncpKSx0aGlzfWNsYW1wU2NhbGFyKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueikpLHRoaXMudz1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy53KSksdGhpc31jbGFtcExlbmd0aCh0LGUpe2NvbnN0IG49dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobnx8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgodCxNYXRoLm1pbihlLG4pKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXMuej1NYXRoLmZsb29yKHRoaXMueiksdGhpcy53PU1hdGguZmxvb3IodGhpcy53KSx0aGlzfWNlaWwoKXtyZXR1cm4gdGhpcy54PU1hdGguY2VpbCh0aGlzLngpLHRoaXMueT1NYXRoLmNlaWwodGhpcy55KSx0aGlzLno9TWF0aC5jZWlsKHRoaXMueiksdGhpcy53PU1hdGguY2VpbCh0aGlzLncpLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXMuej1NYXRoLnJvdW5kKHRoaXMueiksdGhpcy53PU1hdGgucm91bmQodGhpcy53KSx0aGlzfXJvdW5kVG9aZXJvKCl7cmV0dXJuIHRoaXMueD10aGlzLng8MD9NYXRoLmNlaWwodGhpcy54KTpNYXRoLmZsb29yKHRoaXMueCksdGhpcy55PXRoaXMueTwwP01hdGguY2VpbCh0aGlzLnkpOk1hdGguZmxvb3IodGhpcy55KSx0aGlzLno9dGhpcy56PDA/TWF0aC5jZWlsKHRoaXMueik6TWF0aC5mbG9vcih0aGlzLnopLHRoaXMudz10aGlzLnc8MD9NYXRoLmNlaWwodGhpcy53KTpNYXRoLmZsb29yKHRoaXMudyksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpcy53PS10aGlzLncsdGhpc31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56K3RoaXMudyp0Lnd9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMud31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KStNYXRoLmFicyh0aGlzLncpfW5vcm1hbGl6ZSgpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpfHwxKX1zZXRMZW5ndGgodCl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCl9bGVycCh0LGUpe3JldHVybiB0aGlzLngrPSh0LngtdGhpcy54KSplLHRoaXMueSs9KHQueS10aGlzLnkpKmUsdGhpcy56Kz0odC56LXRoaXMueikqZSx0aGlzLncrPSh0LnctdGhpcy53KSplLHRoaXN9bGVycFZlY3RvcnModCxlLG4pe3JldHVybiB0aGlzLng9dC54KyhlLngtdC54KSpuLHRoaXMueT10LnkrKGUueS10LnkpKm4sdGhpcy56PXQueisoZS56LXQueikqbix0aGlzLnc9dC53KyhlLnctdC53KSpuLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lng9PT10aGlzLngmJnQueT09PXRoaXMueSYmdC56PT09dGhpcy56JiZ0Lnc9PT10aGlzLnd9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy54PXRbZV0sdGhpcy55PXRbZSsxXSx0aGlzLno9dFtlKzJdLHRoaXMudz10W2UrM10sdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLngsdFtlKzFdPXRoaXMueSx0W2UrMl09dGhpcy56LHRbZSszXT10aGlzLncsdH1mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSxuKXtyZXR1cm4gdm9pZCAwIT09biYmY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yNDogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLlwiKSx0aGlzLng9dC5nZXRYKGUpLHRoaXMueT10LmdldFkoZSksdGhpcy56PXQuZ2V0WihlKSx0aGlzLnc9dC5nZXRXKGUpLHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXMuej1NYXRoLnJhbmRvbSgpLHRoaXMudz1NYXRoLnJhbmRvbSgpLHRoaXN9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy54LHlpZWxkIHRoaXMueSx5aWVsZCB0aGlzLnoseWllbGQgdGhpcy53fX1PdC5wcm90b3R5cGUuaXNWZWN0b3I0PSEwO2NsYXNzIFV0IGV4dGVuZHMgcHR7Y29uc3RydWN0b3IodCxlLG49e30pe3N1cGVyKCksdGhpcy53aWR0aD10LHRoaXMuaGVpZ2h0PWUsdGhpcy5kZXB0aD0xLHRoaXMuc2Npc3Nvcj1uZXcgT3QoMCwwLHQsZSksdGhpcy5zY2lzc29yVGVzdD0hMSx0aGlzLnZpZXdwb3J0PW5ldyBPdCgwLDAsdCxlKSx0aGlzLnRleHR1cmU9bmV3IE50KHZvaWQgMCxuLm1hcHBpbmcsbi53cmFwUyxuLndyYXBULG4ubWFnRmlsdGVyLG4ubWluRmlsdGVyLG4uZm9ybWF0LG4udHlwZSxuLmFuaXNvdHJvcHksbi5lbmNvZGluZyksdGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMCx0aGlzLnRleHR1cmUuaW1hZ2U9e3dpZHRoOnQsaGVpZ2h0OmUsZGVwdGg6MX0sdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz12b2lkIDAhPT1uLmdlbmVyYXRlTWlwbWFwcyYmbi5nZW5lcmF0ZU1pcG1hcHMsdGhpcy50ZXh0dXJlLmludGVybmFsRm9ybWF0PXZvaWQgMCE9PW4uaW50ZXJuYWxGb3JtYXQ/bi5pbnRlcm5hbEZvcm1hdDpudWxsLHRoaXMudGV4dHVyZS5taW5GaWx0ZXI9dm9pZCAwIT09bi5taW5GaWx0ZXI/bi5taW5GaWx0ZXI6MTAwNix0aGlzLmRlcHRoQnVmZmVyPXZvaWQgMD09PW4uZGVwdGhCdWZmZXJ8fG4uZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPXZvaWQgMCE9PW4uc3RlbmNpbEJ1ZmZlciYmbi5zdGVuY2lsQnVmZmVyLHRoaXMuZGVwdGhUZXh0dXJlPXZvaWQgMCE9PW4uZGVwdGhUZXh0dXJlP24uZGVwdGhUZXh0dXJlOm51bGx9c2V0VGV4dHVyZSh0KXt0LmltYWdlPXt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodCxkZXB0aDp0aGlzLmRlcHRofSx0aGlzLnRleHR1cmU9dH1zZXRTaXplKHQsZSxuPTEpe3RoaXMud2lkdGg9PT10JiZ0aGlzLmhlaWdodD09PWUmJnRoaXMuZGVwdGg9PT1ufHwodGhpcy53aWR0aD10LHRoaXMuaGVpZ2h0PWUsdGhpcy5kZXB0aD1uLHRoaXMudGV4dHVyZS5pbWFnZS53aWR0aD10LHRoaXMudGV4dHVyZS5pbWFnZS5oZWlnaHQ9ZSx0aGlzLnRleHR1cmUuaW1hZ2UuZGVwdGg9bix0aGlzLmRpc3Bvc2UoKSksdGhpcy52aWV3cG9ydC5zZXQoMCwwLHQsZSksdGhpcy5zY2lzc29yLnNldCgwLDAsdCxlKX1jbG9uZSgpe3JldHVybihuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKX1jb3B5KHQpe3JldHVybiB0aGlzLndpZHRoPXQud2lkdGgsdGhpcy5oZWlnaHQ9dC5oZWlnaHQsdGhpcy5kZXB0aD10LmRlcHRoLHRoaXMudmlld3BvcnQuY29weSh0LnZpZXdwb3J0KSx0aGlzLnRleHR1cmU9dC50ZXh0dXJlLmNsb25lKCksdGhpcy50ZXh0dXJlLmltYWdlPXsuLi50aGlzLnRleHR1cmUuaW1hZ2V9LHRoaXMuZGVwdGhCdWZmZXI9dC5kZXB0aEJ1ZmZlcix0aGlzLnN0ZW5jaWxCdWZmZXI9dC5zdGVuY2lsQnVmZmVyLHRoaXMuZGVwdGhUZXh0dXJlPXQuZGVwdGhUZXh0dXJlLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTpcImRpc3Bvc2VcIn0pfX1VdC5wcm90b3R5cGUuaXNXZWJHTFJlbmRlclRhcmdldD0hMDsoY2xhc3MgZXh0ZW5kcyBVdHtjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIodCxlKTtjb25zdCBpPXRoaXMudGV4dHVyZTt0aGlzLnRleHR1cmU9W107Zm9yKGxldCB0PTA7dDxuO3QrKyl0aGlzLnRleHR1cmVbdF09aS5jbG9uZSgpfXNldFNpemUodCxlLG49MSl7aWYodGhpcy53aWR0aCE9PXR8fHRoaXMuaGVpZ2h0IT09ZXx8dGhpcy5kZXB0aCE9PW4pe3RoaXMud2lkdGg9dCx0aGlzLmhlaWdodD1lLHRoaXMuZGVwdGg9bjtmb3IobGV0IGk9MCxyPXRoaXMudGV4dHVyZS5sZW5ndGg7aTxyO2krKyl0aGlzLnRleHR1cmVbaV0uaW1hZ2Uud2lkdGg9dCx0aGlzLnRleHR1cmVbaV0uaW1hZ2UuaGVpZ2h0PWUsdGhpcy50ZXh0dXJlW2ldLmltYWdlLmRlcHRoPW47dGhpcy5kaXNwb3NlKCl9cmV0dXJuIHRoaXMudmlld3BvcnQuc2V0KDAsMCx0LGUpLHRoaXMuc2Npc3Nvci5zZXQoMCwwLHQsZSksdGhpc31jb3B5KHQpe3RoaXMuZGlzcG9zZSgpLHRoaXMud2lkdGg9dC53aWR0aCx0aGlzLmhlaWdodD10LmhlaWdodCx0aGlzLmRlcHRoPXQuZGVwdGgsdGhpcy52aWV3cG9ydC5zZXQoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuc2Npc3Nvci5zZXQoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuZGVwdGhCdWZmZXI9dC5kZXB0aEJ1ZmZlcix0aGlzLnN0ZW5jaWxCdWZmZXI9dC5zdGVuY2lsQnVmZmVyLHRoaXMuZGVwdGhUZXh0dXJlPXQuZGVwdGhUZXh0dXJlLHRoaXMudGV4dHVyZS5sZW5ndGg9MDtmb3IobGV0IGU9MCxuPXQudGV4dHVyZS5sZW5ndGg7ZTxuO2UrKyl0aGlzLnRleHR1cmVbZV09dC50ZXh0dXJlW2VdLmNsb25lKCk7cmV0dXJuIHRoaXN9fSkucHJvdG90eXBlLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHM9ITA7Y2xhc3Mga3QgZXh0ZW5kcyBVdHtjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIodCxlLG4pLHRoaXMuc2FtcGxlcz00fWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkuY2FsbCh0aGlzLHQpLHRoaXMuc2FtcGxlcz10LnNhbXBsZXMsdGhpc319a3QucHJvdG90eXBlLmlzV2ViR0xNdWx0aXNhbXBsZVJlbmRlclRhcmdldD0hMDtjbGFzcyB6dHtjb25zdHJ1Y3Rvcih0PTAsZT0wLG49MCxpPTEpe3RoaXMuX3g9dCx0aGlzLl95PWUsdGhpcy5fej1uLHRoaXMuX3c9aX1zdGF0aWMgc2xlcnAodCxlLG4saSl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlF1YXRlcm5pb246IFN0YXRpYyAuc2xlcnAoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgcW0uc2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkgaW5zdGVhZC5cIiksbi5zbGVycFF1YXRlcm5pb25zKHQsZSxpKX1zdGF0aWMgc2xlcnBGbGF0KHQsZSxuLGkscixzLGEpe2xldCBvPW5baSswXSxsPW5baSsxXSxjPW5baSsyXSxoPW5baSszXTtjb25zdCB1PXJbcyswXSxkPXJbcysxXSxwPXJbcysyXSxtPXJbcyszXTtpZigwPT09YSlyZXR1cm4gdFtlKzBdPW8sdFtlKzFdPWwsdFtlKzJdPWMsdm9pZCh0W2UrM109aCk7aWYoMT09PWEpcmV0dXJuIHRbZSswXT11LHRbZSsxXT1kLHRbZSsyXT1wLHZvaWQodFtlKzNdPW0pO2lmKGghPT1tfHxvIT09dXx8bCE9PWR8fGMhPT1wKXtsZXQgdD0xLWE7Y29uc3QgZT1vKnUrbCpkK2MqcCtoKm0sbj1lPj0wPzE6LTEsaT0xLWUqZTtpZihpPk51bWJlci5FUFNJTE9OKXtjb25zdCByPU1hdGguc3FydChpKSxzPU1hdGguYXRhbjIocixlKm4pO3Q9TWF0aC5zaW4odCpzKS9yLGE9TWF0aC5zaW4oYSpzKS9yfWNvbnN0IHI9YSpuO2lmKG89byp0K3UqcixsPWwqdCtkKnIsYz1jKnQrcCpyLGg9aCp0K20qcix0PT09MS1hKXtjb25zdCB0PTEvTWF0aC5zcXJ0KG8qbytsKmwrYypjK2gqaCk7byo9dCxsKj10LGMqPXQsaCo9dH19dFtlXT1vLHRbZSsxXT1sLHRbZSsyXT1jLHRbZSszXT1ofXN0YXRpYyBtdWx0aXBseVF1YXRlcm5pb25zRmxhdCh0LGUsbixpLHIscyl7Y29uc3QgYT1uW2ldLG89bltpKzFdLGw9bltpKzJdLGM9bltpKzNdLGg9cltzXSx1PXJbcysxXSxkPXJbcysyXSxwPXJbcyszXTtyZXR1cm4gdFtlXT1hKnArYypoK28qZC1sKnUsdFtlKzFdPW8qcCtjKnUrbCpoLWEqZCx0W2UrMl09bCpwK2MqZCthKnUtbypoLHRbZSszXT1jKnAtYSpoLW8qdS1sKmQsdH1nZXQgeCgpe3JldHVybiB0aGlzLl94fXNldCB4KHQpe3RoaXMuX3g9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5feX1zZXQgeSh0KXt0aGlzLl95PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB6KCl7cmV0dXJuIHRoaXMuX3p9c2V0IHoodCl7dGhpcy5fej10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgdygpe3JldHVybiB0aGlzLl93fXNldCB3KHQpe3RoaXMuX3c9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9c2V0KHQsZSxuLGkpe3JldHVybiB0aGlzLl94PXQsdGhpcy5feT1lLHRoaXMuX3o9bix0aGlzLl93PWksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCx0aGlzLl95LHRoaXMuX3osdGhpcy5fdyl9Y29weSh0KXtyZXR1cm4gdGhpcy5feD10LngsdGhpcy5feT10LnksdGhpcy5fej10LnosdGhpcy5fdz10LncsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUV1bGVyKHQsZSl7aWYoIXR8fCF0LmlzRXVsZXIpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuXCIpO2NvbnN0IG49dC5feCxpPXQuX3kscj10Ll96LHM9dC5fb3JkZXIsYT1NYXRoLmNvcyxvPU1hdGguc2luLGw9YShuLzIpLGM9YShpLzIpLGg9YShyLzIpLHU9byhuLzIpLGQ9byhpLzIpLHA9byhyLzIpO3N3aXRjaChzKXtjYXNlXCJYWVpcIjp0aGlzLl94PXUqYypoK2wqZCpwLHRoaXMuX3k9bCpkKmgtdSpjKnAsdGhpcy5fej1sKmMqcCt1KmQqaCx0aGlzLl93PWwqYypoLXUqZCpwO2JyZWFrO2Nhc2VcIllYWlwiOnRoaXMuX3g9dSpjKmgrbCpkKnAsdGhpcy5feT1sKmQqaC11KmMqcCx0aGlzLl96PWwqYypwLXUqZCpoLHRoaXMuX3c9bCpjKmgrdSpkKnA7YnJlYWs7Y2FzZVwiWlhZXCI6dGhpcy5feD11KmMqaC1sKmQqcCx0aGlzLl95PWwqZCpoK3UqYypwLHRoaXMuX3o9bCpjKnArdSpkKmgsdGhpcy5fdz1sKmMqaC11KmQqcDticmVhaztjYXNlXCJaWVhcIjp0aGlzLl94PXUqYypoLWwqZCpwLHRoaXMuX3k9bCpkKmgrdSpjKnAsdGhpcy5fej1sKmMqcC11KmQqaCx0aGlzLl93PWwqYypoK3UqZCpwO2JyZWFrO2Nhc2VcIllaWFwiOnRoaXMuX3g9dSpjKmgrbCpkKnAsdGhpcy5feT1sKmQqaCt1KmMqcCx0aGlzLl96PWwqYypwLXUqZCpoLHRoaXMuX3c9bCpjKmgtdSpkKnA7YnJlYWs7Y2FzZVwiWFpZXCI6dGhpcy5feD11KmMqaC1sKmQqcCx0aGlzLl95PWwqZCpoLXUqYypwLHRoaXMuX3o9bCpjKnArdSpkKmgsdGhpcy5fdz1sKmMqaCt1KmQqcDticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybihcIlRIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiBcIitzKX1yZXR1cm4hMSE9PWUmJnRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21BeGlzQW5nbGUodCxlKXtjb25zdCBuPWUvMixpPU1hdGguc2luKG4pO3JldHVybiB0aGlzLl94PXQueCppLHRoaXMuX3k9dC55KmksdGhpcy5fej10LnoqaSx0aGlzLl93PU1hdGguY29zKG4pLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21Sb3RhdGlvbk1hdHJpeCh0KXtjb25zdCBlPXQuZWxlbWVudHMsbj1lWzBdLGk9ZVs0XSxyPWVbOF0scz1lWzFdLGE9ZVs1XSxvPWVbOV0sbD1lWzJdLGM9ZVs2XSxoPWVbMTBdLHU9bithK2g7aWYodT4wKXtjb25zdCB0PS41L01hdGguc3FydCh1KzEpO3RoaXMuX3c9LjI1L3QsdGhpcy5feD0oYy1vKSp0LHRoaXMuX3k9KHItbCkqdCx0aGlzLl96PShzLWkpKnR9ZWxzZSBpZihuPmEmJm4+aCl7Y29uc3QgdD0yKk1hdGguc3FydCgxK24tYS1oKTt0aGlzLl93PShjLW8pL3QsdGhpcy5feD0uMjUqdCx0aGlzLl95PShpK3MpL3QsdGhpcy5fej0ocitsKS90fWVsc2UgaWYoYT5oKXtjb25zdCB0PTIqTWF0aC5zcXJ0KDErYS1uLWgpO3RoaXMuX3c9KHItbCkvdCx0aGlzLl94PShpK3MpL3QsdGhpcy5feT0uMjUqdCx0aGlzLl96PShvK2MpL3R9ZWxzZXtjb25zdCB0PTIqTWF0aC5zcXJ0KDEraC1uLWEpO3RoaXMuX3c9KHMtaSkvdCx0aGlzLl94PShyK2wpL3QsdGhpcy5feT0obytjKS90LHRoaXMuX3o9LjI1KnR9cmV0dXJuIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21Vbml0VmVjdG9ycyh0LGUpe2xldCBuPXQuZG90KGUpKzE7cmV0dXJuIG48TnVtYmVyLkVQU0lMT04/KG49MCxNYXRoLmFicyh0LngpPk1hdGguYWJzKHQueik/KHRoaXMuX3g9LXQueSx0aGlzLl95PXQueCx0aGlzLl96PTAsdGhpcy5fdz1uKToodGhpcy5feD0wLHRoaXMuX3k9LXQueix0aGlzLl96PXQueSx0aGlzLl93PW4pKToodGhpcy5feD10LnkqZS56LXQueiplLnksdGhpcy5feT10LnoqZS54LXQueCplLnosdGhpcy5fej10LngqZS55LXQueSplLngsdGhpcy5fdz1uKSx0aGlzLm5vcm1hbGl6ZSgpfWFuZ2xlVG8odCl7cmV0dXJuIDIqTWF0aC5hY29zKE1hdGguYWJzKGJ0KHRoaXMuZG90KHQpLC0xLDEpKSl9cm90YXRlVG93YXJkcyh0LGUpe2NvbnN0IG49dGhpcy5hbmdsZVRvKHQpO2lmKDA9PT1uKXJldHVybiB0aGlzO2NvbnN0IGk9TWF0aC5taW4oMSxlL24pO3JldHVybiB0aGlzLnNsZXJwKHQsaSksdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgwLDAsMCwxKX1pbnZlcnQoKXtyZXR1cm4gdGhpcy5jb25qdWdhdGUoKX1jb25qdWdhdGUoKXtyZXR1cm4gdGhpcy5feCo9LTEsdGhpcy5feSo9LTEsdGhpcy5feio9LTEsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9ZG90KHQpe3JldHVybiB0aGlzLl94KnQuX3grdGhpcy5feSp0Ll95K3RoaXMuX3oqdC5feit0aGlzLl93KnQuX3d9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy5feCp0aGlzLl94K3RoaXMuX3kqdGhpcy5feSt0aGlzLl96KnRoaXMuX3ordGhpcy5fdyp0aGlzLl93fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy5feCp0aGlzLl94K3RoaXMuX3kqdGhpcy5feSt0aGlzLl96KnRoaXMuX3ordGhpcy5fdyp0aGlzLl93KX1ub3JtYWxpemUoKXtsZXQgdD10aGlzLmxlbmd0aCgpO3JldHVybiAwPT09dD8odGhpcy5feD0wLHRoaXMuX3k9MCx0aGlzLl96PTAsdGhpcy5fdz0xKToodD0xL3QsdGhpcy5feD10aGlzLl94KnQsdGhpcy5feT10aGlzLl95KnQsdGhpcy5fej10aGlzLl96KnQsdGhpcy5fdz10aGlzLl93KnQpLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfW11bHRpcGx5KHQsZSl7cmV0dXJuIHZvaWQgMCE9PWU/KGNvbnNvbGUud2FybihcIlRIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModCxlKSk6dGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsdCl9cHJlbXVsdGlwbHkodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0LHRoaXMpfW11bHRpcGx5UXVhdGVybmlvbnModCxlKXtjb25zdCBuPXQuX3gsaT10Ll95LHI9dC5feixzPXQuX3csYT1lLl94LG89ZS5feSxsPWUuX3osYz1lLl93O3JldHVybiB0aGlzLl94PW4qYytzKmEraSpsLXIqbyx0aGlzLl95PWkqYytzKm8rciphLW4qbCx0aGlzLl96PXIqYytzKmwrbipvLWkqYSx0aGlzLl93PXMqYy1uKmEtaSpvLXIqbCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycCh0LGUpe2lmKDA9PT1lKXJldHVybiB0aGlzO2lmKDE9PT1lKXJldHVybiB0aGlzLmNvcHkodCk7Y29uc3Qgbj10aGlzLl94LGk9dGhpcy5feSxyPXRoaXMuX3oscz10aGlzLl93O2xldCBhPXMqdC5fdytuKnQuX3graSp0Ll95K3IqdC5fejtpZihhPDA/KHRoaXMuX3c9LXQuX3csdGhpcy5feD0tdC5feCx0aGlzLl95PS10Ll95LHRoaXMuX3o9LXQuX3osYT0tYSk6dGhpcy5jb3B5KHQpLGE+PTEpcmV0dXJuIHRoaXMuX3c9cyx0aGlzLl94PW4sdGhpcy5feT1pLHRoaXMuX3o9cix0aGlzO2NvbnN0IG89MS1hKmE7aWYobzw9TnVtYmVyLkVQU0lMT04pe2NvbnN0IHQ9MS1lO3JldHVybiB0aGlzLl93PXQqcytlKnRoaXMuX3csdGhpcy5feD10Km4rZSp0aGlzLl94LHRoaXMuX3k9dCppK2UqdGhpcy5feSx0aGlzLl96PXQqcitlKnRoaXMuX3osdGhpcy5ub3JtYWxpemUoKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31jb25zdCBsPU1hdGguc3FydChvKSxjPU1hdGguYXRhbjIobCxhKSxoPU1hdGguc2luKCgxLWUpKmMpL2wsdT1NYXRoLnNpbihlKmMpL2w7cmV0dXJuIHRoaXMuX3c9cypoK3RoaXMuX3cqdSx0aGlzLl94PW4qaCt0aGlzLl94KnUsdGhpcy5feT1pKmgrdGhpcy5feSp1LHRoaXMuX3o9cipoK3RoaXMuX3oqdSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycFF1YXRlcm5pb25zKHQsZSxuKXt0aGlzLmNvcHkodCkuc2xlcnAoZSxuKX1yYW5kb20oKXtjb25zdCB0PU1hdGgucmFuZG9tKCksZT1NYXRoLnNxcnQoMS10KSxuPU1hdGguc3FydCh0KSxpPTIqTWF0aC5QSSpNYXRoLnJhbmRvbSgpLHI9MipNYXRoLlBJKk1hdGgucmFuZG9tKCk7cmV0dXJuIHRoaXMuc2V0KGUqTWF0aC5jb3MoaSksbipNYXRoLnNpbihyKSxuKk1hdGguY29zKHIpLGUqTWF0aC5zaW4oaSkpfWVxdWFscyh0KXtyZXR1cm4gdC5feD09PXRoaXMuX3gmJnQuX3k9PT10aGlzLl95JiZ0Ll96PT09dGhpcy5feiYmdC5fdz09PXRoaXMuX3d9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy5feD10W2VdLHRoaXMuX3k9dFtlKzFdLHRoaXMuX3o9dFtlKzJdLHRoaXMuX3c9dFtlKzNdLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMuX3gsdFtlKzFdPXRoaXMuX3ksdFtlKzJdPXRoaXMuX3osdFtlKzNdPXRoaXMuX3csdH1mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMuX3g9dC5nZXRYKGUpLHRoaXMuX3k9dC5nZXRZKGUpLHRoaXMuX3o9dC5nZXRaKGUpLHRoaXMuX3c9dC5nZXRXKGUpLHRoaXN9X29uQ2hhbmdlKHQpe3JldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrPXQsdGhpc31fb25DaGFuZ2VDYWxsYmFjaygpe319enQucHJvdG90eXBlLmlzUXVhdGVybmlvbj0hMDtjbGFzcyBCdHtjb25zdHJ1Y3Rvcih0PTAsZT0wLG49MCl7dGhpcy54PXQsdGhpcy55PWUsdGhpcy56PW59c2V0KHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49dGhpcy56KSx0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9bix0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PXQsdGhpcy56PXQsdGhpc31zZXRYKHQpe3JldHVybiB0aGlzLng9dCx0aGlzfXNldFkodCl7cmV0dXJuIHRoaXMueT10LHRoaXN9c2V0Wih0KXtyZXR1cm4gdGhpcy56PXQsdGhpc31zZXRDb21wb25lbnQodCxlKXtzd2l0Y2godCl7Y2FzZSAwOnRoaXMueD1lO2JyZWFrO2Nhc2UgMTp0aGlzLnk9ZTticmVhaztjYXNlIDI6dGhpcy56PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiK3QpfXJldHVybiB0aGlzfWdldENvbXBvbmVudCh0KXtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB0aGlzLng7Y2FzZSAxOnJldHVybiB0aGlzLnk7Y2FzZSAyOnJldHVybiB0aGlzLno7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiK3QpfX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsdGhpcy55LHRoaXMueil9Y29weSh0KXtyZXR1cm4gdGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LnosdGhpc31hZGQodCxlKXtyZXR1cm4gdm9pZCAwIT09ZT8oY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLmFkZFZlY3RvcnModCxlKSk6KHRoaXMueCs9dC54LHRoaXMueSs9dC55LHRoaXMueis9dC56LHRoaXMpfWFkZFNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kz10LHRoaXMueSs9dCx0aGlzLnorPXQsdGhpc31hZGRWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngrZS54LHRoaXMueT10LnkrZS55LHRoaXMuej10LnorZS56LHRoaXN9YWRkU2NhbGVkVmVjdG9yKHQsZSl7cmV0dXJuIHRoaXMueCs9dC54KmUsdGhpcy55Kz10LnkqZSx0aGlzLnorPXQueiplLHRoaXN9c3ViKHQsZSl7cmV0dXJuIHZvaWQgMCE9PWU/KGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5zdWJWZWN0b3JzKHQsZSkpOih0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzLnotPXQueix0aGlzKX1zdWJTY2FsYXIodCl7cmV0dXJuIHRoaXMueC09dCx0aGlzLnktPXQsdGhpcy56LT10LHRoaXN9c3ViVmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54LWUueCx0aGlzLnk9dC55LWUueSx0aGlzLno9dC56LWUueix0aGlzfW11bHRpcGx5KHQsZSl7cmV0dXJuIHZvaWQgMCE9PWU/KGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMubXVsdGlwbHlWZWN0b3JzKHQsZSkpOih0aGlzLngqPXQueCx0aGlzLnkqPXQueSx0aGlzLnoqPXQueix0aGlzKX1tdWx0aXBseVNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXQsdGhpc31tdWx0aXBseVZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueCplLngsdGhpcy55PXQueSplLnksdGhpcy56PXQueiplLnosdGhpc31hcHBseUV1bGVyKHQpe3JldHVybiB0JiZ0LmlzRXVsZXJ8fGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuXCIpLHRoaXMuYXBwbHlRdWF0ZXJuaW9uKFZ0LnNldEZyb21FdWxlcih0KSl9YXBwbHlBeGlzQW5nbGUodCxlKXtyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oVnQuc2V0RnJvbUF4aXNBbmdsZSh0LGUpKX1hcHBseU1hdHJpeDModCl7Y29uc3QgZT10aGlzLngsbj10aGlzLnksaT10aGlzLnoscj10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9clswXSplK3JbM10qbityWzZdKmksdGhpcy55PXJbMV0qZStyWzRdKm4rcls3XSppLHRoaXMuej1yWzJdKmUrcls1XSpuK3JbOF0qaSx0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KHQpe3JldHVybiB0aGlzLmFwcGx5TWF0cml4Myh0KS5ub3JtYWxpemUoKX1hcHBseU1hdHJpeDQodCl7Y29uc3QgZT10aGlzLngsbj10aGlzLnksaT10aGlzLnoscj10LmVsZW1lbnRzLHM9MS8oclszXSplK3JbN10qbityWzExXSppK3JbMTVdKTtyZXR1cm4gdGhpcy54PShyWzBdKmUrcls0XSpuK3JbOF0qaStyWzEyXSkqcyx0aGlzLnk9KHJbMV0qZStyWzVdKm4rcls5XSppK3JbMTNdKSpzLHRoaXMuej0oclsyXSplK3JbNl0qbityWzEwXSppK3JbMTRdKSpzLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKHQpe2NvbnN0IGU9dGhpcy54LG49dGhpcy55LGk9dGhpcy56LHI9dC54LHM9dC55LGE9dC56LG89dC53LGw9byplK3MqaS1hKm4sYz1vKm4rYSplLXIqaSxoPW8qaStyKm4tcyplLHU9LXIqZS1zKm4tYSppO3JldHVybiB0aGlzLng9bCpvK3UqLXIrYyotYS1oKi1zLHRoaXMueT1jKm8rdSotcytoKi1yLWwqLWEsdGhpcy56PWgqbyt1Ki1hK2wqLXMtYyotcix0aGlzfXByb2plY3QodCl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGRJbnZlcnNlKS5hcHBseU1hdHJpeDQodC5wcm9qZWN0aW9uTWF0cml4KX11bnByb2plY3QodCl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KHQucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkKX10cmFuc2Zvcm1EaXJlY3Rpb24odCl7Y29uc3QgZT10aGlzLngsbj10aGlzLnksaT10aGlzLnoscj10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9clswXSplK3JbNF0qbityWzhdKmksdGhpcy55PXJbMV0qZStyWzVdKm4rcls5XSppLHRoaXMuej1yWzJdKmUrcls2XSpuK3JbMTBdKmksdGhpcy5ub3JtYWxpemUoKX1kaXZpZGUodCl7cmV0dXJuIHRoaXMueC89dC54LHRoaXMueS89dC55LHRoaXMuei89dC56LHRoaXN9ZGl2aWRlU2NhbGFyKHQpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEvdCl9bWluKHQpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LHQueCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0LnkpLHRoaXMuej1NYXRoLm1pbih0aGlzLnosdC56KSx0aGlzfW1heCh0KXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCx0LngpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksdC55KSx0aGlzLno9TWF0aC5tYXgodGhpcy56LHQueiksdGhpc31jbGFtcCh0LGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodC54LE1hdGgubWluKGUueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodC55LE1hdGgubWluKGUueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgodC56LE1hdGgubWluKGUueix0aGlzLnopKSx0aGlzfWNsYW1wU2NhbGFyKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueikpLHRoaXN9Y2xhbXBMZW5ndGgodCxlKXtjb25zdCBuPXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKG58fDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KHQsTWF0aC5taW4oZSxuKSkpfWZsb29yKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzLno9TWF0aC5mbG9vcih0aGlzLnopLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXMuej1NYXRoLmNlaWwodGhpcy56KSx0aGlzfXJvdW5kKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzLno9TWF0aC5yb3VuZCh0aGlzLnopLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PXRoaXMueDwwP01hdGguY2VpbCh0aGlzLngpOk1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9dGhpcy55PDA/TWF0aC5jZWlsKHRoaXMueSk6TWF0aC5mbG9vcih0aGlzLnkpLHRoaXMuej10aGlzLno8MD9NYXRoLmNlaWwodGhpcy56KTpNYXRoLmZsb29yKHRoaXMueiksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpc31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9c2V0TGVuZ3RoKHQpe3JldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHQpfWxlcnAodCxlKXtyZXR1cm4gdGhpcy54Kz0odC54LXRoaXMueCkqZSx0aGlzLnkrPSh0LnktdGhpcy55KSplLHRoaXMueis9KHQuei10aGlzLnopKmUsdGhpc31sZXJwVmVjdG9ycyh0LGUsbil7cmV0dXJuIHRoaXMueD10LngrKGUueC10LngpKm4sdGhpcy55PXQueSsoZS55LXQueSkqbix0aGlzLno9dC56KyhlLnotdC56KSpuLHRoaXN9Y3Jvc3ModCxlKXtyZXR1cm4gdm9pZCAwIT09ZT8oY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5jcm9zc1ZlY3RvcnModCxlKSk6dGhpcy5jcm9zc1ZlY3RvcnModGhpcyx0KX1jcm9zc1ZlY3RvcnModCxlKXtjb25zdCBuPXQueCxpPXQueSxyPXQueixzPWUueCxhPWUueSxvPWUuejtyZXR1cm4gdGhpcy54PWkqby1yKmEsdGhpcy55PXIqcy1uKm8sdGhpcy56PW4qYS1pKnMsdGhpc31wcm9qZWN0T25WZWN0b3IodCl7Y29uc3QgZT10Lmxlbmd0aFNxKCk7aWYoMD09PWUpcmV0dXJuIHRoaXMuc2V0KDAsMCwwKTtjb25zdCBuPXQuZG90KHRoaXMpL2U7cmV0dXJuIHRoaXMuY29weSh0KS5tdWx0aXBseVNjYWxhcihuKX1wcm9qZWN0T25QbGFuZSh0KXtyZXR1cm4gSHQuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IodCksdGhpcy5zdWIoSHQpfXJlZmxlY3QodCl7cmV0dXJuIHRoaXMuc3ViKEh0LmNvcHkodCkubXVsdGlwbHlTY2FsYXIoMip0aGlzLmRvdCh0KSkpfWFuZ2xlVG8odCl7Y29uc3QgZT1NYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpKnQubGVuZ3RoU3EoKSk7aWYoMD09PWUpcmV0dXJuIE1hdGguUEkvMjtjb25zdCBuPXRoaXMuZG90KHQpL2U7cmV0dXJuIE1hdGguYWNvcyhidChuLC0xLDEpKX1kaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh0KSl9ZGlzdGFuY2VUb1NxdWFyZWQodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueSxpPXRoaXMuei10Lno7cmV0dXJuIGUqZStuKm4raSppfW1hbmhhdHRhbkRpc3RhbmNlVG8odCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueC10LngpK01hdGguYWJzKHRoaXMueS10LnkpK01hdGguYWJzKHRoaXMuei10LnopfXNldEZyb21TcGhlcmljYWwodCl7cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyh0LnJhZGl1cyx0LnBoaSx0LnRoZXRhKX1zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKHQsZSxuKXtjb25zdCBpPU1hdGguc2luKGUpKnQ7cmV0dXJuIHRoaXMueD1pKk1hdGguc2luKG4pLHRoaXMueT1NYXRoLmNvcyhlKSp0LHRoaXMuej1pKk1hdGguY29zKG4pLHRoaXN9c2V0RnJvbUN5bGluZHJpY2FsKHQpe3JldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3Jkcyh0LnJhZGl1cyx0LnRoZXRhLHQueSl9c2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKHQsZSxuKXtyZXR1cm4gdGhpcy54PXQqTWF0aC5zaW4oZSksdGhpcy55PW4sdGhpcy56PXQqTWF0aC5jb3MoZSksdGhpc31zZXRGcm9tTWF0cml4UG9zaXRpb24odCl7Y29uc3QgZT10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9ZVsxMl0sdGhpcy55PWVbMTNdLHRoaXMuej1lWzE0XSx0aGlzfXNldEZyb21NYXRyaXhTY2FsZSh0KXtjb25zdCBlPXRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LDApLmxlbmd0aCgpLG49dGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMSkubGVuZ3RoKCksaT10aGlzLnNldEZyb21NYXRyaXhDb2x1bW4odCwyKS5sZW5ndGgoKTtyZXR1cm4gdGhpcy54PWUsdGhpcy55PW4sdGhpcy56PWksdGhpc31zZXRGcm9tTWF0cml4Q29sdW1uKHQsZSl7cmV0dXJuIHRoaXMuZnJvbUFycmF5KHQuZWxlbWVudHMsNCplKX1zZXRGcm9tTWF0cml4M0NvbHVtbih0LGUpe3JldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLDMqZSl9ZXF1YWxzKHQpe3JldHVybiB0Lng9PT10aGlzLngmJnQueT09PXRoaXMueSYmdC56PT09dGhpcy56fWZyb21BcnJheSh0LGU9MCl7cmV0dXJuIHRoaXMueD10W2VdLHRoaXMueT10W2UrMV0sdGhpcy56PXRbZSsyXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMueCx0W2UrMV09dGhpcy55LHRbZSsyXT10aGlzLnosdH1mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSxuKXtyZXR1cm4gdm9pZCAwIT09biYmY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLlwiKSx0aGlzLng9dC5nZXRYKGUpLHRoaXMueT10LmdldFkoZSksdGhpcy56PXQuZ2V0WihlKSx0aGlzfXJhbmRvbSgpe3JldHVybiB0aGlzLng9TWF0aC5yYW5kb20oKSx0aGlzLnk9TWF0aC5yYW5kb20oKSx0aGlzLno9TWF0aC5yYW5kb20oKSx0aGlzfXJhbmRvbURpcmVjdGlvbigpe2NvbnN0IHQ9MiooTWF0aC5yYW5kb20oKS0uNSksZT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMixuPU1hdGguc3FydCgxLXQqKjIpO3JldHVybiB0aGlzLng9bipNYXRoLmNvcyhlKSx0aGlzLnk9bipNYXRoLnNpbihlKSx0aGlzLno9dCx0aGlzfSpbU3ltYm9sLml0ZXJhdG9yXSgpe3lpZWxkIHRoaXMueCx5aWVsZCB0aGlzLnkseWllbGQgdGhpcy56fX1CdC5wcm90b3R5cGUuaXNWZWN0b3IzPSEwO2NvbnN0IEh0PW5ldyBCdCxWdD1uZXcgenQ7Y2xhc3MgR3R7Y29uc3RydWN0b3IodD1uZXcgQnQoMS8wLDEvMCwxLzApLGU9bmV3IEJ0KC0xLzAsLTEvMCwtMS8wKSl7dGhpcy5taW49dCx0aGlzLm1heD1lfXNldCh0LGUpe3JldHVybiB0aGlzLm1pbi5jb3B5KHQpLHRoaXMubWF4LmNvcHkoZSksdGhpc31zZXRGcm9tQXJyYXkodCl7bGV0IGU9MS8wLG49MS8wLGk9MS8wLHI9LTEvMCxzPS0xLzAsYT0tMS8wO2ZvcihsZXQgbz0wLGw9dC5sZW5ndGg7bzxsO28rPTMpe2NvbnN0IGw9dFtvXSxjPXRbbysxXSxoPXRbbysyXTtsPGUmJihlPWwpLGM8biYmKG49YyksaDxpJiYoaT1oKSxsPnImJihyPWwpLGM+cyYmKHM9YyksaD5hJiYoYT1oKX1yZXR1cm4gdGhpcy5taW4uc2V0KGUsbixpKSx0aGlzLm1heC5zZXQocixzLGEpLHRoaXN9c2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSh0KXtsZXQgZT0xLzAsbj0xLzAsaT0xLzAscj0tMS8wLHM9LTEvMCxhPS0xLzA7Zm9yKGxldCBvPTAsbD10LmNvdW50O288bDtvKyspe2NvbnN0IGw9dC5nZXRYKG8pLGM9dC5nZXRZKG8pLGg9dC5nZXRaKG8pO2w8ZSYmKGU9bCksYzxuJiYobj1jKSxoPGkmJihpPWgpLGw+ciYmKHI9bCksYz5zJiYocz1jKSxoPmEmJihhPWgpfXJldHVybiB0aGlzLm1pbi5zZXQoZSxuLGkpLHRoaXMubWF4LnNldChyLHMsYSksdGhpc31zZXRGcm9tUG9pbnRzKHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXRoaXMuZXhwYW5kQnlQb2ludCh0W2VdKTtyZXR1cm4gdGhpc31zZXRGcm9tQ2VudGVyQW5kU2l6ZSh0LGUpe2NvbnN0IG49anQuY29weShlKS5tdWx0aXBseVNjYWxhciguNSk7cmV0dXJuIHRoaXMubWluLmNvcHkodCkuc3ViKG4pLHRoaXMubWF4LmNvcHkodCkuYWRkKG4pLHRoaXN9c2V0RnJvbU9iamVjdCh0KXtyZXR1cm4gdGhpcy5tYWtlRW1wdHkoKSx0aGlzLmV4cGFuZEJ5T2JqZWN0KHQpfWNsb25lKCl7cmV0dXJuKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpfWNvcHkodCl7cmV0dXJuIHRoaXMubWluLmNvcHkodC5taW4pLHRoaXMubWF4LmNvcHkodC5tYXgpLHRoaXN9bWFrZUVtcHR5KCl7cmV0dXJuIHRoaXMubWluLng9dGhpcy5taW4ueT10aGlzLm1pbi56PTEvMCx0aGlzLm1heC54PXRoaXMubWF4Lnk9dGhpcy5tYXguej0tMS8wLHRoaXN9aXNFbXB0eSgpe3JldHVybiB0aGlzLm1heC54PHRoaXMubWluLnh8fHRoaXMubWF4Lnk8dGhpcy5taW4ueXx8dGhpcy5tYXguejx0aGlzLm1pbi56fWdldENlbnRlcih0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dC5zZXQoMCwwLDApOnQuYWRkVmVjdG9ycyh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoLjUpfWdldFNpemUodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfWV4cGFuZEJ5UG9pbnQodCl7cmV0dXJuIHRoaXMubWluLm1pbih0KSx0aGlzLm1heC5tYXgodCksdGhpc31leHBhbmRCeVZlY3Rvcih0KXtyZXR1cm4gdGhpcy5taW4uc3ViKHQpLHRoaXMubWF4LmFkZCh0KSx0aGlzfWV4cGFuZEJ5U2NhbGFyKHQpe3JldHVybiB0aGlzLm1pbi5hZGRTY2FsYXIoLXQpLHRoaXMubWF4LmFkZFNjYWxhcih0KSx0aGlzfWV4cGFuZEJ5T2JqZWN0KHQpe3QudXBkYXRlV29ybGRNYXRyaXgoITEsITEpO2NvbnN0IGU9dC5nZW9tZXRyeTt2b2lkIDAhPT1lJiYobnVsbD09PWUuYm91bmRpbmdCb3gmJmUuY29tcHV0ZUJvdW5kaW5nQm94KCkscXQuY29weShlLmJvdW5kaW5nQm94KSxxdC5hcHBseU1hdHJpeDQodC5tYXRyaXhXb3JsZCksdGhpcy51bmlvbihxdCkpO2NvbnN0IG49dC5jaGlsZHJlbjtmb3IobGV0IHQ9MCxlPW4ubGVuZ3RoO3Q8ZTt0KyspdGhpcy5leHBhbmRCeU9iamVjdChuW3RdKTtyZXR1cm4gdGhpc31jb250YWluc1BvaW50KHQpe3JldHVybiEodC54PHRoaXMubWluLnh8fHQueD50aGlzLm1heC54fHx0Lnk8dGhpcy5taW4ueXx8dC55PnRoaXMubWF4Lnl8fHQuejx0aGlzLm1pbi56fHx0Lno+dGhpcy5tYXgueil9Y29udGFpbnNCb3godCl7cmV0dXJuIHRoaXMubWluLng8PXQubWluLngmJnQubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PXQubWluLnkmJnQubWF4Lnk8PXRoaXMubWF4LnkmJnRoaXMubWluLno8PXQubWluLnomJnQubWF4Lno8PXRoaXMubWF4Lnp9Z2V0UGFyYW1ldGVyKHQsZSl7cmV0dXJuIGUuc2V0KCh0LngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtdGhpcy5taW4ueCksKHQueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSwodC56LXRoaXMubWluLnopLyh0aGlzLm1heC56LXRoaXMubWluLnopKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiEodC5tYXgueDx0aGlzLm1pbi54fHx0Lm1pbi54PnRoaXMubWF4Lnh8fHQubWF4Lnk8dGhpcy5taW4ueXx8dC5taW4ueT50aGlzLm1heC55fHx0Lm1heC56PHRoaXMubWluLnp8fHQubWluLno+dGhpcy5tYXgueil9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4gdGhpcy5jbGFtcFBvaW50KHQuY2VudGVyLGp0KSxqdC5kaXN0YW5jZVRvU3F1YXJlZCh0LmNlbnRlcik8PXQucmFkaXVzKnQucmFkaXVzfWludGVyc2VjdHNQbGFuZSh0KXtsZXQgZSxuO3JldHVybiB0Lm5vcm1hbC54PjA/KGU9dC5ub3JtYWwueCp0aGlzLm1pbi54LG49dC5ub3JtYWwueCp0aGlzLm1heC54KTooZT10Lm5vcm1hbC54KnRoaXMubWF4Lngsbj10Lm5vcm1hbC54KnRoaXMubWluLngpLHQubm9ybWFsLnk+MD8oZSs9dC5ub3JtYWwueSp0aGlzLm1pbi55LG4rPXQubm9ybWFsLnkqdGhpcy5tYXgueSk6KGUrPXQubm9ybWFsLnkqdGhpcy5tYXgueSxuKz10Lm5vcm1hbC55KnRoaXMubWluLnkpLHQubm9ybWFsLno+MD8oZSs9dC5ub3JtYWwueip0aGlzLm1pbi56LG4rPXQubm9ybWFsLnoqdGhpcy5tYXgueik6KGUrPXQubm9ybWFsLnoqdGhpcy5tYXgueixuKz10Lm5vcm1hbC56KnRoaXMubWluLnopLGU8PS10LmNvbnN0YW50JiZuPj0tdC5jb25zdGFudH1pbnRlcnNlY3RzVHJpYW5nbGUodCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7dGhpcy5nZXRDZW50ZXIoUXQpLHRlLnN1YlZlY3RvcnModGhpcy5tYXgsUXQpLFh0LnN1YlZlY3RvcnModC5hLFF0KSxZdC5zdWJWZWN0b3JzKHQuYixRdCksWnQuc3ViVmVjdG9ycyh0LmMsUXQpLEp0LnN1YlZlY3RvcnMoWXQsWHQpLCR0LnN1YlZlY3RvcnMoWnQsWXQpLEt0LnN1YlZlY3RvcnMoWHQsWnQpO2xldCBlPVswLC1KdC56LEp0LnksMCwtJHQueiwkdC55LDAsLUt0LnosS3QueSxKdC56LDAsLUp0LngsJHQueiwwLC0kdC54LEt0LnosMCwtS3QueCwtSnQueSxKdC54LDAsLSR0LnksJHQueCwwLC1LdC55LEt0LngsMF07cmV0dXJuISFpZShlLFh0LFl0LFp0LHRlKSYmKGU9WzEsMCwwLDAsMSwwLDAsMCwxXSwhIWllKGUsWHQsWXQsWnQsdGUpJiYoZWUuY3Jvc3NWZWN0b3JzKEp0LCR0KSxlPVtlZS54LGVlLnksZWUuel0saWUoZSxYdCxZdCxadCx0ZSkpKX1jbGFtcFBvaW50KHQsZSl7cmV0dXJuIGUuY29weSh0KS5jbGFtcCh0aGlzLm1pbix0aGlzLm1heCl9ZGlzdGFuY2VUb1BvaW50KHQpe3JldHVybiBqdC5jb3B5KHQpLmNsYW1wKHRoaXMubWluLHRoaXMubWF4KS5zdWIodCkubGVuZ3RoKCl9Z2V0Qm91bmRpbmdTcGhlcmUodCl7cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKHQuY2VudGVyKSx0LnJhZGl1cz0uNSp0aGlzLmdldFNpemUoanQpLmxlbmd0aCgpLHR9aW50ZXJzZWN0KHQpe3JldHVybiB0aGlzLm1pbi5tYXgodC5taW4pLHRoaXMubWF4Lm1pbih0Lm1heCksdGhpcy5pc0VtcHR5KCkmJnRoaXMubWFrZUVtcHR5KCksdGhpc311bmlvbih0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQubWluKSx0aGlzLm1heC5tYXgodC5tYXgpLHRoaXN9YXBwbHlNYXRyaXg0KHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKXx8KFd0WzBdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLFd0WzFdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLFd0WzJdLnNldCh0aGlzLm1pbi54LHRoaXMubWF4LnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLFd0WzNdLnNldCh0aGlzLm1pbi54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLFd0WzRdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLFd0WzVdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLFd0WzZdLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLFd0WzddLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0RnJvbVBvaW50cyhXdCkpLHRoaXN9dHJhbnNsYXRlKHQpe3JldHVybiB0aGlzLm1pbi5hZGQodCksdGhpcy5tYXguYWRkKHQpLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lm1pbi5lcXVhbHModGhpcy5taW4pJiZ0Lm1heC5lcXVhbHModGhpcy5tYXgpfX1HdC5wcm90b3R5cGUuaXNCb3gzPSEwO2NvbnN0IFd0PVtuZXcgQnQsbmV3IEJ0LG5ldyBCdCxuZXcgQnQsbmV3IEJ0LG5ldyBCdCxuZXcgQnQsbmV3IEJ0XSxqdD1uZXcgQnQscXQ9bmV3IEd0LFh0PW5ldyBCdCxZdD1uZXcgQnQsWnQ9bmV3IEJ0LEp0PW5ldyBCdCwkdD1uZXcgQnQsS3Q9bmV3IEJ0LFF0PW5ldyBCdCx0ZT1uZXcgQnQsZWU9bmV3IEJ0LG5lPW5ldyBCdDtmdW5jdGlvbiBpZSh0LGUsbixpLHIpe2ZvcihsZXQgcz0wLGE9dC5sZW5ndGgtMztzPD1hO3MrPTMpe25lLmZyb21BcnJheSh0LHMpO2NvbnN0IGE9ci54Kk1hdGguYWJzKG5lLngpK3IueSpNYXRoLmFicyhuZS55KStyLnoqTWF0aC5hYnMobmUueiksbz1lLmRvdChuZSksbD1uLmRvdChuZSksYz1pLmRvdChuZSk7aWYoTWF0aC5tYXgoLU1hdGgubWF4KG8sbCxjKSxNYXRoLm1pbihvLGwsYykpPmEpcmV0dXJuITF9cmV0dXJuITB9Y29uc3QgcmU9bmV3IEd0LHNlPW5ldyBCdCxhZT1uZXcgQnQsb2U9bmV3IEJ0O2NsYXNzIGxle2NvbnN0cnVjdG9yKHQ9bmV3IEJ0LGU9LTEpe3RoaXMuY2VudGVyPXQsdGhpcy5yYWRpdXM9ZX1zZXQodCxlKXtyZXR1cm4gdGhpcy5jZW50ZXIuY29weSh0KSx0aGlzLnJhZGl1cz1lLHRoaXN9c2V0RnJvbVBvaW50cyh0LGUpe2NvbnN0IG49dGhpcy5jZW50ZXI7dm9pZCAwIT09ZT9uLmNvcHkoZSk6cmUuc2V0RnJvbVBvaW50cyh0KS5nZXRDZW50ZXIobik7bGV0IGk9MDtmb3IobGV0IGU9MCxyPXQubGVuZ3RoO2U8cjtlKyspaT1NYXRoLm1heChpLG4uZGlzdGFuY2VUb1NxdWFyZWQodFtlXSkpO3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQoaSksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KHQuY2VudGVyKSx0aGlzLnJhZGl1cz10LnJhZGl1cyx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5yYWRpdXM8MH1tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5jZW50ZXIuc2V0KDAsMCwwKSx0aGlzLnJhZGl1cz0tMSx0aGlzfWNvbnRhaW5zUG9pbnQodCl7cmV0dXJuIHQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD10aGlzLnJhZGl1cyp0aGlzLnJhZGl1c31kaXN0YW5jZVRvUG9pbnQodCl7cmV0dXJuIHQuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9aW50ZXJzZWN0c1NwaGVyZSh0KXtjb25zdCBlPXRoaXMucmFkaXVzK3QucmFkaXVzO3JldHVybiB0LmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcik8PWUqZX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiB0LmludGVyc2VjdHNTcGhlcmUodGhpcyl9aW50ZXJzZWN0c1BsYW5lKHQpe3JldHVybiBNYXRoLmFicyh0LmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpPD10aGlzLnJhZGl1c31jbGFtcFBvaW50KHQsZSl7Y29uc3Qgbj10aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0KTtyZXR1cm4gZS5jb3B5KHQpLG4+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMmJihlLnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCksZS5tdWx0aXBseVNjYWxhcih0aGlzLnJhZGl1cykuYWRkKHRoaXMuY2VudGVyKSksZX1nZXRCb3VuZGluZ0JveCh0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/KHQubWFrZUVtcHR5KCksdCk6KHQuc2V0KHRoaXMuY2VudGVyLHRoaXMuY2VudGVyKSx0LmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKSx0KX1hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCh0KSx0aGlzLnJhZGl1cz10aGlzLnJhZGl1cyp0LmdldE1heFNjYWxlT25BeGlzKCksdGhpc310cmFuc2xhdGUodCl7cmV0dXJuIHRoaXMuY2VudGVyLmFkZCh0KSx0aGlzfWV4cGFuZEJ5UG9pbnQodCl7b2Uuc3ViVmVjdG9ycyh0LHRoaXMuY2VudGVyKTtjb25zdCBlPW9lLmxlbmd0aFNxKCk7aWYoZT50aGlzLnJhZGl1cyp0aGlzLnJhZGl1cyl7Y29uc3QgdD1NYXRoLnNxcnQoZSksbj0uNSoodC10aGlzLnJhZGl1cyk7dGhpcy5jZW50ZXIuYWRkKG9lLm11bHRpcGx5U2NhbGFyKG4vdCkpLHRoaXMucmFkaXVzKz1ufXJldHVybiB0aGlzfXVuaW9uKHQpe3JldHVybiBhZS5zdWJWZWN0b3JzKHQuY2VudGVyLHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcih0LnJhZGl1cyksdGhpcy5leHBhbmRCeVBvaW50KHNlLmNvcHkodC5jZW50ZXIpLmFkZChhZSkpLHRoaXMuZXhwYW5kQnlQb2ludChzZS5jb3B5KHQuY2VudGVyKS5zdWIoYWUpKSx0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC5jZW50ZXIuZXF1YWxzKHRoaXMuY2VudGVyKSYmdC5yYWRpdXM9PT10aGlzLnJhZGl1c31jbG9uZSgpe3JldHVybihuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKX19Y29uc3QgY2U9bmV3IEJ0LGhlPW5ldyBCdCx1ZT1uZXcgQnQsZGU9bmV3IEJ0LHBlPW5ldyBCdCxtZT1uZXcgQnQsZmU9bmV3IEJ0O2NsYXNzIGdle2NvbnN0cnVjdG9yKHQ9bmV3IEJ0LGU9bmV3IEJ0KDAsMCwtMSkpe3RoaXMub3JpZ2luPXQsdGhpcy5kaXJlY3Rpb249ZX1zZXQodCxlKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weSh0KSx0aGlzLmRpcmVjdGlvbi5jb3B5KGUpLHRoaXN9Y29weSh0KXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weSh0Lm9yaWdpbiksdGhpcy5kaXJlY3Rpb24uY29weSh0LmRpcmVjdGlvbiksdGhpc31hdCh0LGUpe3JldHVybiBlLmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLm9yaWdpbil9bG9va0F0KHQpe3JldHVybiB0aGlzLmRpcmVjdGlvbi5jb3B5KHQpLnN1Yih0aGlzLm9yaWdpbikubm9ybWFsaXplKCksdGhpc31yZWNhc3QodCl7cmV0dXJuIHRoaXMub3JpZ2luLmNvcHkodGhpcy5hdCh0LGNlKSksdGhpc31jbG9zZXN0UG9pbnRUb1BvaW50KHQsZSl7ZS5zdWJWZWN0b3JzKHQsdGhpcy5vcmlnaW4pO2NvbnN0IG49ZS5kb3QodGhpcy5kaXJlY3Rpb24pO3JldHVybiBuPDA/ZS5jb3B5KHRoaXMub3JpZ2luKTplLmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKG4pLmFkZCh0aGlzLm9yaWdpbil9ZGlzdGFuY2VUb1BvaW50KHQpe3JldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG9Qb2ludCh0KSl9ZGlzdGFuY2VTcVRvUG9pbnQodCl7Y29uc3QgZT1jZS5zdWJWZWN0b3JzKHQsdGhpcy5vcmlnaW4pLmRvdCh0aGlzLmRpcmVjdGlvbik7cmV0dXJuIGU8MD90aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCh0KTooY2UuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoZSkuYWRkKHRoaXMub3JpZ2luKSxjZS5kaXN0YW5jZVRvU3F1YXJlZCh0KSl9ZGlzdGFuY2VTcVRvU2VnbWVudCh0LGUsbixpKXtoZS5jb3B5KHQpLmFkZChlKS5tdWx0aXBseVNjYWxhciguNSksdWUuY29weShlKS5zdWIodCkubm9ybWFsaXplKCksZGUuY29weSh0aGlzLm9yaWdpbikuc3ViKGhlKTtjb25zdCByPS41KnQuZGlzdGFuY2VUbyhlKSxzPS10aGlzLmRpcmVjdGlvbi5kb3QodWUpLGE9ZGUuZG90KHRoaXMuZGlyZWN0aW9uKSxvPS1kZS5kb3QodWUpLGw9ZGUubGVuZ3RoU3EoKSxjPU1hdGguYWJzKDEtcypzKTtsZXQgaCx1LGQscDtpZihjPjApaWYoaD1zKm8tYSx1PXMqYS1vLHA9cipjLGg+PTApaWYodT49LXApaWYodTw9cCl7Y29uc3QgdD0xL2M7aCo9dCx1Kj10LGQ9aCooaCtzKnUrMiphKSt1KihzKmgrdSsyKm8pK2x9ZWxzZSB1PXIsaD1NYXRoLm1heCgwLC0ocyp1K2EpKSxkPS1oKmgrdSoodSsyKm8pK2w7ZWxzZSB1PS1yLGg9TWF0aC5tYXgoMCwtKHMqdSthKSksZD0taCpoK3UqKHUrMipvKStsO2Vsc2UgdTw9LXA/KGg9TWF0aC5tYXgoMCwtKC1zKnIrYSkpLHU9aD4wPy1yOk1hdGgubWluKE1hdGgubWF4KC1yLC1vKSxyKSxkPS1oKmgrdSoodSsyKm8pK2wpOnU8PXA/KGg9MCx1PU1hdGgubWluKE1hdGgubWF4KC1yLC1vKSxyKSxkPXUqKHUrMipvKStsKTooaD1NYXRoLm1heCgwLC0ocypyK2EpKSx1PWg+MD9yOk1hdGgubWluKE1hdGgubWF4KC1yLC1vKSxyKSxkPS1oKmgrdSoodSsyKm8pK2wpO2Vsc2UgdT1zPjA/LXI6cixoPU1hdGgubWF4KDAsLShzKnUrYSkpLGQ9LWgqaCt1Kih1KzIqbykrbDtyZXR1cm4gbiYmbi5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihoKS5hZGQodGhpcy5vcmlnaW4pLGkmJmkuY29weSh1ZSkubXVsdGlwbHlTY2FsYXIodSkuYWRkKGhlKSxkfWludGVyc2VjdFNwaGVyZSh0LGUpe2NlLnN1YlZlY3RvcnModC5jZW50ZXIsdGhpcy5vcmlnaW4pO2NvbnN0IG49Y2UuZG90KHRoaXMuZGlyZWN0aW9uKSxpPWNlLmRvdChjZSktbipuLHI9dC5yYWRpdXMqdC5yYWRpdXM7aWYoaT5yKXJldHVybiBudWxsO2NvbnN0IHM9TWF0aC5zcXJ0KHItaSksYT1uLXMsbz1uK3M7cmV0dXJuIGE8MCYmbzwwP251bGw6YTwwP3RoaXMuYXQobyxlKTp0aGlzLmF0KGEsZSl9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4gdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCh0LmNlbnRlcik8PXQucmFkaXVzKnQucmFkaXVzfWRpc3RhbmNlVG9QbGFuZSh0KXtjb25zdCBlPXQubm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbik7aWYoMD09PWUpcmV0dXJuIDA9PT10LmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik/MDpudWxsO2NvbnN0IG49LSh0aGlzLm9yaWdpbi5kb3QodC5ub3JtYWwpK3QuY29uc3RhbnQpL2U7cmV0dXJuIG4+PTA/bjpudWxsfWludGVyc2VjdFBsYW5lKHQsZSl7Y29uc3Qgbj10aGlzLmRpc3RhbmNlVG9QbGFuZSh0KTtyZXR1cm4gbnVsbD09PW4/bnVsbDp0aGlzLmF0KG4sZSl9aW50ZXJzZWN0c1BsYW5lKHQpe2NvbnN0IGU9dC5kaXN0YW5jZVRvUG9pbnQodGhpcy5vcmlnaW4pO2lmKDA9PT1lKXJldHVybiEwO3JldHVybiB0Lm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pKmU8MH1pbnRlcnNlY3RCb3godCxlKXtsZXQgbixpLHIscyxhLG87Y29uc3QgbD0xL3RoaXMuZGlyZWN0aW9uLngsYz0xL3RoaXMuZGlyZWN0aW9uLnksaD0xL3RoaXMuZGlyZWN0aW9uLnosdT10aGlzLm9yaWdpbjtyZXR1cm4gbD49MD8obj0odC5taW4ueC11LngpKmwsaT0odC5tYXgueC11LngpKmwpOihuPSh0Lm1heC54LXUueCkqbCxpPSh0Lm1pbi54LXUueCkqbCksYz49MD8ocj0odC5taW4ueS11LnkpKmMscz0odC5tYXgueS11LnkpKmMpOihyPSh0Lm1heC55LXUueSkqYyxzPSh0Lm1pbi55LXUueSkqYyksbj5zfHxyPmk/bnVsbDooKHI+bnx8biE9bikmJihuPXIpLChzPGl8fGkhPWkpJiYoaT1zKSxoPj0wPyhhPSh0Lm1pbi56LXUueikqaCxvPSh0Lm1heC56LXUueikqaCk6KGE9KHQubWF4LnotdS56KSpoLG89KHQubWluLnotdS56KSpoKSxuPm98fGE+aT9udWxsOigoYT5ufHxuIT1uKSYmKG49YSksKG88aXx8aSE9aSkmJihpPW8pLGk8MD9udWxsOnRoaXMuYXQobj49MD9uOmksZSkpKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiBudWxsIT09dGhpcy5pbnRlcnNlY3RCb3godCxjZSl9aW50ZXJzZWN0VHJpYW5nbGUodCxlLG4saSxyKXtwZS5zdWJWZWN0b3JzKGUsdCksbWUuc3ViVmVjdG9ycyhuLHQpLGZlLmNyb3NzVmVjdG9ycyhwZSxtZSk7bGV0IHMsYT10aGlzLmRpcmVjdGlvbi5kb3QoZmUpO2lmKGE+MCl7aWYoaSlyZXR1cm4gbnVsbDtzPTF9ZWxzZXtpZighKGE8MCkpcmV0dXJuIG51bGw7cz0tMSxhPS1hfWRlLnN1YlZlY3RvcnModGhpcy5vcmlnaW4sdCk7Y29uc3Qgbz1zKnRoaXMuZGlyZWN0aW9uLmRvdChtZS5jcm9zc1ZlY3RvcnMoZGUsbWUpKTtpZihvPDApcmV0dXJuIG51bGw7Y29uc3QgbD1zKnRoaXMuZGlyZWN0aW9uLmRvdChwZS5jcm9zcyhkZSkpO2lmKGw8MClyZXR1cm4gbnVsbDtpZihvK2w+YSlyZXR1cm4gbnVsbDtjb25zdCBjPS1zKmRlLmRvdChmZSk7cmV0dXJuIGM8MD9udWxsOnRoaXMuYXQoYy9hLHIpfWFwcGx5TWF0cml4NCh0KXtyZXR1cm4gdGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KHQpLHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih0KSx0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC5vcmlnaW4uZXF1YWxzKHRoaXMub3JpZ2luKSYmdC5kaXJlY3Rpb24uZXF1YWxzKHRoaXMuZGlyZWN0aW9uKX1jbG9uZSgpe3JldHVybihuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKX19Y2xhc3MgdmV7Y29uc3RydWN0b3IoKXt0aGlzLmVsZW1lbnRzPVsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSxhcmd1bWVudHMubGVuZ3RoPjAmJmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLlwiKX1zZXQodCxlLG4saSxyLHMsYSxvLGwsYyxoLHUsZCxwLG0sZil7Y29uc3QgZz10aGlzLmVsZW1lbnRzO3JldHVybiBnWzBdPXQsZ1s0XT1lLGdbOF09bixnWzEyXT1pLGdbMV09cixnWzVdPXMsZ1s5XT1hLGdbMTNdPW8sZ1syXT1sLGdbNl09YyxnWzEwXT1oLGdbMTRdPXUsZ1szXT1kLGdbN109cCxnWzExXT1tLGdbMTVdPWYsdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfWNsb25lKCl7cmV0dXJuKG5ldyB2ZSkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpfWNvcHkodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLG49dC5lbGVtZW50cztyZXR1cm4gZVswXT1uWzBdLGVbMV09blsxXSxlWzJdPW5bMl0sZVszXT1uWzNdLGVbNF09bls0XSxlWzVdPW5bNV0sZVs2XT1uWzZdLGVbN109bls3XSxlWzhdPW5bOF0sZVs5XT1uWzldLGVbMTBdPW5bMTBdLGVbMTFdPW5bMTFdLGVbMTJdPW5bMTJdLGVbMTNdPW5bMTNdLGVbMTRdPW5bMTRdLGVbMTVdPW5bMTVdLHRoaXN9Y29weVBvc2l0aW9uKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxuPXQuZWxlbWVudHM7cmV0dXJuIGVbMTJdPW5bMTJdLGVbMTNdPW5bMTNdLGVbMTRdPW5bMTRdLHRoaXN9c2V0RnJvbU1hdHJpeDModCl7Y29uc3QgZT10LmVsZW1lbnRzO3JldHVybiB0aGlzLnNldChlWzBdLGVbM10sZVs2XSwwLGVbMV0sZVs0XSxlWzddLDAsZVsyXSxlWzVdLGVbOF0sMCwwLDAsMCwxKSx0aGlzfWV4dHJhY3RCYXNpcyh0LGUsbil7cmV0dXJuIHQuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLDApLGUuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLDEpLG4uc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLDIpLHRoaXN9bWFrZUJhc2lzKHQsZSxuKXtyZXR1cm4gdGhpcy5zZXQodC54LGUueCxuLngsMCx0LnksZS55LG4ueSwwLHQueixlLnosbi56LDAsMCwwLDAsMSksdGhpc31leHRyYWN0Um90YXRpb24odCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLG49dC5lbGVtZW50cyxpPTEveWUuc2V0RnJvbU1hdHJpeENvbHVtbih0LDApLmxlbmd0aCgpLHI9MS95ZS5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMSkubGVuZ3RoKCkscz0xL3llLnNldEZyb21NYXRyaXhDb2x1bW4odCwyKS5sZW5ndGgoKTtyZXR1cm4gZVswXT1uWzBdKmksZVsxXT1uWzFdKmksZVsyXT1uWzJdKmksZVszXT0wLGVbNF09bls0XSpyLGVbNV09bls1XSpyLGVbNl09bls2XSpyLGVbN109MCxlWzhdPW5bOF0qcyxlWzldPW5bOV0qcyxlWzEwXT1uWzEwXSpzLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSx0aGlzfW1ha2VSb3RhdGlvbkZyb21FdWxlcih0KXt0JiZ0LmlzRXVsZXJ8fGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLlwiKTtjb25zdCBlPXRoaXMuZWxlbWVudHMsbj10LngsaT10Lnkscj10Lnoscz1NYXRoLmNvcyhuKSxhPU1hdGguc2luKG4pLG89TWF0aC5jb3MoaSksbD1NYXRoLnNpbihpKSxjPU1hdGguY29zKHIpLGg9TWF0aC5zaW4ocik7aWYoXCJYWVpcIj09PXQub3JkZXIpe2NvbnN0IHQ9cypjLG49cypoLGk9YSpjLHI9YSpoO2VbMF09bypjLGVbNF09LW8qaCxlWzhdPWwsZVsxXT1uK2kqbCxlWzVdPXQtcipsLGVbOV09LWEqbyxlWzJdPXItdCpsLGVbNl09aStuKmwsZVsxMF09cypvfWVsc2UgaWYoXCJZWFpcIj09PXQub3JkZXIpe2NvbnN0IHQ9bypjLG49bypoLGk9bCpjLHI9bCpoO2VbMF09dCtyKmEsZVs0XT1pKmEtbixlWzhdPXMqbCxlWzFdPXMqaCxlWzVdPXMqYyxlWzldPS1hLGVbMl09biphLWksZVs2XT1yK3QqYSxlWzEwXT1zKm99ZWxzZSBpZihcIlpYWVwiPT09dC5vcmRlcil7Y29uc3QgdD1vKmMsbj1vKmgsaT1sKmMscj1sKmg7ZVswXT10LXIqYSxlWzRdPS1zKmgsZVs4XT1pK24qYSxlWzFdPW4raSphLGVbNV09cypjLGVbOV09ci10KmEsZVsyXT0tcypsLGVbNl09YSxlWzEwXT1zKm99ZWxzZSBpZihcIlpZWFwiPT09dC5vcmRlcil7Y29uc3QgdD1zKmMsbj1zKmgsaT1hKmMscj1hKmg7ZVswXT1vKmMsZVs0XT1pKmwtbixlWzhdPXQqbCtyLGVbMV09bypoLGVbNV09cipsK3QsZVs5XT1uKmwtaSxlWzJdPS1sLGVbNl09YSpvLGVbMTBdPXMqb31lbHNlIGlmKFwiWVpYXCI9PT10Lm9yZGVyKXtjb25zdCB0PXMqbyxuPXMqbCxpPWEqbyxyPWEqbDtlWzBdPW8qYyxlWzRdPXItdCpoLGVbOF09aSpoK24sZVsxXT1oLGVbNV09cypjLGVbOV09LWEqYyxlWzJdPS1sKmMsZVs2XT1uKmgraSxlWzEwXT10LXIqaH1lbHNlIGlmKFwiWFpZXCI9PT10Lm9yZGVyKXtjb25zdCB0PXMqbyxuPXMqbCxpPWEqbyxyPWEqbDtlWzBdPW8qYyxlWzRdPS1oLGVbOF09bCpjLGVbMV09dCpoK3IsZVs1XT1zKmMsZVs5XT1uKmgtaSxlWzJdPWkqaC1uLGVbNl09YSpjLGVbMTBdPXIqaCt0fXJldHVybiBlWzNdPTAsZVs3XT0wLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSx0aGlzfW1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpe3JldHVybiB0aGlzLmNvbXBvc2UoYmUsdCx3ZSl9bG9va0F0KHQsZSxuKXtjb25zdCBpPXRoaXMuZWxlbWVudHM7cmV0dXJuIFNlLnN1YlZlY3RvcnModCxlKSwwPT09U2UubGVuZ3RoU3EoKSYmKFNlLno9MSksU2Uubm9ybWFsaXplKCksX2UuY3Jvc3NWZWN0b3JzKG4sU2UpLDA9PT1fZS5sZW5ndGhTcSgpJiYoMT09PU1hdGguYWJzKG4ueik/U2UueCs9MWUtNDpTZS56Kz0xZS00LFNlLm5vcm1hbGl6ZSgpLF9lLmNyb3NzVmVjdG9ycyhuLFNlKSksX2Uubm9ybWFsaXplKCksTWUuY3Jvc3NWZWN0b3JzKFNlLF9lKSxpWzBdPV9lLngsaVs0XT1NZS54LGlbOF09U2UueCxpWzFdPV9lLnksaVs1XT1NZS55LGlbOV09U2UueSxpWzJdPV9lLnosaVs2XT1NZS56LGlbMTBdPVNlLnosdGhpc31tdWx0aXBseSh0LGUpe3JldHVybiB2b2lkIDAhPT1lPyhjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsZSkpOnRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLHQpfXByZW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModCx0aGlzKX1tdWx0aXBseU1hdHJpY2VzKHQsZSl7Y29uc3Qgbj10LmVsZW1lbnRzLGk9ZS5lbGVtZW50cyxyPXRoaXMuZWxlbWVudHMscz1uWzBdLGE9bls0XSxvPW5bOF0sbD1uWzEyXSxjPW5bMV0saD1uWzVdLHU9bls5XSxkPW5bMTNdLHA9blsyXSxtPW5bNl0sZj1uWzEwXSxnPW5bMTRdLHY9blszXSx5PW5bN10seD1uWzExXSxiPW5bMTVdLHc9aVswXSxfPWlbNF0sTT1pWzhdLFM9aVsxMl0sVD1pWzFdLEU9aVs1XSxBPWlbOV0sTD1pWzEzXSxSPWlbMl0sQz1pWzZdLFA9aVsxMF0sST1pWzE0XSxEPWlbM10sTj1pWzddLEY9aVsxMV0sTz1pWzE1XTtyZXR1cm4gclswXT1zKncrYSpUK28qUitsKkQscls0XT1zKl8rYSpFK28qQytsKk4scls4XT1zKk0rYSpBK28qUCtsKkYsclsxMl09cypTK2EqTCtvKkkrbCpPLHJbMV09Yyp3K2gqVCt1KlIrZCpELHJbNV09YypfK2gqRSt1KkMrZCpOLHJbOV09YypNK2gqQSt1KlArZCpGLHJbMTNdPWMqUytoKkwrdSpJK2QqTyxyWzJdPXAqdyttKlQrZipSK2cqRCxyWzZdPXAqXyttKkUrZipDK2cqTixyWzEwXT1wKk0rbSpBK2YqUCtnKkYsclsxNF09cCpTK20qTCtmKkkrZypPLHJbM109dip3K3kqVCt4KlIrYipELHJbN109dipfK3kqRSt4KkMrYipOLHJbMTFdPXYqTSt5KkEreCpQK2IqRixyWzE1XT12KlMreSpMK3gqSStiKk8sdGhpc31tdWx0aXBseVNjYWxhcih0KXtjb25zdCBlPXRoaXMuZWxlbWVudHM7cmV0dXJuIGVbMF0qPXQsZVs0XSo9dCxlWzhdKj10LGVbMTJdKj10LGVbMV0qPXQsZVs1XSo9dCxlWzldKj10LGVbMTNdKj10LGVbMl0qPXQsZVs2XSo9dCxlWzEwXSo9dCxlWzE0XSo9dCxlWzNdKj10LGVbN10qPXQsZVsxMV0qPXQsZVsxNV0qPXQsdGhpc31kZXRlcm1pbmFudCgpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxlPXRbMF0sbj10WzRdLGk9dFs4XSxyPXRbMTJdLHM9dFsxXSxhPXRbNV0sbz10WzldLGw9dFsxM10sYz10WzJdLGg9dFs2XSx1PXRbMTBdLGQ9dFsxNF07cmV0dXJuIHRbM10qKCtyKm8qaC1pKmwqaC1yKmEqdStuKmwqdStpKmEqZC1uKm8qZCkrdFs3XSooK2UqbypkLWUqbCp1K3Iqcyp1LWkqcypkK2kqbCpjLXIqbypjKSt0WzExXSooK2UqbCpoLWUqYSpkLXIqcypoK24qcypkK3IqYSpjLW4qbCpjKSt0WzE1XSooLWkqYSpjLWUqbypoK2UqYSp1K2kqcypoLW4qcyp1K24qbypjKX10cmFuc3Bvc2UoKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7bGV0IGU7cmV0dXJuIGU9dFsxXSx0WzFdPXRbNF0sdFs0XT1lLGU9dFsyXSx0WzJdPXRbOF0sdFs4XT1lLGU9dFs2XSx0WzZdPXRbOV0sdFs5XT1lLGU9dFszXSx0WzNdPXRbMTJdLHRbMTJdPWUsZT10WzddLHRbN109dFsxM10sdFsxM109ZSxlPXRbMTFdLHRbMTFdPXRbMTRdLHRbMTRdPWUsdGhpc31zZXRQb3NpdGlvbih0LGUsbil7Y29uc3QgaT10aGlzLmVsZW1lbnRzO3JldHVybiB0LmlzVmVjdG9yMz8oaVsxMl09dC54LGlbMTNdPXQueSxpWzE0XT10LnopOihpWzEyXT10LGlbMTNdPWUsaVsxNF09biksdGhpc31pbnZlcnQoKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsZT10WzBdLG49dFsxXSxpPXRbMl0scj10WzNdLHM9dFs0XSxhPXRbNV0sbz10WzZdLGw9dFs3XSxjPXRbOF0saD10WzldLHU9dFsxMF0sZD10WzExXSxwPXRbMTJdLG09dFsxM10sZj10WzE0XSxnPXRbMTVdLHY9aCpmKmwtbSp1KmwrbSpvKmQtYSpmKmQtaCpvKmcrYSp1KmcseT1wKnUqbC1jKmYqbC1wKm8qZCtzKmYqZCtjKm8qZy1zKnUqZyx4PWMqbSpsLXAqaCpsK3AqYSpkLXMqbSpkLWMqYSpnK3MqaCpnLGI9cCpoKm8tYyptKm8tcCphKnUrcyptKnUrYyphKmYtcypoKmYsdz1lKnYrbip5K2kqeCtyKmI7aWYoMD09PXcpcmV0dXJuIHRoaXMuc2V0KDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDApO2NvbnN0IF89MS93O3JldHVybiB0WzBdPXYqXyx0WzFdPShtKnUqci1oKmYqci1tKmkqZCtuKmYqZCtoKmkqZy1uKnUqZykqXyx0WzJdPShhKmYqci1tKm8qcittKmkqbC1uKmYqbC1hKmkqZytuKm8qZykqXyx0WzNdPShoKm8qci1hKnUqci1oKmkqbCtuKnUqbCthKmkqZC1uKm8qZCkqXyx0WzRdPXkqXyx0WzVdPShjKmYqci1wKnUqcitwKmkqZC1lKmYqZC1jKmkqZytlKnUqZykqXyx0WzZdPShwKm8qci1zKmYqci1wKmkqbCtlKmYqbCtzKmkqZy1lKm8qZykqXyx0WzddPShzKnUqci1jKm8qcitjKmkqbC1lKnUqbC1zKmkqZCtlKm8qZCkqXyx0WzhdPXgqXyx0WzldPShwKmgqci1jKm0qci1wKm4qZCtlKm0qZCtjKm4qZy1lKmgqZykqXyx0WzEwXT0ocyptKnItcCphKnIrcCpuKmwtZSptKmwtcypuKmcrZSphKmcpKl8sdFsxMV09KGMqYSpyLXMqaCpyLWMqbipsK2UqaCpsK3MqbipkLWUqYSpkKSpfLHRbMTJdPWIqXyx0WzEzXT0oYyptKmktcCpoKmkrcCpuKnUtZSptKnUtYypuKmYrZSpoKmYpKl8sdFsxNF09KHAqYSppLXMqbSppLXAqbipvK2UqbSpvK3MqbipmLWUqYSpmKSpfLHRbMTVdPShzKmgqaS1jKmEqaStjKm4qby1lKmgqby1zKm4qdStlKmEqdSkqXyx0aGlzfXNjYWxlKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxuPXQueCxpPXQueSxyPXQuejtyZXR1cm4gZVswXSo9bixlWzRdKj1pLGVbOF0qPXIsZVsxXSo9bixlWzVdKj1pLGVbOV0qPXIsZVsyXSo9bixlWzZdKj1pLGVbMTBdKj1yLGVbM10qPW4sZVs3XSo9aSxlWzExXSo9cix0aGlzfWdldE1heFNjYWxlT25BeGlzKCl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGU9dFswXSp0WzBdK3RbMV0qdFsxXSt0WzJdKnRbMl0sbj10WzRdKnRbNF0rdFs1XSp0WzVdK3RbNl0qdFs2XSxpPXRbOF0qdFs4XSt0WzldKnRbOV0rdFsxMF0qdFsxMF07cmV0dXJuIE1hdGguc3FydChNYXRoLm1heChlLG4saSkpfW1ha2VUcmFuc2xhdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuc2V0KDEsMCwwLHQsMCwxLDAsZSwwLDAsMSxuLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uWCh0KXtjb25zdCBlPU1hdGguY29zKHQpLG49TWF0aC5zaW4odCk7cmV0dXJuIHRoaXMuc2V0KDEsMCwwLDAsMCxlLC1uLDAsMCxuLGUsMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvblkodCl7Y29uc3QgZT1NYXRoLmNvcyh0KSxuPU1hdGguc2luKHQpO3JldHVybiB0aGlzLnNldChlLDAsbiwwLDAsMSwwLDAsLW4sMCxlLDAsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25aKHQpe2NvbnN0IGU9TWF0aC5jb3ModCksbj1NYXRoLnNpbih0KTtyZXR1cm4gdGhpcy5zZXQoZSwtbiwwLDAsbixlLDAsMCwwLDAsMSwwLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uQXhpcyh0LGUpe2NvbnN0IG49TWF0aC5jb3MoZSksaT1NYXRoLnNpbihlKSxyPTEtbixzPXQueCxhPXQueSxvPXQueixsPXIqcyxjPXIqYTtyZXR1cm4gdGhpcy5zZXQobCpzK24sbCphLWkqbyxsKm8raSphLDAsbCphK2kqbyxjKmErbixjKm8taSpzLDAsbCpvLWkqYSxjKm8raSpzLHIqbypvK24sMCwwLDAsMCwxKSx0aGlzfW1ha2VTY2FsZSh0LGUsbil7cmV0dXJuIHRoaXMuc2V0KHQsMCwwLDAsMCxlLDAsMCwwLDAsbiwwLDAsMCwwLDEpLHRoaXN9bWFrZVNoZWFyKHQsZSxuLGkscixzKXtyZXR1cm4gdGhpcy5zZXQoMSxuLHIsMCx0LDEscywwLGUsaSwxLDAsMCwwLDAsMSksdGhpc31jb21wb3NlKHQsZSxuKXtjb25zdCBpPXRoaXMuZWxlbWVudHMscj1lLl94LHM9ZS5feSxhPWUuX3osbz1lLl93LGw9cityLGM9cytzLGg9YSthLHU9cipsLGQ9cipjLHA9cipoLG09cypjLGY9cypoLGc9YSpoLHY9bypsLHk9bypjLHg9bypoLGI9bi54LHc9bi55LF89bi56O3JldHVybiBpWzBdPSgxLShtK2cpKSpiLGlbMV09KGQreCkqYixpWzJdPShwLXkpKmIsaVszXT0wLGlbNF09KGQteCkqdyxpWzVdPSgxLSh1K2cpKSp3LGlbNl09KGYrdikqdyxpWzddPTAsaVs4XT0ocCt5KSpfLGlbOV09KGYtdikqXyxpWzEwXT0oMS0odSttKSkqXyxpWzExXT0wLGlbMTJdPXQueCxpWzEzXT10LnksaVsxNF09dC56LGlbMTVdPTEsdGhpc31kZWNvbXBvc2UodCxlLG4pe2NvbnN0IGk9dGhpcy5lbGVtZW50cztsZXQgcj15ZS5zZXQoaVswXSxpWzFdLGlbMl0pLmxlbmd0aCgpO2NvbnN0IHM9eWUuc2V0KGlbNF0saVs1XSxpWzZdKS5sZW5ndGgoKSxhPXllLnNldChpWzhdLGlbOV0saVsxMF0pLmxlbmd0aCgpO3RoaXMuZGV0ZXJtaW5hbnQoKTwwJiYocj0tciksdC54PWlbMTJdLHQueT1pWzEzXSx0Lno9aVsxNF0seGUuY29weSh0aGlzKTtjb25zdCBvPTEvcixsPTEvcyxjPTEvYTtyZXR1cm4geGUuZWxlbWVudHNbMF0qPW8seGUuZWxlbWVudHNbMV0qPW8seGUuZWxlbWVudHNbMl0qPW8seGUuZWxlbWVudHNbNF0qPWwseGUuZWxlbWVudHNbNV0qPWwseGUuZWxlbWVudHNbNl0qPWwseGUuZWxlbWVudHNbOF0qPWMseGUuZWxlbWVudHNbOV0qPWMseGUuZWxlbWVudHNbMTBdKj1jLGUuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHhlKSxuLng9cixuLnk9cyxuLno9YSx0aGlzfW1ha2VQZXJzcGVjdGl2ZSh0LGUsbixpLHIscyl7dm9pZCAwPT09cyYmY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLm1ha2VQZXJzcGVjdGl2ZSgpIGhhcyBiZWVuIHJlZGVmaW5lZCBhbmQgaGFzIGEgbmV3IHNpZ25hdHVyZS4gUGxlYXNlIGNoZWNrIHRoZSBkb2NzLlwiKTtjb25zdCBhPXRoaXMuZWxlbWVudHMsbz0yKnIvKGUtdCksbD0yKnIvKG4taSksYz0oZSt0KS8oZS10KSxoPShuK2kpLyhuLWkpLHU9LShzK3IpLyhzLXIpLGQ9LTIqcypyLyhzLXIpO3JldHVybiBhWzBdPW8sYVs0XT0wLGFbOF09YyxhWzEyXT0wLGFbMV09MCxhWzVdPWwsYVs5XT1oLGFbMTNdPTAsYVsyXT0wLGFbNl09MCxhWzEwXT11LGFbMTRdPWQsYVszXT0wLGFbN109MCxhWzExXT0tMSxhWzE1XT0wLHRoaXN9bWFrZU9ydGhvZ3JhcGhpYyh0LGUsbixpLHIscyl7Y29uc3QgYT10aGlzLmVsZW1lbnRzLG89MS8oZS10KSxsPTEvKG4taSksYz0xLyhzLXIpLGg9KGUrdCkqbyx1PShuK2kpKmwsZD0ocytyKSpjO3JldHVybiBhWzBdPTIqbyxhWzRdPTAsYVs4XT0wLGFbMTJdPS1oLGFbMV09MCxhWzVdPTIqbCxhWzldPTAsYVsxM109LXUsYVsyXT0wLGFbNl09MCxhWzEwXT0tMipjLGFbMTRdPS1kLGFbM109MCxhWzddPTAsYVsxMV09MCxhWzE1XT0xLHRoaXN9ZXF1YWxzKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxuPXQuZWxlbWVudHM7Zm9yKGxldCB0PTA7dDwxNjt0KyspaWYoZVt0XSE9PW5bdF0pcmV0dXJuITE7cmV0dXJuITB9ZnJvbUFycmF5KHQsZT0wKXtmb3IobGV0IG49MDtuPDE2O24rKyl0aGlzLmVsZW1lbnRzW25dPXRbbitlXTtyZXR1cm4gdGhpc310b0FycmF5KHQ9W10sZT0wKXtjb25zdCBuPXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbZV09blswXSx0W2UrMV09blsxXSx0W2UrMl09blsyXSx0W2UrM109blszXSx0W2UrNF09bls0XSx0W2UrNV09bls1XSx0W2UrNl09bls2XSx0W2UrN109bls3XSx0W2UrOF09bls4XSx0W2UrOV09bls5XSx0W2UrMTBdPW5bMTBdLHRbZSsxMV09blsxMV0sdFtlKzEyXT1uWzEyXSx0W2UrMTNdPW5bMTNdLHRbZSsxNF09blsxNF0sdFtlKzE1XT1uWzE1XSx0fX12ZS5wcm90b3R5cGUuaXNNYXRyaXg0PSEwO2NvbnN0IHllPW5ldyBCdCx4ZT1uZXcgdmUsYmU9bmV3IEJ0KDAsMCwwKSx3ZT1uZXcgQnQoMSwxLDEpLF9lPW5ldyBCdCxNZT1uZXcgQnQsU2U9bmV3IEJ0LFRlPW5ldyB2ZSxFZT1uZXcgenQ7Y2xhc3MgQWV7Y29uc3RydWN0b3IodD0wLGU9MCxuPTAsaT1BZS5EZWZhdWx0T3JkZXIpe3RoaXMuX3g9dCx0aGlzLl95PWUsdGhpcy5fej1uLHRoaXMuX29yZGVyPWl9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1zZXQgeCh0KXt0aGlzLl94PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9c2V0IHkodCl7dGhpcy5feT10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeigpe3JldHVybiB0aGlzLl96fXNldCB6KHQpe3RoaXMuX3o9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IG9yZGVyKCl7cmV0dXJuIHRoaXMuX29yZGVyfXNldCBvcmRlcih0KXt0aGlzLl9vcmRlcj10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1zZXQodCxlLG4saT10aGlzLl9vcmRlcil7cmV0dXJuIHRoaXMuX3g9dCx0aGlzLl95PWUsdGhpcy5fej1uLHRoaXMuX29yZGVyPWksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCx0aGlzLl95LHRoaXMuX3osdGhpcy5fb3JkZXIpfWNvcHkodCl7cmV0dXJuIHRoaXMuX3g9dC5feCx0aGlzLl95PXQuX3ksdGhpcy5fej10Ll96LHRoaXMuX29yZGVyPXQuX29yZGVyLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21Sb3RhdGlvbk1hdHJpeCh0LGU9dGhpcy5fb3JkZXIsbj0hMCl7Y29uc3QgaT10LmVsZW1lbnRzLHI9aVswXSxzPWlbNF0sYT1pWzhdLG89aVsxXSxsPWlbNV0sYz1pWzldLGg9aVsyXSx1PWlbNl0sZD1pWzEwXTtzd2l0Y2goZSl7Y2FzZVwiWFlaXCI6dGhpcy5feT1NYXRoLmFzaW4oYnQoYSwtMSwxKSksTWF0aC5hYnMoYSk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMigtYyxkKSx0aGlzLl96PU1hdGguYXRhbjIoLXMscikpOih0aGlzLl94PU1hdGguYXRhbjIodSxsKSx0aGlzLl96PTApO2JyZWFrO2Nhc2VcIllYWlwiOnRoaXMuX3g9TWF0aC5hc2luKC1idChjLC0xLDEpKSxNYXRoLmFicyhjKTwuOTk5OTk5OT8odGhpcy5feT1NYXRoLmF0YW4yKGEsZCksdGhpcy5fej1NYXRoLmF0YW4yKG8sbCkpOih0aGlzLl95PU1hdGguYXRhbjIoLWgsciksdGhpcy5fej0wKTticmVhaztjYXNlXCJaWFlcIjp0aGlzLl94PU1hdGguYXNpbihidCh1LC0xLDEpKSxNYXRoLmFicyh1KTwuOTk5OTk5OT8odGhpcy5feT1NYXRoLmF0YW4yKC1oLGQpLHRoaXMuX3o9TWF0aC5hdGFuMigtcyxsKSk6KHRoaXMuX3k9MCx0aGlzLl96PU1hdGguYXRhbjIobyxyKSk7YnJlYWs7Y2FzZVwiWllYXCI6dGhpcy5feT1NYXRoLmFzaW4oLWJ0KGgsLTEsMSkpLE1hdGguYWJzKGgpPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIodSxkKSx0aGlzLl96PU1hdGguYXRhbjIobyxyKSk6KHRoaXMuX3g9MCx0aGlzLl96PU1hdGguYXRhbjIoLXMsbCkpO2JyZWFrO2Nhc2VcIllaWFwiOnRoaXMuX3o9TWF0aC5hc2luKGJ0KG8sLTEsMSkpLE1hdGguYWJzKG8pPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoLWMsbCksdGhpcy5feT1NYXRoLmF0YW4yKC1oLHIpKToodGhpcy5feD0wLHRoaXMuX3k9TWF0aC5hdGFuMihhLGQpKTticmVhaztjYXNlXCJYWllcIjp0aGlzLl96PU1hdGguYXNpbigtYnQocywtMSwxKSksTWF0aC5hYnMocyk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMih1LGwpLHRoaXMuX3k9TWF0aC5hdGFuMihhLHIpKToodGhpcy5feD1NYXRoLmF0YW4yKC1jLGQpLHRoaXMuX3k9MCk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLndhcm4oXCJUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6IFwiK2UpfXJldHVybiB0aGlzLl9vcmRlcj1lLCEwPT09biYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVF1YXRlcm5pb24odCxlLG4pe3JldHVybiBUZS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbih0KSx0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeChUZSxlLG4pfXNldEZyb21WZWN0b3IzKHQsZT10aGlzLl9vcmRlcil7cmV0dXJuIHRoaXMuc2V0KHQueCx0LnksdC56LGUpfXJlb3JkZXIodCl7cmV0dXJuIEVlLnNldEZyb21FdWxlcih0aGlzKSx0aGlzLnNldEZyb21RdWF0ZXJuaW9uKEVlLHQpfWVxdWFscyh0KXtyZXR1cm4gdC5feD09PXRoaXMuX3gmJnQuX3k9PT10aGlzLl95JiZ0Ll96PT09dGhpcy5feiYmdC5fb3JkZXI9PT10aGlzLl9vcmRlcn1mcm9tQXJyYXkodCl7cmV0dXJuIHRoaXMuX3g9dFswXSx0aGlzLl95PXRbMV0sdGhpcy5fej10WzJdLHZvaWQgMCE9PXRbM10mJih0aGlzLl9vcmRlcj10WzNdKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLl94LHRbZSsxXT10aGlzLl95LHRbZSsyXT10aGlzLl96LHRbZSszXT10aGlzLl9vcmRlcix0fXRvVmVjdG9yMyh0KXtyZXR1cm4gdD90LnNldCh0aGlzLl94LHRoaXMuX3ksdGhpcy5feik6bmV3IEJ0KHRoaXMuX3gsdGhpcy5feSx0aGlzLl96KX1fb25DaGFuZ2UodCl7cmV0dXJuIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2s9dCx0aGlzfV9vbkNoYW5nZUNhbGxiYWNrKCl7fX1BZS5wcm90b3R5cGUuaXNFdWxlcj0hMCxBZS5EZWZhdWx0T3JkZXI9XCJYWVpcIixBZS5Sb3RhdGlvbk9yZGVycz1bXCJYWVpcIixcIllaWFwiLFwiWlhZXCIsXCJYWllcIixcIllYWlwiLFwiWllYXCJdO2NsYXNzIExle2NvbnN0cnVjdG9yKCl7dGhpcy5tYXNrPTF9c2V0KHQpe3RoaXMubWFzaz0xPDx0fDB9ZW5hYmxlKHQpe3RoaXMubWFza3w9MTw8dHwwfWVuYWJsZUFsbCgpe3RoaXMubWFzaz0tMX10b2dnbGUodCl7dGhpcy5tYXNrXj0xPDx0fDB9ZGlzYWJsZSh0KXt0aGlzLm1hc2smPX4oMTw8dHwwKX1kaXNhYmxlQWxsKCl7dGhpcy5tYXNrPTB9dGVzdCh0KXtyZXR1cm4gMCE9KHRoaXMubWFzayZ0Lm1hc2spfX1sZXQgUmU9MDtjb25zdCBDZT1uZXcgQnQsUGU9bmV3IHp0LEllPW5ldyB2ZSxEZT1uZXcgQnQsTmU9bmV3IEJ0LEZlPW5ldyBCdCxPZT1uZXcgenQsVWU9bmV3IEJ0KDEsMCwwKSxrZT1uZXcgQnQoMCwxLDApLHplPW5ldyBCdCgwLDAsMSksQmU9e3R5cGU6XCJhZGRlZFwifSxIZT17dHlwZTpcInJlbW92ZWRcIn07Y2xhc3MgVmUgZXh0ZW5kcyBwdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJpZFwiLHt2YWx1ZTpSZSsrfSksdGhpcy51dWlkPXh0KCksdGhpcy5uYW1lPVwiXCIsdGhpcy50eXBlPVwiT2JqZWN0M0RcIix0aGlzLnBhcmVudD1udWxsLHRoaXMuY2hpbGRyZW49W10sdGhpcy51cD1WZS5EZWZhdWx0VXAuY2xvbmUoKTtjb25zdCB0PW5ldyBCdCxlPW5ldyBBZSxuPW5ldyB6dCxpPW5ldyBCdCgxLDEsMSk7ZS5fb25DaGFuZ2UoKGZ1bmN0aW9uKCl7bi5zZXRGcm9tRXVsZXIoZSwhMSl9KSksbi5fb25DaGFuZ2UoKGZ1bmN0aW9uKCl7ZS5zZXRGcm9tUXVhdGVybmlvbihuLHZvaWQgMCwhMSl9KSksT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyx7cG9zaXRpb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOnR9LHJvdGF0aW9uOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTplfSxxdWF0ZXJuaW9uOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpufSxzY2FsZTp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6aX0sbW9kZWxWaWV3TWF0cml4Ont2YWx1ZTpuZXcgdmV9LG5vcm1hbE1hdHJpeDp7dmFsdWU6bmV3IEx0fX0pLHRoaXMubWF0cml4PW5ldyB2ZSx0aGlzLm1hdHJpeFdvcmxkPW5ldyB2ZSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9VmUuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSExLHRoaXMubGF5ZXJzPW5ldyBMZSx0aGlzLnZpc2libGU9ITAsdGhpcy5jYXN0U2hhZG93PSExLHRoaXMucmVjZWl2ZVNoYWRvdz0hMSx0aGlzLmZydXN0dW1DdWxsZWQ9ITAsdGhpcy5yZW5kZXJPcmRlcj0wLHRoaXMuYW5pbWF0aW9ucz1bXSx0aGlzLnVzZXJEYXRhPXt9fW9uQmVmb3JlUmVuZGVyKCl7fW9uQWZ0ZXJSZW5kZXIoKXt9YXBwbHlNYXRyaXg0KHQpe3RoaXMubWF0cml4QXV0b1VwZGF0ZSYmdGhpcy51cGRhdGVNYXRyaXgoKSx0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSh0KSx0aGlzLm1hdHJpeC5kZWNvbXBvc2UodGhpcy5wb3NpdGlvbix0aGlzLnF1YXRlcm5pb24sdGhpcy5zY2FsZSl9YXBwbHlRdWF0ZXJuaW9uKHQpe3JldHVybiB0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkodCksdGhpc31zZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUodCxlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSh0LGUpfXNldFJvdGF0aW9uRnJvbUV1bGVyKHQpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIodCwhMCl9c2V0Um90YXRpb25Gcm9tTWF0cml4KHQpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgodCl9c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0KXt0aGlzLnF1YXRlcm5pb24uY29weSh0KX1yb3RhdGVPbkF4aXModCxlKXtyZXR1cm4gUGUuc2V0RnJvbUF4aXNBbmdsZSh0LGUpLHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShQZSksdGhpc31yb3RhdGVPbldvcmxkQXhpcyh0LGUpe3JldHVybiBQZS5zZXRGcm9tQXhpc0FuZ2xlKHQsZSksdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KFBlKSx0aGlzfXJvdGF0ZVgodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKFVlLHQpfXJvdGF0ZVkodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGtlLHQpfXJvdGF0ZVoodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKHplLHQpfXRyYW5zbGF0ZU9uQXhpcyh0LGUpe3JldHVybiBDZS5jb3B5KHQpLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pLHRoaXMucG9zaXRpb24uYWRkKENlLm11bHRpcGx5U2NhbGFyKGUpKSx0aGlzfXRyYW5zbGF0ZVgodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKFVlLHQpfXRyYW5zbGF0ZVkodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGtlLHQpfXRyYW5zbGF0ZVoodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKHplLHQpfWxvY2FsVG9Xb3JsZCh0KXtyZXR1cm4gdC5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCl9d29ybGRUb0xvY2FsKHQpe3JldHVybiB0LmFwcGx5TWF0cml4NChJZS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpKX1sb29rQXQodCxlLG4pe3QuaXNWZWN0b3IzP0RlLmNvcHkodCk6RGUuc2V0KHQsZSxuKTtjb25zdCBpPXRoaXMucGFyZW50O3RoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLE5lLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKSx0aGlzLmlzQ2FtZXJhfHx0aGlzLmlzTGlnaHQ/SWUubG9va0F0KE5lLERlLHRoaXMudXApOkllLmxvb2tBdChEZSxOZSx0aGlzLnVwKSx0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KEllKSxpJiYoSWUuZXh0cmFjdFJvdGF0aW9uKGkubWF0cml4V29ybGQpLFBlLnNldEZyb21Sb3RhdGlvbk1hdHJpeChJZSksdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KFBlLmludmVydCgpKSl9YWRkKHQpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKGxldCB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl0aGlzLmFkZChhcmd1bWVudHNbdF0pO3JldHVybiB0aGlzfXJldHVybiB0PT09dGhpcz8oY29uc29sZS5lcnJvcihcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLHQpLHRoaXMpOih0JiZ0LmlzT2JqZWN0M0Q/KG51bGwhPT10LnBhcmVudCYmdC5wYXJlbnQucmVtb3ZlKHQpLHQucGFyZW50PXRoaXMsdGhpcy5jaGlsZHJlbi5wdXNoKHQpLHQuZGlzcGF0Y2hFdmVudChCZSkpOmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsdCksdGhpcyl9cmVtb3ZlKHQpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKGxldCB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl0aGlzLnJlbW92ZShhcmd1bWVudHNbdF0pO3JldHVybiB0aGlzfWNvbnN0IGU9dGhpcy5jaGlsZHJlbi5pbmRleE9mKHQpO3JldHVybi0xIT09ZSYmKHQucGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbi5zcGxpY2UoZSwxKSx0LmRpc3BhdGNoRXZlbnQoSGUpKSx0aGlzfXJlbW92ZUZyb21QYXJlbnQoKXtjb25zdCB0PXRoaXMucGFyZW50O3JldHVybiBudWxsIT09dCYmdC5yZW1vdmUodGhpcyksdGhpc31jbGVhcigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5jaGlsZHJlbi5sZW5ndGg7dCsrKXtjb25zdCBlPXRoaXMuY2hpbGRyZW5bdF07ZS5wYXJlbnQ9bnVsbCxlLmRpc3BhdGNoRXZlbnQoSGUpfXJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aD0wLHRoaXN9YXR0YWNoKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxJZS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpLG51bGwhPT10LnBhcmVudCYmKHQucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxJZS5tdWx0aXBseSh0LnBhcmVudC5tYXRyaXhXb3JsZCkpLHQuYXBwbHlNYXRyaXg0KEllKSx0aGlzLmFkZCh0KSx0LnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKSx0aGlzfWdldE9iamVjdEJ5SWQodCl7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eShcImlkXCIsdCl9Z2V0T2JqZWN0QnlOYW1lKHQpe3JldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoXCJuYW1lXCIsdCl9Z2V0T2JqZWN0QnlQcm9wZXJ0eSh0LGUpe2lmKHRoaXNbdF09PT1lKXJldHVybiB0aGlzO2ZvcihsZXQgbj0wLGk9dGhpcy5jaGlsZHJlbi5sZW5ndGg7bjxpO24rKyl7Y29uc3QgaT10aGlzLmNoaWxkcmVuW25dLmdldE9iamVjdEJ5UHJvcGVydHkodCxlKTtpZih2b2lkIDAhPT1pKXJldHVybiBpfX1nZXRXb3JsZFBvc2l0aW9uKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0LnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKX1nZXRXb3JsZFF1YXRlcm5pb24odCl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKE5lLHQsRmUpLHR9Z2V0V29ybGRTY2FsZSh0KXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoTmUsT2UsdCksdH1nZXRXb3JsZERpcmVjdGlvbih0KXt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtjb25zdCBlPXRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7cmV0dXJuIHQuc2V0KGVbOF0sZVs5XSxlWzEwXSkubm9ybWFsaXplKCl9cmF5Y2FzdCgpe310cmF2ZXJzZSh0KXt0KHRoaXMpO2NvbnN0IGU9dGhpcy5jaGlsZHJlbjtmb3IobGV0IG49MCxpPWUubGVuZ3RoO248aTtuKyspZVtuXS50cmF2ZXJzZSh0KX10cmF2ZXJzZVZpc2libGUodCl7aWYoITE9PT10aGlzLnZpc2libGUpcmV0dXJuO3QodGhpcyk7Y29uc3QgZT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7bjxpO24rKyllW25dLnRyYXZlcnNlVmlzaWJsZSh0KX10cmF2ZXJzZUFuY2VzdG9ycyh0KXtjb25zdCBlPXRoaXMucGFyZW50O251bGwhPT1lJiYodChlKSxlLnRyYXZlcnNlQW5jZXN0b3JzKHQpKX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH11cGRhdGVNYXRyaXhXb3JsZCh0KXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZXx8dCkmJihudWxsPT09dGhpcy5wYXJlbnQ/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMSx0PSEwKTtjb25zdCBlPXRoaXMuY2hpbGRyZW47Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKWVbbl0udXBkYXRlTWF0cml4V29ybGQodCl9dXBkYXRlV29ybGRNYXRyaXgodCxlKXtjb25zdCBuPXRoaXMucGFyZW50O2lmKCEwPT09dCYmbnVsbCE9PW4mJm4udXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubWF0cml4QXV0b1VwZGF0ZSYmdGhpcy51cGRhdGVNYXRyaXgoKSxudWxsPT09dGhpcy5wYXJlbnQ/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpLCEwPT09ZSl7Y29uc3QgdD10aGlzLmNoaWxkcmVuO2ZvcihsZXQgZT0wLG49dC5sZW5ndGg7ZTxuO2UrKyl0W2VdLnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKX19dG9KU09OKHQpe2NvbnN0IGU9dm9pZCAwPT09dHx8XCJzdHJpbmdcIj09dHlwZW9mIHQsbj17fTtlJiYodD17Z2VvbWV0cmllczp7fSxtYXRlcmlhbHM6e30sdGV4dHVyZXM6e30saW1hZ2VzOnt9LHNoYXBlczp7fSxza2VsZXRvbnM6e30sYW5pbWF0aW9uczp7fX0sbi5tZXRhZGF0YT17dmVyc2lvbjo0LjUsdHlwZTpcIk9iamVjdFwiLGdlbmVyYXRvcjpcIk9iamVjdDNELnRvSlNPTlwifSk7Y29uc3QgaT17fTtmdW5jdGlvbiByKGUsbil7cmV0dXJuIHZvaWQgMD09PWVbbi51dWlkXSYmKGVbbi51dWlkXT1uLnRvSlNPTih0KSksbi51dWlkfWlmKGkudXVpZD10aGlzLnV1aWQsaS50eXBlPXRoaXMudHlwZSxcIlwiIT09dGhpcy5uYW1lJiYoaS5uYW1lPXRoaXMubmFtZSksITA9PT10aGlzLmNhc3RTaGFkb3cmJihpLmNhc3RTaGFkb3c9ITApLCEwPT09dGhpcy5yZWNlaXZlU2hhZG93JiYoaS5yZWNlaXZlU2hhZG93PSEwKSwhMT09PXRoaXMudmlzaWJsZSYmKGkudmlzaWJsZT0hMSksITE9PT10aGlzLmZydXN0dW1DdWxsZWQmJihpLmZydXN0dW1DdWxsZWQ9ITEpLDAhPT10aGlzLnJlbmRlck9yZGVyJiYoaS5yZW5kZXJPcmRlcj10aGlzLnJlbmRlck9yZGVyKSxcInt9XCIhPT1KU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJEYXRhKSYmKGkudXNlckRhdGE9dGhpcy51c2VyRGF0YSksaS5sYXllcnM9dGhpcy5sYXllcnMubWFzayxpLm1hdHJpeD10aGlzLm1hdHJpeC50b0FycmF5KCksITE9PT10aGlzLm1hdHJpeEF1dG9VcGRhdGUmJihpLm1hdHJpeEF1dG9VcGRhdGU9ITEpLHRoaXMuaXNJbnN0YW5jZWRNZXNoJiYoaS50eXBlPVwiSW5zdGFuY2VkTWVzaFwiLGkuY291bnQ9dGhpcy5jb3VudCxpLmluc3RhbmNlTWF0cml4PXRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCksbnVsbCE9PXRoaXMuaW5zdGFuY2VDb2xvciYmKGkuaW5zdGFuY2VDb2xvcj10aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCkpKSx0aGlzLmlzU2NlbmUpdGhpcy5iYWNrZ3JvdW5kJiYodGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3I/aS5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04oKTp0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlJiYoaS5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZC50b0pTT04odCkudXVpZCkpLHRoaXMuZW52aXJvbm1lbnQmJnRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlJiYoaS5lbnZpcm9ubWVudD10aGlzLmVudmlyb25tZW50LnRvSlNPTih0KS51dWlkKTtlbHNlIGlmKHRoaXMuaXNNZXNofHx0aGlzLmlzTGluZXx8dGhpcy5pc1BvaW50cyl7aS5nZW9tZXRyeT1yKHQuZ2VvbWV0cmllcyx0aGlzLmdlb21ldHJ5KTtjb25zdCBlPXRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztpZih2b2lkIDAhPT1lJiZ2b2lkIDAhPT1lLnNoYXBlcyl7Y29uc3Qgbj1lLnNoYXBlcztpZihBcnJheS5pc0FycmF5KG4pKWZvcihsZXQgZT0wLGk9bi5sZW5ndGg7ZTxpO2UrKyl7Y29uc3QgaT1uW2VdO3IodC5zaGFwZXMsaSl9ZWxzZSByKHQuc2hhcGVzLG4pfX1pZih0aGlzLmlzU2tpbm5lZE1lc2gmJihpLmJpbmRNb2RlPXRoaXMuYmluZE1vZGUsaS5iaW5kTWF0cml4PXRoaXMuYmluZE1hdHJpeC50b0FycmF5KCksdm9pZCAwIT09dGhpcy5za2VsZXRvbiYmKHIodC5za2VsZXRvbnMsdGhpcy5za2VsZXRvbiksaS5za2VsZXRvbj10aGlzLnNrZWxldG9uLnV1aWQpKSx2b2lkIDAhPT10aGlzLm1hdGVyaWFsKWlmKEFycmF5LmlzQXJyYXkodGhpcy5tYXRlcmlhbCkpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAsaT10aGlzLm1hdGVyaWFsLmxlbmd0aDtuPGk7bisrKWUucHVzaChyKHQubWF0ZXJpYWxzLHRoaXMubWF0ZXJpYWxbbl0pKTtpLm1hdGVyaWFsPWV9ZWxzZSBpLm1hdGVyaWFsPXIodC5tYXRlcmlhbHMsdGhpcy5tYXRlcmlhbCk7aWYodGhpcy5jaGlsZHJlbi5sZW5ndGg+MCl7aS5jaGlsZHJlbj1bXTtmb3IobGV0IGU9MDtlPHRoaXMuY2hpbGRyZW4ubGVuZ3RoO2UrKylpLmNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltlXS50b0pTT04odCkub2JqZWN0KX1pZih0aGlzLmFuaW1hdGlvbnMubGVuZ3RoPjApe2kuYW5pbWF0aW9ucz1bXTtmb3IobGV0IGU9MDtlPHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuYW5pbWF0aW9uc1tlXTtpLmFuaW1hdGlvbnMucHVzaChyKHQuYW5pbWF0aW9ucyxuKSl9fWlmKGUpe2NvbnN0IGU9cyh0Lmdlb21ldHJpZXMpLGk9cyh0Lm1hdGVyaWFscykscj1zKHQudGV4dHVyZXMpLGE9cyh0LmltYWdlcyksbz1zKHQuc2hhcGVzKSxsPXModC5za2VsZXRvbnMpLGM9cyh0LmFuaW1hdGlvbnMpO2UubGVuZ3RoPjAmJihuLmdlb21ldHJpZXM9ZSksaS5sZW5ndGg+MCYmKG4ubWF0ZXJpYWxzPWkpLHIubGVuZ3RoPjAmJihuLnRleHR1cmVzPXIpLGEubGVuZ3RoPjAmJihuLmltYWdlcz1hKSxvLmxlbmd0aD4wJiYobi5zaGFwZXM9byksbC5sZW5ndGg+MCYmKG4uc2tlbGV0b25zPWwpLGMubGVuZ3RoPjAmJihuLmFuaW1hdGlvbnM9Yyl9cmV0dXJuIG4ub2JqZWN0PWksbjtmdW5jdGlvbiBzKHQpe2NvbnN0IGU9W107Zm9yKGNvbnN0IG4gaW4gdCl7Y29uc3QgaT10W25dO2RlbGV0ZSBpLm1ldGFkYXRhLGUucHVzaChpKX1yZXR1cm4gZX19Y2xvbmUodCl7cmV0dXJuKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMsdCl9Y29weSh0LGU9ITApe2lmKHRoaXMubmFtZT10Lm5hbWUsdGhpcy51cC5jb3B5KHQudXApLHRoaXMucG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSx0aGlzLnJvdGF0aW9uLm9yZGVyPXQucm90YXRpb24ub3JkZXIsdGhpcy5xdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKSx0aGlzLnNjYWxlLmNvcHkodC5zY2FsZSksdGhpcy5tYXRyaXguY29weSh0Lm1hdHJpeCksdGhpcy5tYXRyaXhXb3JsZC5jb3B5KHQubWF0cml4V29ybGQpLHRoaXMubWF0cml4QXV0b1VwZGF0ZT10Lm1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPXQubWF0cml4V29ybGROZWVkc1VwZGF0ZSx0aGlzLmxheWVycy5tYXNrPXQubGF5ZXJzLm1hc2ssdGhpcy52aXNpYmxlPXQudmlzaWJsZSx0aGlzLmNhc3RTaGFkb3c9dC5jYXN0U2hhZG93LHRoaXMucmVjZWl2ZVNoYWRvdz10LnJlY2VpdmVTaGFkb3csdGhpcy5mcnVzdHVtQ3VsbGVkPXQuZnJ1c3R1bUN1bGxlZCx0aGlzLnJlbmRlck9yZGVyPXQucmVuZGVyT3JkZXIsdGhpcy51c2VyRGF0YT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQudXNlckRhdGEpKSwhMD09PWUpZm9yKGxldCBlPTA7ZTx0LmNoaWxkcmVuLmxlbmd0aDtlKyspe2NvbnN0IG49dC5jaGlsZHJlbltlXTt0aGlzLmFkZChuLmNsb25lKCkpfXJldHVybiB0aGlzfX1WZS5EZWZhdWx0VXA9bmV3IEJ0KDAsMSwwKSxWZS5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZT0hMCxWZS5wcm90b3R5cGUuaXNPYmplY3QzRD0hMDtjb25zdCBHZT1uZXcgQnQsV2U9bmV3IEJ0LGplPW5ldyBCdCxxZT1uZXcgQnQsWGU9bmV3IEJ0LFllPW5ldyBCdCxaZT1uZXcgQnQsSmU9bmV3IEJ0LCRlPW5ldyBCdCxLZT1uZXcgQnQ7Y2xhc3MgUWV7Y29uc3RydWN0b3IodD1uZXcgQnQsZT1uZXcgQnQsbj1uZXcgQnQpe3RoaXMuYT10LHRoaXMuYj1lLHRoaXMuYz1ufXN0YXRpYyBnZXROb3JtYWwodCxlLG4saSl7aS5zdWJWZWN0b3JzKG4sZSksR2Uuc3ViVmVjdG9ycyh0LGUpLGkuY3Jvc3MoR2UpO2NvbnN0IHI9aS5sZW5ndGhTcSgpO3JldHVybiByPjA/aS5tdWx0aXBseVNjYWxhcigxL01hdGguc3FydChyKSk6aS5zZXQoMCwwLDApfXN0YXRpYyBnZXRCYXJ5Y29vcmQodCxlLG4saSxyKXtHZS5zdWJWZWN0b3JzKGksZSksV2Uuc3ViVmVjdG9ycyhuLGUpLGplLnN1YlZlY3RvcnModCxlKTtjb25zdCBzPUdlLmRvdChHZSksYT1HZS5kb3QoV2UpLG89R2UuZG90KGplKSxsPVdlLmRvdChXZSksYz1XZS5kb3QoamUpLGg9cypsLWEqYTtpZigwPT09aClyZXR1cm4gci5zZXQoLTIsLTEsLTEpO2NvbnN0IHU9MS9oLGQ9KGwqby1hKmMpKnUscD0ocypjLWEqbykqdTtyZXR1cm4gci5zZXQoMS1kLXAscCxkKX1zdGF0aWMgY29udGFpbnNQb2ludCh0LGUsbixpKXtyZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQodCxlLG4saSxxZSkscWUueD49MCYmcWUueT49MCYmcWUueCtxZS55PD0xfXN0YXRpYyBnZXRVVih0LGUsbixpLHIscyxhLG8pe3JldHVybiB0aGlzLmdldEJhcnljb29yZCh0LGUsbixpLHFlKSxvLnNldCgwLDApLG8uYWRkU2NhbGVkVmVjdG9yKHIscWUueCksby5hZGRTY2FsZWRWZWN0b3IocyxxZS55KSxvLmFkZFNjYWxlZFZlY3RvcihhLHFlLnopLG99c3RhdGljIGlzRnJvbnRGYWNpbmcodCxlLG4saSl7cmV0dXJuIEdlLnN1YlZlY3RvcnMobixlKSxXZS5zdWJWZWN0b3JzKHQsZSksR2UuY3Jvc3MoV2UpLmRvdChpKTwwfXNldCh0LGUsbil7cmV0dXJuIHRoaXMuYS5jb3B5KHQpLHRoaXMuYi5jb3B5KGUpLHRoaXMuYy5jb3B5KG4pLHRoaXN9c2V0RnJvbVBvaW50c0FuZEluZGljZXModCxlLG4saSl7cmV0dXJuIHRoaXMuYS5jb3B5KHRbZV0pLHRoaXMuYi5jb3B5KHRbbl0pLHRoaXMuYy5jb3B5KHRbaV0pLHRoaXN9c2V0RnJvbUF0dHJpYnV0ZUFuZEluZGljZXModCxlLG4saSl7cmV0dXJuIHRoaXMuYS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSksdGhpcy5iLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxuKSx0aGlzLmMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGkpLHRoaXN9Y2xvbmUoKXtyZXR1cm4obmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcyl9Y29weSh0KXtyZXR1cm4gdGhpcy5hLmNvcHkodC5hKSx0aGlzLmIuY29weSh0LmIpLHRoaXMuYy5jb3B5KHQuYyksdGhpc31nZXRBcmVhKCl7cmV0dXJuIEdlLnN1YlZlY3RvcnModGhpcy5jLHRoaXMuYiksV2Uuc3ViVmVjdG9ycyh0aGlzLmEsdGhpcy5iKSwuNSpHZS5jcm9zcyhXZSkubGVuZ3RoKCl9Z2V0TWlkcG9pbnQodCl7cmV0dXJuIHQuYWRkVmVjdG9ycyh0aGlzLmEsdGhpcy5iKS5hZGQodGhpcy5jKS5tdWx0aXBseVNjYWxhcigxLzMpfWdldE5vcm1hbCh0KXtyZXR1cm4gUWUuZ2V0Tm9ybWFsKHRoaXMuYSx0aGlzLmIsdGhpcy5jLHQpfWdldFBsYW5lKHQpe3JldHVybiB0LnNldEZyb21Db3BsYW5hclBvaW50cyh0aGlzLmEsdGhpcy5iLHRoaXMuYyl9Z2V0QmFyeWNvb3JkKHQsZSl7cmV0dXJuIFFlLmdldEJhcnljb29yZCh0LHRoaXMuYSx0aGlzLmIsdGhpcy5jLGUpfWdldFVWKHQsZSxuLGkscil7cmV0dXJuIFFlLmdldFVWKHQsdGhpcy5hLHRoaXMuYix0aGlzLmMsZSxuLGkscil9Y29udGFpbnNQb2ludCh0KXtyZXR1cm4gUWUuY29udGFpbnNQb2ludCh0LHRoaXMuYSx0aGlzLmIsdGhpcy5jKX1pc0Zyb250RmFjaW5nKHQpe3JldHVybiBRZS5pc0Zyb250RmFjaW5nKHRoaXMuYSx0aGlzLmIsdGhpcy5jLHQpfWludGVyc2VjdHNCb3godCl7cmV0dXJuIHQuaW50ZXJzZWN0c1RyaWFuZ2xlKHRoaXMpfWNsb3Nlc3RQb2ludFRvUG9pbnQodCxlKXtjb25zdCBuPXRoaXMuYSxpPXRoaXMuYixyPXRoaXMuYztsZXQgcyxhO1hlLnN1YlZlY3RvcnMoaSxuKSxZZS5zdWJWZWN0b3JzKHIsbiksSmUuc3ViVmVjdG9ycyh0LG4pO2NvbnN0IG89WGUuZG90KEplKSxsPVllLmRvdChKZSk7aWYobzw9MCYmbDw9MClyZXR1cm4gZS5jb3B5KG4pOyRlLnN1YlZlY3RvcnModCxpKTtjb25zdCBjPVhlLmRvdCgkZSksaD1ZZS5kb3QoJGUpO2lmKGM+PTAmJmg8PWMpcmV0dXJuIGUuY29weShpKTtjb25zdCB1PW8qaC1jKmw7aWYodTw9MCYmbz49MCYmYzw9MClyZXR1cm4gcz1vLyhvLWMpLGUuY29weShuKS5hZGRTY2FsZWRWZWN0b3IoWGUscyk7S2Uuc3ViVmVjdG9ycyh0LHIpO2NvbnN0IGQ9WGUuZG90KEtlKSxwPVllLmRvdChLZSk7aWYocD49MCYmZDw9cClyZXR1cm4gZS5jb3B5KHIpO2NvbnN0IG09ZCpsLW8qcDtpZihtPD0wJiZsPj0wJiZwPD0wKXJldHVybiBhPWwvKGwtcCksZS5jb3B5KG4pLmFkZFNjYWxlZFZlY3RvcihZZSxhKTtjb25zdCBmPWMqcC1kKmg7aWYoZjw9MCYmaC1jPj0wJiZkLXA+PTApcmV0dXJuIFplLnN1YlZlY3RvcnMocixpKSxhPShoLWMpLyhoLWMrKGQtcCkpLGUuY29weShpKS5hZGRTY2FsZWRWZWN0b3IoWmUsYSk7Y29uc3QgZz0xLyhmK20rdSk7cmV0dXJuIHM9bSpnLGE9dSpnLGUuY29weShuKS5hZGRTY2FsZWRWZWN0b3IoWGUscykuYWRkU2NhbGVkVmVjdG9yKFllLGEpfWVxdWFscyh0KXtyZXR1cm4gdC5hLmVxdWFscyh0aGlzLmEpJiZ0LmIuZXF1YWxzKHRoaXMuYikmJnQuYy5lcXVhbHModGhpcy5jKX19bGV0IHRuPTA7Y2xhc3MgZW4gZXh0ZW5kcyBwdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJpZFwiLHt2YWx1ZTp0bisrfSksdGhpcy51dWlkPXh0KCksdGhpcy5uYW1lPVwiXCIsdGhpcy50eXBlPVwiTWF0ZXJpYWxcIix0aGlzLmZvZz0hMCx0aGlzLmJsZW5kaW5nPTEsdGhpcy5zaWRlPTAsdGhpcy52ZXJ0ZXhDb2xvcnM9ITEsdGhpcy5vcGFjaXR5PTEsdGhpcy5mb3JtYXQ9MTAyMyx0aGlzLnRyYW5zcGFyZW50PSExLHRoaXMuYmxlbmRTcmM9MjA0LHRoaXMuYmxlbmREc3Q9MjA1LHRoaXMuYmxlbmRFcXVhdGlvbj0xMDAsdGhpcy5ibGVuZFNyY0FscGhhPW51bGwsdGhpcy5ibGVuZERzdEFscGhhPW51bGwsdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGE9bnVsbCx0aGlzLmRlcHRoRnVuYz0zLHRoaXMuZGVwdGhUZXN0PSEwLHRoaXMuZGVwdGhXcml0ZT0hMCx0aGlzLnN0ZW5jaWxXcml0ZU1hc2s9MjU1LHRoaXMuc3RlbmNpbEZ1bmM9NTE5LHRoaXMuc3RlbmNpbFJlZj0wLHRoaXMuc3RlbmNpbEZ1bmNNYXNrPTI1NSx0aGlzLnN0ZW5jaWxGYWlsPTc2ODAsdGhpcy5zdGVuY2lsWkZhaWw9NzY4MCx0aGlzLnN0ZW5jaWxaUGFzcz03NjgwLHRoaXMuc3RlbmNpbFdyaXRlPSExLHRoaXMuY2xpcHBpbmdQbGFuZXM9bnVsbCx0aGlzLmNsaXBJbnRlcnNlY3Rpb249ITEsdGhpcy5jbGlwU2hhZG93cz0hMSx0aGlzLnNoYWRvd1NpZGU9bnVsbCx0aGlzLmNvbG9yV3JpdGU9ITAsdGhpcy5wcmVjaXNpb249bnVsbCx0aGlzLnBvbHlnb25PZmZzZXQ9ITEsdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yPTAsdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM9MCx0aGlzLmRpdGhlcmluZz0hMSx0aGlzLmFscGhhVG9Db3ZlcmFnZT0hMSx0aGlzLnByZW11bHRpcGxpZWRBbHBoYT0hMSx0aGlzLnZpc2libGU9ITAsdGhpcy50b25lTWFwcGVkPSEwLHRoaXMudXNlckRhdGE9e30sdGhpcy52ZXJzaW9uPTAsdGhpcy5fYWxwaGFUZXN0PTB9Z2V0IGFscGhhVGVzdCgpe3JldHVybiB0aGlzLl9hbHBoYVRlc3R9c2V0IGFscGhhVGVzdCh0KXt0aGlzLl9hbHBoYVRlc3Q+MCE9dD4wJiZ0aGlzLnZlcnNpb24rKyx0aGlzLl9hbHBoYVRlc3Q9dH1vbkJ1aWxkKCl7fW9uQmVmb3JlUmVuZGVyKCl7fW9uQmVmb3JlQ29tcGlsZSgpe31jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKX1zZXRWYWx1ZXModCl7aWYodm9pZCAwIT09dClmb3IoY29uc3QgZSBpbiB0KXtjb25zdCBuPXRbZV07aWYodm9pZCAwPT09bil7Y29uc29sZS53YXJuKFwiVEhSRUUuTWF0ZXJpYWw6ICdcIitlK1wiJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlwiKTtjb250aW51ZX1pZihcInNoYWRpbmdcIj09PWUpe2NvbnNvbGUud2FybihcIlRIUkVFLlwiK3RoaXMudHlwZStcIjogLnNoYWRpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHRoZSBib29sZWFuIC5mbGF0U2hhZGluZyBpbnN0ZWFkLlwiKSx0aGlzLmZsYXRTaGFkaW5nPTE9PT1uO2NvbnRpbnVlfWNvbnN0IGk9dGhpc1tlXTt2b2lkIDAhPT1pP2kmJmkuaXNDb2xvcj9pLnNldChuKTppJiZpLmlzVmVjdG9yMyYmbiYmbi5pc1ZlY3RvcjM/aS5jb3B5KG4pOnRoaXNbZV09bjpjb25zb2xlLndhcm4oXCJUSFJFRS5cIit0aGlzLnR5cGUrXCI6ICdcIitlK1wiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiKX19dG9KU09OKHQpe2NvbnN0IGU9dm9pZCAwPT09dHx8XCJzdHJpbmdcIj09dHlwZW9mIHQ7ZSYmKHQ9e3RleHR1cmVzOnt9LGltYWdlczp7fX0pO2NvbnN0IG49e21ldGFkYXRhOnt2ZXJzaW9uOjQuNSx0eXBlOlwiTWF0ZXJpYWxcIixnZW5lcmF0b3I6XCJNYXRlcmlhbC50b0pTT05cIn19O2Z1bmN0aW9uIGkodCl7Y29uc3QgZT1bXTtmb3IoY29uc3QgbiBpbiB0KXtjb25zdCBpPXRbbl07ZGVsZXRlIGkubWV0YWRhdGEsZS5wdXNoKGkpfXJldHVybiBlfWlmKG4udXVpZD10aGlzLnV1aWQsbi50eXBlPXRoaXMudHlwZSxcIlwiIT09dGhpcy5uYW1lJiYobi5uYW1lPXRoaXMubmFtZSksdGhpcy5jb2xvciYmdGhpcy5jb2xvci5pc0NvbG9yJiYobi5jb2xvcj10aGlzLmNvbG9yLmdldEhleCgpKSx2b2lkIDAhPT10aGlzLnJvdWdobmVzcyYmKG4ucm91Z2huZXNzPXRoaXMucm91Z2huZXNzKSx2b2lkIDAhPT10aGlzLm1ldGFsbmVzcyYmKG4ubWV0YWxuZXNzPXRoaXMubWV0YWxuZXNzKSx2b2lkIDAhPT10aGlzLnNoZWVuJiYobi5zaGVlbj10aGlzLnNoZWVuKSx0aGlzLnNoZWVuVGludCYmdGhpcy5zaGVlblRpbnQuaXNDb2xvciYmKG4uc2hlZW5UaW50PXRoaXMuc2hlZW5UaW50LmdldEhleCgpKSx2b2lkIDAhPT10aGlzLnNoZWVuUm91Z2huZXNzJiYobi5zaGVlblJvdWdobmVzcz10aGlzLnNoZWVuUm91Z2huZXNzKSx0aGlzLmVtaXNzaXZlJiZ0aGlzLmVtaXNzaXZlLmlzQ29sb3ImJihuLmVtaXNzaXZlPXRoaXMuZW1pc3NpdmUuZ2V0SGV4KCkpLHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkmJjEhPT10aGlzLmVtaXNzaXZlSW50ZW5zaXR5JiYobi5lbWlzc2l2ZUludGVuc2l0eT10aGlzLmVtaXNzaXZlSW50ZW5zaXR5KSx0aGlzLnNwZWN1bGFyJiZ0aGlzLnNwZWN1bGFyLmlzQ29sb3ImJihuLnNwZWN1bGFyPXRoaXMuc3BlY3VsYXIuZ2V0SGV4KCkpLHZvaWQgMCE9PXRoaXMuc3BlY3VsYXJJbnRlbnNpdHkmJihuLnNwZWN1bGFySW50ZW5zaXR5PXRoaXMuc3BlY3VsYXJJbnRlbnNpdHkpLHRoaXMuc3BlY3VsYXJUaW50JiZ0aGlzLnNwZWN1bGFyVGludC5pc0NvbG9yJiYobi5zcGVjdWxhclRpbnQ9dGhpcy5zcGVjdWxhclRpbnQuZ2V0SGV4KCkpLHZvaWQgMCE9PXRoaXMuc2hpbmluZXNzJiYobi5zaGluaW5lc3M9dGhpcy5zaGluaW5lc3MpLHZvaWQgMCE9PXRoaXMuY2xlYXJjb2F0JiYobi5jbGVhcmNvYXQ9dGhpcy5jbGVhcmNvYXQpLHZvaWQgMCE9PXRoaXMuY2xlYXJjb2F0Um91Z2huZXNzJiYobi5jbGVhcmNvYXRSb3VnaG5lc3M9dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MpLHRoaXMuY2xlYXJjb2F0TWFwJiZ0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUmJihuLmNsZWFyY29hdE1hcD10aGlzLmNsZWFyY29hdE1hcC50b0pTT04odCkudXVpZCksdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAmJnRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSYmKG4uY2xlYXJjb2F0Um91Z2huZXNzTWFwPXRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCYmdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlJiYobi5jbGVhcmNvYXROb3JtYWxNYXA9dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKHQpLnV1aWQsbi5jbGVhcmNvYXROb3JtYWxTY2FsZT10aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLnRvQXJyYXkoKSksdGhpcy5tYXAmJnRoaXMubWFwLmlzVGV4dHVyZSYmKG4ubWFwPXRoaXMubWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLm1hdGNhcCYmdGhpcy5tYXRjYXAuaXNUZXh0dXJlJiYobi5tYXRjYXA9dGhpcy5tYXRjYXAudG9KU09OKHQpLnV1aWQpLHRoaXMuYWxwaGFNYXAmJnRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlJiYobi5hbHBoYU1hcD10aGlzLmFscGhhTWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLmxpZ2h0TWFwJiZ0aGlzLmxpZ2h0TWFwLmlzVGV4dHVyZSYmKG4ubGlnaHRNYXA9dGhpcy5saWdodE1hcC50b0pTT04odCkudXVpZCxuLmxpZ2h0TWFwSW50ZW5zaXR5PXRoaXMubGlnaHRNYXBJbnRlbnNpdHkpLHRoaXMuYW9NYXAmJnRoaXMuYW9NYXAuaXNUZXh0dXJlJiYobi5hb01hcD10aGlzLmFvTWFwLnRvSlNPTih0KS51dWlkLG4uYW9NYXBJbnRlbnNpdHk9dGhpcy5hb01hcEludGVuc2l0eSksdGhpcy5idW1wTWFwJiZ0aGlzLmJ1bXBNYXAuaXNUZXh0dXJlJiYobi5idW1wTWFwPXRoaXMuYnVtcE1hcC50b0pTT04odCkudXVpZCxuLmJ1bXBTY2FsZT10aGlzLmJ1bXBTY2FsZSksdGhpcy5ub3JtYWxNYXAmJnRoaXMubm9ybWFsTWFwLmlzVGV4dHVyZSYmKG4ubm9ybWFsTWFwPXRoaXMubm9ybWFsTWFwLnRvSlNPTih0KS51dWlkLG4ubm9ybWFsTWFwVHlwZT10aGlzLm5vcm1hbE1hcFR5cGUsbi5ub3JtYWxTY2FsZT10aGlzLm5vcm1hbFNjYWxlLnRvQXJyYXkoKSksdGhpcy5kaXNwbGFjZW1lbnRNYXAmJnRoaXMuZGlzcGxhY2VtZW50TWFwLmlzVGV4dHVyZSYmKG4uZGlzcGxhY2VtZW50TWFwPXRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTih0KS51dWlkLG4uZGlzcGxhY2VtZW50U2NhbGU9dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSxuLmRpc3BsYWNlbWVudEJpYXM9dGhpcy5kaXNwbGFjZW1lbnRCaWFzKSx0aGlzLnJvdWdobmVzc01hcCYmdGhpcy5yb3VnaG5lc3NNYXAuaXNUZXh0dXJlJiYobi5yb3VnaG5lc3NNYXA9dGhpcy5yb3VnaG5lc3NNYXAudG9KU09OKHQpLnV1aWQpLHRoaXMubWV0YWxuZXNzTWFwJiZ0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUmJihuLm1ldGFsbmVzc01hcD10aGlzLm1ldGFsbmVzc01hcC50b0pTT04odCkudXVpZCksdGhpcy5lbWlzc2l2ZU1hcCYmdGhpcy5lbWlzc2l2ZU1hcC5pc1RleHR1cmUmJihuLmVtaXNzaXZlTWFwPXRoaXMuZW1pc3NpdmVNYXAudG9KU09OKHQpLnV1aWQpLHRoaXMuc3BlY3VsYXJNYXAmJnRoaXMuc3BlY3VsYXJNYXAuaXNUZXh0dXJlJiYobi5zcGVjdWxhck1hcD10aGlzLnNwZWN1bGFyTWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwJiZ0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLmlzVGV4dHVyZSYmKG4uc3BlY3VsYXJJbnRlbnNpdHlNYXA9dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcC50b0pTT04odCkudXVpZCksdGhpcy5zcGVjdWxhclRpbnRNYXAmJnRoaXMuc3BlY3VsYXJUaW50TWFwLmlzVGV4dHVyZSYmKG4uc3BlY3VsYXJUaW50TWFwPXRoaXMuc3BlY3VsYXJUaW50TWFwLnRvSlNPTih0KS51dWlkKSx0aGlzLmVudk1hcCYmdGhpcy5lbnZNYXAuaXNUZXh0dXJlJiYobi5lbnZNYXA9dGhpcy5lbnZNYXAudG9KU09OKHQpLnV1aWQsdm9pZCAwIT09dGhpcy5jb21iaW5lJiYobi5jb21iaW5lPXRoaXMuY29tYmluZSkpLHZvaWQgMCE9PXRoaXMuZW52TWFwSW50ZW5zaXR5JiYobi5lbnZNYXBJbnRlbnNpdHk9dGhpcy5lbnZNYXBJbnRlbnNpdHkpLHZvaWQgMCE9PXRoaXMucmVmbGVjdGl2aXR5JiYobi5yZWZsZWN0aXZpdHk9dGhpcy5yZWZsZWN0aXZpdHkpLHZvaWQgMCE9PXRoaXMucmVmcmFjdGlvblJhdGlvJiYobi5yZWZyYWN0aW9uUmF0aW89dGhpcy5yZWZyYWN0aW9uUmF0aW8pLHRoaXMuZ3JhZGllbnRNYXAmJnRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlJiYobi5ncmFkaWVudE1hcD10aGlzLmdyYWRpZW50TWFwLnRvSlNPTih0KS51dWlkKSx2b2lkIDAhPT10aGlzLnRyYW5zbWlzc2lvbiYmKG4udHJhbnNtaXNzaW9uPXRoaXMudHJhbnNtaXNzaW9uKSx0aGlzLnRyYW5zbWlzc2lvbk1hcCYmdGhpcy50cmFuc21pc3Npb25NYXAuaXNUZXh0dXJlJiYobi50cmFuc21pc3Npb25NYXA9dGhpcy50cmFuc21pc3Npb25NYXAudG9KU09OKHQpLnV1aWQpLHZvaWQgMCE9PXRoaXMudGhpY2tuZXNzJiYobi50aGlja25lc3M9dGhpcy50aGlja25lc3MpLHRoaXMudGhpY2tuZXNzTWFwJiZ0aGlzLnRoaWNrbmVzc01hcC5pc1RleHR1cmUmJihuLnRoaWNrbmVzc01hcD10aGlzLnRoaWNrbmVzc01hcC50b0pTT04odCkudXVpZCksdm9pZCAwIT09dGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlJiYobi5hdHRlbnVhdGlvbkRpc3RhbmNlPXRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSksdm9pZCAwIT09dGhpcy5hdHRlbnVhdGlvblRpbnQmJihuLmF0dGVudWF0aW9uVGludD10aGlzLmF0dGVudWF0aW9uVGludC5nZXRIZXgoKSksdm9pZCAwIT09dGhpcy5zaXplJiYobi5zaXplPXRoaXMuc2l6ZSksbnVsbCE9PXRoaXMuc2hhZG93U2lkZSYmKG4uc2hhZG93U2lkZT10aGlzLnNoYWRvd1NpZGUpLHZvaWQgMCE9PXRoaXMuc2l6ZUF0dGVudWF0aW9uJiYobi5zaXplQXR0ZW51YXRpb249dGhpcy5zaXplQXR0ZW51YXRpb24pLDEhPT10aGlzLmJsZW5kaW5nJiYobi5ibGVuZGluZz10aGlzLmJsZW5kaW5nKSwwIT09dGhpcy5zaWRlJiYobi5zaWRlPXRoaXMuc2lkZSksdGhpcy52ZXJ0ZXhDb2xvcnMmJihuLnZlcnRleENvbG9ycz0hMCksdGhpcy5vcGFjaXR5PDEmJihuLm9wYWNpdHk9dGhpcy5vcGFjaXR5KSwxMDIzIT09dGhpcy5mb3JtYXQmJihuLmZvcm1hdD10aGlzLmZvcm1hdCksITA9PT10aGlzLnRyYW5zcGFyZW50JiYobi50cmFuc3BhcmVudD10aGlzLnRyYW5zcGFyZW50KSxuLmRlcHRoRnVuYz10aGlzLmRlcHRoRnVuYyxuLmRlcHRoVGVzdD10aGlzLmRlcHRoVGVzdCxuLmRlcHRoV3JpdGU9dGhpcy5kZXB0aFdyaXRlLG4uY29sb3JXcml0ZT10aGlzLmNvbG9yV3JpdGUsbi5zdGVuY2lsV3JpdGU9dGhpcy5zdGVuY2lsV3JpdGUsbi5zdGVuY2lsV3JpdGVNYXNrPXRoaXMuc3RlbmNpbFdyaXRlTWFzayxuLnN0ZW5jaWxGdW5jPXRoaXMuc3RlbmNpbEZ1bmMsbi5zdGVuY2lsUmVmPXRoaXMuc3RlbmNpbFJlZixuLnN0ZW5jaWxGdW5jTWFzaz10aGlzLnN0ZW5jaWxGdW5jTWFzayxuLnN0ZW5jaWxGYWlsPXRoaXMuc3RlbmNpbEZhaWwsbi5zdGVuY2lsWkZhaWw9dGhpcy5zdGVuY2lsWkZhaWwsbi5zdGVuY2lsWlBhc3M9dGhpcy5zdGVuY2lsWlBhc3MsdGhpcy5yb3RhdGlvbiYmMCE9PXRoaXMucm90YXRpb24mJihuLnJvdGF0aW9uPXRoaXMucm90YXRpb24pLCEwPT09dGhpcy5wb2x5Z29uT2Zmc2V0JiYobi5wb2x5Z29uT2Zmc2V0PSEwKSwwIT09dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yJiYobi5wb2x5Z29uT2Zmc2V0RmFjdG9yPXRoaXMucG9seWdvbk9mZnNldEZhY3RvciksMCE9PXRoaXMucG9seWdvbk9mZnNldFVuaXRzJiYobi5wb2x5Z29uT2Zmc2V0VW5pdHM9dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMpLHRoaXMubGluZXdpZHRoJiYxIT09dGhpcy5saW5ld2lkdGgmJihuLmxpbmV3aWR0aD10aGlzLmxpbmV3aWR0aCksdm9pZCAwIT09dGhpcy5kYXNoU2l6ZSYmKG4uZGFzaFNpemU9dGhpcy5kYXNoU2l6ZSksdm9pZCAwIT09dGhpcy5nYXBTaXplJiYobi5nYXBTaXplPXRoaXMuZ2FwU2l6ZSksdm9pZCAwIT09dGhpcy5zY2FsZSYmKG4uc2NhbGU9dGhpcy5zY2FsZSksITA9PT10aGlzLmRpdGhlcmluZyYmKG4uZGl0aGVyaW5nPSEwKSx0aGlzLmFscGhhVGVzdD4wJiYobi5hbHBoYVRlc3Q9dGhpcy5hbHBoYVRlc3QpLCEwPT09dGhpcy5hbHBoYVRvQ292ZXJhZ2UmJihuLmFscGhhVG9Db3ZlcmFnZT10aGlzLmFscGhhVG9Db3ZlcmFnZSksITA9PT10aGlzLnByZW11bHRpcGxpZWRBbHBoYSYmKG4ucHJlbXVsdGlwbGllZEFscGhhPXRoaXMucHJlbXVsdGlwbGllZEFscGhhKSwhMD09PXRoaXMud2lyZWZyYW1lJiYobi53aXJlZnJhbWU9dGhpcy53aXJlZnJhbWUpLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPjEmJihuLndpcmVmcmFtZUxpbmV3aWR0aD10aGlzLndpcmVmcmFtZUxpbmV3aWR0aCksXCJyb3VuZFwiIT09dGhpcy53aXJlZnJhbWVMaW5lY2FwJiYobi53aXJlZnJhbWVMaW5lY2FwPXRoaXMud2lyZWZyYW1lTGluZWNhcCksXCJyb3VuZFwiIT09dGhpcy53aXJlZnJhbWVMaW5lam9pbiYmKG4ud2lyZWZyYW1lTGluZWpvaW49dGhpcy53aXJlZnJhbWVMaW5lam9pbiksITA9PT10aGlzLmZsYXRTaGFkaW5nJiYobi5mbGF0U2hhZGluZz10aGlzLmZsYXRTaGFkaW5nKSwhMT09PXRoaXMudmlzaWJsZSYmKG4udmlzaWJsZT0hMSksITE9PT10aGlzLnRvbmVNYXBwZWQmJihuLnRvbmVNYXBwZWQ9ITEpLFwie31cIiE9PUpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpJiYobi51c2VyRGF0YT10aGlzLnVzZXJEYXRhKSxlKXtjb25zdCBlPWkodC50ZXh0dXJlcykscj1pKHQuaW1hZ2VzKTtlLmxlbmd0aD4wJiYobi50ZXh0dXJlcz1lKSxyLmxlbmd0aD4wJiYobi5pbWFnZXM9cil9cmV0dXJuIG59Y2xvbmUoKXtyZXR1cm4obmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcyl9Y29weSh0KXt0aGlzLm5hbWU9dC5uYW1lLHRoaXMuZm9nPXQuZm9nLHRoaXMuYmxlbmRpbmc9dC5ibGVuZGluZyx0aGlzLnNpZGU9dC5zaWRlLHRoaXMudmVydGV4Q29sb3JzPXQudmVydGV4Q29sb3JzLHRoaXMub3BhY2l0eT10Lm9wYWNpdHksdGhpcy5mb3JtYXQ9dC5mb3JtYXQsdGhpcy50cmFuc3BhcmVudD10LnRyYW5zcGFyZW50LHRoaXMuYmxlbmRTcmM9dC5ibGVuZFNyYyx0aGlzLmJsZW5kRHN0PXQuYmxlbmREc3QsdGhpcy5ibGVuZEVxdWF0aW9uPXQuYmxlbmRFcXVhdGlvbix0aGlzLmJsZW5kU3JjQWxwaGE9dC5ibGVuZFNyY0FscGhhLHRoaXMuYmxlbmREc3RBbHBoYT10LmJsZW5kRHN0QWxwaGEsdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGE9dC5ibGVuZEVxdWF0aW9uQWxwaGEsdGhpcy5kZXB0aEZ1bmM9dC5kZXB0aEZ1bmMsdGhpcy5kZXB0aFRlc3Q9dC5kZXB0aFRlc3QsdGhpcy5kZXB0aFdyaXRlPXQuZGVwdGhXcml0ZSx0aGlzLnN0ZW5jaWxXcml0ZU1hc2s9dC5zdGVuY2lsV3JpdGVNYXNrLHRoaXMuc3RlbmNpbEZ1bmM9dC5zdGVuY2lsRnVuYyx0aGlzLnN0ZW5jaWxSZWY9dC5zdGVuY2lsUmVmLHRoaXMuc3RlbmNpbEZ1bmNNYXNrPXQuc3RlbmNpbEZ1bmNNYXNrLHRoaXMuc3RlbmNpbEZhaWw9dC5zdGVuY2lsRmFpbCx0aGlzLnN0ZW5jaWxaRmFpbD10LnN0ZW5jaWxaRmFpbCx0aGlzLnN0ZW5jaWxaUGFzcz10LnN0ZW5jaWxaUGFzcyx0aGlzLnN0ZW5jaWxXcml0ZT10LnN0ZW5jaWxXcml0ZTtjb25zdCBlPXQuY2xpcHBpbmdQbGFuZXM7bGV0IG49bnVsbDtpZihudWxsIT09ZSl7Y29uc3QgdD1lLmxlbmd0aDtuPW5ldyBBcnJheSh0KTtmb3IobGV0IGk9MDtpIT09dDsrK2kpbltpXT1lW2ldLmNsb25lKCl9cmV0dXJuIHRoaXMuY2xpcHBpbmdQbGFuZXM9bix0aGlzLmNsaXBJbnRlcnNlY3Rpb249dC5jbGlwSW50ZXJzZWN0aW9uLHRoaXMuY2xpcFNoYWRvd3M9dC5jbGlwU2hhZG93cyx0aGlzLnNoYWRvd1NpZGU9dC5zaGFkb3dTaWRlLHRoaXMuY29sb3JXcml0ZT10LmNvbG9yV3JpdGUsdGhpcy5wcmVjaXNpb249dC5wcmVjaXNpb24sdGhpcy5wb2x5Z29uT2Zmc2V0PXQucG9seWdvbk9mZnNldCx0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I9dC5wb2x5Z29uT2Zmc2V0RmFjdG9yLHRoaXMucG9seWdvbk9mZnNldFVuaXRzPXQucG9seWdvbk9mZnNldFVuaXRzLHRoaXMuZGl0aGVyaW5nPXQuZGl0aGVyaW5nLHRoaXMuYWxwaGFUZXN0PXQuYWxwaGFUZXN0LHRoaXMuYWxwaGFUb0NvdmVyYWdlPXQuYWxwaGFUb0NvdmVyYWdlLHRoaXMucHJlbXVsdGlwbGllZEFscGhhPXQucHJlbXVsdGlwbGllZEFscGhhLHRoaXMudmlzaWJsZT10LnZpc2libGUsdGhpcy50b25lTWFwcGVkPXQudG9uZU1hcHBlZCx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodC51c2VyRGF0YSkpLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTpcImRpc3Bvc2VcIn0pfXNldCBuZWVkc1VwZGF0ZSh0KXshMD09PXQmJnRoaXMudmVyc2lvbisrfX1lbi5wcm90b3R5cGUuaXNNYXRlcmlhbD0hMDtjb25zdCBubj17YWxpY2VibHVlOjE1NzkyMzgzLGFudGlxdWV3aGl0ZToxNjQ0NDM3NSxhcXVhOjY1NTM1LGFxdWFtYXJpbmU6ODM4ODU2NCxhenVyZToxNTc5NDE3NSxiZWlnZToxNjExOTI2MCxiaXNxdWU6MTY3NzAyNDQsYmxhY2s6MCxibGFuY2hlZGFsbW9uZDoxNjc3MjA0NSxibHVlOjI1NSxibHVldmlvbGV0OjkwNTUyMDIsYnJvd246MTA4MjQyMzQsYnVybHl3b29kOjE0NTk2MjMxLGNhZGV0Ymx1ZTo2MjY2NTI4LGNoYXJ0cmV1c2U6ODM4ODM1MixjaG9jb2xhdGU6MTM3ODk0NzAsY29yYWw6MTY3NDQyNzIsY29ybmZsb3dlcmJsdWU6NjU5MTk4MSxjb3Juc2lsazoxNjc3NTM4OCxjcmltc29uOjE0NDIzMTAwLGN5YW46NjU1MzUsZGFya2JsdWU6MTM5LGRhcmtjeWFuOjM1NzIzLGRhcmtnb2xkZW5yb2Q6MTIwOTI5MzksZGFya2dyYXk6MTExMTkwMTcsZGFya2dyZWVuOjI1NjAwLGRhcmtncmV5OjExMTE5MDE3LGRhcmtraGFraToxMjQzMzI1OSxkYXJrbWFnZW50YTo5MTA5NjQzLGRhcmtvbGl2ZWdyZWVuOjU1OTc5OTksZGFya29yYW5nZToxNjc0NzUyMCxkYXJrb3JjaGlkOjEwMDQwMDEyLGRhcmtyZWQ6OTEwOTUwNCxkYXJrc2FsbW9uOjE1MzA4NDEwLGRhcmtzZWFncmVlbjo5NDE5OTE5LGRhcmtzbGF0ZWJsdWU6NDczNDM0NyxkYXJrc2xhdGVncmF5OjMxMDA0OTUsZGFya3NsYXRlZ3JleTozMTAwNDk1LGRhcmt0dXJxdW9pc2U6NTI5NDUsZGFya3Zpb2xldDo5Njk5NTM5LGRlZXBwaW5rOjE2NzE2OTQ3LGRlZXBza3libHVlOjQ5MTUxLGRpbWdyYXk6NjkwODI2NSxkaW1ncmV5OjY5MDgyNjUsZG9kZ2VyYmx1ZToyMDAzMTk5LGZpcmVicmljazoxMTY3NDE0NixmbG9yYWx3aGl0ZToxNjc3NTkyMCxmb3Jlc3RncmVlbjoyMjYzODQyLGZ1Y2hzaWE6MTY3MTE5MzUsZ2FpbnNib3JvOjE0NDc0NDYwLGdob3N0d2hpdGU6MTYzMTY2NzEsZ29sZDoxNjc2NjcyMCxnb2xkZW5yb2Q6MTQzMjkxMjAsZ3JheTo4NDIxNTA0LGdyZWVuOjMyNzY4LGdyZWVueWVsbG93OjExNDAzMDU1LGdyZXk6ODQyMTUwNCxob25leWRldzoxNTc5NDE2MCxob3RwaW5rOjE2NzM4NzQwLGluZGlhbnJlZDoxMzQ1ODUyNCxpbmRpZ286NDkxNTMzMCxpdm9yeToxNjc3NzIwMCxraGFraToxNTc4NzY2MCxsYXZlbmRlcjoxNTEzMjQxMCxsYXZlbmRlcmJsdXNoOjE2NzczMzY1LGxhd25ncmVlbjo4MTkwOTc2LGxlbW9uY2hpZmZvbjoxNjc3NTg4NSxsaWdodGJsdWU6MTEzOTMyNTQsbGlnaHRjb3JhbDoxNTc2MTUzNixsaWdodGN5YW46MTQ3NDU1OTksbGlnaHRnb2xkZW5yb2R5ZWxsb3c6MTY0NDgyMTAsbGlnaHRncmF5OjEzODgyMzIzLGxpZ2h0Z3JlZW46OTQ5ODI1NixsaWdodGdyZXk6MTM4ODIzMjMsbGlnaHRwaW5rOjE2NzU4NDY1LGxpZ2h0c2FsbW9uOjE2NzUyNzYyLGxpZ2h0c2VhZ3JlZW46MjE0Mjg5MCxsaWdodHNreWJsdWU6ODkwMDM0NixsaWdodHNsYXRlZ3JheTo3ODMzNzUzLGxpZ2h0c2xhdGVncmV5Ojc4MzM3NTMsbGlnaHRzdGVlbGJsdWU6MTE1ODQ3MzQsbGlnaHR5ZWxsb3c6MTY3NzcxODQsbGltZTo2NTI4MCxsaW1lZ3JlZW46MzMyOTMzMCxsaW5lbjoxNjQ0NTY3MCxtYWdlbnRhOjE2NzExOTM1LG1hcm9vbjo4Mzg4NjA4LG1lZGl1bWFxdWFtYXJpbmU6NjczNzMyMixtZWRpdW1ibHVlOjIwNSxtZWRpdW1vcmNoaWQ6MTIyMTE2NjcsbWVkaXVtcHVycGxlOjk2NjI2ODMsbWVkaXVtc2VhZ3JlZW46Mzk3ODA5NyxtZWRpdW1zbGF0ZWJsdWU6ODA4Nzc5MCxtZWRpdW1zcHJpbmdncmVlbjo2NDE1NCxtZWRpdW10dXJxdW9pc2U6NDc3MjMwMCxtZWRpdW12aW9sZXRyZWQ6MTMwNDcxNzMsbWlkbmlnaHRibHVlOjE2NDQ5MTIsbWludGNyZWFtOjE2MTIxODUwLG1pc3R5cm9zZToxNjc3MDI3Myxtb2NjYXNpbjoxNjc3MDIyOSxuYXZham93aGl0ZToxNjc2ODY4NSxuYXZ5OjEyOCxvbGRsYWNlOjE2NjQzNTU4LG9saXZlOjg0MjEzNzYsb2xpdmVkcmFiOjcwNDg3Mzksb3JhbmdlOjE2NzUzOTIwLG9yYW5nZXJlZDoxNjcyOTM0NCxvcmNoaWQ6MTQzMTU3MzQscGFsZWdvbGRlbnJvZDoxNTY1NzEzMCxwYWxlZ3JlZW46MTAwMjU4ODAscGFsZXR1cnF1b2lzZToxMTUyOTk2NixwYWxldmlvbGV0cmVkOjE0MzgxMjAzLHBhcGF5YXdoaXA6MTY3NzMwNzcscGVhY2hwdWZmOjE2NzY3NjczLHBlcnU6MTM0Njg5OTEscGluazoxNjc2MTAzNSxwbHVtOjE0NTI0NjM3LHBvd2RlcmJsdWU6MTE1OTE5MTAscHVycGxlOjgzODg3MzYscmViZWNjYXB1cnBsZTo2Njk3ODgxLHJlZDoxNjcxMTY4MCxyb3N5YnJvd246MTIzNTc1MTkscm95YWxibHVlOjQyODY5NDUsc2FkZGxlYnJvd246OTEyNzE4NyxzYWxtb246MTY0MTY4ODIsc2FuZHlicm93bjoxNjAzMjg2NCxzZWFncmVlbjozMDUwMzI3LHNlYXNoZWxsOjE2Nzc0NjM4LHNpZW5uYToxMDUwNjc5NyxzaWx2ZXI6MTI2MzIyNTYsc2t5Ymx1ZTo4OTAwMzMxLHNsYXRlYmx1ZTo2OTcwMDYxLHNsYXRlZ3JheTo3MzcyOTQ0LHNsYXRlZ3JleTo3MzcyOTQ0LHNub3c6MTY3NzU5MzAsc3ByaW5nZ3JlZW46NjU0MDcsc3RlZWxibHVlOjQ2MjA5ODAsdGFuOjEzODA4NzgwLHRlYWw6MzI4OTYsdGhpc3RsZToxNDIwNDg4OCx0b21hdG86MTY3MzcwOTUsdHVycXVvaXNlOjQyNTE4NTYsdmlvbGV0OjE1NjMxMDg2LHdoZWF0OjE2MTEzMzMxLHdoaXRlOjE2Nzc3MjE1LHdoaXRlc21va2U6MTYxMTkyODUseWVsbG93OjE2Nzc2OTYwLHllbGxvd2dyZWVuOjEwMTQ1MDc0fSxybj17aDowLHM6MCxsOjB9LHNuPXtoOjAsczowLGw6MH07ZnVuY3Rpb24gYW4odCxlLG4pe3JldHVybiBuPDAmJihuKz0xKSxuPjEmJihuLT0xKSxuPDEvNj90KzYqKGUtdCkqbjpuPC41P2U6bjwyLzM/dCs2KihlLXQpKigyLzMtbik6dH1mdW5jdGlvbiBvbih0KXtyZXR1cm4gdDwuMDQwNDU/LjA3NzM5OTM4MDgqdDpNYXRoLnBvdyguOTQ3ODY3Mjk4Nip0Ky4wNTIxMzI3MDE0LDIuNCl9ZnVuY3Rpb24gbG4odCl7cmV0dXJuIHQ8LjAwMzEzMDg/MTIuOTIqdDoxLjA1NSpNYXRoLnBvdyh0LC40MTY2NiktLjA1NX1jbGFzcyBjbntjb25zdHJ1Y3Rvcih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJnZvaWQgMD09PW4/dGhpcy5zZXQodCk6dGhpcy5zZXRSR0IodCxlLG4pfXNldCh0KXtyZXR1cm4gdCYmdC5pc0NvbG9yP3RoaXMuY29weSh0KTpcIm51bWJlclwiPT10eXBlb2YgdD90aGlzLnNldEhleCh0KTpcInN0cmluZ1wiPT10eXBlb2YgdCYmdGhpcy5zZXRTdHlsZSh0KSx0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy5yPXQsdGhpcy5nPXQsdGhpcy5iPXQsdGhpc31zZXRIZXgodCl7cmV0dXJuIHQ9TWF0aC5mbG9vcih0KSx0aGlzLnI9KHQ+PjE2JjI1NSkvMjU1LHRoaXMuZz0odD4+OCYyNTUpLzI1NSx0aGlzLmI9KDI1NSZ0KS8yNTUsdGhpc31zZXRSR0IodCxlLG4pe3JldHVybiB0aGlzLnI9dCx0aGlzLmc9ZSx0aGlzLmI9bix0aGlzfXNldEhTTCh0LGUsbil7aWYodD13dCh0LDEpLGU9YnQoZSwwLDEpLG49YnQobiwwLDEpLDA9PT1lKXRoaXMucj10aGlzLmc9dGhpcy5iPW47ZWxzZXtjb25zdCBpPW48PS41P24qKDErZSk6bitlLW4qZSxyPTIqbi1pO3RoaXMucj1hbihyLGksdCsxLzMpLHRoaXMuZz1hbihyLGksdCksdGhpcy5iPWFuKHIsaSx0LTEvMyl9cmV0dXJuIHRoaXN9c2V0U3R5bGUodCl7ZnVuY3Rpb24gZShlKXt2b2lkIDAhPT1lJiZwYXJzZUZsb2F0KGUpPDEmJmNvbnNvbGUud2FybihcIlRIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgXCIrdCtcIiB3aWxsIGJlIGlnbm9yZWQuXCIpfWxldCBuO2lmKG49L14oKD86cmdifGhzbClhPylcXCgoW15cXCldKilcXCkvLmV4ZWModCkpe2xldCB0O2NvbnN0IGk9blsxXSxyPW5bMl07c3dpdGNoKGkpe2Nhc2VcInJnYlwiOmNhc2VcInJnYmFcIjppZih0PS9eXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyhyKSlyZXR1cm4gdGhpcy5yPU1hdGgubWluKDI1NSxwYXJzZUludCh0WzFdLDEwKSkvMjU1LHRoaXMuZz1NYXRoLm1pbigyNTUscGFyc2VJbnQodFsyXSwxMCkpLzI1NSx0aGlzLmI9TWF0aC5taW4oMjU1LHBhcnNlSW50KHRbM10sMTApKS8yNTUsZSh0WzRdKSx0aGlzO2lmKHQ9L15cXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKig/OixcXHMqKFxcZCpcXC4/XFxkKylcXHMqKT8kLy5leGVjKHIpKXJldHVybiB0aGlzLnI9TWF0aC5taW4oMTAwLHBhcnNlSW50KHRbMV0sMTApKS8xMDAsdGhpcy5nPU1hdGgubWluKDEwMCxwYXJzZUludCh0WzJdLDEwKSkvMTAwLHRoaXMuYj1NYXRoLm1pbigxMDAscGFyc2VJbnQodFszXSwxMCkpLzEwMCxlKHRbNF0pLHRoaXM7YnJlYWs7Y2FzZVwiaHNsXCI6Y2FzZVwiaHNsYVwiOmlmKHQ9L15cXHMqKFxcZCpcXC4/XFxkKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMocikpe2NvbnN0IG49cGFyc2VGbG9hdCh0WzFdKS8zNjAsaT1wYXJzZUludCh0WzJdLDEwKS8xMDAscj1wYXJzZUludCh0WzNdLDEwKS8xMDA7cmV0dXJuIGUodFs0XSksdGhpcy5zZXRIU0wobixpLHIpfX19ZWxzZSBpZihuPS9eXFwjKFtBLUZhLWZcXGRdKykkLy5leGVjKHQpKXtjb25zdCB0PW5bMV0sZT10Lmxlbmd0aDtpZigzPT09ZSlyZXR1cm4gdGhpcy5yPXBhcnNlSW50KHQuY2hhckF0KDApK3QuY2hhckF0KDApLDE2KS8yNTUsdGhpcy5nPXBhcnNlSW50KHQuY2hhckF0KDEpK3QuY2hhckF0KDEpLDE2KS8yNTUsdGhpcy5iPXBhcnNlSW50KHQuY2hhckF0KDIpK3QuY2hhckF0KDIpLDE2KS8yNTUsdGhpcztpZig2PT09ZSlyZXR1cm4gdGhpcy5yPXBhcnNlSW50KHQuY2hhckF0KDApK3QuY2hhckF0KDEpLDE2KS8yNTUsdGhpcy5nPXBhcnNlSW50KHQuY2hhckF0KDIpK3QuY2hhckF0KDMpLDE2KS8yNTUsdGhpcy5iPXBhcnNlSW50KHQuY2hhckF0KDQpK3QuY2hhckF0KDUpLDE2KS8yNTUsdGhpc31yZXR1cm4gdCYmdC5sZW5ndGg+MD90aGlzLnNldENvbG9yTmFtZSh0KTp0aGlzfXNldENvbG9yTmFtZSh0KXtjb25zdCBlPW5uW3QudG9Mb3dlckNhc2UoKV07cmV0dXJuIHZvaWQgMCE9PWU/dGhpcy5zZXRIZXgoZSk6Y29uc29sZS53YXJuKFwiVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgXCIrdCksdGhpc31jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnIsdGhpcy5nLHRoaXMuYil9Y29weSh0KXtyZXR1cm4gdGhpcy5yPXQucix0aGlzLmc9dC5nLHRoaXMuYj10LmIsdGhpc31jb3B5R2FtbWFUb0xpbmVhcih0LGU9Mil7cmV0dXJuIHRoaXMucj1NYXRoLnBvdyh0LnIsZSksdGhpcy5nPU1hdGgucG93KHQuZyxlKSx0aGlzLmI9TWF0aC5wb3codC5iLGUpLHRoaXN9Y29weUxpbmVhclRvR2FtbWEodCxlPTIpe2NvbnN0IG49ZT4wPzEvZToxO3JldHVybiB0aGlzLnI9TWF0aC5wb3codC5yLG4pLHRoaXMuZz1NYXRoLnBvdyh0LmcsbiksdGhpcy5iPU1hdGgucG93KHQuYixuKSx0aGlzfWNvbnZlcnRHYW1tYVRvTGluZWFyKHQpe3JldHVybiB0aGlzLmNvcHlHYW1tYVRvTGluZWFyKHRoaXMsdCksdGhpc31jb252ZXJ0TGluZWFyVG9HYW1tYSh0KXtyZXR1cm4gdGhpcy5jb3B5TGluZWFyVG9HYW1tYSh0aGlzLHQpLHRoaXN9Y29weVNSR0JUb0xpbmVhcih0KXtyZXR1cm4gdGhpcy5yPW9uKHQuciksdGhpcy5nPW9uKHQuZyksdGhpcy5iPW9uKHQuYiksdGhpc31jb3B5TGluZWFyVG9TUkdCKHQpe3JldHVybiB0aGlzLnI9bG4odC5yKSx0aGlzLmc9bG4odC5nKSx0aGlzLmI9bG4odC5iKSx0aGlzfWNvbnZlcnRTUkdCVG9MaW5lYXIoKXtyZXR1cm4gdGhpcy5jb3B5U1JHQlRvTGluZWFyKHRoaXMpLHRoaXN9Y29udmVydExpbmVhclRvU1JHQigpe3JldHVybiB0aGlzLmNvcHlMaW5lYXJUb1NSR0IodGhpcyksdGhpc31nZXRIZXgoKXtyZXR1cm4gMjU1KnRoaXMucjw8MTZeMjU1KnRoaXMuZzw8OF4yNTUqdGhpcy5iPDwwfWdldEhleFN0cmluZygpe3JldHVybihcIjAwMDAwMFwiK3RoaXMuZ2V0SGV4KCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNil9Z2V0SFNMKHQpe2NvbnN0IGU9dGhpcy5yLG49dGhpcy5nLGk9dGhpcy5iLHI9TWF0aC5tYXgoZSxuLGkpLHM9TWF0aC5taW4oZSxuLGkpO2xldCBhLG87Y29uc3QgbD0ocytyKS8yO2lmKHM9PT1yKWE9MCxvPTA7ZWxzZXtjb25zdCB0PXItcztzd2l0Y2gobz1sPD0uNT90LyhyK3MpOnQvKDItci1zKSxyKXtjYXNlIGU6YT0obi1pKS90KyhuPGk/NjowKTticmVhaztjYXNlIG46YT0oaS1lKS90KzI7YnJlYWs7Y2FzZSBpOmE9KGUtbikvdCs0fWEvPTZ9cmV0dXJuIHQuaD1hLHQucz1vLHQubD1sLHR9Z2V0U3R5bGUoKXtyZXR1cm5cInJnYihcIisoMjU1KnRoaXMucnwwKStcIixcIisoMjU1KnRoaXMuZ3wwKStcIixcIisoMjU1KnRoaXMuYnwwKStcIilcIn1vZmZzZXRIU0wodCxlLG4pe3JldHVybiB0aGlzLmdldEhTTChybikscm4uaCs9dCxybi5zKz1lLHJuLmwrPW4sdGhpcy5zZXRIU0wocm4uaCxybi5zLHJuLmwpLHRoaXN9YWRkKHQpe3JldHVybiB0aGlzLnIrPXQucix0aGlzLmcrPXQuZyx0aGlzLmIrPXQuYix0aGlzfWFkZENvbG9ycyh0LGUpe3JldHVybiB0aGlzLnI9dC5yK2Uucix0aGlzLmc9dC5nK2UuZyx0aGlzLmI9dC5iK2UuYix0aGlzfWFkZFNjYWxhcih0KXtyZXR1cm4gdGhpcy5yKz10LHRoaXMuZys9dCx0aGlzLmIrPXQsdGhpc31zdWIodCl7cmV0dXJuIHRoaXMucj1NYXRoLm1heCgwLHRoaXMuci10LnIpLHRoaXMuZz1NYXRoLm1heCgwLHRoaXMuZy10LmcpLHRoaXMuYj1NYXRoLm1heCgwLHRoaXMuYi10LmIpLHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMucio9dC5yLHRoaXMuZyo9dC5nLHRoaXMuYio9dC5iLHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7cmV0dXJuIHRoaXMucio9dCx0aGlzLmcqPXQsdGhpcy5iKj10LHRoaXN9bGVycCh0LGUpe3JldHVybiB0aGlzLnIrPSh0LnItdGhpcy5yKSplLHRoaXMuZys9KHQuZy10aGlzLmcpKmUsdGhpcy5iKz0odC5iLXRoaXMuYikqZSx0aGlzfWxlcnBDb2xvcnModCxlLG4pe3JldHVybiB0aGlzLnI9dC5yKyhlLnItdC5yKSpuLHRoaXMuZz10LmcrKGUuZy10LmcpKm4sdGhpcy5iPXQuYisoZS5iLXQuYikqbix0aGlzfWxlcnBIU0wodCxlKXt0aGlzLmdldEhTTChybiksdC5nZXRIU0woc24pO2NvbnN0IG49X3Qocm4uaCxzbi5oLGUpLGk9X3Qocm4ucyxzbi5zLGUpLHI9X3Qocm4ubCxzbi5sLGUpO3JldHVybiB0aGlzLnNldEhTTChuLGksciksdGhpc31lcXVhbHModCl7cmV0dXJuIHQucj09PXRoaXMuciYmdC5nPT09dGhpcy5nJiZ0LmI9PT10aGlzLmJ9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy5yPXRbZV0sdGhpcy5nPXRbZSsxXSx0aGlzLmI9dFtlKzJdLHRoaXN9dG9BcnJheSh0PVtdLGU9MCl7cmV0dXJuIHRbZV09dGhpcy5yLHRbZSsxXT10aGlzLmcsdFtlKzJdPXRoaXMuYix0fWZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKXtyZXR1cm4gdGhpcy5yPXQuZ2V0WChlKSx0aGlzLmc9dC5nZXRZKGUpLHRoaXMuYj10LmdldFooZSksITA9PT10Lm5vcm1hbGl6ZWQmJih0aGlzLnIvPTI1NSx0aGlzLmcvPTI1NSx0aGlzLmIvPTI1NSksdGhpc310b0pTT04oKXtyZXR1cm4gdGhpcy5nZXRIZXgoKX19Y24uTkFNRVM9bm4sY24ucHJvdG90eXBlLmlzQ29sb3I9ITAsY24ucHJvdG90eXBlLnI9MSxjbi5wcm90b3R5cGUuZz0xLGNuLnByb3RvdHlwZS5iPTE7Y2xhc3MgaG4gZXh0ZW5kcyBlbntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMudHlwZT1cIk1lc2hCYXNpY01hdGVyaWFsXCIsdGhpcy5jb2xvcj1uZXcgY24oMTY3NzcyMTUpLHRoaXMubWFwPW51bGwsdGhpcy5saWdodE1hcD1udWxsLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9MSx0aGlzLmFvTWFwPW51bGwsdGhpcy5hb01hcEludGVuc2l0eT0xLHRoaXMuc3BlY3VsYXJNYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5lbnZNYXA9bnVsbCx0aGlzLmNvbWJpbmU9MCx0aGlzLnJlZmxlY3Rpdml0eT0xLHRoaXMucmVmcmFjdGlvblJhdGlvPS45OCx0aGlzLndpcmVmcmFtZT0hMSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xLHRoaXMud2lyZWZyYW1lTGluZWNhcD1cInJvdW5kXCIsdGhpcy53aXJlZnJhbWVMaW5lam9pbj1cInJvdW5kXCIsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5tYXA9dC5tYXAsdGhpcy5saWdodE1hcD10LmxpZ2h0TWFwLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9dC5saWdodE1hcEludGVuc2l0eSx0aGlzLmFvTWFwPXQuYW9NYXAsdGhpcy5hb01hcEludGVuc2l0eT10LmFvTWFwSW50ZW5zaXR5LHRoaXMuc3BlY3VsYXJNYXA9dC5zcGVjdWxhck1hcCx0aGlzLmFscGhhTWFwPXQuYWxwaGFNYXAsdGhpcy5lbnZNYXA9dC5lbnZNYXAsdGhpcy5jb21iaW5lPXQuY29tYmluZSx0aGlzLnJlZmxlY3Rpdml0eT10LnJlZmxlY3Rpdml0eSx0aGlzLnJlZnJhY3Rpb25SYXRpbz10LnJlZnJhY3Rpb25SYXRpbyx0aGlzLndpcmVmcmFtZT10LndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD10LndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzLndpcmVmcmFtZUxpbmVjYXA9dC53aXJlZnJhbWVMaW5lY2FwLHRoaXMud2lyZWZyYW1lTGluZWpvaW49dC53aXJlZnJhbWVMaW5lam9pbix0aGlzfX1obi5wcm90b3R5cGUuaXNNZXNoQmFzaWNNYXRlcmlhbD0hMDtjb25zdCB1bj1uZXcgQnQsZG49bmV3IEF0O2NsYXNzIHBue2NvbnN0cnVjdG9yKHQsZSxuKXtpZihBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LlwiKTt0aGlzLm5hbWU9XCJcIix0aGlzLmFycmF5PXQsdGhpcy5pdGVtU2l6ZT1lLHRoaXMuY291bnQ9dm9pZCAwIT09dD90Lmxlbmd0aC9lOjAsdGhpcy5ub3JtYWxpemVkPSEwPT09bix0aGlzLnVzYWdlPTM1MDQ0LHRoaXMudXBkYXRlUmFuZ2U9e29mZnNldDowLGNvdW50Oi0xfSx0aGlzLnZlcnNpb249MH1vblVwbG9hZENhbGxiYWNrKCl7fXNldCBuZWVkc1VwZGF0ZSh0KXshMD09PXQmJnRoaXMudmVyc2lvbisrfXNldFVzYWdlKHQpe3JldHVybiB0aGlzLnVzYWdlPXQsdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLm5hbWU9dC5uYW1lLHRoaXMuYXJyYXk9bmV3IHQuYXJyYXkuY29uc3RydWN0b3IodC5hcnJheSksdGhpcy5pdGVtU2l6ZT10Lml0ZW1TaXplLHRoaXMuY291bnQ9dC5jb3VudCx0aGlzLm5vcm1hbGl6ZWQ9dC5ub3JtYWxpemVkLHRoaXMudXNhZ2U9dC51c2FnZSx0aGlzfWNvcHlBdCh0LGUsbil7dCo9dGhpcy5pdGVtU2l6ZSxuKj1lLml0ZW1TaXplO2ZvcihsZXQgaT0wLHI9dGhpcy5pdGVtU2l6ZTtpPHI7aSsrKXRoaXMuYXJyYXlbdCtpXT1lLmFycmF5W24raV07cmV0dXJuIHRoaXN9Y29weUFycmF5KHQpe3JldHVybiB0aGlzLmFycmF5LnNldCh0KSx0aGlzfWNvcHlDb2xvcnNBcnJheSh0KXtjb25zdCBlPXRoaXMuYXJyYXk7bGV0IG49MDtmb3IobGV0IGk9MCxyPXQubGVuZ3RoO2k8cjtpKyspe2xldCByPXRbaV07dm9pZCAwPT09ciYmKGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkXCIsaSkscj1uZXcgY24pLGVbbisrXT1yLnIsZVtuKytdPXIuZyxlW24rK109ci5ifXJldHVybiB0aGlzfWNvcHlWZWN0b3Iyc0FycmF5KHQpe2NvbnN0IGU9dGhpcy5hcnJheTtsZXQgbj0wO2ZvcihsZXQgaT0wLHI9dC5sZW5ndGg7aTxyO2krKyl7bGV0IHI9dFtpXTt2b2lkIDA9PT1yJiYoY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWRcIixpKSxyPW5ldyBBdCksZVtuKytdPXIueCxlW24rK109ci55fXJldHVybiB0aGlzfWNvcHlWZWN0b3Izc0FycmF5KHQpe2NvbnN0IGU9dGhpcy5hcnJheTtsZXQgbj0wO2ZvcihsZXQgaT0wLHI9dC5sZW5ndGg7aTxyO2krKyl7bGV0IHI9dFtpXTt2b2lkIDA9PT1yJiYoY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWRcIixpKSxyPW5ldyBCdCksZVtuKytdPXIueCxlW24rK109ci55LGVbbisrXT1yLnp9cmV0dXJuIHRoaXN9Y29weVZlY3RvcjRzQXJyYXkodCl7Y29uc3QgZT10aGlzLmFycmF5O2xldCBuPTA7Zm9yKGxldCBpPTAscj10Lmxlbmd0aDtpPHI7aSsrKXtsZXQgcj10W2ldO3ZvaWQgMD09PXImJihjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZFwiLGkpLHI9bmV3IE90KSxlW24rK109ci54LGVbbisrXT1yLnksZVtuKytdPXIueixlW24rK109ci53fXJldHVybiB0aGlzfWFwcGx5TWF0cml4Myh0KXtpZigyPT09dGhpcy5pdGVtU2l6ZSlmb3IobGV0IGU9MCxuPXRoaXMuY291bnQ7ZTxuO2UrKylkbi5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsZSksZG4uYXBwbHlNYXRyaXgzKHQpLHRoaXMuc2V0WFkoZSxkbi54LGRuLnkpO2Vsc2UgaWYoMz09PXRoaXMuaXRlbVNpemUpZm9yKGxldCBlPTAsbj10aGlzLmNvdW50O2U8bjtlKyspdW4uZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLHVuLmFwcGx5TWF0cml4Myh0KSx0aGlzLnNldFhZWihlLHVuLngsdW4ueSx1bi56KTtyZXR1cm4gdGhpc31hcHBseU1hdHJpeDQodCl7Zm9yKGxldCBlPTAsbj10aGlzLmNvdW50O2U8bjtlKyspdW4ueD10aGlzLmdldFgoZSksdW4ueT10aGlzLmdldFkoZSksdW4uej10aGlzLmdldFooZSksdW4uYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0WFlaKGUsdW4ueCx1bi55LHVuLnopO3JldHVybiB0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KHQpe2ZvcihsZXQgZT0wLG49dGhpcy5jb3VudDtlPG47ZSsrKXVuLng9dGhpcy5nZXRYKGUpLHVuLnk9dGhpcy5nZXRZKGUpLHVuLno9dGhpcy5nZXRaKGUpLHVuLmFwcGx5Tm9ybWFsTWF0cml4KHQpLHRoaXMuc2V0WFlaKGUsdW4ueCx1bi55LHVuLnopO3JldHVybiB0aGlzfXRyYW5zZm9ybURpcmVjdGlvbih0KXtmb3IobGV0IGU9MCxuPXRoaXMuY291bnQ7ZTxuO2UrKyl1bi54PXRoaXMuZ2V0WChlKSx1bi55PXRoaXMuZ2V0WShlKSx1bi56PXRoaXMuZ2V0WihlKSx1bi50cmFuc2Zvcm1EaXJlY3Rpb24odCksdGhpcy5zZXRYWVooZSx1bi54LHVuLnksdW4ueik7cmV0dXJuIHRoaXN9c2V0KHQsZT0wKXtyZXR1cm4gdGhpcy5hcnJheS5zZXQodCxlKSx0aGlzfWdldFgodCl7cmV0dXJuIHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplXX1zZXRYKHQsZSl7cmV0dXJuIHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplXT1lLHRoaXN9Z2V0WSh0KXtyZXR1cm4gdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrMV19c2V0WSh0LGUpe3JldHVybiB0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsxXT1lLHRoaXN9Z2V0Wih0KXtyZXR1cm4gdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrMl19c2V0Wih0LGUpe3JldHVybiB0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsyXT1lLHRoaXN9Z2V0Vyh0KXtyZXR1cm4gdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrM119c2V0Vyh0LGUpe3JldHVybiB0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSszXT1lLHRoaXN9c2V0WFkodCxlLG4pe3JldHVybiB0Kj10aGlzLml0ZW1TaXplLHRoaXMuYXJyYXlbdCswXT1lLHRoaXMuYXJyYXlbdCsxXT1uLHRoaXN9c2V0WFlaKHQsZSxuLGkpe3JldHVybiB0Kj10aGlzLml0ZW1TaXplLHRoaXMuYXJyYXlbdCswXT1lLHRoaXMuYXJyYXlbdCsxXT1uLHRoaXMuYXJyYXlbdCsyXT1pLHRoaXN9c2V0WFlaVyh0LGUsbixpLHIpe3JldHVybiB0Kj10aGlzLml0ZW1TaXplLHRoaXMuYXJyYXlbdCswXT1lLHRoaXMuYXJyYXlbdCsxXT1uLHRoaXMuYXJyYXlbdCsyXT1pLHRoaXMuYXJyYXlbdCszXT1yLHRoaXN9b25VcGxvYWQodCl7cmV0dXJuIHRoaXMub25VcGxvYWRDYWxsYmFjaz10LHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hcnJheSx0aGlzLml0ZW1TaXplKS5jb3B5KHRoaXMpfXRvSlNPTigpe2NvbnN0IHQ9e2l0ZW1TaXplOnRoaXMuaXRlbVNpemUsdHlwZTp0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsYXJyYXk6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5hcnJheSksbm9ybWFsaXplZDp0aGlzLm5vcm1hbGl6ZWR9O3JldHVyblwiXCIhPT10aGlzLm5hbWUmJih0Lm5hbWU9dGhpcy5uYW1lKSwzNTA0NCE9PXRoaXMudXNhZ2UmJih0LnVzYWdlPXRoaXMudXNhZ2UpLDA9PT10aGlzLnVwZGF0ZVJhbmdlLm9mZnNldCYmLTE9PT10aGlzLnVwZGF0ZVJhbmdlLmNvdW50fHwodC51cGRhdGVSYW5nZT10aGlzLnVwZGF0ZVJhbmdlKSx0fX1wbi5wcm90b3R5cGUuaXNCdWZmZXJBdHRyaWJ1dGU9ITA7Y2xhc3MgbW4gZXh0ZW5kcyBwbntjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIobmV3IFVpbnQxNkFycmF5KHQpLGUsbil9fWNsYXNzIGZuIGV4dGVuZHMgcG57Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKG5ldyBVaW50MzJBcnJheSh0KSxlLG4pfX0oY2xhc3MgZXh0ZW5kcyBwbntjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIobmV3IFVpbnQxNkFycmF5KHQpLGUsbil9fSkucHJvdG90eXBlLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZT0hMDtjbGFzcyBnbiBleHRlbmRzIHBue2NvbnN0cnVjdG9yKHQsZSxuKXtzdXBlcihuZXcgRmxvYXQzMkFycmF5KHQpLGUsbil9fWxldCB2bj0wO2NvbnN0IHluPW5ldyB2ZSx4bj1uZXcgVmUsYm49bmV3IEJ0LHduPW5ldyBHdCxfbj1uZXcgR3QsTW49bmV3IEJ0O2NsYXNzIFNuIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiaWRcIix7dmFsdWU6dm4rK30pLHRoaXMudXVpZD14dCgpLHRoaXMubmFtZT1cIlwiLHRoaXMudHlwZT1cIkJ1ZmZlckdlb21ldHJ5XCIsdGhpcy5pbmRleD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSExLHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGwsdGhpcy5kcmF3UmFuZ2U9e3N0YXJ0OjAsY291bnQ6MS8wfSx0aGlzLnVzZXJEYXRhPXt9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXh9c2V0SW5kZXgodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dGhpcy5pbmRleD1uZXcoUnQodCk+NjU1MzU/Zm46bW4pKHQsMSk6dGhpcy5pbmRleD10LHRoaXN9Z2V0QXR0cmlidXRlKHQpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF19c2V0QXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1t0XT1lLHRoaXN9ZGVsZXRlQXR0cmlidXRlKHQpe3JldHVybiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW3RdLHRoaXN9aGFzQXR0cmlidXRlKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmF0dHJpYnV0ZXNbdF19YWRkR3JvdXAodCxlLG49MCl7dGhpcy5ncm91cHMucHVzaCh7c3RhcnQ6dCxjb3VudDplLG1hdGVyaWFsSW5kZXg6bn0pfWNsZWFyR3JvdXBzKCl7dGhpcy5ncm91cHM9W119c2V0RHJhd1JhbmdlKHQsZSl7dGhpcy5kcmF3UmFuZ2Uuc3RhcnQ9dCx0aGlzLmRyYXdSYW5nZS5jb3VudD1lfWFwcGx5TWF0cml4NCh0KXtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjt2b2lkIDAhPT1lJiYoZS5hcHBseU1hdHJpeDQodCksZS5uZWVkc1VwZGF0ZT0hMCk7Y29uc3Qgbj10aGlzLmF0dHJpYnV0ZXMubm9ybWFsO2lmKHZvaWQgMCE9PW4pe2NvbnN0IGU9KG5ldyBMdCkuZ2V0Tm9ybWFsTWF0cml4KHQpO24uYXBwbHlOb3JtYWxNYXRyaXgoZSksbi5uZWVkc1VwZGF0ZT0hMH1jb25zdCBpPXRoaXMuYXR0cmlidXRlcy50YW5nZW50O3JldHVybiB2b2lkIDAhPT1pJiYoaS50cmFuc2Zvcm1EaXJlY3Rpb24odCksaS5uZWVkc1VwZGF0ZT0hMCksbnVsbCE9PXRoaXMuYm91bmRpbmdCb3gmJnRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksbnVsbCE9PXRoaXMuYm91bmRpbmdTcGhlcmUmJnRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksdGhpc31hcHBseVF1YXRlcm5pb24odCl7cmV0dXJuIHluLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpLHRoaXMuYXBwbHlNYXRyaXg0KHluKSx0aGlzfXJvdGF0ZVgodCl7cmV0dXJuIHluLm1ha2VSb3RhdGlvblgodCksdGhpcy5hcHBseU1hdHJpeDQoeW4pLHRoaXN9cm90YXRlWSh0KXtyZXR1cm4geW4ubWFrZVJvdGF0aW9uWSh0KSx0aGlzLmFwcGx5TWF0cml4NCh5biksdGhpc31yb3RhdGVaKHQpe3JldHVybiB5bi5tYWtlUm90YXRpb25aKHQpLHRoaXMuYXBwbHlNYXRyaXg0KHluKSx0aGlzfXRyYW5zbGF0ZSh0LGUsbil7cmV0dXJuIHluLm1ha2VUcmFuc2xhdGlvbih0LGUsbiksdGhpcy5hcHBseU1hdHJpeDQoeW4pLHRoaXN9c2NhbGUodCxlLG4pe3JldHVybiB5bi5tYWtlU2NhbGUodCxlLG4pLHRoaXMuYXBwbHlNYXRyaXg0KHluKSx0aGlzfWxvb2tBdCh0KXtyZXR1cm4geG4ubG9va0F0KHQpLHhuLnVwZGF0ZU1hdHJpeCgpLHRoaXMuYXBwbHlNYXRyaXg0KHhuLm1hdHJpeCksdGhpc31jZW50ZXIoKXtyZXR1cm4gdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihibikubmVnYXRlKCksdGhpcy50cmFuc2xhdGUoYm4ueCxibi55LGJuLnopLHRoaXN9c2V0RnJvbVBvaW50cyh0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLGk9dC5sZW5ndGg7bjxpO24rKyl7Y29uc3QgaT10W25dO2UucHVzaChpLngsaS55LGkuenx8MCl9cmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgZ24oZSwzKSksdGhpc31jb21wdXRlQm91bmRpbmdCb3goKXtudWxsPT09dGhpcy5ib3VuZGluZ0JveCYmKHRoaXMuYm91bmRpbmdCb3g9bmV3IEd0KTtjb25zdCB0PXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbixlPXRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO2lmKHQmJnQuaXNHTEJ1ZmZlckF0dHJpYnV0ZSlyZXR1cm4gY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIGJveC4gQWx0ZXJuYXRpdmVseSBzZXQgXCJtZXNoLmZydXN0dW1DdWxsZWRcIiB0byBcImZhbHNlXCIuJyx0aGlzKSx2b2lkIHRoaXMuYm91bmRpbmdCb3guc2V0KG5ldyBCdCgtMS8wLC0xLzAsLTEvMCksbmV3IEJ0KDEvMCwxLzAsMS8wKSk7aWYodm9pZCAwIT09dCl7aWYodGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHQpLGUpZm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0PG47dCsrKXtjb25zdCBuPWVbdF07d24uc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShuKSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPyhNbi5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWluLHduLm1pbiksdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KE1uKSxNbi5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWF4LHduLm1heCksdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KE1uKSk6KHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCh3bi5taW4pLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCh3bi5tYXgpKX19ZWxzZSB0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpOyhpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi54KXx8aXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueSl8fGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnopKSYmY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsdGhpcyl9Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl7bnVsbD09PXRoaXMuYm91bmRpbmdTcGhlcmUmJih0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBsZSk7Y29uc3QgdD10aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sZT10aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtpZih0JiZ0LmlzR0xCdWZmZXJBdHRyaWJ1dGUpcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsdGhpcyksdm9pZCB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgQnQsMS8wKTtpZih0KXtjb25zdCBuPXRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO2lmKHduLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUodCksZSlmb3IobGV0IHQ9MCxuPWUubGVuZ3RoO3Q8bjt0Kyspe2NvbnN0IG49ZVt0XTtfbi5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKG4pLHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU/KE1uLmFkZFZlY3RvcnMod24ubWluLF9uLm1pbiksd24uZXhwYW5kQnlQb2ludChNbiksTW4uYWRkVmVjdG9ycyh3bi5tYXgsX24ubWF4KSx3bi5leHBhbmRCeVBvaW50KE1uKSk6KHduLmV4cGFuZEJ5UG9pbnQoX24ubWluKSx3bi5leHBhbmRCeVBvaW50KF9uLm1heCkpfXduLmdldENlbnRlcihuKTtsZXQgaT0wO2ZvcihsZXQgZT0wLHI9dC5jb3VudDtlPHI7ZSsrKU1uLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKSxpPU1hdGgubWF4KGksbi5kaXN0YW5jZVRvU3F1YXJlZChNbikpO2lmKGUpZm9yKGxldCByPTAscz1lLmxlbmd0aDtyPHM7cisrKXtjb25zdCBzPWVbcl0sYT10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2ZvcihsZXQgZT0wLHI9cy5jb3VudDtlPHI7ZSsrKU1uLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxlKSxhJiYoYm4uZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpLE1uLmFkZChibikpLGk9TWF0aC5tYXgoaSxuLmRpc3RhbmNlVG9TcXVhcmVkKE1uKSl9dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM9TWF0aC5zcXJ0KGkpLGlzTmFOKHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzKSYmY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX19Y29tcHV0ZVRhbmdlbnRzKCl7Y29uc3QgdD10aGlzLmluZGV4LGU9dGhpcy5hdHRyaWJ1dGVzO2lmKG51bGw9PT10fHx2b2lkIDA9PT1lLnBvc2l0aW9ufHx2b2lkIDA9PT1lLm5vcm1hbHx8dm9pZCAwPT09ZS51dilyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpXCIpO2NvbnN0IG49dC5hcnJheSxpPWUucG9zaXRpb24uYXJyYXkscj1lLm5vcm1hbC5hcnJheSxzPWUudXYuYXJyYXksYT1pLmxlbmd0aC8zO3ZvaWQgMD09PWUudGFuZ2VudCYmdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0YW5nZW50XCIsbmV3IHBuKG5ldyBGbG9hdDMyQXJyYXkoNCphKSw0KSk7Y29uc3Qgbz1lLnRhbmdlbnQuYXJyYXksbD1bXSxjPVtdO2ZvcihsZXQgdD0wO3Q8YTt0KyspbFt0XT1uZXcgQnQsY1t0XT1uZXcgQnQ7Y29uc3QgaD1uZXcgQnQsdT1uZXcgQnQsZD1uZXcgQnQscD1uZXcgQXQsbT1uZXcgQXQsZj1uZXcgQXQsZz1uZXcgQnQsdj1uZXcgQnQ7ZnVuY3Rpb24geSh0LGUsbil7aC5mcm9tQXJyYXkoaSwzKnQpLHUuZnJvbUFycmF5KGksMyplKSxkLmZyb21BcnJheShpLDMqbikscC5mcm9tQXJyYXkocywyKnQpLG0uZnJvbUFycmF5KHMsMiplKSxmLmZyb21BcnJheShzLDIqbiksdS5zdWIoaCksZC5zdWIoaCksbS5zdWIocCksZi5zdWIocCk7Y29uc3Qgcj0xLyhtLngqZi55LWYueCptLnkpO2lzRmluaXRlKHIpJiYoZy5jb3B5KHUpLm11bHRpcGx5U2NhbGFyKGYueSkuYWRkU2NhbGVkVmVjdG9yKGQsLW0ueSkubXVsdGlwbHlTY2FsYXIociksdi5jb3B5KGQpLm11bHRpcGx5U2NhbGFyKG0ueCkuYWRkU2NhbGVkVmVjdG9yKHUsLWYueCkubXVsdGlwbHlTY2FsYXIociksbFt0XS5hZGQoZyksbFtlXS5hZGQoZyksbFtuXS5hZGQoZyksY1t0XS5hZGQodiksY1tlXS5hZGQodiksY1tuXS5hZGQodikpfWxldCB4PXRoaXMuZ3JvdXBzOzA9PT14Lmxlbmd0aCYmKHg9W3tzdGFydDowLGNvdW50Om4ubGVuZ3RofV0pO2ZvcihsZXQgdD0wLGU9eC5sZW5ndGg7dDxlOysrdCl7Y29uc3QgZT14W3RdLGk9ZS5zdGFydDtmb3IobGV0IHQ9aSxyPWkrZS5jb3VudDt0PHI7dCs9Myl5KG5bdCswXSxuW3QrMV0sblt0KzJdKX1jb25zdCBiPW5ldyBCdCx3PW5ldyBCdCxfPW5ldyBCdCxNPW5ldyBCdDtmdW5jdGlvbiBTKHQpe18uZnJvbUFycmF5KHIsMyp0KSxNLmNvcHkoXyk7Y29uc3QgZT1sW3RdO2IuY29weShlKSxiLnN1YihfLm11bHRpcGx5U2NhbGFyKF8uZG90KGUpKSkubm9ybWFsaXplKCksdy5jcm9zc1ZlY3RvcnMoTSxlKTtjb25zdCBuPXcuZG90KGNbdF0pPDA/LTE6MTtvWzQqdF09Yi54LG9bNCp0KzFdPWIueSxvWzQqdCsyXT1iLnosb1s0KnQrM109bn1mb3IobGV0IHQ9MCxlPXgubGVuZ3RoO3Q8ZTsrK3Qpe2NvbnN0IGU9eFt0XSxpPWUuc3RhcnQ7Zm9yKGxldCB0PWkscj1pK2UuY291bnQ7dDxyO3QrPTMpUyhuW3QrMF0pLFMoblt0KzFdKSxTKG5bdCsyXSl9fWNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCl7Y29uc3QgdD10aGlzLmluZGV4LGU9dGhpcy5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtpZih2b2lkIDAhPT1lKXtsZXQgbj10aGlzLmdldEF0dHJpYnV0ZShcIm5vcm1hbFwiKTtpZih2b2lkIDA9PT1uKW49bmV3IHBuKG5ldyBGbG9hdDMyQXJyYXkoMyplLmNvdW50KSwzKSx0aGlzLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLG4pO2Vsc2UgZm9yKGxldCB0PTAsZT1uLmNvdW50O3Q8ZTt0Kyspbi5zZXRYWVoodCwwLDAsMCk7Y29uc3QgaT1uZXcgQnQscj1uZXcgQnQscz1uZXcgQnQsYT1uZXcgQnQsbz1uZXcgQnQsbD1uZXcgQnQsYz1uZXcgQnQsaD1uZXcgQnQ7aWYodClmb3IobGV0IHU9MCxkPXQuY291bnQ7dTxkO3UrPTMpe2NvbnN0IGQ9dC5nZXRYKHUrMCkscD10LmdldFgodSsxKSxtPXQuZ2V0WCh1KzIpO2kuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGQpLHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHApLHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLG0pLGMuc3ViVmVjdG9ycyhzLHIpLGguc3ViVmVjdG9ycyhpLHIpLGMuY3Jvc3MoaCksYS5mcm9tQnVmZmVyQXR0cmlidXRlKG4sZCksby5mcm9tQnVmZmVyQXR0cmlidXRlKG4scCksbC5mcm9tQnVmZmVyQXR0cmlidXRlKG4sbSksYS5hZGQoYyksby5hZGQoYyksbC5hZGQoYyksbi5zZXRYWVooZCxhLngsYS55LGEueiksbi5zZXRYWVoocCxvLngsby55LG8ueiksbi5zZXRYWVoobSxsLngsbC55LGwueil9ZWxzZSBmb3IobGV0IHQ9MCxhPWUuY291bnQ7dDxhO3QrPTMpaS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsdCswKSxyLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSx0KzEpLHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQrMiksYy5zdWJWZWN0b3JzKHMsciksaC5zdWJWZWN0b3JzKGksciksYy5jcm9zcyhoKSxuLnNldFhZWih0KzAsYy54LGMueSxjLnopLG4uc2V0WFlaKHQrMSxjLngsYy55LGMueiksbi5zZXRYWVoodCsyLGMueCxjLnksYy56KTt0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKSxuLm5lZWRzVXBkYXRlPSEwfX1tZXJnZSh0LGUpe2lmKCF0fHwhdC5pc0J1ZmZlckdlb21ldHJ5KXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkuXCIsdCk7dm9pZCAwPT09ZSYmKGU9MCxjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBPdmVyd3JpdGluZyBvcmlnaW5hbCBnZW9tZXRyeSwgc3RhcnRpbmcgYXQgb2Zmc2V0PTAuIFVzZSBCdWZmZXJHZW9tZXRyeVV0aWxzLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZvciBsb3NzbGVzcyBtZXJnZS5cIikpO2NvbnN0IG49dGhpcy5hdHRyaWJ1dGVzO2Zvcihjb25zdCBpIGluIG4pe2lmKHZvaWQgMD09PXQuYXR0cmlidXRlc1tpXSljb250aW51ZTtjb25zdCByPW5baV0uYXJyYXkscz10LmF0dHJpYnV0ZXNbaV0sYT1zLmFycmF5LG89cy5pdGVtU2l6ZSplLGw9TWF0aC5taW4oYS5sZW5ndGgsci5sZW5ndGgtbyk7Zm9yKGxldCB0PTAsZT1vO3Q8bDt0KyssZSsrKXJbZV09YVt0XX1yZXR1cm4gdGhpc31ub3JtYWxpemVOb3JtYWxzKCl7Y29uc3QgdD10aGlzLmF0dHJpYnV0ZXMubm9ybWFsO2ZvcihsZXQgZT0wLG49dC5jb3VudDtlPG47ZSsrKU1uLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKSxNbi5ub3JtYWxpemUoKSx0LnNldFhZWihlLE1uLngsTW4ueSxNbi56KX10b05vbkluZGV4ZWQoKXtmdW5jdGlvbiB0KHQsZSl7Y29uc3Qgbj10LmFycmF5LGk9dC5pdGVtU2l6ZSxyPXQubm9ybWFsaXplZCxzPW5ldyBuLmNvbnN0cnVjdG9yKGUubGVuZ3RoKmkpO2xldCBhPTAsbz0wO2ZvcihsZXQgcj0wLGw9ZS5sZW5ndGg7cjxsO3IrKyl7YT10LmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU/ZVtyXSp0LmRhdGEuc3RyaWRlK3Qub2Zmc2V0OmVbcl0qaTtmb3IobGV0IHQ9MDt0PGk7dCsrKXNbbysrXT1uW2ErK119cmV0dXJuIG5ldyBwbihzLGkscil9aWYobnVsbD09PXRoaXMuaW5kZXgpcmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLlwiKSx0aGlzO2NvbnN0IGU9bmV3IFNuLG49dGhpcy5pbmRleC5hcnJheSxpPXRoaXMuYXR0cmlidXRlcztmb3IoY29uc3QgciBpbiBpKXtjb25zdCBzPXQoaVtyXSxuKTtlLnNldEF0dHJpYnV0ZShyLHMpfWNvbnN0IHI9dGhpcy5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGkgaW4gcil7Y29uc3Qgcz1bXSxhPXJbaV07Zm9yKGxldCBlPTAsaT1hLmxlbmd0aDtlPGk7ZSsrKXtjb25zdCBpPXQoYVtlXSxuKTtzLnB1c2goaSl9ZS5tb3JwaEF0dHJpYnV0ZXNbaV09c31lLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7Y29uc3Qgcz10aGlzLmdyb3Vwcztmb3IobGV0IHQ9MCxuPXMubGVuZ3RoO3Q8bjt0Kyspe2NvbnN0IG49c1t0XTtlLmFkZEdyb3VwKG4uc3RhcnQsbi5jb3VudCxuLm1hdGVyaWFsSW5kZXgpfXJldHVybiBlfXRvSlNPTigpe2NvbnN0IHQ9e21ldGFkYXRhOnt2ZXJzaW9uOjQuNSx0eXBlOlwiQnVmZmVyR2VvbWV0cnlcIixnZW5lcmF0b3I6XCJCdWZmZXJHZW9tZXRyeS50b0pTT05cIn19O2lmKHQudXVpZD10aGlzLnV1aWQsdC50eXBlPXRoaXMudHlwZSxcIlwiIT09dGhpcy5uYW1lJiYodC5uYW1lPXRoaXMubmFtZSksT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJih0LnVzZXJEYXRhPXRoaXMudXNlckRhdGEpLHZvaWQgMCE9PXRoaXMucGFyYW1ldGVycyl7Y29uc3QgZT10aGlzLnBhcmFtZXRlcnM7Zm9yKGNvbnN0IG4gaW4gZSl2b2lkIDAhPT1lW25dJiYodFtuXT1lW25dKTtyZXR1cm4gdH10LmRhdGE9e2F0dHJpYnV0ZXM6e319O2NvbnN0IGU9dGhpcy5pbmRleDtudWxsIT09ZSYmKHQuZGF0YS5pbmRleD17dHlwZTplLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsYXJyYXk6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5hcnJheSl9KTtjb25zdCBuPXRoaXMuYXR0cmlidXRlcztmb3IoY29uc3QgZSBpbiBuKXtjb25zdCBpPW5bZV07dC5kYXRhLmF0dHJpYnV0ZXNbZV09aS50b0pTT04odC5kYXRhKX1jb25zdCBpPXt9O2xldCByPSExO2Zvcihjb25zdCBlIGluIHRoaXMubW9ycGhBdHRyaWJ1dGVzKXtjb25zdCBuPXRoaXMubW9ycGhBdHRyaWJ1dGVzW2VdLHM9W107Zm9yKGxldCBlPTAsaT1uLmxlbmd0aDtlPGk7ZSsrKXtjb25zdCBpPW5bZV07cy5wdXNoKGkudG9KU09OKHQuZGF0YSkpfXMubGVuZ3RoPjAmJihpW2VdPXMscj0hMCl9ciYmKHQuZGF0YS5tb3JwaEF0dHJpYnV0ZXM9aSx0LmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU9dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSk7Y29uc3Qgcz10aGlzLmdyb3VwcztzLmxlbmd0aD4wJiYodC5kYXRhLmdyb3Vwcz1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHMpKSk7Y29uc3QgYT10aGlzLmJvdW5kaW5nU3BoZXJlO3JldHVybiBudWxsIT09YSYmKHQuZGF0YS5ib3VuZGluZ1NwaGVyZT17Y2VudGVyOmEuY2VudGVyLnRvQXJyYXkoKSxyYWRpdXM6YS5yYWRpdXN9KSx0fWNsb25lKCl7cmV0dXJuKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpfWNvcHkodCl7dGhpcy5pbmRleD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLmdyb3Vwcz1bXSx0aGlzLmJvdW5kaW5nQm94PW51bGwsdGhpcy5ib3VuZGluZ1NwaGVyZT1udWxsO2NvbnN0IGU9e307dGhpcy5uYW1lPXQubmFtZTtjb25zdCBuPXQuaW5kZXg7bnVsbCE9PW4mJnRoaXMuc2V0SW5kZXgobi5jbG9uZShlKSk7Y29uc3QgaT10LmF0dHJpYnV0ZXM7Zm9yKGNvbnN0IHQgaW4gaSl7Y29uc3Qgbj1pW3RdO3RoaXMuc2V0QXR0cmlidXRlKHQsbi5jbG9uZShlKSl9Y29uc3Qgcj10Lm1vcnBoQXR0cmlidXRlcztmb3IoY29uc3QgdCBpbiByKXtjb25zdCBuPVtdLGk9clt0XTtmb3IobGV0IHQ9MCxyPWkubGVuZ3RoO3Q8cjt0Kyspbi5wdXNoKGlbdF0uY2xvbmUoZSkpO3RoaXMubW9ycGhBdHRyaWJ1dGVzW3RdPW59dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT10Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2NvbnN0IHM9dC5ncm91cHM7Zm9yKGxldCB0PTAsZT1zLmxlbmd0aDt0PGU7dCsrKXtjb25zdCBlPXNbdF07dGhpcy5hZGRHcm91cChlLnN0YXJ0LGUuY291bnQsZS5tYXRlcmlhbEluZGV4KX1jb25zdCBhPXQuYm91bmRpbmdCb3g7bnVsbCE9PWEmJih0aGlzLmJvdW5kaW5nQm94PWEuY2xvbmUoKSk7Y29uc3Qgbz10LmJvdW5kaW5nU3BoZXJlO3JldHVybiBudWxsIT09byYmKHRoaXMuYm91bmRpbmdTcGhlcmU9by5jbG9uZSgpKSx0aGlzLmRyYXdSYW5nZS5zdGFydD10LmRyYXdSYW5nZS5zdGFydCx0aGlzLmRyYXdSYW5nZS5jb3VudD10LmRyYXdSYW5nZS5jb3VudCx0aGlzLnVzZXJEYXRhPXQudXNlckRhdGEsdm9pZCAwIT09dC5wYXJhbWV0ZXJzJiYodGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oe30sdC5wYXJhbWV0ZXJzKSksdGhpc31kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZGlzcG9zZVwifSl9fVNuLnByb3RvdHlwZS5pc0J1ZmZlckdlb21ldHJ5PSEwO2NvbnN0IFRuPW5ldyB2ZSxFbj1uZXcgZ2UsQW49bmV3IGxlLExuPW5ldyBCdCxSbj1uZXcgQnQsQ249bmV3IEJ0LFBuPW5ldyBCdCxJbj1uZXcgQnQsRG49bmV3IEJ0LE5uPW5ldyBCdCxGbj1uZXcgQnQsT249bmV3IEJ0LFVuPW5ldyBBdCxrbj1uZXcgQXQsem49bmV3IEF0LEJuPW5ldyBCdCxIbj1uZXcgQnQ7Y2xhc3MgVm4gZXh0ZW5kcyBWZXtjb25zdHJ1Y3Rvcih0PW5ldyBTbixlPW5ldyBobil7c3VwZXIoKSx0aGlzLnR5cGU9XCJNZXNoXCIsdGhpcy5nZW9tZXRyeT10LHRoaXMubWF0ZXJpYWw9ZSx0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdm9pZCAwIT09dC5tb3JwaFRhcmdldEluZmx1ZW5jZXMmJih0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz10Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpKSx2b2lkIDAhPT10Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeSYmKHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PU9iamVjdC5hc3NpZ24oe30sdC5tb3JwaFRhcmdldERpY3Rpb25hcnkpKSx0aGlzLm1hdGVyaWFsPXQubWF0ZXJpYWwsdGhpcy5nZW9tZXRyeT10Lmdlb21ldHJ5LHRoaXN9dXBkYXRlTW9ycGhUYXJnZXRzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5O2lmKHQuaXNCdWZmZXJHZW9tZXRyeSl7Y29uc3QgZT10Lm1vcnBoQXR0cmlidXRlcyxuPU9iamVjdC5rZXlzKGUpO2lmKG4ubGVuZ3RoPjApe2NvbnN0IHQ9ZVtuWzBdXTtpZih2b2lkIDAhPT10KXt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1bXSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeT17fTtmb3IobGV0IGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49dFtlXS5uYW1lfHxTdHJpbmcoZSk7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtuXT1lfX19fWVsc2V7Y29uc3QgZT10Lm1vcnBoVGFyZ2V0czt2b2lkIDAhPT1lJiZlLmxlbmd0aD4wJiZjb25zb2xlLmVycm9yKFwiVEhSRUUuTWVzaC51cGRhdGVNb3JwaFRhcmdldHMoKSBubyBsb25nZXIgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnkuIFVzZSBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLlwiKX19cmF5Y2FzdCh0LGUpe2NvbnN0IG49dGhpcy5nZW9tZXRyeSxpPXRoaXMubWF0ZXJpYWwscj10aGlzLm1hdHJpeFdvcmxkO2lmKHZvaWQgMD09PWkpcmV0dXJuO2lmKG51bGw9PT1uLmJvdW5kaW5nU3BoZXJlJiZuLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLEFuLmNvcHkobi5ib3VuZGluZ1NwaGVyZSksQW4uYXBwbHlNYXRyaXg0KHIpLCExPT09dC5yYXkuaW50ZXJzZWN0c1NwaGVyZShBbikpcmV0dXJuO2lmKFRuLmNvcHkocikuaW52ZXJ0KCksRW4uY29weSh0LnJheSkuYXBwbHlNYXRyaXg0KFRuKSxudWxsIT09bi5ib3VuZGluZ0JveCYmITE9PT1Fbi5pbnRlcnNlY3RzQm94KG4uYm91bmRpbmdCb3gpKXJldHVybjtsZXQgcztpZihuLmlzQnVmZmVyR2VvbWV0cnkpe2NvbnN0IHI9bi5pbmRleCxhPW4uYXR0cmlidXRlcy5wb3NpdGlvbixvPW4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLGw9bi5tb3JwaFRhcmdldHNSZWxhdGl2ZSxjPW4uYXR0cmlidXRlcy51dixoPW4uYXR0cmlidXRlcy51djIsdT1uLmdyb3VwcyxkPW4uZHJhd1JhbmdlO2lmKG51bGwhPT1yKWlmKEFycmF5LmlzQXJyYXkoaSkpZm9yKGxldCBuPTAscD11Lmxlbmd0aDtuPHA7bisrKXtjb25zdCBwPXVbbl0sbT1pW3AubWF0ZXJpYWxJbmRleF07Zm9yKGxldCBuPU1hdGgubWF4KHAuc3RhcnQsZC5zdGFydCksaT1NYXRoLm1pbihyLmNvdW50LE1hdGgubWluKHAuc3RhcnQrcC5jb3VudCxkLnN0YXJ0K2QuY291bnQpKTtuPGk7bis9Myl7Y29uc3QgaT1yLmdldFgobiksdT1yLmdldFgobisxKSxkPXIuZ2V0WChuKzIpO3M9R24odGhpcyxtLHQsRW4sYSxvLGwsYyxoLGksdSxkKSxzJiYocy5mYWNlSW5kZXg9TWF0aC5mbG9vcihuLzMpLHMuZmFjZS5tYXRlcmlhbEluZGV4PXAubWF0ZXJpYWxJbmRleCxlLnB1c2gocykpfX1lbHNle2ZvcihsZXQgbj1NYXRoLm1heCgwLGQuc3RhcnQpLHU9TWF0aC5taW4oci5jb3VudCxkLnN0YXJ0K2QuY291bnQpO248dTtuKz0zKXtjb25zdCB1PXIuZ2V0WChuKSxkPXIuZ2V0WChuKzEpLHA9ci5nZXRYKG4rMik7cz1Hbih0aGlzLGksdCxFbixhLG8sbCxjLGgsdSxkLHApLHMmJihzLmZhY2VJbmRleD1NYXRoLmZsb29yKG4vMyksZS5wdXNoKHMpKX19ZWxzZSBpZih2b2lkIDAhPT1hKWlmKEFycmF5LmlzQXJyYXkoaSkpZm9yKGxldCBuPTAscj11Lmxlbmd0aDtuPHI7bisrKXtjb25zdCByPXVbbl0scD1pW3IubWF0ZXJpYWxJbmRleF07Zm9yKGxldCBuPU1hdGgubWF4KHIuc3RhcnQsZC5zdGFydCksaT1NYXRoLm1pbihhLmNvdW50LE1hdGgubWluKHIuc3RhcnQrci5jb3VudCxkLnN0YXJ0K2QuY291bnQpKTtuPGk7bis9Myl7cz1Hbih0aGlzLHAsdCxFbixhLG8sbCxjLGgsbixuKzEsbisyKSxzJiYocy5mYWNlSW5kZXg9TWF0aC5mbG9vcihuLzMpLHMuZmFjZS5tYXRlcmlhbEluZGV4PXIubWF0ZXJpYWxJbmRleCxlLnB1c2gocykpfX1lbHNle2ZvcihsZXQgbj1NYXRoLm1heCgwLGQuc3RhcnQpLHI9TWF0aC5taW4oYS5jb3VudCxkLnN0YXJ0K2QuY291bnQpO248cjtuKz0zKXtzPUduKHRoaXMsaSx0LEVuLGEsbyxsLGMsaCxuLG4rMSxuKzIpLHMmJihzLmZhY2VJbmRleD1NYXRoLmZsb29yKG4vMyksZS5wdXNoKHMpKX19fWVsc2Ugbi5pc0dlb21ldHJ5JiZjb25zb2xlLmVycm9yKFwiVEhSRUUuTWVzaC5yYXljYXN0KCkgbm8gbG9uZ2VyIHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC5cIil9fWZ1bmN0aW9uIEduKHQsZSxuLGkscixzLGEsbyxsLGMsaCx1KXtMbi5mcm9tQnVmZmVyQXR0cmlidXRlKHIsYyksUm4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLGgpLENuLmZyb21CdWZmZXJBdHRyaWJ1dGUocix1KTtjb25zdCBkPXQubW9ycGhUYXJnZXRJbmZsdWVuY2VzO2lmKHMmJmQpe05uLnNldCgwLDAsMCksRm4uc2V0KDAsMCwwKSxPbi5zZXQoMCwwLDApO2ZvcihsZXQgdD0wLGU9cy5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT1kW3RdLG49c1t0XTswIT09ZSYmKFBuLmZyb21CdWZmZXJBdHRyaWJ1dGUobixjKSxJbi5mcm9tQnVmZmVyQXR0cmlidXRlKG4saCksRG4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShuLHUpLGE/KE5uLmFkZFNjYWxlZFZlY3RvcihQbixlKSxGbi5hZGRTY2FsZWRWZWN0b3IoSW4sZSksT24uYWRkU2NhbGVkVmVjdG9yKERuLGUpKTooTm4uYWRkU2NhbGVkVmVjdG9yKFBuLnN1YihMbiksZSksRm4uYWRkU2NhbGVkVmVjdG9yKEluLnN1YihSbiksZSksT24uYWRkU2NhbGVkVmVjdG9yKERuLnN1YihDbiksZSkpKX1Mbi5hZGQoTm4pLFJuLmFkZChGbiksQ24uYWRkKE9uKX10LmlzU2tpbm5lZE1lc2gmJih0LmJvbmVUcmFuc2Zvcm0oYyxMbiksdC5ib25lVHJhbnNmb3JtKGgsUm4pLHQuYm9uZVRyYW5zZm9ybSh1LENuKSk7Y29uc3QgcD1mdW5jdGlvbih0LGUsbixpLHIscyxhLG8pe2xldCBsO2lmKGw9MT09PWUuc2lkZT9pLmludGVyc2VjdFRyaWFuZ2xlKGEscyxyLCEwLG8pOmkuaW50ZXJzZWN0VHJpYW5nbGUocixzLGEsMiE9PWUuc2lkZSxvKSxudWxsPT09bClyZXR1cm4gbnVsbDtIbi5jb3B5KG8pLEhuLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkKTtjb25zdCBjPW4ucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKEhuKTtyZXR1cm4gYzxuLm5lYXJ8fGM+bi5mYXI/bnVsbDp7ZGlzdGFuY2U6Yyxwb2ludDpIbi5jbG9uZSgpLG9iamVjdDp0fX0odCxlLG4saSxMbixSbixDbixCbik7aWYocCl7byYmKFVuLmZyb21CdWZmZXJBdHRyaWJ1dGUobyxjKSxrbi5mcm9tQnVmZmVyQXR0cmlidXRlKG8saCksem4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShvLHUpLHAudXY9UWUuZ2V0VVYoQm4sTG4sUm4sQ24sVW4sa24sem4sbmV3IEF0KSksbCYmKFVuLmZyb21CdWZmZXJBdHRyaWJ1dGUobCxjKSxrbi5mcm9tQnVmZmVyQXR0cmlidXRlKGwsaCksem4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShsLHUpLHAudXYyPVFlLmdldFVWKEJuLExuLFJuLENuLFVuLGtuLHpuLG5ldyBBdCkpO2NvbnN0IHQ9e2E6YyxiOmgsYzp1LG5vcm1hbDpuZXcgQnQsbWF0ZXJpYWxJbmRleDowfTtRZS5nZXROb3JtYWwoTG4sUm4sQ24sdC5ub3JtYWwpLHAuZmFjZT10fXJldHVybiBwfVZuLnByb3RvdHlwZS5pc01lc2g9ITA7Y2xhc3MgV24gZXh0ZW5kcyBTbntjb25zdHJ1Y3Rvcih0PTEsZT0xLG49MSxpPTEscj0xLHM9MSl7c3VwZXIoKSx0aGlzLnR5cGU9XCJCb3hHZW9tZXRyeVwiLHRoaXMucGFyYW1ldGVycz17d2lkdGg6dCxoZWlnaHQ6ZSxkZXB0aDpuLHdpZHRoU2VnbWVudHM6aSxoZWlnaHRTZWdtZW50czpyLGRlcHRoU2VnbWVudHM6c307Y29uc3QgYT10aGlzO2k9TWF0aC5mbG9vcihpKSxyPU1hdGguZmxvb3Iocikscz1NYXRoLmZsb29yKHMpO2NvbnN0IG89W10sbD1bXSxjPVtdLGg9W107bGV0IHU9MCxkPTA7ZnVuY3Rpb24gcCh0LGUsbixpLHIscyxwLG0sZixnLHYpe2NvbnN0IHk9cy9mLHg9cC9nLGI9cy8yLHc9cC8yLF89bS8yLE09ZisxLFM9ZysxO2xldCBUPTAsRT0wO2NvbnN0IEE9bmV3IEJ0O2ZvcihsZXQgcz0wO3M8UztzKyspe2NvbnN0IGE9cyp4LXc7Zm9yKGxldCBvPTA7bzxNO28rKyl7Y29uc3QgdT1vKnktYjtBW3RdPXUqaSxBW2VdPWEqcixBW25dPV8sbC5wdXNoKEEueCxBLnksQS56KSxBW3RdPTAsQVtlXT0wLEFbbl09bT4wPzE6LTEsYy5wdXNoKEEueCxBLnksQS56KSxoLnB1c2goby9mKSxoLnB1c2goMS1zL2cpLFQrPTF9fWZvcihsZXQgdD0wO3Q8Zzt0KyspZm9yKGxldCBlPTA7ZTxmO2UrKyl7Y29uc3Qgbj11K2UrTSp0LGk9dStlK00qKHQrMSkscj11KyhlKzEpK00qKHQrMSkscz11KyhlKzEpK00qdDtvLnB1c2gobixpLHMpLG8ucHVzaChpLHIscyksRSs9Nn1hLmFkZEdyb3VwKGQsRSx2KSxkKz1FLHUrPVR9cChcInpcIixcInlcIixcInhcIiwtMSwtMSxuLGUsdCxzLHIsMCkscChcInpcIixcInlcIixcInhcIiwxLC0xLG4sZSwtdCxzLHIsMSkscChcInhcIixcInpcIixcInlcIiwxLDEsdCxuLGUsaSxzLDIpLHAoXCJ4XCIsXCJ6XCIsXCJ5XCIsMSwtMSx0LG4sLWUsaSxzLDMpLHAoXCJ4XCIsXCJ5XCIsXCJ6XCIsMSwtMSx0LGUsbixpLHIsNCkscChcInhcIixcInlcIixcInpcIiwtMSwtMSx0LGUsLW4saSxyLDUpLHRoaXMuc2V0SW5kZXgobyksdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBnbihsLDMpKSx0aGlzLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLG5ldyBnbihjLDMpKSx0aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsbmV3IGduKGgsMikpfXN0YXRpYyBmcm9tSlNPTih0KXtyZXR1cm4gbmV3IFduKHQud2lkdGgsdC5oZWlnaHQsdC5kZXB0aCx0LndpZHRoU2VnbWVudHMsdC5oZWlnaHRTZWdtZW50cyx0LmRlcHRoU2VnbWVudHMpfX1mdW5jdGlvbiBqbih0KXtjb25zdCBlPXt9O2Zvcihjb25zdCBuIGluIHQpe2Vbbl09e307Zm9yKGNvbnN0IGkgaW4gdFtuXSl7Y29uc3Qgcj10W25dW2ldO3ImJihyLmlzQ29sb3J8fHIuaXNNYXRyaXgzfHxyLmlzTWF0cml4NHx8ci5pc1ZlY3RvcjJ8fHIuaXNWZWN0b3IzfHxyLmlzVmVjdG9yNHx8ci5pc1RleHR1cmV8fHIuaXNRdWF0ZXJuaW9uKT9lW25dW2ldPXIuY2xvbmUoKTpBcnJheS5pc0FycmF5KHIpP2Vbbl1baV09ci5zbGljZSgpOmVbbl1baV09cn19cmV0dXJuIGV9ZnVuY3Rpb24gcW4odCl7Y29uc3QgZT17fTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3QgaT1qbih0W25dKTtmb3IoY29uc3QgdCBpbiBpKWVbdF09aVt0XX1yZXR1cm4gZX1jb25zdCBYbj17Y2xvbmU6am4sbWVyZ2U6cW59O2NsYXNzIFluIGV4dGVuZHMgZW57Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJTaGFkZXJNYXRlcmlhbFwiLHRoaXMuZGVmaW5lcz17fSx0aGlzLnVuaWZvcm1zPXt9LHRoaXMudmVydGV4U2hhZGVyPVwidm9pZCBtYWluKCkge1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59XCIsdGhpcy5mcmFnbWVudFNoYWRlcj1cInZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59XCIsdGhpcy5saW5ld2lkdGg9MSx0aGlzLndpcmVmcmFtZT0hMSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xLHRoaXMuZm9nPSExLHRoaXMubGlnaHRzPSExLHRoaXMuY2xpcHBpbmc9ITEsdGhpcy5leHRlbnNpb25zPXtkZXJpdmF0aXZlczohMSxmcmFnRGVwdGg6ITEsZHJhd0J1ZmZlcnM6ITEsc2hhZGVyVGV4dHVyZUxPRDohMX0sdGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzPXtjb2xvcjpbMSwxLDFdLHV2OlswLDBdLHV2MjpbMCwwXX0sdGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lPXZvaWQgMCx0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZT0hMSx0aGlzLmdsc2xWZXJzaW9uPW51bGwsdm9pZCAwIT09dCYmKHZvaWQgMCE9PXQuYXR0cmlidXRlcyYmY29uc29sZS5lcnJvcihcIlRIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgZGVmaW5lZCBpbiBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLlwiKSx0aGlzLnNldFZhbHVlcyh0KSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmZyYWdtZW50U2hhZGVyPXQuZnJhZ21lbnRTaGFkZXIsdGhpcy52ZXJ0ZXhTaGFkZXI9dC52ZXJ0ZXhTaGFkZXIsdGhpcy51bmlmb3Jtcz1qbih0LnVuaWZvcm1zKSx0aGlzLmRlZmluZXM9T2JqZWN0LmFzc2lnbih7fSx0LmRlZmluZXMpLHRoaXMud2lyZWZyYW1lPXQud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPXQud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMubGlnaHRzPXQubGlnaHRzLHRoaXMuY2xpcHBpbmc9dC5jbGlwcGluZyx0aGlzLmV4dGVuc2lvbnM9T2JqZWN0LmFzc2lnbih7fSx0LmV4dGVuc2lvbnMpLHRoaXMuZ2xzbFZlcnNpb249dC5nbHNsVmVyc2lvbix0aGlzfXRvSlNPTih0KXtjb25zdCBlPXN1cGVyLnRvSlNPTih0KTtlLmdsc2xWZXJzaW9uPXRoaXMuZ2xzbFZlcnNpb24sZS51bmlmb3Jtcz17fTtmb3IoY29uc3QgbiBpbiB0aGlzLnVuaWZvcm1zKXtjb25zdCBpPXRoaXMudW5pZm9ybXNbbl0udmFsdWU7aSYmaS5pc1RleHR1cmU/ZS51bmlmb3Jtc1tuXT17dHlwZTpcInRcIix2YWx1ZTppLnRvSlNPTih0KS51dWlkfTppJiZpLmlzQ29sb3I/ZS51bmlmb3Jtc1tuXT17dHlwZTpcImNcIix2YWx1ZTppLmdldEhleCgpfTppJiZpLmlzVmVjdG9yMj9lLnVuaWZvcm1zW25dPXt0eXBlOlwidjJcIix2YWx1ZTppLnRvQXJyYXkoKX06aSYmaS5pc1ZlY3RvcjM/ZS51bmlmb3Jtc1tuXT17dHlwZTpcInYzXCIsdmFsdWU6aS50b0FycmF5KCl9OmkmJmkuaXNWZWN0b3I0P2UudW5pZm9ybXNbbl09e3R5cGU6XCJ2NFwiLHZhbHVlOmkudG9BcnJheSgpfTppJiZpLmlzTWF0cml4Mz9lLnVuaWZvcm1zW25dPXt0eXBlOlwibTNcIix2YWx1ZTppLnRvQXJyYXkoKX06aSYmaS5pc01hdHJpeDQ/ZS51bmlmb3Jtc1tuXT17dHlwZTpcIm00XCIsdmFsdWU6aS50b0FycmF5KCl9OmUudW5pZm9ybXNbbl09e3ZhbHVlOml9fU9iamVjdC5rZXlzKHRoaXMuZGVmaW5lcykubGVuZ3RoPjAmJihlLmRlZmluZXM9dGhpcy5kZWZpbmVzKSxlLnZlcnRleFNoYWRlcj10aGlzLnZlcnRleFNoYWRlcixlLmZyYWdtZW50U2hhZGVyPXRoaXMuZnJhZ21lbnRTaGFkZXI7Y29uc3Qgbj17fTtmb3IoY29uc3QgdCBpbiB0aGlzLmV4dGVuc2lvbnMpITA9PT10aGlzLmV4dGVuc2lvbnNbdF0mJihuW3RdPSEwKTtyZXR1cm4gT2JqZWN0LmtleXMobikubGVuZ3RoPjAmJihlLmV4dGVuc2lvbnM9biksZX19WW4ucHJvdG90eXBlLmlzU2hhZGVyTWF0ZXJpYWw9ITA7Y2xhc3MgWm4gZXh0ZW5kcyBWZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy50eXBlPVwiQ2FtZXJhXCIsdGhpcy5tYXRyaXhXb3JsZEludmVyc2U9bmV3IHZlLHRoaXMucHJvamVjdGlvbk1hdHJpeD1uZXcgdmUsdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZT1uZXcgdmV9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0Lm1hdHJpeFdvcmxkSW52ZXJzZSksdGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkodC5wcm9qZWN0aW9uTWF0cml4KSx0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSksdGhpc31nZXRXb3JsZERpcmVjdGlvbih0KXt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtjb25zdCBlPXRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7cmV0dXJuIHQuc2V0KC1lWzhdLC1lWzldLC1lWzEwXSkubm9ybWFsaXplKCl9dXBkYXRlTWF0cml4V29ybGQodCl7c3VwZXIudXBkYXRlTWF0cml4V29ybGQodCksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX11cGRhdGVXb3JsZE1hdHJpeCh0LGUpe3N1cGVyLnVwZGF0ZVdvcmxkTWF0cml4KHQsZSksdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKX1jbG9uZSgpe3JldHVybihuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKX19Wm4ucHJvdG90eXBlLmlzQ2FtZXJhPSEwO2NsYXNzIEpuIGV4dGVuZHMgWm57Y29uc3RydWN0b3IodD01MCxlPTEsbj0uMSxpPTJlMyl7c3VwZXIoKSx0aGlzLnR5cGU9XCJQZXJzcGVjdGl2ZUNhbWVyYVwiLHRoaXMuZm92PXQsdGhpcy56b29tPTEsdGhpcy5uZWFyPW4sdGhpcy5mYXI9aSx0aGlzLmZvY3VzPTEwLHRoaXMuYXNwZWN0PWUsdGhpcy52aWV3PW51bGwsdGhpcy5maWxtR2F1Z2U9MzUsdGhpcy5maWxtT2Zmc2V0PTAsdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5mb3Y9dC5mb3YsdGhpcy56b29tPXQuem9vbSx0aGlzLm5lYXI9dC5uZWFyLHRoaXMuZmFyPXQuZmFyLHRoaXMuZm9jdXM9dC5mb2N1cyx0aGlzLmFzcGVjdD10LmFzcGVjdCx0aGlzLnZpZXc9bnVsbD09PXQudmlldz9udWxsOk9iamVjdC5hc3NpZ24oe30sdC52aWV3KSx0aGlzLmZpbG1HYXVnZT10LmZpbG1HYXVnZSx0aGlzLmZpbG1PZmZzZXQ9dC5maWxtT2Zmc2V0LHRoaXN9c2V0Rm9jYWxMZW5ndGgodCl7Y29uc3QgZT0uNSp0aGlzLmdldEZpbG1IZWlnaHQoKS90O3RoaXMuZm92PTIqZ3QqTWF0aC5hdGFuKGUpLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfWdldEZvY2FsTGVuZ3RoKCl7Y29uc3QgdD1NYXRoLnRhbiguNSpmdCp0aGlzLmZvdik7cmV0dXJuLjUqdGhpcy5nZXRGaWxtSGVpZ2h0KCkvdH1nZXRFZmZlY3RpdmVGT1YoKXtyZXR1cm4gMipndCpNYXRoLmF0YW4oTWF0aC50YW4oLjUqZnQqdGhpcy5mb3YpL3RoaXMuem9vbSl9Z2V0RmlsbVdpZHRoKCl7cmV0dXJuIHRoaXMuZmlsbUdhdWdlKk1hdGgubWluKHRoaXMuYXNwZWN0LDEpfWdldEZpbG1IZWlnaHQoKXtyZXR1cm4gdGhpcy5maWxtR2F1Z2UvTWF0aC5tYXgodGhpcy5hc3BlY3QsMSl9c2V0Vmlld09mZnNldCh0LGUsbixpLHIscyl7dGhpcy5hc3BlY3Q9dC9lLG51bGw9PT10aGlzLnZpZXcmJih0aGlzLnZpZXc9e2VuYWJsZWQ6ITAsZnVsbFdpZHRoOjEsZnVsbEhlaWdodDoxLG9mZnNldFg6MCxvZmZzZXRZOjAsd2lkdGg6MSxoZWlnaHQ6MX0pLHRoaXMudmlldy5lbmFibGVkPSEwLHRoaXMudmlldy5mdWxsV2lkdGg9dCx0aGlzLnZpZXcuZnVsbEhlaWdodD1lLHRoaXMudmlldy5vZmZzZXRYPW4sdGhpcy52aWV3Lm9mZnNldFk9aSx0aGlzLnZpZXcud2lkdGg9cix0aGlzLnZpZXcuaGVpZ2h0PXMsdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9Y2xlYXJWaWV3T2Zmc2V0KCl7bnVsbCE9PXRoaXMudmlldyYmKHRoaXMudmlldy5lbmFibGVkPSExKSx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX11cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl7Y29uc3QgdD10aGlzLm5lYXI7bGV0IGU9dCpNYXRoLnRhbiguNSpmdCp0aGlzLmZvdikvdGhpcy56b29tLG49MiplLGk9dGhpcy5hc3BlY3QqbixyPS0uNSppO2NvbnN0IHM9dGhpcy52aWV3O2lmKG51bGwhPT10aGlzLnZpZXcmJnRoaXMudmlldy5lbmFibGVkKXtjb25zdCB0PXMuZnVsbFdpZHRoLGE9cy5mdWxsSGVpZ2h0O3IrPXMub2Zmc2V0WCppL3QsZS09cy5vZmZzZXRZKm4vYSxpKj1zLndpZHRoL3Qsbio9cy5oZWlnaHQvYX1jb25zdCBhPXRoaXMuZmlsbU9mZnNldDswIT09YSYmKHIrPXQqYS90aGlzLmdldEZpbG1XaWR0aCgpKSx0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKHIscitpLGUsZS1uLHQsdGhpcy5mYXIpLHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpfXRvSlNPTih0KXtjb25zdCBlPXN1cGVyLnRvSlNPTih0KTtyZXR1cm4gZS5vYmplY3QuZm92PXRoaXMuZm92LGUub2JqZWN0Lnpvb209dGhpcy56b29tLGUub2JqZWN0Lm5lYXI9dGhpcy5uZWFyLGUub2JqZWN0LmZhcj10aGlzLmZhcixlLm9iamVjdC5mb2N1cz10aGlzLmZvY3VzLGUub2JqZWN0LmFzcGVjdD10aGlzLmFzcGVjdCxudWxsIT09dGhpcy52aWV3JiYoZS5vYmplY3Qudmlldz1PYmplY3QuYXNzaWduKHt9LHRoaXMudmlldykpLGUub2JqZWN0LmZpbG1HYXVnZT10aGlzLmZpbG1HYXVnZSxlLm9iamVjdC5maWxtT2Zmc2V0PXRoaXMuZmlsbU9mZnNldCxlfX1Kbi5wcm90b3R5cGUuaXNQZXJzcGVjdGl2ZUNhbWVyYT0hMDtjbGFzcyAkbiBleHRlbmRzIFZle2NvbnN0cnVjdG9yKHQsZSxuKXtpZihzdXBlcigpLHRoaXMudHlwZT1cIkN1YmVDYW1lcmFcIiwhMCE9PW4uaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIlRIUkVFLkN1YmVDYW1lcmE6IFRoZSBjb25zdHJ1Y3RvciBub3cgZXhwZWN0cyBhbiBpbnN0YW5jZSBvZiBXZWJHTEN1YmVSZW5kZXJUYXJnZXQgYXMgdGhpcmQgcGFyYW1ldGVyLlwiKTt0aGlzLnJlbmRlclRhcmdldD1uO2NvbnN0IGk9bmV3IEpuKDkwLDEsdCxlKTtpLmxheWVycz10aGlzLmxheWVycyxpLnVwLnNldCgwLC0xLDApLGkubG9va0F0KG5ldyBCdCgxLDAsMCkpLHRoaXMuYWRkKGkpO2NvbnN0IHI9bmV3IEpuKDkwLDEsdCxlKTtyLmxheWVycz10aGlzLmxheWVycyxyLnVwLnNldCgwLC0xLDApLHIubG9va0F0KG5ldyBCdCgtMSwwLDApKSx0aGlzLmFkZChyKTtjb25zdCBzPW5ldyBKbig5MCwxLHQsZSk7cy5sYXllcnM9dGhpcy5sYXllcnMscy51cC5zZXQoMCwwLDEpLHMubG9va0F0KG5ldyBCdCgwLDEsMCkpLHRoaXMuYWRkKHMpO2NvbnN0IGE9bmV3IEpuKDkwLDEsdCxlKTthLmxheWVycz10aGlzLmxheWVycyxhLnVwLnNldCgwLDAsLTEpLGEubG9va0F0KG5ldyBCdCgwLC0xLDApKSx0aGlzLmFkZChhKTtjb25zdCBvPW5ldyBKbig5MCwxLHQsZSk7by5sYXllcnM9dGhpcy5sYXllcnMsby51cC5zZXQoMCwtMSwwKSxvLmxvb2tBdChuZXcgQnQoMCwwLDEpKSx0aGlzLmFkZChvKTtjb25zdCBsPW5ldyBKbig5MCwxLHQsZSk7bC5sYXllcnM9dGhpcy5sYXllcnMsbC51cC5zZXQoMCwtMSwwKSxsLmxvb2tBdChuZXcgQnQoMCwwLC0xKSksdGhpcy5hZGQobCl9dXBkYXRlKHQsZSl7bnVsbD09PXRoaXMucGFyZW50JiZ0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7Y29uc3Qgbj10aGlzLnJlbmRlclRhcmdldCxbaSxyLHMsYSxvLGxdPXRoaXMuY2hpbGRyZW4sYz10LnhyLmVuYWJsZWQsaD10LmdldFJlbmRlclRhcmdldCgpO3QueHIuZW5hYmxlZD0hMTtjb25zdCB1PW4udGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7bi50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz0hMSx0LnNldFJlbmRlclRhcmdldChuLDApLHQucmVuZGVyKGUsaSksdC5zZXRSZW5kZXJUYXJnZXQobiwxKSx0LnJlbmRlcihlLHIpLHQuc2V0UmVuZGVyVGFyZ2V0KG4sMiksdC5yZW5kZXIoZSxzKSx0LnNldFJlbmRlclRhcmdldChuLDMpLHQucmVuZGVyKGUsYSksdC5zZXRSZW5kZXJUYXJnZXQobiw0KSx0LnJlbmRlcihlLG8pLG4udGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9dSx0LnNldFJlbmRlclRhcmdldChuLDUpLHQucmVuZGVyKGUsbCksdC5zZXRSZW5kZXJUYXJnZXQoaCksdC54ci5lbmFibGVkPWN9fWNsYXNzIEtuIGV4dGVuZHMgTnR7Y29uc3RydWN0b3IodCxlLG4saSxyLHMsYSxvLGwsYyl7c3VwZXIodD12b2lkIDAhPT10P3Q6W10sZT12b2lkIDAhPT1lP2U6MzAxLG4saSxyLHMsYSxvLGwsYyksdGhpcy5mbGlwWT0hMX1nZXQgaW1hZ2VzKCl7cmV0dXJuIHRoaXMuaW1hZ2V9c2V0IGltYWdlcyh0KXt0aGlzLmltYWdlPXR9fUtuLnByb3RvdHlwZS5pc0N1YmVUZXh0dXJlPSEwO2NsYXNzIFFuIGV4dGVuZHMgVXR7Y29uc3RydWN0b3IodCxlLG4pe051bWJlci5pc0ludGVnZXIoZSkmJihjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTEN1YmVSZW5kZXJUYXJnZXQ6IGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBpcyBub3cgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KCBzaXplLCBvcHRpb25zIClcIiksZT1uKSxzdXBlcih0LHQsZSksZT1lfHx7fSx0aGlzLnRleHR1cmU9bmV3IEtuKHZvaWQgMCxlLm1hcHBpbmcsZS53cmFwUyxlLndyYXBULGUubWFnRmlsdGVyLGUubWluRmlsdGVyLGUuZm9ybWF0LGUudHlwZSxlLmFuaXNvdHJvcHksZS5lbmNvZGluZyksdGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMCx0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPXZvaWQgMCE9PWUuZ2VuZXJhdGVNaXBtYXBzJiZlLmdlbmVyYXRlTWlwbWFwcyx0aGlzLnRleHR1cmUubWluRmlsdGVyPXZvaWQgMCE9PWUubWluRmlsdGVyP2UubWluRmlsdGVyOjEwMDYsdGhpcy50ZXh0dXJlLl9uZWVkc0ZsaXBFbnZNYXA9ITF9ZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUodCxlKXt0aGlzLnRleHR1cmUudHlwZT1lLnR5cGUsdGhpcy50ZXh0dXJlLmZvcm1hdD0xMDIzLHRoaXMudGV4dHVyZS5lbmNvZGluZz1lLmVuY29kaW5nLHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9ZS5nZW5lcmF0ZU1pcG1hcHMsdGhpcy50ZXh0dXJlLm1pbkZpbHRlcj1lLm1pbkZpbHRlcix0aGlzLnRleHR1cmUubWFnRmlsdGVyPWUubWFnRmlsdGVyO2NvbnN0IG49e3VuaWZvcm1zOnt0RXF1aXJlY3Q6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6XCJcXG5cXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdFxcdHZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0XFx0XFx0XFx0XFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIixmcmFnbWVudFNoYWRlcjpcIlxcblxcblxcdFxcdFxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcXG5cXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdFxcdCNpbmNsdWRlIDxjb21tb24+XFxuXFxuXFx0XFx0XFx0XFx0dm9pZCBtYWluKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWMyIHNhbXBsZVVWID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwifSxpPW5ldyBXbig1LDUsNSkscj1uZXcgWW4oe25hbWU6XCJDdWJlbWFwRnJvbUVxdWlyZWN0XCIsdW5pZm9ybXM6am4obi51bmlmb3JtcyksdmVydGV4U2hhZGVyOm4udmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyOm4uZnJhZ21lbnRTaGFkZXIsc2lkZToxLGJsZW5kaW5nOjB9KTtyLnVuaWZvcm1zLnRFcXVpcmVjdC52YWx1ZT1lO2NvbnN0IHM9bmV3IFZuKGksciksYT1lLm1pbkZpbHRlcjsxMDA4PT09ZS5taW5GaWx0ZXImJihlLm1pbkZpbHRlcj0xMDA2KTtyZXR1cm4gbmV3ICRuKDEsMTAsdGhpcykudXBkYXRlKHQscyksZS5taW5GaWx0ZXI9YSxzLmdlb21ldHJ5LmRpc3Bvc2UoKSxzLm1hdGVyaWFsLmRpc3Bvc2UoKSx0aGlzfWNsZWFyKHQsZSxuLGkpe2NvbnN0IHI9dC5nZXRSZW5kZXJUYXJnZXQoKTtmb3IobGV0IHI9MDtyPDY7cisrKXQuc2V0UmVuZGVyVGFyZ2V0KHRoaXMsciksdC5jbGVhcihlLG4saSk7dC5zZXRSZW5kZXJUYXJnZXQocil9fVFuLnByb3RvdHlwZS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldD0hMDtjb25zdCB0aT1uZXcgQnQsZWk9bmV3IEJ0LG5pPW5ldyBMdDtjbGFzcyBpaXtjb25zdHJ1Y3Rvcih0PW5ldyBCdCgxLDAsMCksZT0wKXt0aGlzLm5vcm1hbD10LHRoaXMuY29uc3RhbnQ9ZX1zZXQodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWwuY29weSh0KSx0aGlzLmNvbnN0YW50PWUsdGhpc31zZXRDb21wb25lbnRzKHQsZSxuLGkpe3JldHVybiB0aGlzLm5vcm1hbC5zZXQodCxlLG4pLHRoaXMuY29uc3RhbnQ9aSx0aGlzfXNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KHQsZSl7cmV0dXJuIHRoaXMubm9ybWFsLmNvcHkodCksdGhpcy5jb25zdGFudD0tZS5kb3QodGhpcy5ub3JtYWwpLHRoaXN9c2V0RnJvbUNvcGxhbmFyUG9pbnRzKHQsZSxuKXtjb25zdCBpPXRpLnN1YlZlY3RvcnMobixlKS5jcm9zcyhlaS5zdWJWZWN0b3JzKHQsZSkpLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KGksdCksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLm5vcm1hbC5jb3B5KHQubm9ybWFsKSx0aGlzLmNvbnN0YW50PXQuY29uc3RhbnQsdGhpc31ub3JtYWxpemUoKXtjb25zdCB0PTEvdGhpcy5ub3JtYWwubGVuZ3RoKCk7cmV0dXJuIHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKHQpLHRoaXMuY29uc3RhbnQqPXQsdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy5jb25zdGFudCo9LTEsdGhpcy5ub3JtYWwubmVnYXRlKCksdGhpc31kaXN0YW5jZVRvUG9pbnQodCl7cmV0dXJuIHRoaXMubm9ybWFsLmRvdCh0KSt0aGlzLmNvbnN0YW50fWRpc3RhbmNlVG9TcGhlcmUodCl7cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KHQuY2VudGVyKS10LnJhZGl1c31wcm9qZWN0UG9pbnQodCxlKXtyZXR1cm4gZS5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5kaXN0YW5jZVRvUG9pbnQodCkpLmFkZCh0KX1pbnRlcnNlY3RMaW5lKHQsZSl7Y29uc3Qgbj10LmRlbHRhKHRpKSxpPXRoaXMubm9ybWFsLmRvdChuKTtpZigwPT09aSlyZXR1cm4gMD09PXRoaXMuZGlzdGFuY2VUb1BvaW50KHQuc3RhcnQpP2UuY29weSh0LnN0YXJ0KTpudWxsO2NvbnN0IHI9LSh0LnN0YXJ0LmRvdCh0aGlzLm5vcm1hbCkrdGhpcy5jb25zdGFudCkvaTtyZXR1cm4gcjwwfHxyPjE/bnVsbDplLmNvcHkobikubXVsdGlwbHlTY2FsYXIocikuYWRkKHQuc3RhcnQpfWludGVyc2VjdHNMaW5lKHQpe2NvbnN0IGU9dGhpcy5kaXN0YW5jZVRvUG9pbnQodC5zdGFydCksbj10aGlzLmRpc3RhbmNlVG9Qb2ludCh0LmVuZCk7cmV0dXJuIGU8MCYmbj4wfHxuPDAmJmU+MH1pbnRlcnNlY3RzQm94KHQpe3JldHVybiB0LmludGVyc2VjdHNQbGFuZSh0aGlzKX1pbnRlcnNlY3RzU3BoZXJlKHQpe3JldHVybiB0LmludGVyc2VjdHNQbGFuZSh0aGlzKX1jb3BsYW5hclBvaW50KHQpe3JldHVybiB0LmNvcHkodGhpcy5ub3JtYWwpLm11bHRpcGx5U2NhbGFyKC10aGlzLmNvbnN0YW50KX1hcHBseU1hdHJpeDQodCxlKXtjb25zdCBuPWV8fG5pLmdldE5vcm1hbE1hdHJpeCh0KSxpPXRoaXMuY29wbGFuYXJQb2ludCh0aSkuYXBwbHlNYXRyaXg0KHQpLHI9dGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKG4pLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzLmNvbnN0YW50PS1pLmRvdChyKSx0aGlzfXRyYW5zbGF0ZSh0KXtyZXR1cm4gdGhpcy5jb25zdGFudC09dC5kb3QodGhpcy5ub3JtYWwpLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpJiZ0LmNvbnN0YW50PT09dGhpcy5jb25zdGFudH1jbG9uZSgpe3JldHVybihuZXcgdGhpcy5jb25zdHJ1Y3RvcikuY29weSh0aGlzKX19aWkucHJvdG90eXBlLmlzUGxhbmU9ITA7Y29uc3Qgcmk9bmV3IGxlLHNpPW5ldyBCdDtjbGFzcyBhaXtjb25zdHJ1Y3Rvcih0PW5ldyBpaSxlPW5ldyBpaSxuPW5ldyBpaSxpPW5ldyBpaSxyPW5ldyBpaSxzPW5ldyBpaSl7dGhpcy5wbGFuZXM9W3QsZSxuLGkscixzXX1zZXQodCxlLG4saSxyLHMpe2NvbnN0IGE9dGhpcy5wbGFuZXM7cmV0dXJuIGFbMF0uY29weSh0KSxhWzFdLmNvcHkoZSksYVsyXS5jb3B5KG4pLGFbM10uY29weShpKSxhWzRdLmNvcHkociksYVs1XS5jb3B5KHMpLHRoaXN9Y29weSh0KXtjb25zdCBlPXRoaXMucGxhbmVzO2ZvcihsZXQgbj0wO248NjtuKyspZVtuXS5jb3B5KHQucGxhbmVzW25dKTtyZXR1cm4gdGhpc31zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCh0KXtjb25zdCBlPXRoaXMucGxhbmVzLG49dC5lbGVtZW50cyxpPW5bMF0scj1uWzFdLHM9blsyXSxhPW5bM10sbz1uWzRdLGw9bls1XSxjPW5bNl0saD1uWzddLHU9bls4XSxkPW5bOV0scD1uWzEwXSxtPW5bMTFdLGY9blsxMl0sZz1uWzEzXSx2PW5bMTRdLHk9blsxNV07cmV0dXJuIGVbMF0uc2V0Q29tcG9uZW50cyhhLWksaC1vLG0tdSx5LWYpLm5vcm1hbGl6ZSgpLGVbMV0uc2V0Q29tcG9uZW50cyhhK2ksaCtvLG0rdSx5K2YpLm5vcm1hbGl6ZSgpLGVbMl0uc2V0Q29tcG9uZW50cyhhK3IsaCtsLG0rZCx5K2cpLm5vcm1hbGl6ZSgpLGVbM10uc2V0Q29tcG9uZW50cyhhLXIsaC1sLG0tZCx5LWcpLm5vcm1hbGl6ZSgpLGVbNF0uc2V0Q29tcG9uZW50cyhhLXMsaC1jLG0tcCx5LXYpLm5vcm1hbGl6ZSgpLGVbNV0uc2V0Q29tcG9uZW50cyhhK3MsaCtjLG0rcCx5K3YpLm5vcm1hbGl6ZSgpLHRoaXN9aW50ZXJzZWN0c09iamVjdCh0KXtjb25zdCBlPXQuZ2VvbWV0cnk7cmV0dXJuIG51bGw9PT1lLmJvdW5kaW5nU3BoZXJlJiZlLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLHJpLmNvcHkoZS5ib3VuZGluZ1NwaGVyZSkuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMuaW50ZXJzZWN0c1NwaGVyZShyaSl9aW50ZXJzZWN0c1Nwcml0ZSh0KXtyZXR1cm4gcmkuY2VudGVyLnNldCgwLDAsMCkscmkucmFkaXVzPS43MDcxMDY3ODExODY1NDc2LHJpLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkKSx0aGlzLmludGVyc2VjdHNTcGhlcmUocmkpfWludGVyc2VjdHNTcGhlcmUodCl7Y29uc3QgZT10aGlzLnBsYW5lcyxuPXQuY2VudGVyLGk9LXQucmFkaXVzO2ZvcihsZXQgdD0wO3Q8Njt0Kyspe2lmKGVbdF0uZGlzdGFuY2VUb1BvaW50KG4pPGkpcmV0dXJuITF9cmV0dXJuITB9aW50ZXJzZWN0c0JveCh0KXtjb25zdCBlPXRoaXMucGxhbmVzO2ZvcihsZXQgbj0wO248NjtuKyspe2NvbnN0IGk9ZVtuXTtpZihzaS54PWkubm9ybWFsLng+MD90Lm1heC54OnQubWluLngsc2kueT1pLm5vcm1hbC55PjA/dC5tYXgueTp0Lm1pbi55LHNpLno9aS5ub3JtYWwuej4wP3QubWF4Lno6dC5taW4ueixpLmRpc3RhbmNlVG9Qb2ludChzaSk8MClyZXR1cm4hMX1yZXR1cm4hMH1jb250YWluc1BvaW50KHQpe2NvbnN0IGU9dGhpcy5wbGFuZXM7Zm9yKGxldCBuPTA7bjw2O24rKylpZihlW25dLmRpc3RhbmNlVG9Qb2ludCh0KTwwKXJldHVybiExO3JldHVybiEwfWNsb25lKCl7cmV0dXJuKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpfX1mdW5jdGlvbiBvaSgpe2xldCB0PW51bGwsZT0hMSxuPW51bGwsaT1udWxsO2Z1bmN0aW9uIHIoZSxzKXtuKGUscyksaT10LnJlcXVlc3RBbmltYXRpb25GcmFtZShyKX1yZXR1cm57c3RhcnQ6ZnVuY3Rpb24oKXshMCE9PWUmJm51bGwhPT1uJiYoaT10LnJlcXVlc3RBbmltYXRpb25GcmFtZShyKSxlPSEwKX0sc3RvcDpmdW5jdGlvbigpe3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaSksZT0hMX0sc2V0QW5pbWF0aW9uTG9vcDpmdW5jdGlvbih0KXtuPXR9LHNldENvbnRleHQ6ZnVuY3Rpb24oZSl7dD1lfX19ZnVuY3Rpb24gbGkodCxlKXtjb25zdCBuPWUuaXNXZWJHTDIsaT1uZXcgV2Vha01hcDtyZXR1cm57Z2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0LmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJih0PXQuZGF0YSksaS5nZXQodCl9LHJlbW92ZTpmdW5jdGlvbihlKXtlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihlPWUuZGF0YSk7Y29uc3Qgbj1pLmdldChlKTtuJiYodC5kZWxldGVCdWZmZXIobi5idWZmZXIpLGkuZGVsZXRlKGUpKX0sdXBkYXRlOmZ1bmN0aW9uKGUscil7aWYoZS5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zdCB0PWkuZ2V0KGUpO3JldHVybiB2b2lkKCghdHx8dC52ZXJzaW9uPGUudmVyc2lvbikmJmkuc2V0KGUse2J1ZmZlcjplLmJ1ZmZlcix0eXBlOmUudHlwZSxieXRlc1BlckVsZW1lbnQ6ZS5lbGVtZW50U2l6ZSx2ZXJzaW9uOmUudmVyc2lvbn0pKX1lLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihlPWUuZGF0YSk7Y29uc3Qgcz1pLmdldChlKTt2b2lkIDA9PT1zP2kuc2V0KGUsZnVuY3Rpb24oZSxpKXtjb25zdCByPWUuYXJyYXkscz1lLnVzYWdlLGE9dC5jcmVhdGVCdWZmZXIoKTt0LmJpbmRCdWZmZXIoaSxhKSx0LmJ1ZmZlckRhdGEoaSxyLHMpLGUub25VcGxvYWRDYWxsYmFjaygpO2xldCBvPTUxMjY7cmV0dXJuIHIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/bz01MTI2OnIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXk/Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBkYXRhIGJ1ZmZlciBmb3JtYXQ6IEZsb2F0NjRBcnJheS5cIik6ciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5P2UuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlP24/bz01MTMxOmNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMQXR0cmlidXRlczogVXNhZ2Ugb2YgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBXZWJHTDIuXCIpOm89NTEyMzpyIGluc3RhbmNlb2YgSW50MTZBcnJheT9vPTUxMjI6ciBpbnN0YW5jZW9mIFVpbnQzMkFycmF5P289NTEyNTpyIGluc3RhbmNlb2YgSW50MzJBcnJheT9vPTUxMjQ6ciBpbnN0YW5jZW9mIEludDhBcnJheT9vPTUxMjA6KHIgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxyIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpJiYobz01MTIxKSx7YnVmZmVyOmEsdHlwZTpvLGJ5dGVzUGVyRWxlbWVudDpyLkJZVEVTX1BFUl9FTEVNRU5ULHZlcnNpb246ZS52ZXJzaW9ufX0oZSxyKSk6cy52ZXJzaW9uPGUudmVyc2lvbiYmKCFmdW5jdGlvbihlLGkscil7Y29uc3Qgcz1pLmFycmF5LGE9aS51cGRhdGVSYW5nZTt0LmJpbmRCdWZmZXIocixlKSwtMT09PWEuY291bnQ/dC5idWZmZXJTdWJEYXRhKHIsMCxzKToobj90LmJ1ZmZlclN1YkRhdGEocixhLm9mZnNldCpzLkJZVEVTX1BFUl9FTEVNRU5ULHMsYS5vZmZzZXQsYS5jb3VudCk6dC5idWZmZXJTdWJEYXRhKHIsYS5vZmZzZXQqcy5CWVRFU19QRVJfRUxFTUVOVCxzLnN1YmFycmF5KGEub2Zmc2V0LGEub2Zmc2V0K2EuY291bnQpKSxhLmNvdW50PS0xKX0ocy5idWZmZXIsZSxyKSxzLnZlcnNpb249ZS52ZXJzaW9uKX19fWNsYXNzIGNpIGV4dGVuZHMgU257Y29uc3RydWN0b3IodD0xLGU9MSxuPTEsaT0xKXtzdXBlcigpLHRoaXMudHlwZT1cIlBsYW5lR2VvbWV0cnlcIix0aGlzLnBhcmFtZXRlcnM9e3dpZHRoOnQsaGVpZ2h0OmUsd2lkdGhTZWdtZW50czpuLGhlaWdodFNlZ21lbnRzOml9O2NvbnN0IHI9dC8yLHM9ZS8yLGE9TWF0aC5mbG9vcihuKSxvPU1hdGguZmxvb3IoaSksbD1hKzEsYz1vKzEsaD10L2EsdT1lL28sZD1bXSxwPVtdLG09W10sZj1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPXQqdS1zO2ZvcihsZXQgbj0wO248bDtuKyspe2NvbnN0IGk9bipoLXI7cC5wdXNoKGksLWUsMCksbS5wdXNoKDAsMCwxKSxmLnB1c2gobi9hKSxmLnB1c2goMS10L28pfX1mb3IobGV0IHQ9MDt0PG87dCsrKWZvcihsZXQgZT0wO2U8YTtlKyspe2NvbnN0IG49ZStsKnQsaT1lK2wqKHQrMSkscj1lKzErbCoodCsxKSxzPWUrMStsKnQ7ZC5wdXNoKG4saSxzKSxkLnB1c2goaSxyLHMpfXRoaXMuc2V0SW5kZXgoZCksdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBnbihwLDMpKSx0aGlzLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLG5ldyBnbihtLDMpKSx0aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsbmV3IGduKGYsMikpfXN0YXRpYyBmcm9tSlNPTih0KXtyZXR1cm4gbmV3IGNpKHQud2lkdGgsdC5oZWlnaHQsdC53aWR0aFNlZ21lbnRzLHQuaGVpZ2h0U2VnbWVudHMpfX1jb25zdCBoaT17YWxwaGFtYXBfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0ZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG4jZW5kaWZcIixhbHBoYW1hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlwiLGFscGhhdGVzdF9mcmFnbWVudDpcIiNpZmRlZiBVU0VfQUxQSEFURVNUXFxuXFx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7XFxuI2VuZGlmXCIsYWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0FMUEhBVEVTVFxcblxcdHVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0O1xcbiNlbmRpZlwiLGFvbWFwX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9BT01BUFxcblxcdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gYW1iaWVudE9jY2x1c2lvbjtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEIClcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixhb21hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9BT01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCIsYmVnaW5fdmVydGV4OlwidmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XCIsYmVnaW5ub3JtYWxfdmVydGV4OlwidmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIG9iamVjdFRhbmdlbnQgPSB2ZWMzKCB0YW5nZW50Lnh5eiApO1xcbiNlbmRpZlwiLGJzZGZzOlwidmVjMyBCUkRGX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yO1xcbn1cXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcXG5cXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtIDUuNTU0NzMgKiBkb3RWSCAtIDYuOTgzMTYgKSAqIGRvdFZIICk7XFxuXFx0cmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTtcXG59XFxuZmxvYXQgVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBndiA9IGRvdE5MICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxuXFx0ZmxvYXQgZ2wgPSBkb3ROViAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcblxcdHJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTtcXG59XFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wO1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApO1xcbn1cXG52ZWMzIEJSREZfR0dYKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBmMCwgZjkwLCBkb3RWSCApO1xcblxcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcXG5cXHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBWICogRCApO1xcbn1cXG52ZWMyIExUQ19VdiggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRjb25zdCBmbG9hdCBMVVRfU0laRSA9IDY0LjA7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKCBMVVRfU0laRSAtIDEuMCApIC8gTFVUX1NJWkU7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX0JJQVMgPSAwLjUgLyBMVVRfU0laRTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIE4sIFYgKSApO1xcblxcdHZlYzIgdXYgPSB2ZWMyKCByb3VnaG5lc3MsIHNxcnQoIDEuMCAtIGRvdE5WICkgKTtcXG5cXHR1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7XFxuXFx0cmV0dXJuIHV2O1xcbn1cXG5mbG9hdCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgZiApIHtcXG5cXHRmbG9hdCBsID0gbGVuZ3RoKCBmICk7XFxuXFx0cmV0dXJuIG1heCggKCBsICogbCArIGYueiApIC8gKCBsICsgMS4wICksIDAuMCApO1xcbn1cXG52ZWMzIExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyB2MSwgY29uc3QgaW4gdmVjMyB2MiApIHtcXG5cXHRmbG9hdCB4ID0gZG90KCB2MSwgdjIgKTtcXG5cXHRmbG9hdCB5ID0gYWJzKCB4ICk7XFxuXFx0ZmxvYXQgYSA9IDAuODU0Mzk4NSArICggMC40OTY1MTU1ICsgMC4wMTQ1MjA2ICogeSApICogeTtcXG5cXHRmbG9hdCBiID0gMy40MTc1OTQwICsgKCA0LjE2MTY3MjQgKyB5ICkgKiB5O1xcblxcdGZsb2F0IHYgPSBhIC8gYjtcXG5cXHRmbG9hdCB0aGV0YV9zaW50aGV0YSA9ICggeCA+IDAuMCApID8gdiA6IDAuNSAqIGludmVyc2VzcXJ0KCBtYXgoIDEuMCAtIHggKiB4LCAxZS03ICkgKSAtIHY7XFxuXFx0cmV0dXJuIGNyb3NzKCB2MSwgdjIgKSAqIHRoZXRhX3NpbnRoZXRhO1xcbn1cXG52ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHtcXG5cXHR2ZWMzIHYxID0gcmVjdENvb3Jkc1sgMSBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgdjIgPSByZWN0Q29vcmRzWyAzIF0gLSByZWN0Q29vcmRzWyAwIF07XFxuXFx0dmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTtcXG5cXHRpZiggZG90KCBsaWdodE5vcm1hbCwgUCAtIHJlY3RDb29yZHNbIDAgXSApIDwgMC4wICkgcmV0dXJuIHZlYzMoIDAuMCApO1xcblxcdHZlYzMgVDEsIFQyO1xcblxcdFQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7XFxuXFx0VDIgPSAtIGNyb3NzKCBOLCBUMSApO1xcblxcdG1hdDMgbWF0ID0gbUludiAqIHRyYW5zcG9zZU1hdDMoIG1hdDMoIFQxLCBUMiwgTiApICk7XFxuXFx0dmVjMyBjb29yZHNbIDQgXTtcXG5cXHRjb29yZHNbIDAgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMCBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMSBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAxIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDMgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMyBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMCBdID0gbm9ybWFsaXplKCBjb29yZHNbIDAgXSApO1xcblxcdGNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApO1xcblxcdGNvb3Jkc1sgMiBdID0gbm9ybWFsaXplKCBjb29yZHNbIDIgXSApO1xcblxcdGNvb3Jkc1sgMyBdID0gbm9ybWFsaXplKCBjb29yZHNbIDMgXSApO1xcblxcdHZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDAgXSwgY29vcmRzWyAxIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAxIF0sIGNvb3Jkc1sgMiBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDMgXSwgY29vcmRzWyAwIF0gKTtcXG5cXHRmbG9hdCByZXN1bHQgPSBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIHZlY3RvckZvcm1GYWN0b3IgKTtcXG5cXHRyZXR1cm4gdmVjMyggcmVzdWx0ICk7XFxufVxcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKSB7XFxuXFx0cmV0dXJuIDAuMjU7XFxufVxcbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG59XFxudmVjMyBCUkRGX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCAxLjAsIGRvdFZIICk7XFxuXFx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKTtcXG5cXHRmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxuXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufVxcbiNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKVxcbmZsb2F0IERfQ2hhcmxpZSggZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBkb3ROSCApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdGZsb2F0IGludkFscGhhID0gMS4wIC8gYWxwaGE7XFxuXFx0ZmxvYXQgY29zMmggPSBkb3ROSCAqIGRvdE5IO1xcblxcdGZsb2F0IHNpbjJoID0gbWF4KCAxLjAgLSBjb3MyaCwgMC4wMDc4MTI1ICk7XFxuXFx0cmV0dXJuICggMi4wICsgaW52QWxwaGEgKSAqIHBvdyggc2luMmgsIGludkFscGhhICogMC41ICkgLyAoIDIuMCAqIFBJICk7XFxufVxcbmZsb2F0IFZfTmV1YmVsdCggZmxvYXQgZG90TlYsIGZsb2F0IGRvdE5MICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggMS4wIC8gKCA0LjAgKiAoIGRvdE5MICsgZG90TlYgLSBkb3ROTCAqIGRvdE5WICkgKSApO1xcbn1cXG52ZWMzIEJSREZfU2hlZW4oIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIHZlYzMgc2hlZW5UaW50LCBjb25zdCBpbiBmbG9hdCBzaGVlblJvdWdobmVzcyApIHtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBEID0gRF9DaGFybGllKCBzaGVlblJvdWdobmVzcywgZG90TkggKTtcXG5cXHRmbG9hdCBWID0gVl9OZXViZWx0KCBkb3ROViwgZG90TkwgKTtcXG5cXHRyZXR1cm4gc2hlZW5UaW50ICogKCBEICogViApO1xcbn1cXG4jZW5kaWZcIixidW1wbWFwX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcdHZlYzIgZEhkeHlfZndkKCkge1xcblxcdFxcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cXHRcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFx0XFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcblxcdFxcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblxcdFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcdFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcdH1cXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5LCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgdlNpZ21hWCA9IHZlYzMoIGRGZHgoIHN1cmZfcG9zLnggKSwgZEZkeCggc3VyZl9wb3MueSApLCBkRmR4KCBzdXJmX3Bvcy56ICkgKTtcXG5cXHRcXHR2ZWMzIHZTaWdtYVkgPSB2ZWMzKCBkRmR5KCBzdXJmX3Bvcy54ICksIGRGZHkoIHN1cmZfcG9zLnkgKSwgZEZkeSggc3VyZl9wb3MueiApICk7XFxuXFx0XFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXG5cXHRcXHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXFx0XFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcdFxcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICkgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXHR9XFxuI2VuZGlmXCIsY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OlwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dmVjNCBwbGFuZTtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRpZiAoIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FU1xcblxcdFxcdGJvb2wgY2xpcHBlZCA9IHRydWU7XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcXG5cXHRcXHRcXHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0XFx0Y2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdFxcdGlmICggY2xpcHBlZCApIGRpc2NhcmQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ6XCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcIixjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg6XCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG4jZW5kaWZcIixjbGlwcGluZ19wbGFuZXNfdmVydGV4OlwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dkNsaXBQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXCIsY29sb3JfZnJhZ21lbnQ6XCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCIsY29sb3JfcGFyc19mcmFnbWVudDpcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdHZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiLGNvbG9yX3BhcnNfdmVydGV4OlwiI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXFxuXFx0dmFyeWluZyB2ZWM0IHZDb2xvcjtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIixjb2xvcl92ZXJ0ZXg6XCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2Q29sb3IgPSB2ZWM0KCAxLjAgKTtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dkNvbG9yID0gdmVjMyggMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZDb2xvciAqPSBjb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcXG5cXHR2Q29sb3IueHl6ICo9IGluc3RhbmNlQ29sb3IueHl6O1xcbiNlbmRpZlwiLGNvbW1vbjpcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTNcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE3OTU4NlxcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjZcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxODM3OTA3XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0MzA5MTg5NTM1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG4jaWZuZGVmIHNhdHVyYXRlXFxuI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2VuZGlmXFxuI2RlZmluZSB3aGl0ZUNvbXBsZW1lbnQoIGEgKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcbmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH1cXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxuZmxvYXQgbWF4MyggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gbWF4KCBtYXgoIHYueCwgdi55ICksIHYueiApOyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXG5oaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkge1xcblxcdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcXG5cXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcXG5cXHRyZXR1cm4gZnJhY3QoIHNpbiggc24gKSAqIGMgKTtcXG59XFxuI2lmZGVmIEhJR0hfUFJFQ0lTSU9OXFxuXFx0ZmxvYXQgcHJlY2lzaW9uU2FmZUxlbmd0aCggdmVjMyB2ICkgeyByZXR1cm4gbGVuZ3RoKCB2ICk7IH1cXG4jZWxzZVxcblxcdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHtcXG5cXHRcXHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgzKCBhYnMoIHYgKSApO1xcblxcdFxcdHJldHVybiBsZW5ndGgoIHYgLyBtYXhDb21wb25lbnQgKSAqIG1heENvbXBvbmVudDtcXG5cXHR9XFxuI2VuZGlmXFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0Ym9vbCB2aXNpYmxlO1xcbn07XFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxufTtcXG5zdHJ1Y3QgR2VvbWV0cmljQ29udGV4dCB7XFxuXFx0dmVjMyBwb3NpdGlvbjtcXG5cXHR2ZWMzIG5vcm1hbDtcXG5cXHR2ZWMzIHZpZXdEaXI7XFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR2ZWMzIGNsZWFyY29hdE5vcm1hbDtcXG4jZW5kaWZcXG59O1xcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxufVxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG5tYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHtcXG5cXHRtYXQzIHRtcDtcXG5cXHR0bXBbIDAgXSA9IHZlYzMoIG1bIDAgXS54LCBtWyAxIF0ueCwgbVsgMiBdLnggKTtcXG5cXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcXG5cXHR0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTtcXG5cXHRyZXR1cm4gdG1wO1xcbn1cXG5mbG9hdCBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkge1xcblxcdHZlYzMgd2VpZ2h0cyA9IHZlYzMoIDAuMjEyNiwgMC43MTUyLCAwLjA3MjIgKTtcXG5cXHRyZXR1cm4gZG90KCB3ZWlnaHRzLCBjb2xvci5yZ2IgKTtcXG59XFxuYm9vbCBpc1BlcnNwZWN0aXZlTWF0cml4KCBtYXQ0IG0gKSB7XFxuXFx0cmV0dXJuIG1bIDIgXVsgMyBdID09IC0gMS4wO1xcbn1cXG52ZWMyIGVxdWlyZWN0VXYoIGluIHZlYzMgZGlyICkge1xcblxcdGZsb2F0IHUgPSBhdGFuKCBkaXIueiwgZGlyLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdGZsb2F0IHYgPSBhc2luKCBjbGFtcCggZGlyLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXG5cXHRyZXR1cm4gdmVjMiggdSwgdiApO1xcbn1cIixjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6XCIjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVlxcblxcdCNkZWZpbmUgY3ViZVVWX21heE1pcExldmVsIDguMFxcblxcdCNkZWZpbmUgY3ViZVVWX21pbk1pcExldmVsIDQuMFxcblxcdCNkZWZpbmUgY3ViZVVWX21heFRpbGVTaXplIDI1Ni4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluVGlsZVNpemUgMTYuMFxcblxcdGZsb2F0IGdldEZhY2UoIHZlYzMgZGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmYWNlID0gLSAxLjA7XFxuXFx0XFx0aWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkge1xcblxcdFxcdFxcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMC4wIDogMy4wO1xcblxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRpZiAoIGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIuMCA6IDUuMDtcXG5cXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZmFjZTtcXG5cXHR9XFxuXFx0dmVjMiBnZXRVViggdmVjMyBkaXJlY3Rpb24sIGZsb2F0IGZhY2UgKSB7XFxuXFx0XFx0dmVjMiB1djtcXG5cXHRcXHRpZiAoIGZhY2UgPT0gMC4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCAtIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMC41ICogKCB1diArIDEuMCApO1xcblxcdH1cXG5cXHR2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkge1xcblxcdFxcdGZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7XFxuXFx0XFx0bWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApO1xcblxcdFxcdGZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7XFxuXFx0XFx0ZmxvYXQgdGV4ZWxTaXplID0gMS4wIC8gKCAzLjAgKiBjdWJlVVZfbWF4VGlsZVNpemUgKTtcXG5cXHRcXHR2ZWMyIHV2ID0gZ2V0VVYoIGRpcmVjdGlvbiwgZmFjZSApICogKCBmYWNlU2l6ZSAtIDEuMCApO1xcblxcdFxcdHZlYzIgZiA9IGZyYWN0KCB1diApO1xcblxcdFxcdHV2ICs9IDAuNSAtIGY7XFxuXFx0XFx0aWYgKCBmYWNlID4gMi4wICkge1xcblxcdFxcdFxcdHV2LnkgKz0gZmFjZVNpemU7XFxuXFx0XFx0XFx0ZmFjZSAtPSAzLjA7XFxuXFx0XFx0fVxcblxcdFxcdHV2LnggKz0gZmFjZSAqIGZhY2VTaXplO1xcblxcdFxcdGlmICggbWlwSW50IDwgY3ViZVVWX21heE1pcExldmVsICkge1xcblxcdFxcdFxcdHV2LnkgKz0gMi4wICogY3ViZVVWX21heFRpbGVTaXplO1xcblxcdFxcdH1cXG5cXHRcXHR1di55ICs9IGZpbHRlckludCAqIDIuMCAqIGN1YmVVVl9taW5UaWxlU2l6ZTtcXG5cXHRcXHR1di54ICs9IDMuMCAqIG1heCggMC4wLCBjdWJlVVZfbWF4VGlsZVNpemUgLSAyLjAgKiBmYWNlU2l6ZSApO1xcblxcdFxcdHV2ICo9IHRleGVsU2l6ZTtcXG5cXHRcXHR2ZWMzIHRsID0gZW52TWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XFxuXFx0XFx0dXYueCArPSB0ZXhlbFNpemU7XFxuXFx0XFx0dmVjMyB0ciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCggZW52TWFwLCB1diApICkucmdiO1xcblxcdFxcdHV2LnkgKz0gdGV4ZWxTaXplO1xcblxcdFxcdHZlYzMgYnIgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQoIGVudk1hcCwgdXYgKSApLnJnYjtcXG5cXHRcXHR1di54IC09IHRleGVsU2l6ZTtcXG5cXHRcXHR2ZWMzIGJsID0gZW52TWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XFxuXFx0XFx0dmVjMyB0bSA9IG1peCggdGwsIHRyLCBmLnggKTtcXG5cXHRcXHR2ZWMzIGJtID0gbWl4KCBibCwgYnIsIGYueCApO1xcblxcdFxcdHJldHVybiBtaXgoIHRtLCBibSwgZi55ICk7XFxuXFx0fVxcblxcdCNkZWZpbmUgcjAgMS4wXFxuXFx0I2RlZmluZSB2MCAwLjMzOVxcblxcdCNkZWZpbmUgbTAgLSAyLjBcXG5cXHQjZGVmaW5lIHIxIDAuOFxcblxcdCNkZWZpbmUgdjEgMC4yNzZcXG5cXHQjZGVmaW5lIG0xIC0gMS4wXFxuXFx0I2RlZmluZSByNCAwLjRcXG5cXHQjZGVmaW5lIHY0IDAuMDQ2XFxuXFx0I2RlZmluZSBtNCAyLjBcXG5cXHQjZGVmaW5lIHI1IDAuMzA1XFxuXFx0I2RlZmluZSB2NSAwLjAxNlxcblxcdCNkZWZpbmUgbTUgMy4wXFxuXFx0I2RlZmluZSByNiAwLjIxXFxuXFx0I2RlZmluZSB2NiAwLjAwMzhcXG5cXHQjZGVmaW5lIG02IDQuMFxcblxcdGZsb2F0IHJvdWdobmVzc1RvTWlwKCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0ZmxvYXQgbWlwID0gMC4wO1xcblxcdFxcdGlmICggcm91Z2huZXNzID49IHIxICkge1xcblxcdFxcdFxcdG1pcCA9ICggcjAgLSByb3VnaG5lc3MgKSAqICggbTEgLSBtMCApIC8gKCByMCAtIHIxICkgKyBtMDtcXG5cXHRcXHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gcjQgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCByMSAtIHJvdWdobmVzcyApICogKCBtNCAtIG0xICkgLyAoIHIxIC0gcjQgKSArIG0xO1xcblxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSByNSApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIHI0IC0gcm91Z2huZXNzICkgKiAoIG01IC0gbTQgKSAvICggcjQgLSByNSApICsgbTQ7XFxuXFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IHI2ICkge1xcblxcdFxcdFxcdG1pcCA9ICggcjUgLSByb3VnaG5lc3MgKSAqICggbTYgLSBtNSApIC8gKCByNSAtIHI2ICkgKyBtNTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1pcCA9IC0gMi4wICogbG9nMiggMS4xNiAqIHJvdWdobmVzcyApO1xcdFxcdH1cXG5cXHRcXHRyZXR1cm4gbWlwO1xcblxcdH1cXG5cXHR2ZWM0IHRleHR1cmVDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgc2FtcGxlRGlyLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0ZmxvYXQgbWlwID0gY2xhbXAoIHJvdWdobmVzc1RvTWlwKCByb3VnaG5lc3MgKSwgbTAsIGN1YmVVVl9tYXhNaXBMZXZlbCApO1xcblxcdFxcdGZsb2F0IG1pcEYgPSBmcmFjdCggbWlwICk7XFxuXFx0XFx0ZmxvYXQgbWlwSW50ID0gZmxvb3IoIG1pcCApO1xcblxcdFxcdHZlYzMgY29sb3IwID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKTtcXG5cXHRcXHRpZiAoIG1pcEYgPT0gMC4wICkge1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBjb2xvcjAsIDEuMCApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dmVjMyBjb2xvcjEgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCArIDEuMCApO1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBtaXgoIGNvbG9yMCwgY29sb3IxLCBtaXBGICksIDEuMCApO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXCIsZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6XCJ2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gb2JqZWN0Tm9ybWFsO1xcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcdG1hdDMgbSA9IG1hdDMoIGluc3RhbmNlTWF0cml4ICk7XFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgLz0gdmVjMyggZG90KCBtWyAwIF0sIG1bIDAgXSApLCBkb3QoIG1bIDEgXSwgbVsgMSBdICksIGRvdCggbVsgMiBdLCBtWyAyIF0gKSApO1xcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gbSAqIHRyYW5zZm9ybWVkTm9ybWFsO1xcbiNlbmRpZlxcbnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogdHJhbnNmb3JtZWROb3JtYWw7XFxuI2lmZGVmIEZMSVBfU0lERURcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCA9IC0gdHJhbnNmb3JtZWROb3JtYWw7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0dmVjMyB0cmFuc2Zvcm1lZFRhbmdlbnQgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6O1xcblxcdCNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0dHJhbnNmb3JtZWRUYW5nZW50ID0gLSB0cmFuc2Zvcm1lZFRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4OlwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuI2VuZGlmXCIsZGlzcGxhY2VtZW50bWFwX3ZlcnRleDpcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsaXplKCBvYmplY3ROb3JtYWwgKSAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHZVdiApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG4jZW5kaWZcIixlbWlzc2l2ZW1hcF9mcmFnbWVudDpcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGVtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhciggZW1pc3NpdmVDb2xvciApLnJnYjtcXG5cXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXCIsZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudDpcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG4jZW5kaWZcIixlbmNvZGluZ3NfZnJhZ21lbnQ6XCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcIixlbmNvZGluZ3NfcGFyc19mcmFnbWVudDpcIlxcbnZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn1cXG52ZWM0IEdhbW1hVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcblxcdHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS5hICk7XFxufVxcbnZlYzQgTGluZWFyVG9HYW1tYSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAxLjAgLyBnYW1tYUZhY3RvciApICksIHZhbHVlLmEgKTtcXG59XFxudmVjNCBzUkdCVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUuYSApO1xcbn1cXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS5hICk7XFxufVxcbnZlYzQgUkdCRVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiBleHAyKCB2YWx1ZS5hICogMjU1LjAgLSAxMjguMCApLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQkUoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4KCBtYXgoIHZhbHVlLnIsIHZhbHVlLmcgKSwgdmFsdWUuYiApO1xcblxcdGZsb2F0IGZFeHAgPSBjbGFtcCggY2VpbCggbG9nMiggbWF4Q29tcG9uZW50ICkgKSwgLTEyOC4wLCAxMjcuMCApO1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyBleHAyKCBmRXhwICksICggZkV4cCArIDEyOC4wICkgLyAyNTUuMCApO1xcbn1cXG52ZWM0IFJHQk1Ub0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqIHZhbHVlLmEgKiBtYXhSYW5nZSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JNKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLnIsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxuXFx0ZmxvYXQgTSA9IGNsYW1wKCBtYXhSR0IgLyBtYXhSYW5nZSwgMC4wLCAxLjAgKTtcXG5cXHRNID0gY2VpbCggTSAqIDI1NS4wICkgLyAyNTUuMDtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gKCBNICogbWF4UmFuZ2UgKSwgTSApO1xcbn1cXG52ZWM0IFJHQkRUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggKCBtYXhSYW5nZSAvIDI1NS4wICkgLyB2YWx1ZS5hICksIDEuMCApO1xcbn1cXG52ZWM0IExpbmVhclRvUkdCRCggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0ZmxvYXQgbWF4UkdCID0gbWF4KCB2YWx1ZS5yLCBtYXgoIHZhbHVlLmcsIHZhbHVlLmIgKSApO1xcblxcdGZsb2F0IEQgPSBtYXgoIG1heFJhbmdlIC8gbWF4UkdCLCAxLjAgKTtcXG5cXHREID0gY2xhbXAoIGZsb29yKCBEICkgLyAyNTUuMCwgMC4wLCAxLjAgKTtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogKCBEICogKCAyNTUuMCAvIG1heFJhbmdlICkgKSwgRCApO1xcbn1cXG5jb25zdCBtYXQzIGNMb2dMdXZNID0gbWF0MyggMC4yMjA5LCAwLjMzOTAsIDAuNDE4NCwgMC4xMTM4LCAwLjY3ODAsIDAuNzMxOSwgMC4wMTAyLCAwLjExMzAsIDAuMjk2OSApO1xcbnZlYzQgTGluZWFyVG9Mb2dMdXYoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0dmVjMyBYcF9ZX1hZWnAgPSBjTG9nTHV2TSAqIHZhbHVlLnJnYjtcXG5cXHRYcF9ZX1hZWnAgPSBtYXgoIFhwX1lfWFlacCwgdmVjMyggMWUtNiwgMWUtNiwgMWUtNiApICk7XFxuXFx0dmVjNCB2UmVzdWx0O1xcblxcdHZSZXN1bHQueHkgPSBYcF9ZX1hZWnAueHkgLyBYcF9ZX1hZWnAuejtcXG5cXHRmbG9hdCBMZSA9IDIuMCAqIGxvZzIoWHBfWV9YWVpwLnkpICsgMTI3LjA7XFxuXFx0dlJlc3VsdC53ID0gZnJhY3QoIExlICk7XFxuXFx0dlJlc3VsdC56ID0gKCBMZSAtICggZmxvb3IoIHZSZXN1bHQudyAqIDI1NS4wICkgKSAvIDI1NS4wICkgLyAyNTUuMDtcXG5cXHRyZXR1cm4gdlJlc3VsdDtcXG59XFxuY29uc3QgbWF0MyBjTG9nTHV2SW52ZXJzZU0gPSBtYXQzKCA2LjAwMTQsIC0yLjcwMDgsIC0xLjc5OTYsIC0xLjMzMjAsIDMuMTAyOSwgLTUuNzcyMSwgMC4zMDA4LCAtMS4wODgyLCA1LjYyNjggKTtcXG52ZWM0IExvZ0x1dlRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdGZsb2F0IExlID0gdmFsdWUueiAqIDI1NS4wICsgdmFsdWUudztcXG5cXHR2ZWMzIFhwX1lfWFlacDtcXG5cXHRYcF9ZX1hZWnAueSA9IGV4cDIoICggTGUgLSAxMjcuMCApIC8gMi4wICk7XFxuXFx0WHBfWV9YWVpwLnogPSBYcF9ZX1hZWnAueSAvIHZhbHVlLnk7XFxuXFx0WHBfWV9YWVpwLnggPSB2YWx1ZS54ICogWHBfWV9YWVpwLno7XFxuXFx0dmVjMyB2UkdCID0gY0xvZ0x1dkludmVyc2VNICogWHBfWV9YWVpwLnJnYjtcXG5cXHRyZXR1cm4gdmVjNCggbWF4KCB2UkdCLCAwLjAgKSwgMS4wICk7XFxufVwiLGVudm1hcF9mcmFnbWVudDpcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmZGVmIEVOVl9XT1JMRFBPU1xcblxcdFxcdHZlYzMgY2FtZXJhVG9GcmFnO1xcblxcdFxcdGlmICggaXNPcnRob2dyYXBoaWMgKSB7XFxuXFx0XFx0XFx0Y2FtZXJhVG9GcmFnID0gbm9ybWFsaXplKCB2ZWMzKCAtIHZpZXdNYXRyaXhbIDAgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDEgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDIgXVsgMiBdICkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdH1cXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcblxcdFxcdGVudkNvbG9yID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52Q29sb3IgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCByZWZsZWN0VmVjLCAwLjAgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdHVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zaXR5O1xcblxcdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXG5cXHR1bmlmb3JtIGludCBtYXhNaXBMZXZlbDtcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcblxcdCNlbmRpZlxcblxcdFxcbiNlbmRpZlwiLGVudm1hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdCNkZWZpbmUgRU5WX1dPUkxEUE9TXFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVl9XT1JMRFBPU1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixlbnZtYXBfcGFyc192ZXJ0ZXg6XCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHQjZGVmaW5lIEVOVl9XT1JMRFBPU1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6XCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRlJBQ1RJT05cXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZW5kaWZcXG5cXHR2ZWMzIGdldElCTElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgd29ybGROb3JtYWwsIDEuMCApO1xcblxcdFxcdFxcdHJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0dmVjMyBnZXRJQkxSYWRpYW5jZSggY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWM7XFxuXFx0XFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHRcXHRyZWZsZWN0VmVjID0gcmVmbGVjdCggLSB2aWV3RGlyLCBub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRyZWZsZWN0VmVjID0gbm9ybWFsaXplKCBtaXgoIHJlZmxlY3RWZWMsIG5vcm1hbCwgcm91Z2huZXNzICogcm91Z2huZXNzKSApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0cmVmbGVjdFZlYyA9IHJlZnJhY3QoIC0gdmlld0Rpciwgbm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIHJlZmxlY3RWZWMsIHJvdWdobmVzcyApO1xcblxcdFxcdFxcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMyggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlwiLGVudm1hcF92ZXJ0ZXg6XCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleDtcXG5cXHRcXHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xcblxcdFxcdFxcdGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2ZWMzKCAtIHZpZXdNYXRyaXhbIDAgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDEgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDIgXVsgMiBdICkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0fVxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixmb2dfdmVydGV4OlwiI2lmZGVmIFVTRV9GT0dcXG5cXHR2Rm9nRGVwdGggPSAtIG12UG9zaXRpb24uejtcXG4jZW5kaWZcIixmb2dfcGFyc192ZXJ0ZXg6XCIjaWZkZWYgVVNFX0ZPR1xcblxcdHZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoO1xcbiNlbmRpZlwiLGZvZ19mcmFnbWVudDpcIiNpZmRlZiBVU0VfRk9HXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gMS4wIC0gZXhwKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogdkZvZ0RlcHRoICogdkZvZ0RlcHRoICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIHZGb2dEZXB0aCApO1xcblxcdCNlbmRpZlxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG4jZW5kaWZcIixmb2dfcGFyc19mcmFnbWVudDpcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcdHZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoO1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGdyYWRpZW50TWFwO1xcbiNlbmRpZlxcbnZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBsaWdodERpcmVjdGlvbiApO1xcblxcdHZlYzIgY29vcmQgPSB2ZWMyKCBkb3ROTCAqIDAuNSArIDAuNSwgMC4wICk7XFxuXFx0I2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnJnYjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiAoIGNvb3JkLnggPCAwLjcgKSA/IHZlYzMoIDAuNyApIDogdmVjMyggMS4wICk7XFxuXFx0I2VuZGlmXFxufVwiLGxpZ2h0bWFwX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKTtcXG5cXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWxUb0xpbmVhciggbGlnaHRNYXBUZXhlbCApLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGxpZ2h0TWFwSXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcbiNlbmRpZlwiLGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcXG4jZW5kaWZcIixsaWdodHNfbGFtYmVydF92ZXJ0ZXg6XCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSAoIGlzT3J0aG9ncmFwaGljICkgPyB2ZWMzKCAwLCAwLCAxICkgOiBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbnZJbmRpcmVjdEZyb250ID0gdmVjMyggMC4wICk7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2SW5kaXJlY3RCYWNrID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG5mbG9hdCBkb3ROTDtcXG52ZWMzIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG52SW5kaXJlY3RGcm9udCArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcbnZJbmRpcmVjdEZyb250ICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBnZW9tZXRyeS5ub3JtYWwgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dkluZGlyZWN0QmFjayArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGJhY2tHZW9tZXRyeS5ub3JtYWwgKTtcXG4jZW5kaWZcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXRQb2ludExpZ2h0SW5mbyggcG9pbnRMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC0gZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0U3BvdExpZ2h0SW5mbyggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLSBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZJbmRpcmVjdEZyb250ICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBiYWNrR2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXCIsbGlnaHRzX3BhcnNfYmVnaW46XCJ1bmlmb3JtIGJvb2wgcmVjZWl2ZVNoYWRvdztcXG51bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxudW5pZm9ybSB2ZWMzIGxpZ2h0UHJvYmVbIDkgXTtcXG52ZWMzIHNoR2V0SXJyYWRpYW5jZUF0KCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBzaENvZWZmaWNpZW50c1sgOSBdICkge1xcblxcdGZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XFxuXFx0dmVjMyByZXN1bHQgPSBzaENvZWZmaWNpZW50c1sgMCBdICogMC44ODYyMjc7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAxIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAyIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHo7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAzIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHg7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA0IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB5O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDYgXSAqICggMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA3IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB6O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTtcXG5cXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG52ZWMzIGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGxpZ2h0UHJvYmVbIDkgXSwgY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IHNoR2V0SXJyYWRpYW5jZUF0KCB3b3JsZE5vcm1hbCwgbGlnaHRQcm9iZSApO1xcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG52ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxufVxcbmZsb2F0IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcdCNpZiBkZWZpbmVkICggUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUUyApXFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2VGYWxsb2ZmID0gMS4wIC8gbWF4KCBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSwgMC4wMSApO1xcblxcdFxcdGlmICggY3V0b2ZmRGlzdGFuY2UgPiAwLjAgKSB7XFxuXFx0XFx0XFx0ZGlzdGFuY2VGYWxsb2ZmICo9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBkaXN0YW5jZUZhbGxvZmY7XFxuXFx0I2Vsc2VcXG5cXHRcXHRpZiAoIGN1dG9mZkRpc3RhbmNlID4gMC4wICYmIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHBvdyggc2F0dXJhdGUoIC0gbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDEuMDtcXG5cXHQjZW5kaWZcXG59XFxuZmxvYXQgZ2V0U3BvdEF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBjb25lQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBwZW51bWJyYUNvc2luZSwgY29uc3QgaW4gZmxvYXQgYW5nbGVDb3NpbmUgKSB7XFxuXFx0cmV0dXJuIHNtb290aHN0ZXAoIGNvbmVDb3NpbmUsIHBlbnVtYnJhQ29zaW5lLCBhbmdsZUNvc2luZSApO1xcbn1cXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0dm9pZCBnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHRsaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxuXFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXFx0XFx0bGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFBvaW50TGlnaHRJbmZvKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0bGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcblxcdFxcdGxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdHN0cnVjdCBTcG90TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRmbG9hdCBjb25lQ29zO1xcblxcdFxcdGZsb2F0IHBlbnVtYnJhQ29zO1xcblxcdH07XFxuXFx0dW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRTcG90TGlnaHRJbmZvKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBhbmdsZUNvcyA9IGRvdCggbGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZmxvYXQgc3BvdEF0dGVudWF0aW9uID0gZ2V0U3BvdEF0dGVudWF0aW9uKCBzcG90TGlnaHQuY29uZUNvcywgc3BvdExpZ2h0LnBlbnVtYnJhQ29zLCBhbmdsZUNvcyApO1xcblxcdFxcdGlmICggc3BvdEF0dGVudWF0aW9uID4gMC4wICkge1xcblxcdFxcdFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXG5cXHRcXHRcXHRsaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvciAqIHNwb3RBdHRlbnVhdGlvbjtcXG5cXHRcXHRcXHRsaWdodC5jb2xvciAqPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBsaWdodERpc3RhbmNlLCBzcG90TGlnaHQuZGlzdGFuY2UsIHNwb3RMaWdodC5kZWNheSApO1xcblxcdFxcdFxcdGxpZ2h0LnZpc2libGUgPSAoIGxpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRsaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcblxcdFxcdFxcdGxpZ2h0LnZpc2libGUgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgUmVjdEFyZWFMaWdodCB7XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgaGFsZldpZHRoO1xcblxcdFxcdHZlYzMgaGFsZkhlaWdodDtcXG5cXHR9O1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y18xO1xcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y18yO1xcblxcdHVuaWZvcm0gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0c1sgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgXTtcXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblxcdHN0cnVjdCBIZW1pc3BoZXJlTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgc2t5Q29sb3I7XFxuXFx0XFx0dmVjMyBncm91bmRDb2xvcjtcXG5cXHR9O1xcblxcdHVuaWZvcm0gSGVtaXNwaGVyZUxpZ2h0IGhlbWlzcGhlcmVMaWdodHNbIE5VTV9IRU1JX0xJR0hUUyBdO1xcblxcdHZlYzMgZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gSGVtaXNwaGVyZUxpZ2h0IGhlbWlMaWdodCwgY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxuXFx0XFx0dmVjMyBpcnJhZGlhbmNlID0gbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXHRcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG5cXHR9XFxuI2VuZGlmXCIsbGlnaHRzX3Rvb25fZnJhZ21lbnQ6XCJUb29uTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcIixsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50OlwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuc3RydWN0IFRvb25NYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9Ub29uKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEdyYWRpZW50SXJyYWRpYW5jZSggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1Rvb24oIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X1Rvb25cXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9Ub29uXFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFx0KDApXCIsbGlnaHRzX3Bob25nX2ZyYWdtZW50OlwiQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xcbm1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzID0gc2hpbmluZXNzO1xcbm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO1wiLGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OlwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0IHNwZWN1bGFyU2hpbmluZXNzO1xcblxcdGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9CbGlublBob25nKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFx0KDApXCIsbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50OlwiUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLjAgLSBtZXRhbG5lc3NGYWN0b3IgKTtcXG52ZWMzIGR4eSA9IG1heCggYWJzKCBkRmR4KCBnZW9tZXRyeU5vcm1hbCApICksIGFicyggZEZkeSggZ2VvbWV0cnlOb3JtYWwgKSApICk7XFxuZmxvYXQgZ2VvbWV0cnlSb3VnaG5lc3MgPSBtYXgoIG1heCggZHh5LngsIGR4eS55ICksIGR4eS56ICk7XFxubWF0ZXJpYWwucm91Z2huZXNzID0gbWF4KCByb3VnaG5lc3NGYWN0b3IsIDAuMDUyNSApO21hdGVyaWFsLnJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcXG5tYXRlcmlhbC5yb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLnJvdWdobmVzcywgMS4wICk7XFxuI2lmZGVmIElPUlxcblxcdCNpZmRlZiBTUEVDVUxBUlxcblxcdFxcdGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yID0gc3BlY3VsYXJJbnRlbnNpdHk7XFxuXFx0XFx0dmVjMyBzcGVjdWxhclRpbnRGYWN0b3IgPSBzcGVjdWxhclRpbnQ7XFxuXFx0XFx0I2lmZGVmIFVTRV9TUEVDVUxBUklOVEVOU0lUWU1BUFxcblxcdFxcdFxcdHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJJbnRlbnNpdHlNYXAsIHZVdiApLmE7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0I2lmZGVmIFVTRV9TUEVDVUxBUlRJTlRNQVBcXG5cXHRcXHRcXHRzcGVjdWxhclRpbnRGYWN0b3IgKj0gc3BlY3VsYXJUaW50TWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEKCBzcGVjdWxhclRpbnRNYXAsIHZVdiApICkucmdiO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdG1hdGVyaWFsLnNwZWN1bGFyRjkwID0gbWl4KCBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgMS4wLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yID0gMS4wO1xcblxcdFxcdHZlYzMgc3BlY3VsYXJUaW50RmFjdG9yID0gdmVjMyggMS4wICk7XFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggbWluKCBwb3cyKCAoIGlvciAtIDEuMCApIC8gKCBpb3IgKyAxLjAgKSApICogc3BlY3VsYXJUaW50RmFjdG9yLCB2ZWMzKCAxLjAgKSApICogc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcbiNlbHNlXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMC4wNCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdG1hdGVyaWFsLmNsZWFyY29hdCA9IGNsZWFyY29hdDtcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0RjAgPSB2ZWMzKCAwLjA0ICk7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0RjkwID0gMS4wO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0XFx0bWF0ZXJpYWwuY2xlYXJjb2F0ICo9IHRleHR1cmUyRCggY2xlYXJjb2F0TWFwLCB2VXYgKS54O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdFxcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdFJvdWdobmVzc01hcCwgdlV2ICkueTtcXG5cXHQjZW5kaWZcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXQgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuY2xlYXJjb2F0ICk7XFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWF4KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDAuMDUyNSApO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcywgMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTlxcblxcdG1hdGVyaWFsLnNoZWVuVGludCA9IHNoZWVuVGludDtcXG5cXHRtYXRlcmlhbC5zaGVlblJvdWdobmVzcyA9IGNsYW1wKCBzaGVlblJvdWdobmVzcywgMC4wNywgMS4wICk7XFxuI2VuZGlmXCIsbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6XCJzdHJ1Y3QgUGh5c2ljYWxNYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxuXFx0ZmxvYXQgcm91Z2huZXNzO1xcblxcdHZlYzMgc3BlY3VsYXJDb2xvcjtcXG5cXHRmbG9hdCBzcGVjdWxhckY5MDtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGZsb2F0IGNsZWFyY29hdDtcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyBjbGVhcmNvYXRGMDtcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXRGOTA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHZlYzMgc2hlZW5UaW50O1xcblxcdFxcdGZsb2F0IHNoZWVuUm91Z2huZXNzO1xcblxcdCNlbmRpZlxcbn07XFxudmVjMyBjbGVhcmNvYXRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcbnZlYzIgREZHQXBwcm94KCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcblxcdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xcblxcdGNvbnN0IHZlYzQgYzEgPSB2ZWM0KCAxLCAwLjA0MjUsIDEuMDQsIC0gMC4wNCApO1xcblxcdHZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7XFxuXFx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XFxuXFx0dmVjMiBmYWIgPSB2ZWMyKCAtIDEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcblxcdHJldHVybiBmYWI7XFxufVxcbnZlYzMgRW52aXJvbm1lbnRCUkRGKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0dmVjMiBmYWIgPSBERkdBcHByb3goIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxuXFx0cmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBmYWIueCArIHNwZWN1bGFyRjkwICogZmFiLnk7XFxufVxcbnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZyggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkge1xcblxcdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcblxcdHZlYzMgRnNzRXNzID0gc3BlY3VsYXJDb2xvciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcXG5cXHRmbG9hdCBFc3MgPSBmYWIueCArIGZhYi55O1xcblxcdGZsb2F0IEVtcyA9IDEuMCAtIEVzcztcXG5cXHR2ZWMzIEZhdmcgPSBzcGVjdWxhckNvbG9yICsgKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiAwLjA0NzYxOTtcXHR2ZWMzIEZtcyA9IEZzc0VzcyAqIEZhdmcgLyAoIDEuMCAtIEVtcyAqIEZhdmcgKTtcXG5cXHRzaW5nbGVTY2F0dGVyICs9IEZzc0VzcztcXG5cXHRtdWx0aVNjYXR0ZXIgKz0gRm1zICogRW1zO1xcbn1cXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxuXFx0dm9pZCBSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWwoIGNvbnN0IGluIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0XFx0dmVjMyBub3JtYWwgPSBnZW9tZXRyeS5ub3JtYWw7XFxuXFx0XFx0dmVjMyB2aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uID0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0XFx0dmVjMyBsaWdodFBvcyA9IHJlY3RBcmVhTGlnaHQucG9zaXRpb247XFxuXFx0XFx0dmVjMyBoYWxmV2lkdGggPSByZWN0QXJlYUxpZ2h0LmhhbGZXaWR0aDtcXG5cXHRcXHR2ZWMzIGhhbGZIZWlnaHQgPSByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQ7XFxuXFx0XFx0dmVjMyBsaWdodENvbG9yID0gcmVjdEFyZWFMaWdodC5jb2xvcjtcXG5cXHRcXHRmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyByZWN0Q29vcmRzWyA0IF07XFxuXFx0XFx0cmVjdENvb3Jkc1sgMCBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcdFxcdHJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0cmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xcblxcdFxcdHZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxuXFx0XFx0dmVjNCB0MSA9IHRleHR1cmUyRCggbHRjXzEsIHV2ICk7XFxuXFx0XFx0dmVjNCB0MiA9IHRleHR1cmUyRCggbHRjXzIsIHV2ICk7XFxuXFx0XFx0bWF0MyBtSW52ID0gbWF0MyhcXG5cXHRcXHRcXHR2ZWMzKCB0MS54LCAwLCB0MS55ICksXFxuXFx0XFx0XFx0dmVjMyggICAgMCwgMSwgICAgMCApLFxcblxcdFxcdFxcdHZlYzMoIHQxLnosIDAsIHQxLncgKVxcblxcdFxcdCk7XFxuXFx0XFx0dmVjMyBmcmVzbmVsID0gKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogdDIueCArICggdmVjMyggMS4wICkgLSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICkgKiB0Mi55ICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIGZyZXNuZWwgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEuMCApLCByZWN0Q29vcmRzICk7XFxuXFx0fVxcbiNlbmRpZlxcbnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0ZmxvYXQgZG90TkxjYyA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHRcXHR2ZWMzIGNjSXJyYWRpYW5jZSA9IGRvdE5MY2MgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHRjbGVhcmNvYXRTcGVjdWxhciArPSBjY0lycmFkaWFuY2UgKiBCUkRGX0dHWCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5cXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TaGVlbiggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnNoZWVuVGludCwgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1goIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhcmNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQpIHtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNsZWFyY29hdFJhZGlhbmNlICogRW52aXJvbm1lbnRCUkRGKCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgc2luZ2xlU2NhdHRlcmluZyA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgbXVsdGlTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2UgPSBpcnJhZGlhbmNlICogUkVDSVBST0NBTF9QSTtcXG5cXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApO1xcblxcdHZlYzMgZGlmZnVzZSA9IG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqICggMS4wIC0gKCBzaW5nbGVTY2F0dGVyaW5nICsgbXVsdGlTY2F0dGVyaW5nICkgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IHJhZGlhbmNlICogc2luZ2xlU2NhdHRlcmluZztcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IG11bHRpU2NhdHRlcmluZyAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gZGlmZnVzZSAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYVxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyXFx0XFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xcbn1cIixsaWdodHNfZnJhZ21lbnRfYmVnaW46XCJcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbDtcXG5nZW9tZXRyeS52aWV3RGlyID0gKCBpc09ydGhvZ3JhcGhpYyApID8gdmVjMyggMCwgMCwgMSApIDogbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwgPSBjbGVhcmNvYXROb3JtYWw7XFxuI2VuZGlmXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG4jaWYgKCBOVU1fUE9JTlRfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0UG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93O1xcblxcdCNlbmRpZlxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFBvaW50TGlnaHRJbmZvKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRwb2ludExpZ2h0U2hhZG93ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBkaXJlY3RMaWdodC52aXNpYmxlLCByZWNlaXZlU2hhZG93ICkgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0U3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvdztcXG5cXHQjZW5kaWZcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXRTcG90TGlnaHRJbmZvKCBzcG90TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0c3BvdExpZ2h0U2hhZG93ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdExpZ2h0LnZpc2libGUsIHJlY2VpdmVTaGFkb3cgKSApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93Qmlhcywgc3BvdExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvdztcXG5cXHQjZW5kaWZcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBkaXJlY3RMaWdodC52aXNpYmxlLCByZWNlaXZlU2hhZG93ICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiAoIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdF9SZWN0QXJlYSApXFxuXFx0UmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0O1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcXG5cXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWEoIHJlY3RBcmVhTGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHR2ZWMzIGlibElycmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGdlb21ldHJ5Lm5vcm1hbCApO1xcblxcdCNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0XFx0aXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Lm5vcm1hbCApO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXHR2ZWMzIHJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBjbGVhcmNvYXRSYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcbiNlbmRpZlwiLGxpZ2h0c19mcmFnbWVudF9tYXBzOlwiI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKTtcXG5cXHRcXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWxUb0xpbmVhciggbGlnaHRNYXBUZXhlbCApLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdFxcdGxpZ2h0TWFwSXJyYWRpYW5jZSAqPSBQSTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRpcnJhZGlhbmNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEICkgJiYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0aWJsSXJyYWRpYW5jZSArPSBnZXRJQkxJcnJhZGlhbmNlKCBnZW9tZXRyeS5ub3JtYWwgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0Y2xlYXJjb2F0UmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsbGlnaHRzX2ZyYWdtZW50X2VuZDpcIiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgaWJsSXJyYWRpYW5jZSwgY2xlYXJjb2F0UmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcIixsb2dkZXB0aGJ1Zl9mcmFnbWVudDpcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcXG5cXHRnbF9GcmFnRGVwdGhFWFQgPSB2SXNQZXJzcGVjdGl2ZSA9PSAwLjAgPyBnbF9GcmFnQ29vcmQueiA6IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuI2VuZGlmXCIsbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDpcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdHZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7XFxuI2VuZGlmXCIsbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg6XCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2SXNQZXJzcGVjdGl2ZTtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixsb2dkZXB0aGJ1Zl92ZXJ0ZXg6XCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXHRcXHR2SXNQZXJzcGVjdGl2ZSA9IGZsb2F0KCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGlmICggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICkge1xcblxcdFxcdFxcdGdsX1Bvc2l0aW9uLnogPSBsb2cyKCBtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSApICogbG9nRGVwdGhCdWZGQyAtIDEuMDtcXG5cXHRcXHRcXHRnbF9Qb3NpdGlvbi56ICo9IGdsX1Bvc2l0aW9uLnc7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlwiLG1hcF9mcmFnbWVudDpcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcdHRleGVsQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhlbENvbG9yICk7XFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuI2VuZGlmXCIsbWFwX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcIixtYXBfcGFydGljbGVfZnJhZ21lbnQ6XCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFx0dmVjMiB1diA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9NQVBcXG5cXHR2ZWM0IG1hcFRleGVsID0gdGV4dHVyZTJEKCBtYXAsIHV2ICk7XFxuXFx0ZGlmZnVzZUNvbG9yICo9IG1hcFRleGVsVG9MaW5lYXIoIG1hcFRleGVsICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHV2ICkuZztcXG4jZW5kaWZcIixtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDpcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXHR1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlwiLG1ldGFsbmVzc21hcF9mcmFnbWVudDpcImZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzcztcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICk7XFxuXFx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLmI7XFxuI2VuZGlmXCIsbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcXG4jZW5kaWZcIixtb3JwaG5vcm1hbF92ZXJ0ZXg6XCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblxcdG9iamVjdE5vcm1hbCAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XFxuXFx0I2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPiAwLjAgKSBvYmplY3ROb3JtYWwgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAxLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwwICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0XFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdFxcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDIgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHRcXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwzICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6XCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdCNpZmRlZiBNT1JQSFRBUkdFVFNfVEVYVFVSRVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTtcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyREFycmF5IG1vcnBoVGFyZ2V0c1RleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSB2ZWMyIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplO1xcblxcdFxcdHZlYzMgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQsIGNvbnN0IGluIGludCBzdHJpZGUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgdGV4ZWxJbmRleCA9IGZsb2F0KCB2ZXJ0ZXhJbmRleCAqIHN0cmlkZSArIG9mZnNldCApO1xcblxcdFxcdFxcdGZsb2F0IHkgPSBmbG9vciggdGV4ZWxJbmRleCAvIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplLnggKTtcXG5cXHRcXHRcXHRmbG9hdCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdFxcdHZlYzMgbW9ycGhVViA9IHZlYzMoICggeCArIDAuNSApIC8gbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueCwgeSAvIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplLnksIG1vcnBoVGFyZ2V0SW5kZXggKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZSggbW9ycGhUYXJnZXRzVGV4dHVyZSwgbW9ycGhVViApLnh5ejtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRcXHRcXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixtb3JwaHRhcmdldF92ZXJ0ZXg6XCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHRyYW5zZm9ybWVkICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHQjaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkVcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0XFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0XFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSA+IDAuMCApIHRyYW5zZm9ybWVkICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMCwgMSApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdID4gMC4wICkgdHJhbnNmb3JtZWQgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAwLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDAgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDEgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDIgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDMgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXHRcXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDQgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDUgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDYgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDcgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixub3JtYWxfZnJhZ21lbnRfYmVnaW46XCJmbG9hdCBmYWNlRGlyZWN0aW9uID0gZ2xfRnJvbnRGYWNpbmcgPyAxLjAgOiAtIDEuMDtcXG4jaWZkZWYgRkxBVF9TSEFERURcXG5cXHR2ZWMzIGZkeCA9IHZlYzMoIGRGZHgoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeCggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG4jZWxzZVxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqIGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmVjMyB0YW5nZW50ID0gbm9ybWFsaXplKCB2VGFuZ2VudCApO1xcblxcdFxcdHZlYzMgYml0YW5nZW50ID0gbm9ybWFsaXplKCB2Qml0YW5nZW50ICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHRhbmdlbnQgPSB0YW5nZW50ICogZmFjZURpcmVjdGlvbjtcXG5cXHRcXHRcXHRiaXRhbmdlbnQgPSBiaXRhbmdlbnQgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCNpZiBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKVxcblxcdFxcdFxcdG1hdDMgdlRCTiA9IG1hdDMoIHRhbmdlbnQsIGJpdGFuZ2VudCwgbm9ybWFsICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxudmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDtcIixub3JtYWxfZnJhZ21lbnRfbWFwczpcIiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcXG5cXHRub3JtYWwgPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdCNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0bm9ybWFsID0gLSBub3JtYWw7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqIGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuXFx0bm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcXG4jZWxpZiBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcXG5cXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdG1hcE4ueHkgKj0gbm9ybWFsU2NhbGU7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsaXplKCB2VEJOICogbWFwTiApO1xcblxcdCNlbHNlXFxuXFx0XFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBtYXBOLCBmYWNlRGlyZWN0aW9uICk7XFxuXFx0I2VuZGlmXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSwgZmFjZURpcmVjdGlvbiApO1xcbiNlbmRpZlwiLG5vcm1hbF9wYXJzX2ZyYWdtZW50OlwiI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdkJpdGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixub3JtYWxfcGFyc192ZXJ0ZXg6XCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiLG5vcm1hbF92ZXJ0ZXg6XCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWRUYW5nZW50ICk7XFxuXFx0XFx0dkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixub3JtYWxtYXBfcGFyc19mcmFnbWVudDpcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblxcdHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcXG4jZW5kaWZcXG4jaWZkZWYgT0JKRUNUU1BBQ0VfTk9STUFMTUFQXFxuXFx0dW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcXG4jZW5kaWZcXG4jaWYgISBkZWZpbmVkICggVVNFX1RBTkdFTlQgKSAmJiAoIGRlZmluZWQgKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgKVxcblxcdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzMgbWFwTiwgZmxvYXQgZmFjZURpcmVjdGlvbiApIHtcXG5cXHRcXHR2ZWMzIHEwID0gdmVjMyggZEZkeCggZXllX3Bvcy54ICksIGRGZHgoIGV5ZV9wb3MueSApLCBkRmR4KCBleWVfcG9zLnogKSApO1xcblxcdFxcdHZlYzMgcTEgPSB2ZWMzKCBkRmR5KCBleWVfcG9zLnggKSwgZEZkeSggZXllX3Bvcy55ICksIGRGZHkoIGV5ZV9wb3MueiApICk7XFxuXFx0XFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcdFxcdHZlYzMgTiA9IHN1cmZfbm9ybTtcXG5cXHRcXHR2ZWMzIHExcGVycCA9IGNyb3NzKCBxMSwgTiApO1xcblxcdFxcdHZlYzMgcTBwZXJwID0gY3Jvc3MoIE4sIHEwICk7XFxuXFx0XFx0dmVjMyBUID0gcTFwZXJwICogc3QwLnggKyBxMHBlcnAgKiBzdDEueDtcXG5cXHRcXHR2ZWMzIEIgPSBxMXBlcnAgKiBzdDAueSArIHEwcGVycCAqIHN0MS55O1xcblxcdFxcdGZsb2F0IGRldCA9IG1heCggZG90KCBULCBUICksIGRvdCggQiwgQiApICk7XFxuXFx0XFx0ZmxvYXQgc2NhbGUgPSAoIGRldCA9PSAwLjAgKSA/IDAuMCA6IGZhY2VEaXJlY3Rpb24gKiBpbnZlcnNlc3FydCggZGV0ICk7XFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggVCAqICggbWFwTi54ICogc2NhbGUgKSArIEIgKiAoIG1hcE4ueSAqIHNjYWxlICkgKyBOICogbWFwTi56ICk7XFxuXFx0fVxcbiNlbmRpZlwiLGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW46XCIjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdHZlYzMgY2xlYXJjb2F0Tm9ybWFsID0gZ2VvbWV0cnlOb3JtYWw7XFxuI2VuZGlmXCIsY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzOlwiI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0dmVjMyBjbGVhcmNvYXRNYXBOID0gdGV4dHVyZTJEKCBjbGVhcmNvYXROb3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRjbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdGNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdlRCTiAqIGNsZWFyY29hdE1hcE4gKTtcXG5cXHQjZWxzZVxcblxcdFxcdGNsZWFyY29hdE5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtIHZWaWV3UG9zaXRpb24sIGNsZWFyY29hdE5vcm1hbCwgY2xlYXJjb2F0TWFwTiwgZmFjZURpcmVjdGlvbiApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiLGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXRNYXA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0Um91Z2huZXNzTWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgY2xlYXJjb2F0Tm9ybWFsU2NhbGU7XFxuI2VuZGlmXCIsb3V0cHV0X2ZyYWdtZW50OlwiI2lmZGVmIE9QQVFVRVxcbmRpZmZ1c2VDb2xvci5hID0gMS4wO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuZGlmZnVzZUNvbG9yLmEgKj0gdHJhbnNtaXNzaW9uQWxwaGEgKyAwLjE7XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixwYWNraW5nOlwidmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xcbn1cXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXG5cXHRyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDtcXG59XFxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2LjtcXG5jb25zdCB2ZWMzIFBhY2tGYWN0b3JzID0gdmVjMyggMjU2LiAqIDI1Ni4gKiAyNTYuLCAyNTYuICogMjU2LiwgMjU2LiApO1xcbmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9ycyA9IFVucGFja0Rvd25zY2FsZSAvIHZlYzQoIFBhY2tGYWN0b3JzLCAxLiApO1xcbmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuO1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBKCBjb25zdCBpbiBmbG9hdCB2ICkge1xcblxcdHZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApO1xcblxcdHIueXp3IC09IHIueHl6ICogU2hpZnRSaWdodDg7XFx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcXG59XFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XFxufVxcbnZlYzQgcGFjazJIYWxmVG9SR0JBKCB2ZWMyIHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggdi54LCBmcmFjdCggdi54ICogMjU1LjAgKSwgdi55LCBmcmFjdCggdi55ICogMjU1LjAgKSApO1xcblxcdHJldHVybiB2ZWM0KCByLnggLSByLnkgLyAyNTUuMCwgci55LCByLnogLSByLncgLyAyNTUuMCwgci53ICk7XFxufVxcbnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gdmVjMiggdi54ICsgKCB2LnkgLyAyNTUuMCApLCB2LnogKyAoIHYudyAvIDI1NS4wICkgKTtcXG59XFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxufVxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gbGluZWFyQ2xpcFogKiAoIG5lYXIgLSBmYXIgKSAtIG5lYXI7XFxufVxcbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoICggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiB2aWV3WiApO1xcbn1cXG5mbG9hdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgaW52Q2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogaW52Q2xpcFogLSBmYXIgKTtcXG59XCIscHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudDpcIiNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTtcXG4jZW5kaWZcIixwcm9qZWN0X3ZlcnRleDpcInZlYzQgbXZQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRtdlBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiBtdlBvc2l0aW9uO1xcbiNlbmRpZlxcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBtdlBvc2l0aW9uO1xcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsZGl0aGVyaW5nX2ZyYWdtZW50OlwiI2lmZGVmIERJVEhFUklOR1xcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBkaXRoZXJpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXG4jZW5kaWZcIixkaXRoZXJpbmdfcGFyc19mcmFnbWVudDpcIiNpZmRlZiBESVRIRVJJTkdcXG5cXHR2ZWMzIGRpdGhlcmluZyggdmVjMyBjb2xvciApIHtcXG5cXHRcXHRmbG9hdCBncmlkX3Bvc2l0aW9uID0gcmFuZCggZ2xfRnJhZ0Nvb3JkLnh5ICk7XFxuXFx0XFx0dmVjMyBkaXRoZXJfc2hpZnRfUkdCID0gdmVjMyggMC4yNSAvIDI1NS4wLCAtMC4yNSAvIDI1NS4wLCAwLjI1IC8gMjU1LjAgKTtcXG5cXHRcXHRkaXRoZXJfc2hpZnRfUkdCID0gbWl4KCAyLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCAtMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgZ3JpZF9wb3NpdGlvbiApO1xcblxcdFxcdHJldHVybiBjb2xvciArIGRpdGhlcl9zaGlmdF9SR0I7XFxuXFx0fVxcbiNlbmRpZlwiLHJvdWdobmVzc21hcF9mcmFnbWVudDpcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxuI2VuZGlmXCIscm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcXG4jZW5kaWZcIixzaGFkb3dtYXBfcGFyc19mcmFnbWVudDpcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFBvaW50TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdGZsb2F0IHRleHR1cmUyRENvbXBhcmUoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxuXFx0XFx0cmV0dXJuIHN0ZXAoIGNvbXBhcmUsIHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIGRlcHRocywgdXYgKSApICk7XFxuXFx0fVxcblxcdHZlYzIgdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2ICkge1xcblxcdFxcdHJldHVybiB1bnBhY2tSR0JBVG8ySGFsZiggdGV4dHVyZTJEKCBzaGFkb3csIHV2ICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgVlNNU2hhZG93IChzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICl7XFxuXFx0XFx0ZmxvYXQgb2NjbHVzaW9uID0gMS4wO1xcblxcdFxcdHZlYzIgZGlzdHJpYnV0aW9uID0gdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzaGFkb3csIHV2ICk7XFxuXFx0XFx0ZmxvYXQgaGFyZF9zaGFkb3cgPSBzdGVwKCBjb21wYXJlICwgZGlzdHJpYnV0aW9uLnggKTtcXG5cXHRcXHRpZiAoaGFyZF9zaGFkb3cgIT0gMS4wICkge1xcblxcdFxcdFxcdGZsb2F0IGRpc3RhbmNlID0gY29tcGFyZSAtIGRpc3RyaWJ1dGlvbi54IDtcXG5cXHRcXHRcXHRmbG9hdCB2YXJpYW5jZSA9IG1heCggMC4wMDAwMCwgZGlzdHJpYnV0aW9uLnkgKiBkaXN0cmlidXRpb24ueSApO1xcblxcdFxcdFxcdGZsb2F0IHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkaXN0YW5jZSAqIGRpc3RhbmNlICk7XFx0XFx0XFx0c29mdG5lc3NfcHJvYmFiaWxpdHkgPSBjbGFtcCggKCBzb2Z0bmVzc19wcm9iYWJpbGl0eSAtIDAuMyApIC8gKCAwLjk1IC0gMC4zICksIDAuMCwgMS4wICk7XFx0XFx0XFx0b2NjbHVzaW9uID0gY2xhbXAoIG1heCggaGFyZF9zaGFkb3csIHNvZnRuZXNzX3Byb2JhYmlsaXR5ICksIDAuMCwgMS4wICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBvY2NsdXNpb247XFxuXFx0fVxcblxcdGZsb2F0IGdldFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7XFxuXFx0XFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcblxcdFxcdHNoYWRvd0Nvb3JkLnh5eiAvPSBzaGFkb3dDb29yZC53O1xcblxcdFxcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhcztcXG5cXHRcXHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXFx0XFx0Ym9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1xcblxcdFxcdGJ2ZWMyIGZydXN0dW1UZXN0VmVjID0gYnZlYzIoIGluRnJ1c3R1bSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXHRcXHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcdFxcdGlmICggZnJ1c3R1bVRlc3QgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDIgPSBkeDAgLyAyLjA7XFxuXFx0XFx0XFx0ZmxvYXQgZHkyID0gZHkwIC8gMi4wO1xcblxcdFxcdFxcdGZsb2F0IGR4MyA9IGR4MSAvIDIuMDtcXG5cXHRcXHRcXHRmbG9hdCBkeTMgPSBkeTEgLyAyLjA7XFxuXFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDE3LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHggPSB0ZXhlbFNpemUueDtcXG5cXHRcXHRcXHRmbG9hdCBkeSA9IHRleGVsU2l6ZS55O1xcblxcdFxcdFxcdHZlYzIgdXYgPSBzaGFkb3dDb29yZC54eTtcXG5cXHRcXHRcXHR2ZWMyIGYgPSBmcmFjdCggdXYgKiBzaGFkb3dNYXBTaXplICsgMC41ICk7XFxuXFx0XFx0XFx0dXYgLT0gZiAqIHRleGVsU2l6ZTtcXG5cXHRcXHRcXHRzaGFkb3cgPSAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHRleGVsU2l6ZSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueCApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnggKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAtZHkgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnkgKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55ICkgK1xcblxcdFxcdFxcdFxcdG1peCggbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHRcXHQgIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgIGYueCApLFxcblxcdFxcdFxcdFxcdFxcdCBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgIGYueCApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnkgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApXFxuXFx0XFx0XFx0c2hhZG93ID0gVlNNU2hhZG93KCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRzaGFkb3cgPSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBzaGFkb3c7XFxuXFx0fVxcblxcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cXHRcXHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXHRcXHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXG5cXHRcXHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblxcdFxcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXG5cXHRcXHR2ZWMyIHBsYW5hciA9IHYueHk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxuXFx0XFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGlmICggdi56ID4gMC4wIClcXG5cXHRcXHRcXHRcXHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblxcdFxcdFxcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7XFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTtcXG5cXHRcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejtcXG5cXHRcXHRmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0NhbWVyYU5lYXIgKSAvICggc2hhZG93Q2FtZXJhRmFyIC0gc2hhZG93Q2FtZXJhTmVhciApO1xcdFxcdGRwICs9IHNoYWRvd0JpYXM7XFxuXFx0XFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9WU00gKVxcblxcdFxcdFxcdHZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlwiLHNoYWRvd21hcF9wYXJzX3ZlcnRleDpcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFNwb3RMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFBvaW50TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiLHNoYWRvd21hcF92ZXJ0ZXg6XCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwIHx8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwIHx8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHZlYzMgc2hhZG93V29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdHZlYzQgc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xcblxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogc3BvdExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIHBvaW50TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xcblxcdFxcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIixzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ6XCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcblxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuXFx0cmV0dXJuIHNoYWRvdztcXG59XCIsc2tpbmJhc2VfdmVydGV4OlwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcbiNlbmRpZlwiLHNraW5uaW5nX3BhcnNfdmVydGV4OlwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFx0XFx0dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVTaXplO1xcblxcdFxcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXHRcXHRcXHRmbG9hdCBqID0gaSAqIDQuMDtcXG5cXHRcXHRcXHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXG5cXHRcXHRcXHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXG5cXHRcXHRcXHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXG5cXHRcXHRcXHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXG5cXHRcXHRcXHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXHRcXHRcXHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIG1hdDQgYm9uZU1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gYm9uZU1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsc2tpbm5pbmdfdmVydGV4OlwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXFx0dHJhbnNmb3JtZWQgPSAoIGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZCApLnh5ejtcXG4jZW5kaWZcIixza2lubm9ybWFsX3ZlcnRleDpcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblxcdHNraW5NYXRyaXggPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdG9iamVjdFRhbmdlbnQgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCIsc3BlY3VsYXJtYXBfZnJhZ21lbnQ6XCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcbiNlbHNlXFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIixzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcbiNlbmRpZlwiLHRvbmVtYXBwaW5nX2ZyYWdtZW50OlwiI2lmIGRlZmluZWQoIFRPTkVfTUFQUElORyApXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxuI2VuZGlmXCIsdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDpcIiNpZm5kZWYgc2F0dXJhdGVcXG4jZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRyZXR1cm4gdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yO1xcbn1cXG52ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXG59XFxudmVjMyBPcHRpbWl6ZWRDaW5lb25Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdGNvbG9yID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgLSAwLjAwNCApO1xcblxcdHJldHVybiBwb3coICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMC41ICkgKSAvICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMS43ICkgKyAwLjA2ICksIHZlYzMoIDIuMiApICk7XFxufVxcbnZlYzMgUlJUQW5kT0RURml0KCB2ZWMzIHYgKSB7XFxuXFx0dmVjMyBhID0gdiAqICggdiArIDAuMDI0NTc4NiApIC0gMC4wMDAwOTA1Mzc7XFxuXFx0dmVjMyBiID0gdiAqICggMC45ODM3MjkgKiB2ICsgMC40MzI5NTEwICkgKyAwLjIzODA4MTtcXG5cXHRyZXR1cm4gYSAvIGI7XFxufVxcbnZlYzMgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbnN0IG1hdDMgQUNFU0lucHV0TWF0ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKCAwLjU5NzE5LCAwLjA3NjAwLCAwLjAyODQwICksXFx0XFx0dmVjMyggMC4zNTQ1OCwgMC45MDgzNCwgMC4xMzM4MyApLFxcblxcdFxcdHZlYzMoIDAuMDQ4MjMsIDAuMDE1NjYsIDAuODM3NzcgKVxcblxcdCk7XFxuXFx0Y29uc3QgbWF0MyBBQ0VTT3V0cHV0TWF0ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKCAgMS42MDQ3NSwgLTAuMTAyMDgsIC0wLjAwMzI3ICksXFx0XFx0dmVjMyggLTAuNTMxMDgsICAxLjEwODEzLCAtMC4wNzI3NiApLFxcblxcdFxcdHZlYzMoIC0wLjA3MzY3LCAtMC4wMDYwNSwgIDEuMDc2MDIgKVxcblxcdCk7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZSAvIDAuNjtcXG5cXHRjb2xvciA9IEFDRVNJbnB1dE1hdCAqIGNvbG9yO1xcblxcdGNvbG9yID0gUlJUQW5kT0RURml0KCBjb2xvciApO1xcblxcdGNvbG9yID0gQUNFU091dHB1dE1hdCAqIGNvbG9yO1xcblxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgKTtcXG59XFxudmVjMyBDdXN0b21Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHsgcmV0dXJuIGNvbG9yOyB9XCIsdHJhbnNtaXNzaW9uX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHRmbG9hdCB0cmFuc21pc3Npb25BbHBoYSA9IDEuMDtcXG5cXHRmbG9hdCB0cmFuc21pc3Npb25GYWN0b3IgPSB0cmFuc21pc3Npb247XFxuXFx0ZmxvYXQgdGhpY2tuZXNzRmFjdG9yID0gdGhpY2tuZXNzO1xcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0XFx0dHJhbnNtaXNzaW9uRmFjdG9yICo9IHRleHR1cmUyRCggdHJhbnNtaXNzaW9uTWFwLCB2VXYgKS5yO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0dGhpY2tuZXNzRmFjdG9yICo9IHRleHR1cmUyRCggdGhpY2tuZXNzTWFwLCB2VXYgKS5nO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247XFxuXFx0dmVjMyB2ID0gbm9ybWFsaXplKCBjYW1lcmFQb3NpdGlvbiAtIHBvcyApO1xcblxcdHZlYzMgbiA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzQgdHJhbnNtaXNzaW9uID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcXG5cXHRcXHRuLCB2LCByb3VnaG5lc3NGYWN0b3IsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXFxuXFx0XFx0cG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgaW9yLCB0aGlja25lc3NGYWN0b3IsXFxuXFx0XFx0YXR0ZW51YXRpb25UaW50LCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7XFxuXFx0dG90YWxEaWZmdXNlID0gbWl4KCB0b3RhbERpZmZ1c2UsIHRyYW5zbWlzc2lvbi5yZ2IsIHRyYW5zbWlzc2lvbkZhY3RvciApO1xcblxcdHRyYW5zbWlzc2lvbkFscGhhID0gbWl4KCB0cmFuc21pc3Npb25BbHBoYSwgdHJhbnNtaXNzaW9uLmEsIHRyYW5zbWlzc2lvbkZhY3RvciApO1xcbiNlbmRpZlwiLHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR1bmlmb3JtIGZsb2F0IHRyYW5zbWlzc2lvbjtcXG5cXHR1bmlmb3JtIGZsb2F0IHRoaWNrbmVzcztcXG5cXHR1bmlmb3JtIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0dW5pZm9ybSB2ZWMzIGF0dGVudWF0aW9uVGludDtcXG5cXHQjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvbk1hcDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1RISUNLTkVTU01BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHRoaWNrbmVzc01hcDtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIHZlYzIgdHJhbnNtaXNzaW9uU2FtcGxlclNpemU7XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgdHJhbnNtaXNzaW9uU2FtcGxlck1hcDtcXG5cXHR1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XFxuXFx0dW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxuXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdHZlYzMgZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCB2ZWMzIG4sIHZlYzMgdiwgZmxvYXQgdGhpY2tuZXNzLCBmbG9hdCBpb3IsIG1hdDQgbW9kZWxNYXRyaXggKSB7XFxuXFx0XFx0dmVjMyByZWZyYWN0aW9uVmVjdG9yID0gcmVmcmFjdCggLSB2LCBub3JtYWxpemUoIG4gKSwgMS4wIC8gaW9yICk7XFxuXFx0XFx0dmVjMyBtb2RlbFNjYWxlO1xcblxcdFxcdG1vZGVsU2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54eXogKSApO1xcblxcdFxcdG1vZGVsU2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54eXogKSApO1xcblxcdFxcdG1vZGVsU2NhbGUueiA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDIgXS54eXogKSApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIHJlZnJhY3Rpb25WZWN0b3IgKSAqIHRoaWNrbmVzcyAqIG1vZGVsU2NhbGU7XFxuXFx0fVxcblxcdGZsb2F0IGFwcGx5SW9yVG9Sb3VnaG5lc3MoIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgaW9yICkge1xcblxcdFxcdHJldHVybiByb3VnaG5lc3MgKiBjbGFtcCggaW9yICogMi4wIC0gMi4wLCAwLjAsIDEuMCApO1xcblxcdH1cXG5cXHR2ZWM0IGdldFRyYW5zbWlzc2lvblNhbXBsZSggdmVjMiBmcmFnQ29vcmQsIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgaW9yICkge1xcblxcdFxcdGZsb2F0IGZyYW1lYnVmZmVyTG9kID0gbG9nMiggdHJhbnNtaXNzaW9uU2FtcGxlclNpemUueCApICogYXBwbHlJb3JUb1JvdWdobmVzcyggcm91Z2huZXNzLCBpb3IgKTtcXG5cXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRExvZEVYVCggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBmcmFtZWJ1ZmZlckxvZCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRCggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBmcmFtZWJ1ZmZlckxvZCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHR2ZWMzIGFwcGx5Vm9sdW1lQXR0ZW51YXRpb24oIHZlYzMgcmFkaWFuY2UsIGZsb2F0IHRyYW5zbWlzc2lvbkRpc3RhbmNlLCB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7XFxuXFx0XFx0aWYgKCBhdHRlbnVhdGlvbkRpc3RhbmNlID09IDAuMCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcmFkaWFuY2U7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2ZWMzIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgPSAtbG9nKCBhdHRlbnVhdGlvbkNvbG9yICkgLyBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcblxcdFxcdFxcdHZlYzMgdHJhbnNtaXR0YW5jZSA9IGV4cCggLSBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ICogdHJhbnNtaXNzaW9uRGlzdGFuY2UgKTtcXHRcXHRcXHRyZXR1cm4gdHJhbnNtaXR0YW5jZSAqIHJhZGlhbmNlO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0dmVjNCBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKCB2ZWMzIG4sIHZlYzMgdiwgZmxvYXQgcm91Z2huZXNzLCB2ZWMzIGRpZmZ1c2VDb2xvciwgdmVjMyBzcGVjdWxhckNvbG9yLCBmbG9hdCBzcGVjdWxhckY5MCxcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uLCBtYXQ0IG1vZGVsTWF0cml4LCBtYXQ0IHZpZXdNYXRyaXgsIG1hdDQgcHJvak1hdHJpeCwgZmxvYXQgaW9yLCBmbG9hdCB0aGlja25lc3MsXFxuXFx0XFx0dmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xcblxcdFxcdHZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcXG5cXHRcXHR2ZWMzIHJlZnJhY3RlZFJheUV4aXQgPSBwb3NpdGlvbiArIHRyYW5zbWlzc2lvblJheTtcXG5cXHRcXHR2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7XFxuXFx0XFx0dmVjMiByZWZyYWN0aW9uQ29vcmRzID0gbmRjUG9zLnh5IC8gbmRjUG9zLnc7XFxuXFx0XFx0cmVmcmFjdGlvbkNvb3JkcyArPSAxLjA7XFxuXFx0XFx0cmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7XFxuXFx0XFx0dmVjNCB0cmFuc21pdHRlZExpZ2h0ID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApO1xcblxcdFxcdHZlYzMgYXR0ZW51YXRlZENvbG9yID0gYXBwbHlWb2x1bWVBdHRlbnVhdGlvbiggdHJhbnNtaXR0ZWRMaWdodC5yZ2IsIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKTtcXG5cXHRcXHR2ZWMzIEYgPSBFbnZpcm9ubWVudEJSREYoIG4sIHYsIHNwZWN1bGFyQ29sb3IsIHNwZWN1bGFyRjkwLCByb3VnaG5lc3MgKTtcXG5cXHRcXHRyZXR1cm4gdmVjNCggKCAxLjAgLSBGICkgKiBhdHRlbnVhdGVkQ29sb3IgKiBkaWZmdXNlQ29sb3IsIHRyYW5zbWl0dGVkTGlnaHQuYSApO1xcblxcdH1cXG4jZW5kaWZcIix1dl9wYXJzX2ZyYWdtZW50OlwiI2lmICggZGVmaW5lZCggVVNFX1VWICkgJiYgISBkZWZpbmVkKCBVVlNfVkVSVEVYX09OTFkgKSApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcIix1dl9wYXJzX3ZlcnRleDpcIiNpZmRlZiBVU0VfVVZcXG5cXHQjaWZkZWYgVVZTX1ZFUlRFWF9PTkxZXFxuXFx0XFx0dmVjMiB2VXY7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXG4jZW5kaWZcIix1dl92ZXJ0ZXg6XCIjaWZkZWYgVVNFX1VWXFxuXFx0dlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTtcXG4jZW5kaWZcIix1djJfcGFyc19mcmFnbWVudDpcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcbiNlbmRpZlwiLHV2Ml9wYXJzX3ZlcnRleDpcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXHR1bmlmb3JtIG1hdDMgdXYyVHJhbnNmb3JtO1xcbiNlbmRpZlwiLHV2Ml92ZXJ0ZXg6XCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHR2VXYyID0gKCB1djJUcmFuc2Zvcm0gKiB2ZWMzKCB1djIsIDEgKSApLnh5O1xcbiNlbmRpZlwiLHdvcmxkcG9zX3ZlcnRleDpcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggRElTVEFOQ0UgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApIHx8IGRlZmluZWQgKCBVU0VfVFJBTlNNSVNTSU9OIClcXG5cXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0I2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFx0XFx0d29ybGRQb3NpdGlvbiA9IGluc3RhbmNlTWF0cml4ICogd29ybGRQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHR3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcbiNlbmRpZlwiLGJhY2tncm91bmRfdmVydDpcInZhcnlpbmcgdmVjMiB2VXY7XFxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcblxcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24ueHksIDEuMCwgMS4wICk7XFxufVwiLGJhY2tncm91bmRfZnJhZzpcInVuaWZvcm0gc2FtcGxlcjJEIHQyRDtcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKCB0MkQsIHZVdiApO1xcblxcdGdsX0ZyYWdDb2xvciA9IG1hcFRleGVsVG9MaW5lYXIoIHRleENvbG9yICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxufVwiLGN1YmVfdmVydDpcInZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHRnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udztcXG59XCIsY3ViZV9mcmFnOlwiI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIHZSZWZsZWN0ID0gdldvcmxkRGlyZWN0aW9uO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gZW52Q29sb3I7XFxuXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG59XCIsZGVwdGhfdmVydDpcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVztcXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2SGlnaFByZWNpc2lvblpXID0gZ2xfUG9zaXRpb24uenc7XFxufVwiLGRlcHRoX2ZyYWc6XCIjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0dW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBmcmFnQ29vcmRaICk7XFxuXFx0I2VuZGlmXFxufVwiLGRpc3RhbmNlUkdCQV92ZXJ0OlwiI2RlZmluZSBESVNUQU5DRVxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbn1cIixkaXN0YW5jZVJHQkFfZnJhZzpcIiNkZWZpbmUgRElTVEFOQ0VcXG51bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247XFxudW5pZm9ybSBmbG9hdCBuZWFyRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCBmYXJEaXN0YW5jZTtcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4gKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdGZsb2F0IGRpc3QgPSBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uIC0gcmVmZXJlbmNlUG9zaXRpb24gKTtcXG5cXHRkaXN0ID0gKCBkaXN0IC0gbmVhckRpc3RhbmNlICkgLyAoIGZhckRpc3RhbmNlIC0gbmVhckRpc3RhbmNlICk7XFxuXFx0ZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBkaXN0ICk7XFxufVwiLGVxdWlyZWN0X3ZlcnQ6XCJ2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxufVwiLGVxdWlyZWN0X2ZyYWc6XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkRGlyZWN0aW9uICk7XFxuXFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xcblxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhDb2xvciApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50Plxcbn1cIixsaW5lZGFzaGVkX3ZlcnQ6XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiLGxpbmVkYXNoZWRfZnJhZzpcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XFxuXFx0XFx0ZGlzY2FyZDtcXG5cXHR9XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxufVwiLG1lc2hiYXNpY192ZXJ0OlwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaWYgZGVmaW5lZCAoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkICggVVNFX1NLSU5OSU5HIClcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiLG1lc2hiYXNpY19mcmFnOlwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRcXHR2ZWM0IGxpZ2h0TWFwVGV4ZWw9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRNYXBUZXhlbFRvTGluZWFyKCBsaWdodE1hcFRleGVsICkucmdiICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdmVjMyggMS4wICk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIixtZXNobGFtYmVydF92ZXJ0OlwiI2RlZmluZSBMQU1CRVJUXFxudmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1xcbnZhcnlpbmcgdmVjMyB2SW5kaXJlY3RGcm9udDtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxuXFx0dmFyeWluZyB2ZWMzIHZJbmRpcmVjdEJhY2s7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiLG1lc2hsYW1iZXJ0X2ZyYWc6XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG52YXJ5aW5nIHZlYzMgdkluZGlyZWN0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcblxcdHZhcnlpbmcgdmVjMyB2SW5kaXJlY3RCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZJbmRpcmVjdEZyb250IDogdkluZGlyZWN0QmFjaztcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB2SW5kaXJlY3RGcm9udDtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8bGlnaHRtYXBfZnJhZ21lbnQ+XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IEJSREZfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApO1xcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gKCBnbF9Gcm9udEZhY2luZyApID8gdkxpZ2h0RnJvbnQgOiB2TGlnaHRCYWNrO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZMaWdodEZyb250O1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKj0gQlJERl9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICkgKiBnZXRTaGFkb3dNYXNrKCk7XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCIsbWVzaG1hdGNhcF92ZXJ0OlwiI2RlZmluZSBNQVRDQVBcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxufVwiLG1lc2htYXRjYXBfZnJhZzpcIiNkZWZpbmUgTUFUQ0FQXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHR2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7XFxuXFx0dmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggZG90KCB4LCBub3JtYWwgKSwgZG90KCB5LCBub3JtYWwgKSApICogMC40OTUgKyAwLjU7XFxuXFx0I2lmZGVmIFVTRV9NQVRDQVBcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdGV4dHVyZTJEKCBtYXRjYXAsIHV2ICk7XFxuXFx0XFx0bWF0Y2FwQ29sb3IgPSBtYXRjYXBUZXhlbFRvTGluZWFyKCBtYXRjYXBDb2xvciApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjNCBtYXRjYXBDb2xvciA9IHZlYzQoIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiLG1lc2hub3JtYWxfdmVydDpcIiNkZWZpbmUgTk9STUFMXFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxufVwiLG1lc2hub3JtYWxfZnJhZzpcIiNkZWZpbmUgTk9STUFMXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCBub3JtYWwgKSwgb3BhY2l0eSApO1xcbn1cIixtZXNocGhvbmdfdmVydDpcIiNkZWZpbmUgUEhPTkdcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCIsbWVzaHBob25nX2ZyYWc6XCIjZGVmaW5lIFBIT05HXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCIsbWVzaHBoeXNpY2FsX3ZlcnQ6XCIjZGVmaW5lIFNUQU5EQVJEXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcXG59XCIsbWVzaHBoeXNpY2FsX2ZyYWc6XCIjZGVmaW5lIFNUQU5EQVJEXFxuI2lmZGVmIFBIWVNJQ0FMXFxuXFx0I2RlZmluZSBJT1JcXG5cXHQjZGVmaW5lIFNQRUNVTEFSXFxuI2VuZGlmXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcbnVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZkZWYgSU9SXFxuXFx0dW5pZm9ybSBmbG9hdCBpb3I7XFxuI2VuZGlmXFxuI2lmZGVmIFNQRUNVTEFSXFxuXFx0dW5pZm9ybSBmbG9hdCBzcGVjdWxhckludGVuc2l0eTtcXG5cXHR1bmlmb3JtIHZlYzMgc3BlY3VsYXJUaW50O1xcblxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckludGVuc2l0eU1hcDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1NQRUNVTEFSVElOVE1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyVGludE1hcDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0O1xcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5cXG5cXHR1bmlmb3JtIHZlYzMgc2hlZW5UaW50O1xcblxcdHVuaWZvcm0gZmxvYXQgc2hlZW5Sb3VnaG5lc3M7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgdG90YWxEaWZmdXNlID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIHRvdGFsU3BlY3VsYXIgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXI7XFxuXFx0I2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB0b3RhbERpZmZ1c2UgKyB0b3RhbFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0ZmxvYXQgZG90TlZjYyA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0dmVjMyBGY2MgPSBGX1NjaGxpY2soIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIGRvdE5WY2MgKTtcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqICggMS4wIC0gY2xlYXJjb2F0ICogRmNjICkgKyBjbGVhcmNvYXRTcGVjdWxhciAqIGNsZWFyY29hdDtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCIsbWVzaHRvb25fdmVydDpcIiNkZWZpbmUgVE9PTlxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCIsbWVzaHRvb25fZnJhZzpcIiNkZWZpbmUgVE9PTlxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c190b29uX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfZW5kPlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIixwb2ludHNfdmVydDpcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcXG5cXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTtcXG5cXHRcXHRpZiAoIGlzUGVyc3BlY3RpdmUgKSBnbF9Qb2ludFNpemUgKj0gKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIixwb2ludHNfZnJhZzpcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxufVwiLHNoYWRvd192ZXJ0OlwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCIsc2hhZG93X2ZyYWc6XCJ1bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVwiLHNwcml0ZV92ZXJ0OlwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XFxuXFx0dmVjMiBzY2FsZTtcXG5cXHRzY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLngsIG1vZGVsTWF0cml4WyAwIF0ueSwgbW9kZWxNYXRyaXhbIDAgXS56ICkgKTtcXG5cXHRzY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLngsIG1vZGVsTWF0cml4WyAxIF0ueSwgbW9kZWxNYXRyaXhbIDEgXS56ICkgKTtcXG5cXHQjaWZuZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXG5cXHRcXHRib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlICkgc2NhbGUgKj0gLSBtdlBvc2l0aW9uLno7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMiBhbGlnbmVkUG9zaXRpb24gPSAoIHBvc2l0aW9uLnh5IC0gKCBjZW50ZXIgLSB2ZWMyKCAwLjUgKSApICkgKiBzY2FsZTtcXG5cXHR2ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcXG5cXHRyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxuXFx0cm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcblxcdG12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCIsc3ByaXRlX2ZyYWc6XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cIn0sdWk9e2NvbW1vbjp7ZGlmZnVzZTp7dmFsdWU6bmV3IGNuKDE2Nzc3MjE1KX0sb3BhY2l0eTp7dmFsdWU6MX0sbWFwOnt2YWx1ZTpudWxsfSx1dlRyYW5zZm9ybTp7dmFsdWU6bmV3IEx0fSx1djJUcmFuc2Zvcm06e3ZhbHVlOm5ldyBMdH0sYWxwaGFNYXA6e3ZhbHVlOm51bGx9LGFscGhhVGVzdDp7dmFsdWU6MH19LHNwZWN1bGFybWFwOntzcGVjdWxhck1hcDp7dmFsdWU6bnVsbH19LGVudm1hcDp7ZW52TWFwOnt2YWx1ZTpudWxsfSxmbGlwRW52TWFwOnt2YWx1ZTotMX0scmVmbGVjdGl2aXR5Ont2YWx1ZToxfSxpb3I6e3ZhbHVlOjEuNX0scmVmcmFjdGlvblJhdGlvOnt2YWx1ZTouOTh9LG1heE1pcExldmVsOnt2YWx1ZTowfX0sYW9tYXA6e2FvTWFwOnt2YWx1ZTpudWxsfSxhb01hcEludGVuc2l0eTp7dmFsdWU6MX19LGxpZ2h0bWFwOntsaWdodE1hcDp7dmFsdWU6bnVsbH0sbGlnaHRNYXBJbnRlbnNpdHk6e3ZhbHVlOjF9fSxlbWlzc2l2ZW1hcDp7ZW1pc3NpdmVNYXA6e3ZhbHVlOm51bGx9fSxidW1wbWFwOntidW1wTWFwOnt2YWx1ZTpudWxsfSxidW1wU2NhbGU6e3ZhbHVlOjF9fSxub3JtYWxtYXA6e25vcm1hbE1hcDp7dmFsdWU6bnVsbH0sbm9ybWFsU2NhbGU6e3ZhbHVlOm5ldyBBdCgxLDEpfX0sZGlzcGxhY2VtZW50bWFwOntkaXNwbGFjZW1lbnRNYXA6e3ZhbHVlOm51bGx9LGRpc3BsYWNlbWVudFNjYWxlOnt2YWx1ZToxfSxkaXNwbGFjZW1lbnRCaWFzOnt2YWx1ZTowfX0scm91Z2huZXNzbWFwOntyb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9fSxtZXRhbG5lc3NtYXA6e21ldGFsbmVzc01hcDp7dmFsdWU6bnVsbH19LGdyYWRpZW50bWFwOntncmFkaWVudE1hcDp7dmFsdWU6bnVsbH19LGZvZzp7Zm9nRGVuc2l0eTp7dmFsdWU6MjVlLTV9LGZvZ05lYXI6e3ZhbHVlOjF9LGZvZ0Zhcjp7dmFsdWU6MmUzfSxmb2dDb2xvcjp7dmFsdWU6bmV3IGNuKDE2Nzc3MjE1KX19LGxpZ2h0czp7YW1iaWVudExpZ2h0Q29sb3I6e3ZhbHVlOltdfSxsaWdodFByb2JlOnt2YWx1ZTpbXX0sZGlyZWN0aW9uYWxMaWdodHM6e3ZhbHVlOltdLHByb3BlcnRpZXM6e2RpcmVjdGlvbjp7fSxjb2xvcjp7fX19LGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntzaGFkb3dCaWFzOnt9LHNoYWRvd05vcm1hbEJpYXM6e30sc2hhZG93UmFkaXVzOnt9LHNoYWRvd01hcFNpemU6e319fSxkaXJlY3Rpb25hbFNoYWRvd01hcDp7dmFsdWU6W119LGRpcmVjdGlvbmFsU2hhZG93TWF0cml4Ont2YWx1ZTpbXX0sc3BvdExpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7Y29sb3I6e30scG9zaXRpb246e30sZGlyZWN0aW9uOnt9LGRpc3RhbmNlOnt9LGNvbmVDb3M6e30scGVudW1icmFDb3M6e30sZGVjYXk6e319fSxzcG90TGlnaHRTaGFkb3dzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntzaGFkb3dCaWFzOnt9LHNoYWRvd05vcm1hbEJpYXM6e30sc2hhZG93UmFkaXVzOnt9LHNoYWRvd01hcFNpemU6e319fSxzcG90U2hhZG93TWFwOnt2YWx1ZTpbXX0sc3BvdFNoYWRvd01hdHJpeDp7dmFsdWU6W119LHBvaW50TGlnaHRzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntjb2xvcjp7fSxwb3NpdGlvbjp7fSxkZWNheTp7fSxkaXN0YW5jZTp7fX19LHBvaW50TGlnaHRTaGFkb3dzOnt2YWx1ZTpbXSxwcm9wZXJ0aWVzOntzaGFkb3dCaWFzOnt9LHNoYWRvd05vcm1hbEJpYXM6e30sc2hhZG93UmFkaXVzOnt9LHNoYWRvd01hcFNpemU6e30sc2hhZG93Q2FtZXJhTmVhcjp7fSxzaGFkb3dDYW1lcmFGYXI6e319fSxwb2ludFNoYWRvd01hcDp7dmFsdWU6W119LHBvaW50U2hhZG93TWF0cml4Ont2YWx1ZTpbXX0saGVtaXNwaGVyZUxpZ2h0czp7dmFsdWU6W10scHJvcGVydGllczp7ZGlyZWN0aW9uOnt9LHNreUNvbG9yOnt9LGdyb3VuZENvbG9yOnt9fX0scmVjdEFyZWFMaWdodHM6e3ZhbHVlOltdLHByb3BlcnRpZXM6e2NvbG9yOnt9LHBvc2l0aW9uOnt9LHdpZHRoOnt9LGhlaWdodDp7fX19LGx0Y18xOnt2YWx1ZTpudWxsfSxsdGNfMjp7dmFsdWU6bnVsbH19LHBvaW50czp7ZGlmZnVzZTp7dmFsdWU6bmV3IGNuKDE2Nzc3MjE1KX0sb3BhY2l0eTp7dmFsdWU6MX0sc2l6ZTp7dmFsdWU6MX0sc2NhbGU6e3ZhbHVlOjF9LG1hcDp7dmFsdWU6bnVsbH0sYWxwaGFNYXA6e3ZhbHVlOm51bGx9LGFscGhhVGVzdDp7dmFsdWU6MH0sdXZUcmFuc2Zvcm06e3ZhbHVlOm5ldyBMdH19LHNwcml0ZTp7ZGlmZnVzZTp7dmFsdWU6bmV3IGNuKDE2Nzc3MjE1KX0sb3BhY2l0eTp7dmFsdWU6MX0sY2VudGVyOnt2YWx1ZTpuZXcgQXQoLjUsLjUpfSxyb3RhdGlvbjp7dmFsdWU6MH0sbWFwOnt2YWx1ZTpudWxsfSxhbHBoYU1hcDp7dmFsdWU6bnVsbH0sYWxwaGFUZXN0Ont2YWx1ZTowfSx1dlRyYW5zZm9ybTp7dmFsdWU6bmV3IEx0fX19LGRpPXtiYXNpYzp7dW5pZm9ybXM6cW4oW3VpLmNvbW1vbix1aS5zcGVjdWxhcm1hcCx1aS5lbnZtYXAsdWkuYW9tYXAsdWkubGlnaHRtYXAsdWkuZm9nXSksdmVydGV4U2hhZGVyOmhpLm1lc2hiYXNpY192ZXJ0LGZyYWdtZW50U2hhZGVyOmhpLm1lc2hiYXNpY19mcmFnfSxsYW1iZXJ0Ont1bmlmb3JtczpxbihbdWkuY29tbW9uLHVpLnNwZWN1bGFybWFwLHVpLmVudm1hcCx1aS5hb21hcCx1aS5saWdodG1hcCx1aS5lbWlzc2l2ZW1hcCx1aS5mb2csdWkubGlnaHRzLHtlbWlzc2l2ZTp7dmFsdWU6bmV3IGNuKDApfX1dKSx2ZXJ0ZXhTaGFkZXI6aGkubWVzaGxhbWJlcnRfdmVydCxmcmFnbWVudFNoYWRlcjpoaS5tZXNobGFtYmVydF9mcmFnfSxwaG9uZzp7dW5pZm9ybXM6cW4oW3VpLmNvbW1vbix1aS5zcGVjdWxhcm1hcCx1aS5lbnZtYXAsdWkuYW9tYXAsdWkubGlnaHRtYXAsdWkuZW1pc3NpdmVtYXAsdWkuYnVtcG1hcCx1aS5ub3JtYWxtYXAsdWkuZGlzcGxhY2VtZW50bWFwLHVpLmZvZyx1aS5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgY24oMCl9LHNwZWN1bGFyOnt2YWx1ZTpuZXcgY24oMTExODQ4MSl9LHNoaW5pbmVzczp7dmFsdWU6MzB9fV0pLHZlcnRleFNoYWRlcjpoaS5tZXNocGhvbmdfdmVydCxmcmFnbWVudFNoYWRlcjpoaS5tZXNocGhvbmdfZnJhZ30sc3RhbmRhcmQ6e3VuaWZvcm1zOnFuKFt1aS5jb21tb24sdWkuZW52bWFwLHVpLmFvbWFwLHVpLmxpZ2h0bWFwLHVpLmVtaXNzaXZlbWFwLHVpLmJ1bXBtYXAsdWkubm9ybWFsbWFwLHVpLmRpc3BsYWNlbWVudG1hcCx1aS5yb3VnaG5lc3NtYXAsdWkubWV0YWxuZXNzbWFwLHVpLmZvZyx1aS5saWdodHMse2VtaXNzaXZlOnt2YWx1ZTpuZXcgY24oMCl9LHJvdWdobmVzczp7dmFsdWU6MX0sbWV0YWxuZXNzOnt2YWx1ZTowfSxlbnZNYXBJbnRlbnNpdHk6e3ZhbHVlOjF9fV0pLHZlcnRleFNoYWRlcjpoaS5tZXNocGh5c2ljYWxfdmVydCxmcmFnbWVudFNoYWRlcjpoaS5tZXNocGh5c2ljYWxfZnJhZ30sdG9vbjp7dW5pZm9ybXM6cW4oW3VpLmNvbW1vbix1aS5hb21hcCx1aS5saWdodG1hcCx1aS5lbWlzc2l2ZW1hcCx1aS5idW1wbWFwLHVpLm5vcm1hbG1hcCx1aS5kaXNwbGFjZW1lbnRtYXAsdWkuZ3JhZGllbnRtYXAsdWkuZm9nLHVpLmxpZ2h0cyx7ZW1pc3NpdmU6e3ZhbHVlOm5ldyBjbigwKX19XSksdmVydGV4U2hhZGVyOmhpLm1lc2h0b29uX3ZlcnQsZnJhZ21lbnRTaGFkZXI6aGkubWVzaHRvb25fZnJhZ30sbWF0Y2FwOnt1bmlmb3JtczpxbihbdWkuY29tbW9uLHVpLmJ1bXBtYXAsdWkubm9ybWFsbWFwLHVpLmRpc3BsYWNlbWVudG1hcCx1aS5mb2cse21hdGNhcDp7dmFsdWU6bnVsbH19XSksdmVydGV4U2hhZGVyOmhpLm1lc2htYXRjYXBfdmVydCxmcmFnbWVudFNoYWRlcjpoaS5tZXNobWF0Y2FwX2ZyYWd9LHBvaW50czp7dW5pZm9ybXM6cW4oW3VpLnBvaW50cyx1aS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6aGkucG9pbnRzX3ZlcnQsZnJhZ21lbnRTaGFkZXI6aGkucG9pbnRzX2ZyYWd9LGRhc2hlZDp7dW5pZm9ybXM6cW4oW3VpLmNvbW1vbix1aS5mb2cse3NjYWxlOnt2YWx1ZToxfSxkYXNoU2l6ZTp7dmFsdWU6MX0sdG90YWxTaXplOnt2YWx1ZToyfX1dKSx2ZXJ0ZXhTaGFkZXI6aGkubGluZWRhc2hlZF92ZXJ0LGZyYWdtZW50U2hhZGVyOmhpLmxpbmVkYXNoZWRfZnJhZ30sZGVwdGg6e3VuaWZvcm1zOnFuKFt1aS5jb21tb24sdWkuZGlzcGxhY2VtZW50bWFwXSksdmVydGV4U2hhZGVyOmhpLmRlcHRoX3ZlcnQsZnJhZ21lbnRTaGFkZXI6aGkuZGVwdGhfZnJhZ30sbm9ybWFsOnt1bmlmb3JtczpxbihbdWkuY29tbW9uLHVpLmJ1bXBtYXAsdWkubm9ybWFsbWFwLHVpLmRpc3BsYWNlbWVudG1hcCx7b3BhY2l0eTp7dmFsdWU6MX19XSksdmVydGV4U2hhZGVyOmhpLm1lc2hub3JtYWxfdmVydCxmcmFnbWVudFNoYWRlcjpoaS5tZXNobm9ybWFsX2ZyYWd9LHNwcml0ZTp7dW5pZm9ybXM6cW4oW3VpLnNwcml0ZSx1aS5mb2ddKSx2ZXJ0ZXhTaGFkZXI6aGkuc3ByaXRlX3ZlcnQsZnJhZ21lbnRTaGFkZXI6aGkuc3ByaXRlX2ZyYWd9LGJhY2tncm91bmQ6e3VuaWZvcm1zOnt1dlRyYW5zZm9ybTp7dmFsdWU6bmV3IEx0fSx0MkQ6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6aGkuYmFja2dyb3VuZF92ZXJ0LGZyYWdtZW50U2hhZGVyOmhpLmJhY2tncm91bmRfZnJhZ30sY3ViZTp7dW5pZm9ybXM6cW4oW3VpLmVudm1hcCx7b3BhY2l0eTp7dmFsdWU6MX19XSksdmVydGV4U2hhZGVyOmhpLmN1YmVfdmVydCxmcmFnbWVudFNoYWRlcjpoaS5jdWJlX2ZyYWd9LGVxdWlyZWN0Ont1bmlmb3Jtczp7dEVxdWlyZWN0Ont2YWx1ZTpudWxsfX0sdmVydGV4U2hhZGVyOmhpLmVxdWlyZWN0X3ZlcnQsZnJhZ21lbnRTaGFkZXI6aGkuZXF1aXJlY3RfZnJhZ30sZGlzdGFuY2VSR0JBOnt1bmlmb3JtczpxbihbdWkuY29tbW9uLHVpLmRpc3BsYWNlbWVudG1hcCx7cmVmZXJlbmNlUG9zaXRpb246e3ZhbHVlOm5ldyBCdH0sbmVhckRpc3RhbmNlOnt2YWx1ZToxfSxmYXJEaXN0YW5jZTp7dmFsdWU6MWUzfX1dKSx2ZXJ0ZXhTaGFkZXI6aGkuZGlzdGFuY2VSR0JBX3ZlcnQsZnJhZ21lbnRTaGFkZXI6aGkuZGlzdGFuY2VSR0JBX2ZyYWd9LHNoYWRvdzp7dW5pZm9ybXM6cW4oW3VpLmxpZ2h0cyx1aS5mb2cse2NvbG9yOnt2YWx1ZTpuZXcgY24oMCl9LG9wYWNpdHk6e3ZhbHVlOjF9fV0pLHZlcnRleFNoYWRlcjpoaS5zaGFkb3dfdmVydCxmcmFnbWVudFNoYWRlcjpoaS5zaGFkb3dfZnJhZ319O2Z1bmN0aW9uIHBpKHQsZSxuLGkscil7Y29uc3Qgcz1uZXcgY24oMCk7bGV0IGEsbyxsPTAsYz1udWxsLGg9MCx1PW51bGw7ZnVuY3Rpb24gZCh0LGUpe24uYnVmZmVycy5jb2xvci5zZXRDbGVhcih0LnIsdC5nLHQuYixlLHIpfXJldHVybntnZXRDbGVhckNvbG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHN9LHNldENsZWFyQ29sb3I6ZnVuY3Rpb24odCxlPTEpe3Muc2V0KHQpLGw9ZSxkKHMsbCl9LGdldENsZWFyQWxwaGE6ZnVuY3Rpb24oKXtyZXR1cm4gbH0sc2V0Q2xlYXJBbHBoYTpmdW5jdGlvbih0KXtsPXQsZChzLGwpfSxyZW5kZXI6ZnVuY3Rpb24obixyKXtsZXQgcD0hMSxtPSEwPT09ci5pc1NjZW5lP3IuYmFja2dyb3VuZDpudWxsO20mJm0uaXNUZXh0dXJlJiYobT1lLmdldChtKSk7Y29uc3QgZj10LnhyLGc9Zi5nZXRTZXNzaW9uJiZmLmdldFNlc3Npb24oKTtnJiZcImFkZGl0aXZlXCI9PT1nLmVudmlyb25tZW50QmxlbmRNb2RlJiYobT1udWxsKSxudWxsPT09bT9kKHMsbCk6bSYmbS5pc0NvbG9yJiYoZChtLDEpLHA9ITApLCh0LmF1dG9DbGVhcnx8cCkmJnQuY2xlYXIodC5hdXRvQ2xlYXJDb2xvcix0LmF1dG9DbGVhckRlcHRoLHQuYXV0b0NsZWFyU3RlbmNpbCksbSYmKG0uaXNDdWJlVGV4dHVyZXx8MzA2PT09bS5tYXBwaW5nKT8odm9pZCAwPT09byYmKG89bmV3IFZuKG5ldyBXbigxLDEsMSksbmV3IFluKHtuYW1lOlwiQmFja2dyb3VuZEN1YmVNYXRlcmlhbFwiLHVuaWZvcm1zOmpuKGRpLmN1YmUudW5pZm9ybXMpLHZlcnRleFNoYWRlcjpkaS5jdWJlLnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjpkaS5jdWJlLmZyYWdtZW50U2hhZGVyLHNpZGU6MSxkZXB0aFRlc3Q6ITEsZGVwdGhXcml0ZTohMSxmb2c6ITF9KSksby5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoXCJub3JtYWxcIiksby5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoXCJ1dlwiKSxvLm9uQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLm1hdHJpeFdvcmxkLmNvcHlQb3NpdGlvbihuLm1hdHJpeFdvcmxkKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KG8ubWF0ZXJpYWwsXCJlbnZNYXBcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuZW52TWFwLnZhbHVlfX0pLGkudXBkYXRlKG8pKSxvLm1hdGVyaWFsLnVuaWZvcm1zLmVudk1hcC52YWx1ZT1tLG8ubWF0ZXJpYWwudW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZT1tLmlzQ3ViZVRleHR1cmUmJiExPT09bS5pc1JlbmRlclRhcmdldFRleHR1cmU/LTE6MSxjPT09bSYmaD09PW0udmVyc2lvbiYmdT09PXQudG9uZU1hcHBpbmd8fChvLm1hdGVyaWFsLm5lZWRzVXBkYXRlPSEwLGM9bSxoPW0udmVyc2lvbix1PXQudG9uZU1hcHBpbmcpLG4udW5zaGlmdChvLG8uZ2VvbWV0cnksby5tYXRlcmlhbCwwLDAsbnVsbCkpOm0mJm0uaXNUZXh0dXJlJiYodm9pZCAwPT09YSYmKGE9bmV3IFZuKG5ldyBjaSgyLDIpLG5ldyBZbih7bmFtZTpcIkJhY2tncm91bmRNYXRlcmlhbFwiLHVuaWZvcm1zOmpuKGRpLmJhY2tncm91bmQudW5pZm9ybXMpLHZlcnRleFNoYWRlcjpkaS5iYWNrZ3JvdW5kLnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjpkaS5iYWNrZ3JvdW5kLmZyYWdtZW50U2hhZGVyLHNpZGU6MCxkZXB0aFRlc3Q6ITEsZGVwdGhXcml0ZTohMSxmb2c6ITF9KSksYS5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoXCJub3JtYWxcIiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEubWF0ZXJpYWwsXCJtYXBcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudDJELnZhbHVlfX0pLGkudXBkYXRlKGEpKSxhLm1hdGVyaWFsLnVuaWZvcm1zLnQyRC52YWx1ZT1tLCEwPT09bS5tYXRyaXhBdXRvVXBkYXRlJiZtLnVwZGF0ZU1hdHJpeCgpLGEubWF0ZXJpYWwudW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weShtLm1hdHJpeCksYz09PW0mJmg9PT1tLnZlcnNpb24mJnU9PT10LnRvbmVNYXBwaW5nfHwoYS5tYXRlcmlhbC5uZWVkc1VwZGF0ZT0hMCxjPW0saD1tLnZlcnNpb24sdT10LnRvbmVNYXBwaW5nKSxuLnVuc2hpZnQoYSxhLmdlb21ldHJ5LGEubWF0ZXJpYWwsMCwwLG51bGwpKX19fWZ1bmN0aW9uIG1pKHQsZSxuLGkpe2NvbnN0IHI9dC5nZXRQYXJhbWV0ZXIoMzQ5MjEpLHM9aS5pc1dlYkdMMj9udWxsOmUuZ2V0KFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiksYT1pLmlzV2ViR0wyfHxudWxsIT09cyxvPXt9LGw9ZChudWxsKTtsZXQgYz1sO2Z1bmN0aW9uIGgoZSl7cmV0dXJuIGkuaXNXZWJHTDI/dC5iaW5kVmVydGV4QXJyYXkoZSk6cy5iaW5kVmVydGV4QXJyYXlPRVMoZSl9ZnVuY3Rpb24gdShlKXtyZXR1cm4gaS5pc1dlYkdMMj90LmRlbGV0ZVZlcnRleEFycmF5KGUpOnMuZGVsZXRlVmVydGV4QXJyYXlPRVMoZSl9ZnVuY3Rpb24gZCh0KXtjb25zdCBlPVtdLG49W10saT1bXTtmb3IobGV0IHQ9MDt0PHI7dCsrKWVbdF09MCxuW3RdPTAsaVt0XT0wO3JldHVybntnZW9tZXRyeTpudWxsLHByb2dyYW06bnVsbCx3aXJlZnJhbWU6ITEsbmV3QXR0cmlidXRlczplLGVuYWJsZWRBdHRyaWJ1dGVzOm4sYXR0cmlidXRlRGl2aXNvcnM6aSxvYmplY3Q6dCxhdHRyaWJ1dGVzOnt9LGluZGV4Om51bGx9fWZ1bmN0aW9uIHAoKXtjb25zdCB0PWMubmV3QXR0cmlidXRlcztmb3IobGV0IGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspdFtlXT0wfWZ1bmN0aW9uIG0odCl7Zih0LDApfWZ1bmN0aW9uIGYobixyKXtjb25zdCBzPWMubmV3QXR0cmlidXRlcyxhPWMuZW5hYmxlZEF0dHJpYnV0ZXMsbz1jLmF0dHJpYnV0ZURpdmlzb3JzO2lmKHNbbl09MSwwPT09YVtuXSYmKHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobiksYVtuXT0xKSxvW25dIT09cil7KGkuaXNXZWJHTDI/dDplLmdldChcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIikpW2kuaXNXZWJHTDI/XCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yXCI6XCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEVcIl0obixyKSxvW25dPXJ9fWZ1bmN0aW9uIGcoKXtjb25zdCBlPWMubmV3QXR0cmlidXRlcyxuPWMuZW5hYmxlZEF0dHJpYnV0ZXM7Zm9yKGxldCBpPTAscj1uLmxlbmd0aDtpPHI7aSsrKW5baV0hPT1lW2ldJiYodC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSksbltpXT0wKX1mdW5jdGlvbiB2KGUsbixyLHMsYSxvKXshMCE9PWkuaXNXZWJHTDJ8fDUxMjQhPT1yJiY1MTI1IT09cj90LnZlcnRleEF0dHJpYlBvaW50ZXIoZSxuLHIscyxhLG8pOnQudmVydGV4QXR0cmliSVBvaW50ZXIoZSxuLHIsYSxvKX1mdW5jdGlvbiB5KCl7eCgpLGMhPT1sJiYoYz1sLGgoYy5vYmplY3QpKX1mdW5jdGlvbiB4KCl7bC5nZW9tZXRyeT1udWxsLGwucHJvZ3JhbT1udWxsLGwud2lyZWZyYW1lPSExfXJldHVybntzZXR1cDpmdW5jdGlvbihyLGwsdSx5LHgpe2xldCBiPSExO2lmKGEpe2NvbnN0IGU9ZnVuY3Rpb24oZSxuLHIpe2NvbnN0IGE9ITA9PT1yLndpcmVmcmFtZTtsZXQgbD1vW2UuaWRdO3ZvaWQgMD09PWwmJihsPXt9LG9bZS5pZF09bCk7bGV0IGM9bFtuLmlkXTt2b2lkIDA9PT1jJiYoYz17fSxsW24uaWRdPWMpO2xldCBoPWNbYV07dm9pZCAwPT09aCYmKGg9ZChpLmlzV2ViR0wyP3QuY3JlYXRlVmVydGV4QXJyYXkoKTpzLmNyZWF0ZVZlcnRleEFycmF5T0VTKCkpLGNbYV09aCk7cmV0dXJuIGh9KHksdSxsKTtjIT09ZSYmKGM9ZSxoKGMub2JqZWN0KSksYj1mdW5jdGlvbih0LGUpe2NvbnN0IG49Yy5hdHRyaWJ1dGVzLGk9dC5hdHRyaWJ1dGVzO2xldCByPTA7Zm9yKGNvbnN0IHQgaW4gaSl7Y29uc3QgZT1uW3RdLHM9aVt0XTtpZih2b2lkIDA9PT1lKXJldHVybiEwO2lmKGUuYXR0cmlidXRlIT09cylyZXR1cm4hMDtpZihlLmRhdGEhPT1zLmRhdGEpcmV0dXJuITA7cisrfXJldHVybiBjLmF0dHJpYnV0ZXNOdW0hPT1yfHxjLmluZGV4IT09ZX0oeSx4KSxiJiZmdW5jdGlvbih0LGUpe2NvbnN0IG49e30saT10LmF0dHJpYnV0ZXM7bGV0IHI9MDtmb3IoY29uc3QgdCBpbiBpKXtjb25zdCBlPWlbdF0scz17fTtzLmF0dHJpYnV0ZT1lLGUuZGF0YSYmKHMuZGF0YT1lLmRhdGEpLG5bdF09cyxyKyt9Yy5hdHRyaWJ1dGVzPW4sYy5hdHRyaWJ1dGVzTnVtPXIsYy5pbmRleD1lfSh5LHgpfWVsc2V7Y29uc3QgdD0hMD09PWwud2lyZWZyYW1lO2MuZ2VvbWV0cnk9PT15LmlkJiZjLnByb2dyYW09PT11LmlkJiZjLndpcmVmcmFtZT09PXR8fChjLmdlb21ldHJ5PXkuaWQsYy5wcm9ncmFtPXUuaWQsYy53aXJlZnJhbWU9dCxiPSEwKX0hMD09PXIuaXNJbnN0YW5jZWRNZXNoJiYoYj0hMCksbnVsbCE9PXgmJm4udXBkYXRlKHgsMzQ5NjMpLGImJighZnVuY3Rpb24ocixzLGEsbyl7aWYoITE9PT1pLmlzV2ViR0wyJiYoci5pc0luc3RhbmNlZE1lc2h8fG8uaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSkmJm51bGw9PT1lLmdldChcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIikpcmV0dXJuO3AoKTtjb25zdCBsPW8uYXR0cmlidXRlcyxjPWEuZ2V0QXR0cmlidXRlcygpLGg9cy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO2Zvcihjb25zdCBlIGluIGMpe2NvbnN0IGk9Y1tlXTtpZihpLmxvY2F0aW9uPj0wKXtsZXQgcz1sW2VdO2lmKHZvaWQgMD09PXMmJihcImluc3RhbmNlTWF0cml4XCI9PT1lJiZyLmluc3RhbmNlTWF0cml4JiYocz1yLmluc3RhbmNlTWF0cml4KSxcImluc3RhbmNlQ29sb3JcIj09PWUmJnIuaW5zdGFuY2VDb2xvciYmKHM9ci5pbnN0YW5jZUNvbG9yKSksdm9pZCAwIT09cyl7Y29uc3QgZT1zLm5vcm1hbGl6ZWQsYT1zLml0ZW1TaXplLGw9bi5nZXQocyk7aWYodm9pZCAwPT09bCljb250aW51ZTtjb25zdCBjPWwuYnVmZmVyLGg9bC50eXBlLHU9bC5ieXRlc1BlckVsZW1lbnQ7aWYocy5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKXtjb25zdCBuPXMuZGF0YSxsPW4uc3RyaWRlLGQ9cy5vZmZzZXQ7aWYobiYmbi5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKXtmb3IobGV0IHQ9MDt0PGkubG9jYXRpb25TaXplO3QrKylmKGkubG9jYXRpb24rdCxuLm1lc2hQZXJBdHRyaWJ1dGUpOyEwIT09ci5pc0luc3RhbmNlZE1lc2gmJnZvaWQgMD09PW8uX21heEluc3RhbmNlQ291bnQmJihvLl9tYXhJbnN0YW5jZUNvdW50PW4ubWVzaFBlckF0dHJpYnV0ZSpuLmNvdW50KX1lbHNlIGZvcihsZXQgdD0wO3Q8aS5sb2NhdGlvblNpemU7dCsrKW0oaS5sb2NhdGlvbit0KTt0LmJpbmRCdWZmZXIoMzQ5NjIsYyk7Zm9yKGxldCB0PTA7dDxpLmxvY2F0aW9uU2l6ZTt0KyspdihpLmxvY2F0aW9uK3QsYS9pLmxvY2F0aW9uU2l6ZSxoLGUsbCp1LChkK2EvaS5sb2NhdGlvblNpemUqdCkqdSl9ZWxzZXtpZihzLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKXtmb3IobGV0IHQ9MDt0PGkubG9jYXRpb25TaXplO3QrKylmKGkubG9jYXRpb24rdCxzLm1lc2hQZXJBdHRyaWJ1dGUpOyEwIT09ci5pc0luc3RhbmNlZE1lc2gmJnZvaWQgMD09PW8uX21heEluc3RhbmNlQ291bnQmJihvLl9tYXhJbnN0YW5jZUNvdW50PXMubWVzaFBlckF0dHJpYnV0ZSpzLmNvdW50KX1lbHNlIGZvcihsZXQgdD0wO3Q8aS5sb2NhdGlvblNpemU7dCsrKW0oaS5sb2NhdGlvbit0KTt0LmJpbmRCdWZmZXIoMzQ5NjIsYyk7Zm9yKGxldCB0PTA7dDxpLmxvY2F0aW9uU2l6ZTt0KyspdihpLmxvY2F0aW9uK3QsYS9pLmxvY2F0aW9uU2l6ZSxoLGUsYSp1LGEvaS5sb2NhdGlvblNpemUqdCp1KX19ZWxzZSBpZih2b2lkIDAhPT1oKXtjb25zdCBuPWhbZV07aWYodm9pZCAwIT09bilzd2l0Y2gobi5sZW5ndGgpe2Nhc2UgMjp0LnZlcnRleEF0dHJpYjJmdihpLmxvY2F0aW9uLG4pO2JyZWFrO2Nhc2UgMzp0LnZlcnRleEF0dHJpYjNmdihpLmxvY2F0aW9uLG4pO2JyZWFrO2Nhc2UgNDp0LnZlcnRleEF0dHJpYjRmdihpLmxvY2F0aW9uLG4pO2JyZWFrO2RlZmF1bHQ6dC52ZXJ0ZXhBdHRyaWIxZnYoaS5sb2NhdGlvbixuKX19fX1nKCl9KHIsbCx1LHkpLG51bGwhPT14JiZ0LmJpbmRCdWZmZXIoMzQ5NjMsbi5nZXQoeCkuYnVmZmVyKSl9LHJlc2V0OnkscmVzZXREZWZhdWx0U3RhdGU6eCxkaXNwb3NlOmZ1bmN0aW9uKCl7eSgpO2Zvcihjb25zdCB0IGluIG8pe2NvbnN0IGU9b1t0XTtmb3IoY29uc3QgdCBpbiBlKXtjb25zdCBuPWVbdF07Zm9yKGNvbnN0IHQgaW4gbil1KG5bdF0ub2JqZWN0KSxkZWxldGUgblt0XTtkZWxldGUgZVt0XX1kZWxldGUgb1t0XX19LHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5OmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PW9bdC5pZF0pcmV0dXJuO2NvbnN0IGU9b1t0LmlkXTtmb3IoY29uc3QgdCBpbiBlKXtjb25zdCBuPWVbdF07Zm9yKGNvbnN0IHQgaW4gbil1KG5bdF0ub2JqZWN0KSxkZWxldGUgblt0XTtkZWxldGUgZVt0XX1kZWxldGUgb1t0LmlkXX0scmVsZWFzZVN0YXRlc09mUHJvZ3JhbTpmdW5jdGlvbih0KXtmb3IoY29uc3QgZSBpbiBvKXtjb25zdCBuPW9bZV07aWYodm9pZCAwPT09blt0LmlkXSljb250aW51ZTtjb25zdCBpPW5bdC5pZF07Zm9yKGNvbnN0IHQgaW4gaSl1KGlbdF0ub2JqZWN0KSxkZWxldGUgaVt0XTtkZWxldGUgblt0LmlkXX19LGluaXRBdHRyaWJ1dGVzOnAsZW5hYmxlQXR0cmlidXRlOm0sZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXM6Z319ZnVuY3Rpb24gZmkodCxlLG4saSl7Y29uc3Qgcj1pLmlzV2ViR0wyO2xldCBzO3RoaXMuc2V0TW9kZT1mdW5jdGlvbih0KXtzPXR9LHRoaXMucmVuZGVyPWZ1bmN0aW9uKGUsaSl7dC5kcmF3QXJyYXlzKHMsZSxpKSxuLnVwZGF0ZShpLHMsMSl9LHRoaXMucmVuZGVySW5zdGFuY2VzPWZ1bmN0aW9uKGksYSxvKXtpZigwPT09bylyZXR1cm47bGV0IGwsYztpZihyKWw9dCxjPVwiZHJhd0FycmF5c0luc3RhbmNlZFwiO2Vsc2UgaWYobD1lLmdldChcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIiksYz1cImRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRVwiLG51bGw9PT1sKXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy5cIik7bFtjXShzLGksYSxvKSxuLnVwZGF0ZShhLHMsbyl9fWZ1bmN0aW9uIGdpKHQsZSxuKXtsZXQgaTtmdW5jdGlvbiByKGUpe2lmKFwiaGlnaHBcIj09PWUpe2lmKHQuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KDM1NjMzLDM2MzM4KS5wcmVjaXNpb24+MCYmdC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoMzU2MzIsMzYzMzgpLnByZWNpc2lvbj4wKXJldHVyblwiaGlnaHBcIjtlPVwibWVkaXVtcFwifXJldHVyblwibWVkaXVtcFwiPT09ZSYmdC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoMzU2MzMsMzYzMzcpLnByZWNpc2lvbj4wJiZ0LmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCgzNTYzMiwzNjMzNykucHJlY2lzaW9uPjA/XCJtZWRpdW1wXCI6XCJsb3dwXCJ9Y29uc3Qgcz1cInVuZGVmaW5lZFwiIT10eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCYmdCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBXZWJHTDJDb21wdXRlUmVuZGVyaW5nQ29udGV4dCYmdCBpbnN0YW5jZW9mIFdlYkdMMkNvbXB1dGVSZW5kZXJpbmdDb250ZXh0O2xldCBhPXZvaWQgMCE9PW4ucHJlY2lzaW9uP24ucHJlY2lzaW9uOlwiaGlnaHBcIjtjb25zdCBvPXIoYSk7byE9PWEmJihjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOlwiLGEsXCJub3Qgc3VwcG9ydGVkLCB1c2luZ1wiLG8sXCJpbnN0ZWFkLlwiKSxhPW8pO2NvbnN0IGw9c3x8ZS5oYXMoXCJXRUJHTF9kcmF3X2J1ZmZlcnNcIiksYz0hMD09PW4ubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixoPXQuZ2V0UGFyYW1ldGVyKDM0OTMwKSx1PXQuZ2V0UGFyYW1ldGVyKDM1NjYwKSxkPXQuZ2V0UGFyYW1ldGVyKDMzNzkpLHA9dC5nZXRQYXJhbWV0ZXIoMzQwNzYpLG09dC5nZXRQYXJhbWV0ZXIoMzQ5MjEpLGY9dC5nZXRQYXJhbWV0ZXIoMzYzNDcpLGc9dC5nZXRQYXJhbWV0ZXIoMzYzNDgpLHY9dC5nZXRQYXJhbWV0ZXIoMzYzNDkpLHk9dT4wLHg9c3x8ZS5oYXMoXCJPRVNfdGV4dHVyZV9mbG9hdFwiKTtyZXR1cm57aXNXZWJHTDI6cyxkcmF3QnVmZmVyczpsLGdldE1heEFuaXNvdHJvcHk6ZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1pKXJldHVybiBpO2lmKCEwPT09ZS5oYXMoXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpe2NvbnN0IG49ZS5nZXQoXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIik7aT10LmdldFBhcmFtZXRlcihuLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCl9ZWxzZSBpPTA7cmV0dXJuIGl9LGdldE1heFByZWNpc2lvbjpyLHByZWNpc2lvbjphLGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6YyxtYXhUZXh0dXJlczpoLG1heFZlcnRleFRleHR1cmVzOnUsbWF4VGV4dHVyZVNpemU6ZCxtYXhDdWJlbWFwU2l6ZTpwLG1heEF0dHJpYnV0ZXM6bSxtYXhWZXJ0ZXhVbmlmb3JtczpmLG1heFZhcnlpbmdzOmcsbWF4RnJhZ21lbnRVbmlmb3Jtczp2LHZlcnRleFRleHR1cmVzOnksZmxvYXRGcmFnbWVudFRleHR1cmVzOngsZmxvYXRWZXJ0ZXhUZXh0dXJlczp5JiZ4LG1heFNhbXBsZXM6cz90LmdldFBhcmFtZXRlcigzNjE4Myk6MH19ZnVuY3Rpb24gdmkodCl7Y29uc3QgZT10aGlzO2xldCBuPW51bGwsaT0wLHI9ITEscz0hMTtjb25zdCBhPW5ldyBpaSxvPW5ldyBMdCxsPXt2YWx1ZTpudWxsLG5lZWRzVXBkYXRlOiExfTtmdW5jdGlvbiBjKCl7bC52YWx1ZSE9PW4mJihsLnZhbHVlPW4sbC5uZWVkc1VwZGF0ZT1pPjApLGUubnVtUGxhbmVzPWksZS5udW1JbnRlcnNlY3Rpb249MH1mdW5jdGlvbiBoKHQsbixpLHIpe2NvbnN0IHM9bnVsbCE9PXQ/dC5sZW5ndGg6MDtsZXQgYz1udWxsO2lmKDAhPT1zKXtpZihjPWwudmFsdWUsITAhPT1yfHxudWxsPT09Yyl7Y29uc3QgZT1pKzQqcyxyPW4ubWF0cml4V29ybGRJbnZlcnNlO28uZ2V0Tm9ybWFsTWF0cml4KHIpLChudWxsPT09Y3x8Yy5sZW5ndGg8ZSkmJihjPW5ldyBGbG9hdDMyQXJyYXkoZSkpO2ZvcihsZXQgZT0wLG49aTtlIT09czsrK2Usbis9NClhLmNvcHkodFtlXSkuYXBwbHlNYXRyaXg0KHIsbyksYS5ub3JtYWwudG9BcnJheShjLG4pLGNbbiszXT1hLmNvbnN0YW50fWwudmFsdWU9YyxsLm5lZWRzVXBkYXRlPSEwfXJldHVybiBlLm51bVBsYW5lcz1zLGUubnVtSW50ZXJzZWN0aW9uPTAsY310aGlzLnVuaWZvcm09bCx0aGlzLm51bVBsYW5lcz0wLHRoaXMubnVtSW50ZXJzZWN0aW9uPTAsdGhpcy5pbml0PWZ1bmN0aW9uKHQsZSxzKXtjb25zdCBhPTAhPT10Lmxlbmd0aHx8ZXx8MCE9PWl8fHI7cmV0dXJuIHI9ZSxuPWgodCxzLDApLGk9dC5sZW5ndGgsYX0sdGhpcy5iZWdpblNoYWRvd3M9ZnVuY3Rpb24oKXtzPSEwLGgobnVsbCl9LHRoaXMuZW5kU2hhZG93cz1mdW5jdGlvbigpe3M9ITEsYygpfSx0aGlzLnNldFN0YXRlPWZ1bmN0aW9uKGUsYSxvKXtjb25zdCB1PWUuY2xpcHBpbmdQbGFuZXMsZD1lLmNsaXBJbnRlcnNlY3Rpb24scD1lLmNsaXBTaGFkb3dzLG09dC5nZXQoZSk7aWYoIXJ8fG51bGw9PT11fHwwPT09dS5sZW5ndGh8fHMmJiFwKXM/aChudWxsKTpjKCk7ZWxzZXtjb25zdCB0PXM/MDppLGU9NCp0O2xldCByPW0uY2xpcHBpbmdTdGF0ZXx8bnVsbDtsLnZhbHVlPXIscj1oKHUsYSxlLG8pO2ZvcihsZXQgdD0wO3QhPT1lOysrdClyW3RdPW5bdF07bS5jbGlwcGluZ1N0YXRlPXIsdGhpcy5udW1JbnRlcnNlY3Rpb249ZD90aGlzLm51bVBsYW5lczowLHRoaXMubnVtUGxhbmVzKz10fX19ZnVuY3Rpb24geWkodCl7bGV0IGU9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gbih0LGUpe3JldHVybiAzMDM9PT1lP3QubWFwcGluZz0zMDE6MzA0PT09ZSYmKHQubWFwcGluZz0zMDIpLHR9ZnVuY3Rpb24gaSh0KXtjb25zdCBuPXQudGFyZ2V0O24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixpKTtjb25zdCByPWUuZ2V0KG4pO3ZvaWQgMCE9PXImJihlLmRlbGV0ZShuKSxyLmRpc3Bvc2UoKSl9cmV0dXJue2dldDpmdW5jdGlvbihyKXtpZihyJiZyLmlzVGV4dHVyZSYmITE9PT1yLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSl7Y29uc3Qgcz1yLm1hcHBpbmc7aWYoMzAzPT09c3x8MzA0PT09cyl7aWYoZS5oYXMocikpe3JldHVybiBuKGUuZ2V0KHIpLnRleHR1cmUsci5tYXBwaW5nKX17Y29uc3Qgcz1yLmltYWdlO2lmKHMmJnMuaGVpZ2h0PjApe2NvbnN0IGE9dC5nZXRSZW5kZXJUYXJnZXQoKSxvPW5ldyBRbihzLmhlaWdodC8yKTtyZXR1cm4gby5mcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZSh0LHIpLGUuc2V0KHIsbyksdC5zZXRSZW5kZXJUYXJnZXQoYSksci5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLGkpLG4oby50ZXh0dXJlLHIubWFwcGluZyl9cmV0dXJuIG51bGx9fX1yZXR1cm4gcn0sZGlzcG9zZTpmdW5jdGlvbigpe2U9bmV3IFdlYWtNYXB9fX1kaS5waHlzaWNhbD17dW5pZm9ybXM6cW4oW2RpLnN0YW5kYXJkLnVuaWZvcm1zLHtjbGVhcmNvYXQ6e3ZhbHVlOjB9LGNsZWFyY29hdE1hcDp7dmFsdWU6bnVsbH0sY2xlYXJjb2F0Um91Z2huZXNzOnt2YWx1ZTowfSxjbGVhcmNvYXRSb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LGNsZWFyY29hdE5vcm1hbFNjYWxlOnt2YWx1ZTpuZXcgQXQoMSwxKX0sY2xlYXJjb2F0Tm9ybWFsTWFwOnt2YWx1ZTpudWxsfSxzaGVlbjp7dmFsdWU6MH0sc2hlZW5UaW50Ont2YWx1ZTpuZXcgY24oMCl9LHNoZWVuUm91Z2huZXNzOnt2YWx1ZTowfSx0cmFuc21pc3Npb246e3ZhbHVlOjB9LHRyYW5zbWlzc2lvbk1hcDp7dmFsdWU6bnVsbH0sdHJhbnNtaXNzaW9uU2FtcGxlclNpemU6e3ZhbHVlOm5ldyBBdH0sdHJhbnNtaXNzaW9uU2FtcGxlck1hcDp7dmFsdWU6bnVsbH0sdGhpY2tuZXNzOnt2YWx1ZTowfSx0aGlja25lc3NNYXA6e3ZhbHVlOm51bGx9LGF0dGVudWF0aW9uRGlzdGFuY2U6e3ZhbHVlOjB9LGF0dGVudWF0aW9uVGludDp7dmFsdWU6bmV3IGNuKDApfSxzcGVjdWxhckludGVuc2l0eTp7dmFsdWU6MH0sc3BlY3VsYXJJbnRlbnNpdHlNYXA6e3ZhbHVlOm51bGx9LHNwZWN1bGFyVGludDp7dmFsdWU6bmV3IGNuKDEsMSwxKX0sc3BlY3VsYXJUaW50TWFwOnt2YWx1ZTpudWxsfX1dKSx2ZXJ0ZXhTaGFkZXI6aGkubWVzaHBoeXNpY2FsX3ZlcnQsZnJhZ21lbnRTaGFkZXI6aGkubWVzaHBoeXNpY2FsX2ZyYWd9O2NsYXNzIHhpIGV4dGVuZHMgWm57Y29uc3RydWN0b3IodD0tMSxlPTEsbj0xLGk9LTEscj0uMSxzPTJlMyl7c3VwZXIoKSx0aGlzLnR5cGU9XCJPcnRob2dyYXBoaWNDYW1lcmFcIix0aGlzLnpvb209MSx0aGlzLnZpZXc9bnVsbCx0aGlzLmxlZnQ9dCx0aGlzLnJpZ2h0PWUsdGhpcy50b3A9bix0aGlzLmJvdHRvbT1pLHRoaXMubmVhcj1yLHRoaXMuZmFyPXMsdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5sZWZ0PXQubGVmdCx0aGlzLnJpZ2h0PXQucmlnaHQsdGhpcy50b3A9dC50b3AsdGhpcy5ib3R0b209dC5ib3R0b20sdGhpcy5uZWFyPXQubmVhcix0aGlzLmZhcj10LmZhcix0aGlzLnpvb209dC56b29tLHRoaXMudmlldz1udWxsPT09dC52aWV3P251bGw6T2JqZWN0LmFzc2lnbih7fSx0LnZpZXcpLHRoaXN9c2V0Vmlld09mZnNldCh0LGUsbixpLHIscyl7bnVsbD09PXRoaXMudmlldyYmKHRoaXMudmlldz17ZW5hYmxlZDohMCxmdWxsV2lkdGg6MSxmdWxsSGVpZ2h0OjEsb2Zmc2V0WDowLG9mZnNldFk6MCx3aWR0aDoxLGhlaWdodDoxfSksdGhpcy52aWV3LmVuYWJsZWQ9ITAsdGhpcy52aWV3LmZ1bGxXaWR0aD10LHRoaXMudmlldy5mdWxsSGVpZ2h0PWUsdGhpcy52aWV3Lm9mZnNldFg9bix0aGlzLnZpZXcub2Zmc2V0WT1pLHRoaXMudmlldy53aWR0aD1yLHRoaXMudmlldy5oZWlnaHQ9cyx0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1jbGVhclZpZXdPZmZzZXQoKXtudWxsIT09dGhpcy52aWV3JiYodGhpcy52aWV3LmVuYWJsZWQ9ITEpLHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfXVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKXtjb25zdCB0PSh0aGlzLnJpZ2h0LXRoaXMubGVmdCkvKDIqdGhpcy56b29tKSxlPSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvKDIqdGhpcy56b29tKSxuPSh0aGlzLnJpZ2h0K3RoaXMubGVmdCkvMixpPSh0aGlzLnRvcCt0aGlzLmJvdHRvbSkvMjtsZXQgcj1uLXQscz1uK3QsYT1pK2Usbz1pLWU7aWYobnVsbCE9PXRoaXMudmlldyYmdGhpcy52aWV3LmVuYWJsZWQpe2NvbnN0IHQ9KHRoaXMucmlnaHQtdGhpcy5sZWZ0KS90aGlzLnZpZXcuZnVsbFdpZHRoL3RoaXMuem9vbSxlPSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvdGhpcy52aWV3LmZ1bGxIZWlnaHQvdGhpcy56b29tO3IrPXQqdGhpcy52aWV3Lm9mZnNldFgscz1yK3QqdGhpcy52aWV3LndpZHRoLGEtPWUqdGhpcy52aWV3Lm9mZnNldFksbz1hLWUqdGhpcy52aWV3LmhlaWdodH10aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyhyLHMsYSxvLHRoaXMubmVhcix0aGlzLmZhciksdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCl9dG9KU09OKHQpe2NvbnN0IGU9c3VwZXIudG9KU09OKHQpO3JldHVybiBlLm9iamVjdC56b29tPXRoaXMuem9vbSxlLm9iamVjdC5sZWZ0PXRoaXMubGVmdCxlLm9iamVjdC5yaWdodD10aGlzLnJpZ2h0LGUub2JqZWN0LnRvcD10aGlzLnRvcCxlLm9iamVjdC5ib3R0b209dGhpcy5ib3R0b20sZS5vYmplY3QubmVhcj10aGlzLm5lYXIsZS5vYmplY3QuZmFyPXRoaXMuZmFyLG51bGwhPT10aGlzLnZpZXcmJihlLm9iamVjdC52aWV3PU9iamVjdC5hc3NpZ24oe30sdGhpcy52aWV3KSksZX19eGkucHJvdG90eXBlLmlzT3J0aG9ncmFwaGljQ2FtZXJhPSEwO2NsYXNzIGJpIGV4dGVuZHMgWW57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy50eXBlPVwiUmF3U2hhZGVyTWF0ZXJpYWxcIn19YmkucHJvdG90eXBlLmlzUmF3U2hhZGVyTWF0ZXJpYWw9ITA7Y29uc3Qgd2k9TWF0aC5wb3coMiw4KSxfaT1bLjEyNSwuMjE1LC4zNSwuNDQ2LC41MjYsLjU4Ml0sTWk9NStfaS5sZW5ndGgsU2k9ezNlMzowLDMwMDE6MSwzMDAyOjIsMzAwNDozLDMwMDU6NCwzMDA2OjUsMzAwNzo2fSxUaT1uZXcgeGkse19sb2RQbGFuZXM6RWksX3NpemVMb2RzOkFpLF9zaWdtYXM6TGl9PU9pKCksUmk9bmV3IGNuO2xldCBDaT1udWxsO2NvbnN0IFBpPSgxK01hdGguc3FydCg1KSkvMixJaT0xL1BpLERpPVtuZXcgQnQoMSwxLDEpLG5ldyBCdCgtMSwxLDEpLG5ldyBCdCgxLDEsLTEpLG5ldyBCdCgtMSwxLC0xKSxuZXcgQnQoMCxQaSxJaSksbmV3IEJ0KDAsUGksLUlpKSxuZXcgQnQoSWksMCxQaSksbmV3IEJ0KC1JaSwwLFBpKSxuZXcgQnQoUGksSWksMCksbmV3IEJ0KC1QaSxJaSwwKV07Y2xhc3MgTml7Y29uc3RydWN0b3IodCl7dGhpcy5fcmVuZGVyZXI9dCx0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldD1udWxsLHRoaXMuX2JsdXJNYXRlcmlhbD1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkodCksbj1uZXcgQnQoMCwxLDApO3JldHVybiBuZXcgYmkoe25hbWU6XCJTcGhlcmljYWxHYXVzc2lhbkJsdXJcIixkZWZpbmVzOntuOnR9LHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LHNhbXBsZXM6e3ZhbHVlOjF9LHdlaWdodHM6e3ZhbHVlOmV9LGxhdGl0dWRpbmFsOnt2YWx1ZTohMX0sZFRoZXRhOnt2YWx1ZTowfSxtaXBJbnQ6e3ZhbHVlOjB9LHBvbGVBeGlzOnt2YWx1ZTpufSxpbnB1dEVuY29kaW5nOnt2YWx1ZTpTaVszZTNdfSxvdXRwdXRFbmNvZGluZzp7dmFsdWU6U2lbM2UzXX19LHZlcnRleFNoYWRlcjpIaSgpLGZyYWdtZW50U2hhZGVyOmBcXG5cXG5cXHRcXHRcXHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXHRcXHRcXHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XFxuXFxuXFx0XFx0XFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XFxuXFxuXFx0XFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcblxcdFxcdFxcdHVuaWZvcm0gaW50IHNhbXBsZXM7XFxuXFx0XFx0XFx0dW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07XFxuXFx0XFx0XFx0dW5pZm9ybSBib29sIGxhdGl0dWRpbmFsO1xcblxcdFxcdFxcdHVuaWZvcm0gZmxvYXQgZFRoZXRhO1xcblxcdFxcdFxcdHVuaWZvcm0gZmxvYXQgbWlwSW50O1xcblxcdFxcdFxcdHVuaWZvcm0gdmVjMyBwb2xlQXhpcztcXG5cXG5cXHRcXHRcXHQke1ZpKCl9XFxuXFxuXFx0XFx0XFx0I2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0XFx0XFx0I2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG5cXG5cXHRcXHRcXHR2ZWMzIGdldFNhbXBsZSggZmxvYXQgdGhldGEsIHZlYzMgYXhpcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBjb3NUaGV0YSA9IGNvcyggdGhldGEgKTtcXG5cXHRcXHRcXHRcXHQvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb25cXG5cXHRcXHRcXHRcXHR2ZWMzIHNhbXBsZURpcmVjdGlvbiA9IHZPdXRwdXREaXJlY3Rpb24gKiBjb3NUaGV0YVxcblxcdFxcdFxcdFxcdFxcdCsgY3Jvc3MoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqIHNpbiggdGhldGEgKVxcblxcdFxcdFxcdFxcdFxcdCsgYXhpcyAqIGRvdCggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogKCAxLjAgLSBjb3NUaGV0YSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXJlY3Rpb24sIG1pcEludCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2b2lkIG1haW4oKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBheGlzID0gbGF0aXR1ZGluYWwgPyBwb2xlQXhpcyA6IGNyb3NzKCBwb2xlQXhpcywgdk91dHB1dERpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF4aXMgPSB2ZWMzKCB2T3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgLSB2T3V0cHV0RGlyZWN0aW9uLnggKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0YXhpcyA9IG5vcm1hbGl6ZSggYXhpcyApO1xcblxcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpID49IHNhbXBsZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGZsb2F0IHRoZXRhID0gZFRoZXRhICogZmxvYXQoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggLTEuMCAqIHRoZXRhLCBheGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIHRoZXRhLCBheGlzICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHRgLGJsZW5kaW5nOjAsZGVwdGhUZXN0OiExLGRlcHRoV3JpdGU6ITF9KX0oMjApLHRoaXMuX2VxdWlyZWN0U2hhZGVyPW51bGwsdGhpcy5fY3ViZW1hcFNoYWRlcj1udWxsLHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9ibHVyTWF0ZXJpYWwpfWZyb21TY2VuZSh0LGU9MCxuPS4xLGk9MTAwKXtDaT10aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtjb25zdCByPXRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO3JldHVybiB0aGlzLl9zY2VuZVRvQ3ViZVVWKHQsbixpLHIpLGU+MCYmdGhpcy5fYmx1cihyLDAsMCxlKSx0aGlzLl9hcHBseVBNUkVNKHIpLHRoaXMuX2NsZWFudXAocikscn1mcm9tRXF1aXJlY3Rhbmd1bGFyKHQpe3JldHVybiB0aGlzLl9mcm9tVGV4dHVyZSh0KX1mcm9tQ3ViZW1hcCh0KXtyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUodCl9Y29tcGlsZUN1YmVtYXBTaGFkZXIoKXtudWxsPT09dGhpcy5fY3ViZW1hcFNoYWRlciYmKHRoaXMuX2N1YmVtYXBTaGFkZXI9QmkoKSx0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fY3ViZW1hcFNoYWRlcikpfWNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKXtudWxsPT09dGhpcy5fZXF1aXJlY3RTaGFkZXImJih0aGlzLl9lcXVpcmVjdFNoYWRlcj16aSgpLHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9lcXVpcmVjdFNoYWRlcikpfWRpc3Bvc2UoKXt0aGlzLl9ibHVyTWF0ZXJpYWwuZGlzcG9zZSgpLG51bGwhPT10aGlzLl9jdWJlbWFwU2hhZGVyJiZ0aGlzLl9jdWJlbWFwU2hhZGVyLmRpc3Bvc2UoKSxudWxsIT09dGhpcy5fZXF1aXJlY3RTaGFkZXImJnRoaXMuX2VxdWlyZWN0U2hhZGVyLmRpc3Bvc2UoKTtmb3IobGV0IHQ9MDt0PEVpLmxlbmd0aDt0KyspRWlbdF0uZGlzcG9zZSgpfV9jbGVhbnVwKHQpe3RoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKSx0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoQ2kpLHQuc2Npc3NvclRlc3Q9ITEsa2kodCwwLDAsdC53aWR0aCx0LmhlaWdodCl9X2Zyb21UZXh0dXJlKHQpe0NpPXRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO2NvbnN0IGU9dGhpcy5fYWxsb2NhdGVUYXJnZXRzKHQpO3JldHVybiB0aGlzLl90ZXh0dXJlVG9DdWJlVVYodCxlKSx0aGlzLl9hcHBseVBNUkVNKGUpLHRoaXMuX2NsZWFudXAoZSksZX1fYWxsb2NhdGVUYXJnZXRzKHQpe2NvbnN0IGU9e21hZ0ZpbHRlcjoxMDAzLG1pbkZpbHRlcjoxMDAzLGdlbmVyYXRlTWlwbWFwczohMSx0eXBlOjEwMDksZm9ybWF0OjEwMjMsZW5jb2Rpbmc6RmkodCk/dC5lbmNvZGluZzozMDAyLGRlcHRoQnVmZmVyOiExfSxuPVVpKGUpO3JldHVybiBuLmRlcHRoQnVmZmVyPSF0LHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0PVVpKGUpLG59X2NvbXBpbGVNYXRlcmlhbCh0KXtjb25zdCBlPW5ldyBWbihFaVswXSx0KTt0aGlzLl9yZW5kZXJlci5jb21waWxlKGUsVGkpfV9zY2VuZVRvQ3ViZVVWKHQsZSxuLGkpe2NvbnN0IHI9bmV3IEpuKDkwLDEsZSxuKSxzPVsxLC0xLDEsMSwxLDFdLGE9WzEsMSwxLC0xLC0xLC0xXSxvPXRoaXMuX3JlbmRlcmVyLGw9by5hdXRvQ2xlYXIsYz1vLm91dHB1dEVuY29kaW5nLGg9by50b25lTWFwcGluZztvLmdldENsZWFyQ29sb3IoUmkpLG8udG9uZU1hcHBpbmc9MCxvLm91dHB1dEVuY29kaW5nPTNlMyxvLmF1dG9DbGVhcj0hMTtjb25zdCB1PW5ldyBobih7bmFtZTpcIlBNUkVNLkJhY2tncm91bmRcIixzaWRlOjEsZGVwdGhXcml0ZTohMSxkZXB0aFRlc3Q6ITF9KSxkPW5ldyBWbihuZXcgV24sdSk7bGV0IHA9ITE7Y29uc3QgbT10LmJhY2tncm91bmQ7bT9tLmlzQ29sb3ImJih1LmNvbG9yLmNvcHkobSksdC5iYWNrZ3JvdW5kPW51bGwscD0hMCk6KHUuY29sb3IuY29weShSaSkscD0hMCk7Zm9yKGxldCBlPTA7ZTw2O2UrKyl7Y29uc3Qgbj1lJTM7MD09bj8oci51cC5zZXQoMCxzW2VdLDApLHIubG9va0F0KGFbZV0sMCwwKSk6MT09bj8oci51cC5zZXQoMCwwLHNbZV0pLHIubG9va0F0KDAsYVtlXSwwKSk6KHIudXAuc2V0KDAsc1tlXSwwKSxyLmxvb2tBdCgwLDAsYVtlXSkpLGtpKGksbip3aSxlPjI/d2k6MCx3aSx3aSksby5zZXRSZW5kZXJUYXJnZXQoaSkscCYmby5yZW5kZXIoZCxyKSxvLnJlbmRlcih0LHIpfWQuZ2VvbWV0cnkuZGlzcG9zZSgpLGQubWF0ZXJpYWwuZGlzcG9zZSgpLG8udG9uZU1hcHBpbmc9aCxvLm91dHB1dEVuY29kaW5nPWMsby5hdXRvQ2xlYXI9bCx0LmJhY2tncm91bmQ9bX1fc2V0RW5jb2RpbmcodCxlKXshMD09PXRoaXMuX3JlbmRlcmVyLmNhcGFiaWxpdGllcy5pc1dlYkdMMiYmMTAyMz09PWUuZm9ybWF0JiYxMDA5PT09ZS50eXBlJiYzMDAxPT09ZS5lbmNvZGluZz90LnZhbHVlPVNpWzNlM106dC52YWx1ZT1TaVtlLmVuY29kaW5nXX1fdGV4dHVyZVRvQ3ViZVVWKHQsZSl7Y29uc3Qgbj10aGlzLl9yZW5kZXJlcjt0LmlzQ3ViZVRleHR1cmU/bnVsbD09dGhpcy5fY3ViZW1hcFNoYWRlciYmKHRoaXMuX2N1YmVtYXBTaGFkZXI9QmkoKSk6bnVsbD09dGhpcy5fZXF1aXJlY3RTaGFkZXImJih0aGlzLl9lcXVpcmVjdFNoYWRlcj16aSgpKTtjb25zdCBpPXQuaXNDdWJlVGV4dHVyZT90aGlzLl9jdWJlbWFwU2hhZGVyOnRoaXMuX2VxdWlyZWN0U2hhZGVyLHI9bmV3IFZuKEVpWzBdLGkpLHM9aS51bmlmb3JtcztzLmVudk1hcC52YWx1ZT10LHQuaXNDdWJlVGV4dHVyZXx8cy50ZXhlbFNpemUudmFsdWUuc2V0KDEvdC5pbWFnZS53aWR0aCwxL3QuaW1hZ2UuaGVpZ2h0KSx0aGlzLl9zZXRFbmNvZGluZyhzLmlucHV0RW5jb2RpbmcsdCksdGhpcy5fc2V0RW5jb2Rpbmcocy5vdXRwdXRFbmNvZGluZyxlLnRleHR1cmUpLGtpKGUsMCwwLDMqd2ksMip3aSksbi5zZXRSZW5kZXJUYXJnZXQoZSksbi5yZW5kZXIocixUaSl9X2FwcGx5UE1SRU0odCl7Y29uc3QgZT10aGlzLl9yZW5kZXJlcixuPWUuYXV0b0NsZWFyO2UuYXV0b0NsZWFyPSExO2ZvcihsZXQgZT0xO2U8TWk7ZSsrKXtjb25zdCBuPU1hdGguc3FydChMaVtlXSpMaVtlXS1MaVtlLTFdKkxpW2UtMV0pLGk9RGlbKGUtMSklRGkubGVuZ3RoXTt0aGlzLl9ibHVyKHQsZS0xLGUsbixpKX1lLmF1dG9DbGVhcj1ufV9ibHVyKHQsZSxuLGkscil7Y29uc3Qgcz10aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldDt0aGlzLl9oYWxmQmx1cih0LHMsZSxuLGksXCJsYXRpdHVkaW5hbFwiLHIpLHRoaXMuX2hhbGZCbHVyKHMsdCxuLG4saSxcImxvbmdpdHVkaW5hbFwiLHIpfV9oYWxmQmx1cih0LGUsbixpLHIscyxhKXtjb25zdCBvPXRoaXMuX3JlbmRlcmVyLGw9dGhpcy5fYmx1ck1hdGVyaWFsO1wibGF0aXR1ZGluYWxcIiE9PXMmJlwibG9uZ2l0dWRpbmFsXCIhPT1zJiZjb25zb2xlLmVycm9yKFwiYmx1ciBkaXJlY3Rpb24gbXVzdCBiZSBlaXRoZXIgbGF0aXR1ZGluYWwgb3IgbG9uZ2l0dWRpbmFsIVwiKTtjb25zdCBjPW5ldyBWbihFaVtpXSxsKSxoPWwudW5pZm9ybXMsdT1BaVtuXS0xLGQ9aXNGaW5pdGUocik/TWF0aC5QSS8oMip1KToyKk1hdGguUEkvMzkscD1yL2QsbT1pc0Zpbml0ZShyKT8xK01hdGguZmxvb3IoMypwKToyMDttPjIwJiZjb25zb2xlLndhcm4oYHNpZ21hUmFkaWFucywgJHtyfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke219IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gMjBgKTtjb25zdCBmPVtdO2xldCBnPTA7Zm9yKGxldCB0PTA7dDwyMDsrK3Qpe2NvbnN0IGU9dC9wLG49TWF0aC5leHAoLWUqZS8yKTtmLnB1c2gobiksMD09dD9nKz1uOnQ8bSYmKGcrPTIqbil9Zm9yKGxldCB0PTA7dDxmLmxlbmd0aDt0KyspZlt0XT1mW3RdL2c7aC5lbnZNYXAudmFsdWU9dC50ZXh0dXJlLGguc2FtcGxlcy52YWx1ZT1tLGgud2VpZ2h0cy52YWx1ZT1mLGgubGF0aXR1ZGluYWwudmFsdWU9XCJsYXRpdHVkaW5hbFwiPT09cyxhJiYoaC5wb2xlQXhpcy52YWx1ZT1hKSxoLmRUaGV0YS52YWx1ZT1kLGgubWlwSW50LnZhbHVlPTgtbix0aGlzLl9zZXRFbmNvZGluZyhoLmlucHV0RW5jb2RpbmcsdC50ZXh0dXJlKSx0aGlzLl9zZXRFbmNvZGluZyhoLm91dHB1dEVuY29kaW5nLHQudGV4dHVyZSk7Y29uc3Qgdj1BaVtpXTtraShlLDMqTWF0aC5tYXgoMCx3aS0yKnYpLCgwPT09aT8wOjIqd2kpKzIqdiooaT40P2ktOCs0OjApLDMqdiwyKnYpLG8uc2V0UmVuZGVyVGFyZ2V0KGUpLG8ucmVuZGVyKGMsVGkpfX1mdW5jdGlvbiBGaSh0KXtyZXR1cm4gdm9pZCAwIT09dCYmMTAwOT09PXQudHlwZSYmKDNlMz09PXQuZW5jb2Rpbmd8fDMwMDE9PT10LmVuY29kaW5nfHwzMDA3PT09dC5lbmNvZGluZyl9ZnVuY3Rpb24gT2koKXtjb25zdCB0PVtdLGU9W10sbj1bXTtsZXQgaT04O2ZvcihsZXQgcj0wO3I8TWk7cisrKXtjb25zdCBzPU1hdGgucG93KDIsaSk7ZS5wdXNoKHMpO2xldCBhPTEvcztyPjQ/YT1faVtyLTgrNC0xXTowPT1yJiYoYT0wKSxuLnB1c2goYSk7Y29uc3Qgbz0xLyhzLTEpLGw9LW8vMixjPTErby8yLGg9W2wsbCxjLGwsYyxjLGwsbCxjLGMsbCxjXSx1PTYsZD02LHA9MyxtPTIsZj0xLGc9bmV3IEZsb2F0MzJBcnJheShwKmQqdSksdj1uZXcgRmxvYXQzMkFycmF5KG0qZCp1KSx5PW5ldyBGbG9hdDMyQXJyYXkoZipkKnUpO2ZvcihsZXQgdD0wO3Q8dTt0Kyspe2NvbnN0IGU9dCUzKjIvMy0xLG49dD4yPzA6LTEsaT1bZSxuLDAsZSsyLzMsbiwwLGUrMi8zLG4rMSwwLGUsbiwwLGUrMi8zLG4rMSwwLGUsbisxLDBdO2cuc2V0KGkscCpkKnQpLHYuc2V0KGgsbSpkKnQpO2NvbnN0IHI9W3QsdCx0LHQsdCx0XTt5LnNldChyLGYqZCp0KX1jb25zdCB4PW5ldyBTbjt4LnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsbmV3IHBuKGcscCkpLHguc2V0QXR0cmlidXRlKFwidXZcIixuZXcgcG4odixtKSkseC5zZXRBdHRyaWJ1dGUoXCJmYWNlSW5kZXhcIixuZXcgcG4oeSxmKSksdC5wdXNoKHgpLGk+NCYmaS0tfXJldHVybntfbG9kUGxhbmVzOnQsX3NpemVMb2RzOmUsX3NpZ21hczpufX1mdW5jdGlvbiBVaSh0KXtjb25zdCBlPW5ldyBVdCgzKndpLDMqd2ksdCk7cmV0dXJuIGUudGV4dHVyZS5tYXBwaW5nPTMwNixlLnRleHR1cmUubmFtZT1cIlBNUkVNLmN1YmVVdlwiLGUuc2Npc3NvclRlc3Q9ITAsZX1mdW5jdGlvbiBraSh0LGUsbixpLHIpe3Qudmlld3BvcnQuc2V0KGUsbixpLHIpLHQuc2Npc3Nvci5zZXQoZSxuLGkscil9ZnVuY3Rpb24gemkoKXtjb25zdCB0PW5ldyBBdCgxLDEpO3JldHVybiBuZXcgYmkoe25hbWU6XCJFcXVpcmVjdGFuZ3VsYXJUb0N1YmVVVlwiLHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LHRleGVsU2l6ZTp7dmFsdWU6dH0saW5wdXRFbmNvZGluZzp7dmFsdWU6U2lbM2UzXX0sb3V0cHV0RW5jb2Rpbmc6e3ZhbHVlOlNpWzNlM119fSx2ZXJ0ZXhTaGFkZXI6SGkoKSxmcmFnbWVudFNoYWRlcjpgXFxuXFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xcblxcblxcdFxcdFxcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHRcXHRcXHR1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcblxcblxcdFxcdFxcdCR7VmkoKX1cXG5cXG5cXHRcXHRcXHQjaW5jbHVkZSA8Y29tbW9uPlxcblxcblxcdFxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApO1xcblxcdFxcdFxcdFxcdHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBvdXRwdXREaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZWMyIGYgPSBmcmFjdCggdXYgLyB0ZXhlbFNpemUgLSAwLjUgKTtcXG5cXHRcXHRcXHRcXHR1diAtPSBmICogdGV4ZWxTaXplO1xcblxcdFxcdFxcdFxcdHZlYzMgdGwgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XFxuXFx0XFx0XFx0XFx0dXYueCArPSB0ZXhlbFNpemUueDtcXG5cXHRcXHRcXHRcXHR2ZWMzIHRyID0gZW52TWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEICggZW52TWFwLCB1diApICkucmdiO1xcblxcdFxcdFxcdFxcdHV2LnkgKz0gdGV4ZWxTaXplLnk7XFxuXFx0XFx0XFx0XFx0dmVjMyBiciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCAoIGVudk1hcCwgdXYgKSApLnJnYjtcXG5cXHRcXHRcXHRcXHR1di54IC09IHRleGVsU2l6ZS54O1xcblxcdFxcdFxcdFxcdHZlYzMgYmwgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyB0bSA9IG1peCggdGwsIHRyLCBmLnggKTtcXG5cXHRcXHRcXHRcXHR2ZWMzIGJtID0gbWl4KCBibCwgYnIsIGYueCApO1xcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIHRtLCBibSwgZi55ICk7XFxuXFxuXFx0XFx0XFx0XFx0Z2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdGAsYmxlbmRpbmc6MCxkZXB0aFRlc3Q6ITEsZGVwdGhXcml0ZTohMX0pfWZ1bmN0aW9uIEJpKCl7cmV0dXJuIG5ldyBiaSh7bmFtZTpcIkN1YmVtYXBUb0N1YmVVVlwiLHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LGlucHV0RW5jb2Rpbmc6e3ZhbHVlOlNpWzNlM119LG91dHB1dEVuY29kaW5nOnt2YWx1ZTpTaVszZTNdfX0sdmVydGV4U2hhZGVyOkhpKCksZnJhZ21lbnRTaGFkZXI6YFxcblxcblxcdFxcdFxcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcdFxcdFxcdHByZWNpc2lvbiBtZWRpdW1wIGludDtcXG5cXG5cXHRcXHRcXHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXG5cXHRcXHRcXHQke1ZpKCl9XFxuXFxuXFx0XFx0XFx0dm9pZCBtYWluKCkge1xcblxcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCAtIHZPdXRwdXREaXJlY3Rpb24ueCwgdk91dHB1dERpcmVjdGlvbi55eiApICkgKS5yZ2I7XFxuXFx0XFx0XFx0XFx0Z2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdGAsYmxlbmRpbmc6MCxkZXB0aFRlc3Q6ITEsZGVwdGhXcml0ZTohMX0pfWZ1bmN0aW9uIEhpKCl7cmV0dXJuXCJcXG5cXG5cXHRcXHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXHRcXHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XFxuXFxuXFx0XFx0YXR0cmlidXRlIHZlYzMgcG9zaXRpb247XFxuXFx0XFx0YXR0cmlidXRlIHZlYzIgdXY7XFxuXFx0XFx0YXR0cmlidXRlIGZsb2F0IGZhY2VJbmRleDtcXG5cXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcXG5cXG5cXHRcXHQvLyBSSCBjb29yZGluYXRlIHN5c3RlbTsgUE1SRU0gZmFjZS1pbmRleGluZyBjb252ZW50aW9uXFxuXFx0XFx0dmVjMyBnZXREaXJlY3Rpb24oIHZlYzIgdXYsIGZsb2F0IGZhY2UgKSB7XFxuXFxuXFx0XFx0XFx0dXYgPSAyLjAgKiB1diAtIDEuMDtcXG5cXG5cXHRcXHRcXHR2ZWMzIGRpcmVjdGlvbiA9IHZlYzMoIHV2LCAxLjAgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGZhY2UgPT0gMC4wICkge1xcblxcblxcdFxcdFxcdFxcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7IC8vICggMSwgdiwgdSApIHBvcyB4XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTtcXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtdSwgMSwgLXYgKSBwb3MgeVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMi4wICkge1xcblxcblxcdFxcdFxcdFxcdGRpcmVjdGlvbi54ICo9IC0xLjA7IC8vICggLXUsIHYsIDEgKSBwb3MgelxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xcblxcblxcdFxcdFxcdFxcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7XFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uLnh6ICo9IC0xLjA7IC8vICggLTEsIHYsIC11ICkgbmVnIHhcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24ueHp5O1xcblxcdFxcdFxcdFxcdGRpcmVjdGlvbi54eSAqPSAtMS4wOyAvLyAoIC11LCAtMSwgdiApIG5lZyB5XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSA1LjAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uLnogKj0gLTEuMDsgLy8gKCB1LCB2LCAtMSApIG5lZyB6XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkaXJlY3Rpb247XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHR2T3V0cHV0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKCB1diwgZmFjZUluZGV4ICk7XFxuXFx0XFx0XFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuXFx0XFx0fVxcblxcdFwifWZ1bmN0aW9uIFZpKCl7cmV0dXJuXCJcXG5cXG5cXHRcXHR1bmlmb3JtIGludCBpbnB1dEVuY29kaW5nO1xcblxcdFxcdHVuaWZvcm0gaW50IG91dHB1dEVuY29kaW5nO1xcblxcblxcdFxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfcGFyc19mcmFnbWVudD5cXG5cXG5cXHRcXHR2ZWM0IGlucHV0VGV4ZWxUb0xpbmVhciggdmVjNCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGlucHV0RW5jb2RpbmcgPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggaW5wdXRFbmNvZGluZyA9PSAxICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBzUkdCVG9MaW5lYXIoIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggaW5wdXRFbmNvZGluZyA9PSAyICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBSR0JFVG9MaW5lYXIoIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggaW5wdXRFbmNvZGluZyA9PSAzICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBSR0JNVG9MaW5lYXIoIHZhbHVlLCA3LjAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBpbnB1dEVuY29kaW5nID09IDQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFJHQk1Ub0xpbmVhciggdmFsdWUsIDE2LjAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBpbnB1dEVuY29kaW5nID09IDUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFJHQkRUb0xpbmVhciggdmFsdWUsIDI1Ni4wICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gR2FtbWFUb0xpbmVhciggdmFsdWUsIDIuMiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmVjNCBsaW5lYXJUb091dHB1dFRleGVsKCB2ZWM0IHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggb3V0cHV0RW5jb2RpbmcgPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3V0cHV0RW5jb2RpbmcgPT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gTGluZWFyVG9zUkdCKCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG91dHB1dEVuY29kaW5nID09IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIExpbmVhclRvUkdCRSggdmFsdWUgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvdXRwdXRFbmNvZGluZyA9PSAzICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBMaW5lYXJUb1JHQk0oIHZhbHVlLCA3LjAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvdXRwdXRFbmNvZGluZyA9PSA0ICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBMaW5lYXJUb1JHQk0oIHZhbHVlLCAxNi4wICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3V0cHV0RW5jb2RpbmcgPT0gNSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gTGluZWFyVG9SR0JEKCB2YWx1ZSwgMjU2LjAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBMaW5lYXJUb0dhbW1hKCB2YWx1ZSwgMi4yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2ZWM0IGVudk1hcFRleGVsVG9MaW5lYXIoIHZlYzQgY29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGlucHV0VGV4ZWxUb0xpbmVhciggY29sb3IgKTtcXG5cXG5cXHRcXHR9XFxuXFx0XCJ9ZnVuY3Rpb24gR2kodCl7bGV0IGU9bmV3IFdlYWtNYXAsbj1udWxsO2Z1bmN0aW9uIGkodCl7Y29uc3Qgbj10LnRhcmdldDtuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsaSk7Y29uc3Qgcj1lLmdldChuKTt2b2lkIDAhPT1yJiYoZS5kZWxldGUobiksci5kaXNwb3NlKCkpfXJldHVybntnZXQ6ZnVuY3Rpb24ocil7aWYociYmci5pc1RleHR1cmUmJiExPT09ci5pc1JlbmRlclRhcmdldFRleHR1cmUpe2NvbnN0IHM9ci5tYXBwaW5nLGE9MzAzPT09c3x8MzA0PT09cyxvPTMwMT09PXN8fDMwMj09PXM7aWYoYXx8byl7aWYoZS5oYXMocikpcmV0dXJuIGUuZ2V0KHIpLnRleHR1cmU7e2NvbnN0IHM9ci5pbWFnZTtpZihhJiZzJiZzLmhlaWdodD4wfHxvJiZzJiZmdW5jdGlvbih0KXtsZXQgZT0wO2NvbnN0IG49Njtmb3IobGV0IGk9MDtpPG47aSsrKXZvaWQgMCE9PXRbaV0mJmUrKztyZXR1cm4gZT09PW59KHMpKXtjb25zdCBzPXQuZ2V0UmVuZGVyVGFyZ2V0KCk7bnVsbD09PW4mJihuPW5ldyBOaSh0KSk7Y29uc3Qgbz1hP24uZnJvbUVxdWlyZWN0YW5ndWxhcihyKTpuLmZyb21DdWJlbWFwKHIpO3JldHVybiBlLnNldChyLG8pLHQuc2V0UmVuZGVyVGFyZ2V0KHMpLHIuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixpKSxvLnRleHR1cmV9cmV0dXJuIG51bGx9fX1yZXR1cm4gcn0sZGlzcG9zZTpmdW5jdGlvbigpe2U9bmV3IFdlYWtNYXAsbnVsbCE9PW4mJihuLmRpc3Bvc2UoKSxuPW51bGwpfX19ZnVuY3Rpb24gV2kodCl7Y29uc3QgZT17fTtmdW5jdGlvbiBuKG4pe2lmKHZvaWQgMCE9PWVbbl0pcmV0dXJuIGVbbl07bGV0IGk7c3dpdGNoKG4pe2Nhc2VcIldFQkdMX2RlcHRoX3RleHR1cmVcIjppPXQuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKXx8dC5nZXRFeHRlbnNpb24oXCJNT1pfV0VCR0xfZGVwdGhfdGV4dHVyZVwiKXx8dC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZVwiKTticmVhaztjYXNlXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIjppPXQuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpfHx0LmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIil8fHQuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKTticmVhaztjYXNlXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiOmk9dC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKXx8dC5nZXRFeHRlbnNpb24oXCJNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIil8fHQuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpO2JyZWFrO2Nhc2VcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiOmk9dC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIil8fHQuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKTticmVhaztkZWZhdWx0Omk9dC5nZXRFeHRlbnNpb24obil9cmV0dXJuIGVbbl09aSxpfXJldHVybntoYXM6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT1uKHQpfSxpbml0OmZ1bmN0aW9uKHQpe3QuaXNXZWJHTDI/bihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIik6KG4oXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIpLG4oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSxuKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSxuKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIiksbihcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKSxuKFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKSxuKFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiksbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIikpLG4oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIiksbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKX0sZ2V0OmZ1bmN0aW9uKHQpe2NvbnN0IGU9bih0KTtyZXR1cm4gbnVsbD09PWUmJmNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFwiK3QrXCIgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuXCIpLGV9fX1mdW5jdGlvbiBqaSh0LGUsbixpKXtjb25zdCByPXt9LHM9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gYSh0KXtjb25zdCBvPXQudGFyZ2V0O251bGwhPT1vLmluZGV4JiZlLnJlbW92ZShvLmluZGV4KTtmb3IoY29uc3QgdCBpbiBvLmF0dHJpYnV0ZXMpZS5yZW1vdmUoby5hdHRyaWJ1dGVzW3RdKTtvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsYSksZGVsZXRlIHJbby5pZF07Y29uc3QgbD1zLmdldChvKTtsJiYoZS5yZW1vdmUobCkscy5kZWxldGUobykpLGkucmVsZWFzZVN0YXRlc09mR2VvbWV0cnkobyksITA9PT1vLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkmJmRlbGV0ZSBvLl9tYXhJbnN0YW5jZUNvdW50LG4ubWVtb3J5Lmdlb21ldHJpZXMtLX1mdW5jdGlvbiBvKHQpe2NvbnN0IG49W10saT10LmluZGV4LHI9dC5hdHRyaWJ1dGVzLnBvc2l0aW9uO2xldCBhPTA7aWYobnVsbCE9PWkpe2NvbnN0IHQ9aS5hcnJheTthPWkudmVyc2lvbjtmb3IobGV0IGU9MCxpPXQubGVuZ3RoO2U8aTtlKz0zKXtjb25zdCBpPXRbZSswXSxyPXRbZSsxXSxzPXRbZSsyXTtuLnB1c2goaSxyLHIscyxzLGkpfX1lbHNle2NvbnN0IHQ9ci5hcnJheTthPXIudmVyc2lvbjtmb3IobGV0IGU9MCxpPXQubGVuZ3RoLzMtMTtlPGk7ZSs9Myl7Y29uc3QgdD1lKzAsaT1lKzEscj1lKzI7bi5wdXNoKHQsaSxpLHIscix0KX19Y29uc3Qgbz1uZXcoUnQobik+NjU1MzU/Zm46bW4pKG4sMSk7by52ZXJzaW9uPWE7Y29uc3QgbD1zLmdldCh0KTtsJiZlLnJlbW92ZShsKSxzLnNldCh0LG8pfXJldHVybntnZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4hMD09PXJbZS5pZF18fChlLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsYSkscltlLmlkXT0hMCxuLm1lbW9yeS5nZW9tZXRyaWVzKyspLGV9LHVwZGF0ZTpmdW5jdGlvbih0KXtjb25zdCBuPXQuYXR0cmlidXRlcztmb3IoY29uc3QgdCBpbiBuKWUudXBkYXRlKG5bdF0sMzQ5NjIpO2NvbnN0IGk9dC5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IHQgaW4gaSl7Y29uc3Qgbj1pW3RdO2ZvcihsZXQgdD0wLGk9bi5sZW5ndGg7dDxpO3QrKyllLnVwZGF0ZShuW3RdLDM0OTYyKX19LGdldFdpcmVmcmFtZUF0dHJpYnV0ZTpmdW5jdGlvbih0KXtjb25zdCBlPXMuZ2V0KHQpO2lmKGUpe2NvbnN0IG49dC5pbmRleDtudWxsIT09biYmZS52ZXJzaW9uPG4udmVyc2lvbiYmbyh0KX1lbHNlIG8odCk7cmV0dXJuIHMuZ2V0KHQpfX19ZnVuY3Rpb24gcWkodCxlLG4saSl7Y29uc3Qgcj1pLmlzV2ViR0wyO2xldCBzLGEsbzt0aGlzLnNldE1vZGU9ZnVuY3Rpb24odCl7cz10fSx0aGlzLnNldEluZGV4PWZ1bmN0aW9uKHQpe2E9dC50eXBlLG89dC5ieXRlc1BlckVsZW1lbnR9LHRoaXMucmVuZGVyPWZ1bmN0aW9uKGUsaSl7dC5kcmF3RWxlbWVudHMocyxpLGEsZSpvKSxuLnVwZGF0ZShpLHMsMSl9LHRoaXMucmVuZGVySW5zdGFuY2VzPWZ1bmN0aW9uKGksbCxjKXtpZigwPT09YylyZXR1cm47bGV0IGgsdTtpZihyKWg9dCx1PVwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkXCI7ZWxzZSBpZihoPWUuZ2V0KFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKSx1PVwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEVcIixudWxsPT09aClyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLlwiKTtoW3VdKHMsbCxhLGkqbyxjKSxuLnVwZGF0ZShsLHMsYyl9fWZ1bmN0aW9uIFhpKHQpe2NvbnN0IGU9e2ZyYW1lOjAsY2FsbHM6MCx0cmlhbmdsZXM6MCxwb2ludHM6MCxsaW5lczowfTtyZXR1cm57bWVtb3J5OntnZW9tZXRyaWVzOjAsdGV4dHVyZXM6MH0scmVuZGVyOmUscHJvZ3JhbXM6bnVsbCxhdXRvUmVzZXQ6ITAscmVzZXQ6ZnVuY3Rpb24oKXtlLmZyYW1lKyssZS5jYWxscz0wLGUudHJpYW5nbGVzPTAsZS5wb2ludHM9MCxlLmxpbmVzPTB9LHVwZGF0ZTpmdW5jdGlvbih0LG4saSl7c3dpdGNoKGUuY2FsbHMrKyxuKXtjYXNlIDQ6ZS50cmlhbmdsZXMrPWkqKHQvMyk7YnJlYWs7Y2FzZSAxOmUubGluZXMrPWkqKHQvMik7YnJlYWs7Y2FzZSAzOmUubGluZXMrPWkqKHQtMSk7YnJlYWs7Y2FzZSAyOmUubGluZXMrPWkqdDticmVhaztjYXNlIDA6ZS5wb2ludHMrPWkqdDticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTEluZm86IFVua25vd24gZHJhdyBtb2RlOlwiLG4pfX19fWNsYXNzIFlpIGV4dGVuZHMgTnR7Y29uc3RydWN0b3IodD1udWxsLGU9MSxuPTEsaT0xKXtzdXBlcihudWxsKSx0aGlzLmltYWdlPXtkYXRhOnQsd2lkdGg6ZSxoZWlnaHQ6bixkZXB0aDppfSx0aGlzLm1hZ0ZpbHRlcj0xMDAzLHRoaXMubWluRmlsdGVyPTEwMDMsdGhpcy53cmFwUj0xMDAxLHRoaXMuZ2VuZXJhdGVNaXBtYXBzPSExLHRoaXMuZmxpcFk9ITEsdGhpcy51bnBhY2tBbGlnbm1lbnQ9MSx0aGlzLm5lZWRzVXBkYXRlPSEwfX1mdW5jdGlvbiBaaSh0LGUpe3JldHVybiB0WzBdLWVbMF19ZnVuY3Rpb24gSmkodCxlKXtyZXR1cm4gTWF0aC5hYnMoZVsxXSktTWF0aC5hYnModFsxXSl9ZnVuY3Rpb24gJGkodCxlKXtsZXQgbj0xO2NvbnN0IGk9ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlP2UuZGF0YS5hcnJheTplLmFycmF5O2kgaW5zdGFuY2VvZiBJbnQ4QXJyYXk/bj0xMjc6aSBpbnN0YW5jZW9mIEludDE2QXJyYXk/bj0zMjc2NzppIGluc3RhbmNlb2YgSW50MzJBcnJheT9uPTIxNDc0ODM2NDc6Y29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMTW9ycGh0YXJnZXRzOiBVbnN1cHBvcnRlZCBtb3JwaCBhdHRyaWJ1dGUgZGF0YSB0eXBlOiBcIixpKSx0LmRpdmlkZVNjYWxhcihuKX1mdW5jdGlvbiBLaSh0LGUsbil7Y29uc3QgaT17fSxyPW5ldyBGbG9hdDMyQXJyYXkoOCkscz1uZXcgV2Vha01hcCxhPW5ldyBCdCxvPVtdO2ZvcihsZXQgdD0wO3Q8ODt0Kyspb1t0XT1bdCwwXTtyZXR1cm57dXBkYXRlOmZ1bmN0aW9uKGwsYyxoLHUpe2NvbnN0IGQ9bC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7aWYoITA9PT1lLmlzV2ViR0wyKXtjb25zdCBpPWMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aDtsZXQgcj1zLmdldChjKTtpZih2b2lkIDA9PT1yfHxyLmNvdW50IT09aSl7dm9pZCAwIT09ciYmci50ZXh0dXJlLmRpc3Bvc2UoKTtjb25zdCB0PXZvaWQgMCE9PWMubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCxuPWMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLG89Yy5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsfHxbXSxsPSEwPT09dD8yOjE7bGV0IGg9Yy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50KmwsdT0xO2g+ZS5tYXhUZXh0dXJlU2l6ZSYmKHU9TWF0aC5jZWlsKGgvZS5tYXhUZXh0dXJlU2l6ZSksaD1lLm1heFRleHR1cmVTaXplKTtjb25zdCBkPW5ldyBGbG9hdDMyQXJyYXkoaCp1KjQqaSkscD1uZXcgWWkoZCxoLHUsaSk7cC5mb3JtYXQ9MTAyMyxwLnR5cGU9MTAxNTtjb25zdCBtPTQqbDtmb3IobGV0IGU9MDtlPGk7ZSsrKXtjb25zdCBpPW5bZV0scj1vW2VdLHM9aCp1KjQqZTtmb3IobGV0IGU9MDtlPGkuY291bnQ7ZSsrKXthLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSxlKSwhMD09PWkubm9ybWFsaXplZCYmJGkoYSxpKTtjb25zdCBuPWUqbTtkW3MrbiswXT1hLngsZFtzK24rMV09YS55LGRbcytuKzJdPWEueixkW3MrbiszXT0wLCEwPT09dCYmKGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLGUpLCEwPT09ci5ub3JtYWxpemVkJiYkaShhLHIpLGRbcytuKzRdPWEueCxkW3Mrbis1XT1hLnksZFtzK24rNl09YS56LGRbcytuKzddPTApfX1yPXtjb3VudDppLHRleHR1cmU6cCxzaXplOm5ldyBBdChoLHUpfSxzLnNldChjLHIpfWxldCBvPTA7Zm9yKGxldCB0PTA7dDxkLmxlbmd0aDt0Kyspbys9ZFt0XTtjb25zdCBsPWMubW9ycGhUYXJnZXRzUmVsYXRpdmU/MToxLW87dS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKHQsXCJtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2VcIixsKSx1LmdldFVuaWZvcm1zKCkuc2V0VmFsdWUodCxcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiLGQpLHUuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSh0LFwibW9ycGhUYXJnZXRzVGV4dHVyZVwiLHIudGV4dHVyZSxuKSx1LmdldFVuaWZvcm1zKCkuc2V0VmFsdWUodCxcIm1vcnBoVGFyZ2V0c1RleHR1cmVTaXplXCIsci5zaXplKX1lbHNle2NvbnN0IGU9dm9pZCAwPT09ZD8wOmQubGVuZ3RoO2xldCBuPWlbYy5pZF07aWYodm9pZCAwPT09bnx8bi5sZW5ndGghPT1lKXtuPVtdO2ZvcihsZXQgdD0wO3Q8ZTt0Kyspblt0XT1bdCwwXTtpW2MuaWRdPW59Zm9yKGxldCB0PTA7dDxlO3QrKyl7Y29uc3QgZT1uW3RdO2VbMF09dCxlWzFdPWRbdF19bi5zb3J0KEppKTtmb3IobGV0IHQ9MDt0PDg7dCsrKXQ8ZSYmblt0XVsxXT8ob1t0XVswXT1uW3RdWzBdLG9bdF1bMV09blt0XVsxXSk6KG9bdF1bMF09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsb1t0XVsxXT0wKTtvLnNvcnQoWmkpO2NvbnN0IHM9Yy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24sYT1jLm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7bGV0IGw9MDtmb3IobGV0IHQ9MDt0PDg7dCsrKXtjb25zdCBlPW9bdF0sbj1lWzBdLGk9ZVsxXTtuIT09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVImJmk/KHMmJmMuZ2V0QXR0cmlidXRlKFwibW9ycGhUYXJnZXRcIit0KSE9PXNbbl0mJmMuc2V0QXR0cmlidXRlKFwibW9ycGhUYXJnZXRcIit0LHNbbl0pLGEmJmMuZ2V0QXR0cmlidXRlKFwibW9ycGhOb3JtYWxcIit0KSE9PWFbbl0mJmMuc2V0QXR0cmlidXRlKFwibW9ycGhOb3JtYWxcIit0LGFbbl0pLHJbdF09aSxsKz1pKToocyYmITA9PT1jLmhhc0F0dHJpYnV0ZShcIm1vcnBoVGFyZ2V0XCIrdCkmJmMuZGVsZXRlQXR0cmlidXRlKFwibW9ycGhUYXJnZXRcIit0KSxhJiYhMD09PWMuaGFzQXR0cmlidXRlKFwibW9ycGhOb3JtYWxcIit0KSYmYy5kZWxldGVBdHRyaWJ1dGUoXCJtb3JwaE5vcm1hbFwiK3QpLHJbdF09MCl9Y29uc3QgaD1jLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPzE6MS1sO3UuZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSh0LFwibW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlXCIsaCksdS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKHQsXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIixyKX19fX1mdW5jdGlvbiBRaSh0LGUsbixpKXtsZXQgcj1uZXcgV2Vha01hcDtmdW5jdGlvbiBzKHQpe2NvbnN0IGU9dC50YXJnZXQ7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLHMpLG4ucmVtb3ZlKGUuaW5zdGFuY2VNYXRyaXgpLG51bGwhPT1lLmluc3RhbmNlQ29sb3ImJm4ucmVtb3ZlKGUuaW5zdGFuY2VDb2xvcil9cmV0dXJue3VwZGF0ZTpmdW5jdGlvbih0KXtjb25zdCBhPWkucmVuZGVyLmZyYW1lLG89dC5nZW9tZXRyeSxsPWUuZ2V0KHQsbyk7cmV0dXJuIHIuZ2V0KGwpIT09YSYmKGUudXBkYXRlKGwpLHIuc2V0KGwsYSkpLHQuaXNJbnN0YW5jZWRNZXNoJiYoITE9PT10Lmhhc0V2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIscykmJnQuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixzKSxuLnVwZGF0ZSh0Lmluc3RhbmNlTWF0cml4LDM0OTYyKSxudWxsIT09dC5pbnN0YW5jZUNvbG9yJiZuLnVwZGF0ZSh0Lmluc3RhbmNlQ29sb3IsMzQ5NjIpKSxsfSxkaXNwb3NlOmZ1bmN0aW9uKCl7cj1uZXcgV2Vha01hcH19fVlpLnByb3RvdHlwZS5pc0RhdGFUZXh0dXJlMkRBcnJheT0hMDtjbGFzcyB0ciBleHRlbmRzIE50e2NvbnN0cnVjdG9yKHQ9bnVsbCxlPTEsbj0xLGk9MSl7c3VwZXIobnVsbCksdGhpcy5pbWFnZT17ZGF0YTp0LHdpZHRoOmUsaGVpZ2h0Om4sZGVwdGg6aX0sdGhpcy5tYWdGaWx0ZXI9MTAwMyx0aGlzLm1pbkZpbHRlcj0xMDAzLHRoaXMud3JhcFI9MTAwMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmZsaXBZPSExLHRoaXMudW5wYWNrQWxpZ25tZW50PTEsdGhpcy5uZWVkc1VwZGF0ZT0hMH19dHIucHJvdG90eXBlLmlzRGF0YVRleHR1cmUzRD0hMDtjb25zdCBlcj1uZXcgTnQsbnI9bmV3IFlpLGlyPW5ldyB0cixycj1uZXcgS24sc3I9W10sYXI9W10sb3I9bmV3IEZsb2F0MzJBcnJheSgxNiksbHI9bmV3IEZsb2F0MzJBcnJheSg5KSxjcj1uZXcgRmxvYXQzMkFycmF5KDQpO2Z1bmN0aW9uIGhyKHQsZSxuKXtjb25zdCBpPXRbMF07aWYoaTw9MHx8aT4wKXJldHVybiB0O2NvbnN0IHI9ZSpuO2xldCBzPXNyW3JdO2lmKHZvaWQgMD09PXMmJihzPW5ldyBGbG9hdDMyQXJyYXkociksc3Jbcl09cyksMCE9PWUpe2kudG9BcnJheShzLDApO2ZvcihsZXQgaT0xLHI9MDtpIT09ZTsrK2kpcis9bix0W2ldLnRvQXJyYXkocyxyKX1yZXR1cm4gc31mdW5jdGlvbiB1cih0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKWlmKHRbbl0hPT1lW25dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGRyKHQsZSl7Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXRbbl09ZVtuXX1mdW5jdGlvbiBwcih0LGUpe2xldCBuPWFyW2VdO3ZvaWQgMD09PW4mJihuPW5ldyBJbnQzMkFycmF5KGUpLGFyW2VdPW4pO2ZvcihsZXQgaT0wO2khPT1lOysraSluW2ldPXQuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO3JldHVybiBufWZ1bmN0aW9uIG1yKHQsZSl7Y29uc3Qgbj10aGlzLmNhY2hlO25bMF0hPT1lJiYodC51bmlmb3JtMWYodGhpcy5hZGRyLGUpLG5bMF09ZSl9ZnVuY3Rpb24gZnIodCxlKXtjb25zdCBuPXRoaXMuY2FjaGU7aWYodm9pZCAwIT09ZS54KW5bMF09PT1lLngmJm5bMV09PT1lLnl8fCh0LnVuaWZvcm0yZih0aGlzLmFkZHIsZS54LGUueSksblswXT1lLngsblsxXT1lLnkpO2Vsc2V7aWYodXIobixlKSlyZXR1cm47dC51bmlmb3JtMmZ2KHRoaXMuYWRkcixlKSxkcihuLGUpfX1mdW5jdGlvbiBncih0LGUpe2NvbnN0IG49dGhpcy5jYWNoZTtpZih2b2lkIDAhPT1lLngpblswXT09PWUueCYmblsxXT09PWUueSYmblsyXT09PWUuenx8KHQudW5pZm9ybTNmKHRoaXMuYWRkcixlLngsZS55LGUueiksblswXT1lLngsblsxXT1lLnksblsyXT1lLnopO2Vsc2UgaWYodm9pZCAwIT09ZS5yKW5bMF09PT1lLnImJm5bMV09PT1lLmcmJm5bMl09PT1lLmJ8fCh0LnVuaWZvcm0zZih0aGlzLmFkZHIsZS5yLGUuZyxlLmIpLG5bMF09ZS5yLG5bMV09ZS5nLG5bMl09ZS5iKTtlbHNle2lmKHVyKG4sZSkpcmV0dXJuO3QudW5pZm9ybTNmdih0aGlzLmFkZHIsZSksZHIobixlKX19ZnVuY3Rpb24gdnIodCxlKXtjb25zdCBuPXRoaXMuY2FjaGU7aWYodm9pZCAwIT09ZS54KW5bMF09PT1lLngmJm5bMV09PT1lLnkmJm5bMl09PT1lLnomJm5bM109PT1lLnd8fCh0LnVuaWZvcm00Zih0aGlzLmFkZHIsZS54LGUueSxlLnosZS53KSxuWzBdPWUueCxuWzFdPWUueSxuWzJdPWUueixuWzNdPWUudyk7ZWxzZXtpZih1cihuLGUpKXJldHVybjt0LnVuaWZvcm00ZnYodGhpcy5hZGRyLGUpLGRyKG4sZSl9fWZ1bmN0aW9uIHlyKHQsZSl7Y29uc3Qgbj10aGlzLmNhY2hlLGk9ZS5lbGVtZW50cztpZih2b2lkIDA9PT1pKXtpZih1cihuLGUpKXJldHVybjt0LnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCExLGUpLGRyKG4sZSl9ZWxzZXtpZih1cihuLGkpKXJldHVybjtjci5zZXQoaSksdC51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwhMSxjciksZHIobixpKX19ZnVuY3Rpb24geHIodCxlKXtjb25zdCBuPXRoaXMuY2FjaGUsaT1lLmVsZW1lbnRzO2lmKHZvaWQgMD09PWkpe2lmKHVyKG4sZSkpcmV0dXJuO3QudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsITEsZSksZHIobixlKX1lbHNle2lmKHVyKG4saSkpcmV0dXJuO2xyLnNldChpKSx0LnVuaWZvcm1NYXRyaXgzZnYodGhpcy5hZGRyLCExLGxyKSxkcihuLGkpfX1mdW5jdGlvbiBicih0LGUpe2NvbnN0IG49dGhpcy5jYWNoZSxpPWUuZWxlbWVudHM7aWYodm9pZCAwPT09aSl7aWYodXIobixlKSlyZXR1cm47dC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwhMSxlKSxkcihuLGUpfWVsc2V7aWYodXIobixpKSlyZXR1cm47b3Iuc2V0KGkpLHQudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsITEsb3IpLGRyKG4saSl9fWZ1bmN0aW9uIHdyKHQsZSl7Y29uc3Qgbj10aGlzLmNhY2hlO25bMF0hPT1lJiYodC51bmlmb3JtMWkodGhpcy5hZGRyLGUpLG5bMF09ZSl9ZnVuY3Rpb24gX3IodCxlKXtjb25zdCBuPXRoaXMuY2FjaGU7dXIobixlKXx8KHQudW5pZm9ybTJpdih0aGlzLmFkZHIsZSksZHIobixlKSl9ZnVuY3Rpb24gTXIodCxlKXtjb25zdCBuPXRoaXMuY2FjaGU7dXIobixlKXx8KHQudW5pZm9ybTNpdih0aGlzLmFkZHIsZSksZHIobixlKSl9ZnVuY3Rpb24gU3IodCxlKXtjb25zdCBuPXRoaXMuY2FjaGU7dXIobixlKXx8KHQudW5pZm9ybTRpdih0aGlzLmFkZHIsZSksZHIobixlKSl9ZnVuY3Rpb24gVHIodCxlKXtjb25zdCBuPXRoaXMuY2FjaGU7blswXSE9PWUmJih0LnVuaWZvcm0xdWkodGhpcy5hZGRyLGUpLG5bMF09ZSl9ZnVuY3Rpb24gRXIodCxlKXtjb25zdCBuPXRoaXMuY2FjaGU7dXIobixlKXx8KHQudW5pZm9ybTJ1aXYodGhpcy5hZGRyLGUpLGRyKG4sZSkpfWZ1bmN0aW9uIEFyKHQsZSl7Y29uc3Qgbj10aGlzLmNhY2hlO3VyKG4sZSl8fCh0LnVuaWZvcm0zdWl2KHRoaXMuYWRkcixlKSxkcihuLGUpKX1mdW5jdGlvbiBMcih0LGUpe2NvbnN0IG49dGhpcy5jYWNoZTt1cihuLGUpfHwodC51bmlmb3JtNHVpdih0aGlzLmFkZHIsZSksZHIobixlKSl9ZnVuY3Rpb24gUnIodCxlLG4pe2NvbnN0IGk9dGhpcy5jYWNoZSxyPW4uYWxsb2NhdGVUZXh0dXJlVW5pdCgpO2lbMF0hPT1yJiYodC51bmlmb3JtMWkodGhpcy5hZGRyLHIpLGlbMF09ciksbi5zYWZlU2V0VGV4dHVyZTJEKGV8fGVyLHIpfWZ1bmN0aW9uIENyKHQsZSxuKXtjb25zdCBpPXRoaXMuY2FjaGUscj1uLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtpWzBdIT09ciYmKHQudW5pZm9ybTFpKHRoaXMuYWRkcixyKSxpWzBdPXIpLG4uc2V0VGV4dHVyZTNEKGV8fGlyLHIpfWZ1bmN0aW9uIFByKHQsZSxuKXtjb25zdCBpPXRoaXMuY2FjaGUscj1uLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtpWzBdIT09ciYmKHQudW5pZm9ybTFpKHRoaXMuYWRkcixyKSxpWzBdPXIpLG4uc2FmZVNldFRleHR1cmVDdWJlKGV8fHJyLHIpfWZ1bmN0aW9uIElyKHQsZSxuKXtjb25zdCBpPXRoaXMuY2FjaGUscj1uLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtpWzBdIT09ciYmKHQudW5pZm9ybTFpKHRoaXMuYWRkcixyKSxpWzBdPXIpLG4uc2V0VGV4dHVyZTJEQXJyYXkoZXx8bnIscil9ZnVuY3Rpb24gRHIodCxlKXt0LnVuaWZvcm0xZnYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIE5yKHQsZSl7Y29uc3Qgbj1ocihlLHRoaXMuc2l6ZSwyKTt0LnVuaWZvcm0yZnYodGhpcy5hZGRyLG4pfWZ1bmN0aW9uIEZyKHQsZSl7Y29uc3Qgbj1ocihlLHRoaXMuc2l6ZSwzKTt0LnVuaWZvcm0zZnYodGhpcy5hZGRyLG4pfWZ1bmN0aW9uIE9yKHQsZSl7Y29uc3Qgbj1ocihlLHRoaXMuc2l6ZSw0KTt0LnVuaWZvcm00ZnYodGhpcy5hZGRyLG4pfWZ1bmN0aW9uIFVyKHQsZSl7Y29uc3Qgbj1ocihlLHRoaXMuc2l6ZSw0KTt0LnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCExLG4pfWZ1bmN0aW9uIGtyKHQsZSl7Y29uc3Qgbj1ocihlLHRoaXMuc2l6ZSw5KTt0LnVuaWZvcm1NYXRyaXgzZnYodGhpcy5hZGRyLCExLG4pfWZ1bmN0aW9uIHpyKHQsZSl7Y29uc3Qgbj1ocihlLHRoaXMuc2l6ZSwxNik7dC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwhMSxuKX1mdW5jdGlvbiBCcih0LGUpe3QudW5pZm9ybTFpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gSHIodCxlKXt0LnVuaWZvcm0yaXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIFZyKHQsZSl7dC51bmlmb3JtM2l2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBHcih0LGUpe3QudW5pZm9ybTRpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gV3IodCxlKXt0LnVuaWZvcm0xdWl2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBqcih0LGUpe3QudW5pZm9ybTJ1aXYodGhpcy5hZGRyLGUpfWZ1bmN0aW9uIHFyKHQsZSl7dC51bmlmb3JtM3Vpdih0aGlzLmFkZHIsZSl9ZnVuY3Rpb24gWHIodCxlKXt0LnVuaWZvcm00dWl2KHRoaXMuYWRkcixlKX1mdW5jdGlvbiBZcih0LGUsbil7Y29uc3QgaT1lLmxlbmd0aCxyPXByKG4saSk7dC51bmlmb3JtMWl2KHRoaXMuYWRkcixyKTtmb3IobGV0IHQ9MDt0IT09aTsrK3Qpbi5zYWZlU2V0VGV4dHVyZTJEKGVbdF18fGVyLHJbdF0pfWZ1bmN0aW9uIFpyKHQsZSxuKXtjb25zdCBpPWUubGVuZ3RoLHI9cHIobixpKTt0LnVuaWZvcm0xaXYodGhpcy5hZGRyLHIpO2ZvcihsZXQgdD0wO3QhPT1pOysrdCluLnNhZmVTZXRUZXh0dXJlQ3ViZShlW3RdfHxycixyW3RdKX1mdW5jdGlvbiBKcih0LGUsbil7dGhpcy5pZD10LHRoaXMuYWRkcj1uLHRoaXMuY2FjaGU9W10sdGhpcy5zZXRWYWx1ZT1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSA1MTI2OnJldHVybiBtcjtjYXNlIDM1NjY0OnJldHVybiBmcjtjYXNlIDM1NjY1OnJldHVybiBncjtjYXNlIDM1NjY2OnJldHVybiB2cjtjYXNlIDM1Njc0OnJldHVybiB5cjtjYXNlIDM1Njc1OnJldHVybiB4cjtjYXNlIDM1Njc2OnJldHVybiBicjtjYXNlIDUxMjQ6Y2FzZSAzNTY3MDpyZXR1cm4gd3I7Y2FzZSAzNTY2NzpjYXNlIDM1NjcxOnJldHVybiBfcjtjYXNlIDM1NjY4OmNhc2UgMzU2NzI6cmV0dXJuIE1yO2Nhc2UgMzU2Njk6Y2FzZSAzNTY3MzpyZXR1cm4gU3I7Y2FzZSA1MTI1OnJldHVybiBUcjtjYXNlIDM2Mjk0OnJldHVybiBFcjtjYXNlIDM2Mjk1OnJldHVybiBBcjtjYXNlIDM2Mjk2OnJldHVybiBMcjtjYXNlIDM1Njc4OmNhc2UgMzYxOTg6Y2FzZSAzNjI5ODpjYXNlIDM2MzA2OmNhc2UgMzU2ODI6cmV0dXJuIFJyO2Nhc2UgMzU2Nzk6Y2FzZSAzNjI5OTpjYXNlIDM2MzA3OnJldHVybiBDcjtjYXNlIDM1NjgwOmNhc2UgMzYzMDA6Y2FzZSAzNjMwODpjYXNlIDM2MjkzOnJldHVybiBQcjtjYXNlIDM2Mjg5OmNhc2UgMzYzMDM6Y2FzZSAzNjMxMTpjYXNlIDM2MjkyOnJldHVybiBJcn19KGUudHlwZSl9ZnVuY3Rpb24gJHIodCxlLG4pe3RoaXMuaWQ9dCx0aGlzLmFkZHI9bix0aGlzLmNhY2hlPVtdLHRoaXMuc2l6ZT1lLnNpemUsdGhpcy5zZXRWYWx1ZT1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSA1MTI2OnJldHVybiBEcjtjYXNlIDM1NjY0OnJldHVybiBOcjtjYXNlIDM1NjY1OnJldHVybiBGcjtjYXNlIDM1NjY2OnJldHVybiBPcjtjYXNlIDM1Njc0OnJldHVybiBVcjtjYXNlIDM1Njc1OnJldHVybiBrcjtjYXNlIDM1Njc2OnJldHVybiB6cjtjYXNlIDUxMjQ6Y2FzZSAzNTY3MDpyZXR1cm4gQnI7Y2FzZSAzNTY2NzpjYXNlIDM1NjcxOnJldHVybiBIcjtjYXNlIDM1NjY4OmNhc2UgMzU2NzI6cmV0dXJuIFZyO2Nhc2UgMzU2Njk6Y2FzZSAzNTY3MzpyZXR1cm4gR3I7Y2FzZSA1MTI1OnJldHVybiBXcjtjYXNlIDM2Mjk0OnJldHVybiBqcjtjYXNlIDM2Mjk1OnJldHVybiBxcjtjYXNlIDM2Mjk2OnJldHVybiBYcjtjYXNlIDM1Njc4OmNhc2UgMzYxOTg6Y2FzZSAzNjI5ODpjYXNlIDM2MzA2OmNhc2UgMzU2ODI6cmV0dXJuIFlyO2Nhc2UgMzU2ODA6Y2FzZSAzNjMwMDpjYXNlIDM2MzA4OmNhc2UgMzYyOTM6cmV0dXJuIFpyfX0oZS50eXBlKX1mdW5jdGlvbiBLcih0KXt0aGlzLmlkPXQsdGhpcy5zZXE9W10sdGhpcy5tYXA9e319JHIucHJvdG90eXBlLnVwZGF0ZUNhY2hlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dGhpcy5jYWNoZTt0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5JiZlLmxlbmd0aCE9PXQubGVuZ3RoJiYodGhpcy5jYWNoZT1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSksZHIoZSx0KX0sS3IucHJvdG90eXBlLnNldFZhbHVlPWZ1bmN0aW9uKHQsZSxuKXtjb25zdCBpPXRoaXMuc2VxO2ZvcihsZXQgcj0wLHM9aS5sZW5ndGg7ciE9PXM7KytyKXtjb25zdCBzPWlbcl07cy5zZXRWYWx1ZSh0LGVbcy5pZF0sbil9fTtjb25zdCBRcj0vKFxcdyspKFxcXSk/KFxcW3xcXC4pPy9nO2Z1bmN0aW9uIHRzKHQsZSl7dC5zZXEucHVzaChlKSx0Lm1hcFtlLmlkXT1lfWZ1bmN0aW9uIGVzKHQsZSxuKXtjb25zdCBpPXQubmFtZSxyPWkubGVuZ3RoO2ZvcihRci5sYXN0SW5kZXg9MDs7KXtjb25zdCBzPVFyLmV4ZWMoaSksYT1Rci5sYXN0SW5kZXg7bGV0IG89c1sxXTtjb25zdCBsPVwiXVwiPT09c1syXSxjPXNbM107aWYobCYmKG98PTApLHZvaWQgMD09PWN8fFwiW1wiPT09YyYmYSsyPT09cil7dHMobix2b2lkIDA9PT1jP25ldyBKcihvLHQsZSk6bmV3ICRyKG8sdCxlKSk7YnJlYWt9e2xldCB0PW4ubWFwW29dO3ZvaWQgMD09PXQmJih0PW5ldyBLcihvKSx0cyhuLHQpKSxuPXR9fX1mdW5jdGlvbiBucyh0LGUpe3RoaXMuc2VxPVtdLHRoaXMubWFwPXt9O2NvbnN0IG49dC5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsMzU3MTgpO2ZvcihsZXQgaT0wO2k8bjsrK2kpe2NvbnN0IG49dC5nZXRBY3RpdmVVbmlmb3JtKGUsaSk7ZXMobix0LmdldFVuaWZvcm1Mb2NhdGlvbihlLG4ubmFtZSksdGhpcyl9fWZ1bmN0aW9uIGlzKHQsZSxuKXtjb25zdCBpPXQuY3JlYXRlU2hhZGVyKGUpO3JldHVybiB0LnNoYWRlclNvdXJjZShpLG4pLHQuY29tcGlsZVNoYWRlcihpKSxpfW5zLnByb3RvdHlwZS5zZXRWYWx1ZT1mdW5jdGlvbih0LGUsbixpKXtjb25zdCByPXRoaXMubWFwW2VdO3ZvaWQgMCE9PXImJnIuc2V0VmFsdWUodCxuLGkpfSxucy5wcm90b3R5cGUuc2V0T3B0aW9uYWw9ZnVuY3Rpb24odCxlLG4pe2NvbnN0IGk9ZVtuXTt2b2lkIDAhPT1pJiZ0aGlzLnNldFZhbHVlKHQsbixpKX0sbnMudXBsb2FkPWZ1bmN0aW9uKHQsZSxuLGkpe2ZvcihsZXQgcj0wLHM9ZS5sZW5ndGg7ciE9PXM7KytyKXtjb25zdCBzPWVbcl0sYT1uW3MuaWRdOyExIT09YS5uZWVkc1VwZGF0ZSYmcy5zZXRWYWx1ZSh0LGEudmFsdWUsaSl9fSxucy5zZXFXaXRoVmFsdWU9ZnVuY3Rpb24odCxlKXtjb25zdCBuPVtdO2ZvcihsZXQgaT0wLHI9dC5sZW5ndGg7aSE9PXI7KytpKXtjb25zdCByPXRbaV07ci5pZCBpbiBlJiZuLnB1c2gocil9cmV0dXJuIG59O2xldCBycz0wO2Z1bmN0aW9uIHNzKHQpe3N3aXRjaCh0KXtjYXNlIDNlMzpyZXR1cm5bXCJMaW5lYXJcIixcIiggdmFsdWUgKVwiXTtjYXNlIDMwMDE6cmV0dXJuW1wic1JHQlwiLFwiKCB2YWx1ZSApXCJdO2Nhc2UgMzAwMjpyZXR1cm5bXCJSR0JFXCIsXCIoIHZhbHVlIClcIl07Y2FzZSAzMDA0OnJldHVybltcIlJHQk1cIixcIiggdmFsdWUsIDcuMCApXCJdO2Nhc2UgMzAwNTpyZXR1cm5bXCJSR0JNXCIsXCIoIHZhbHVlLCAxNi4wIClcIl07Y2FzZSAzMDA2OnJldHVybltcIlJHQkRcIixcIiggdmFsdWUsIDI1Ni4wIClcIl07Y2FzZSAzMDA3OnJldHVybltcIkdhbW1hXCIsXCIoIHZhbHVlLCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKVwiXTtjYXNlIDMwMDM6cmV0dXJuW1wiTG9nTHV2XCIsXCIoIHZhbHVlIClcIl07ZGVmYXVsdDpyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBVbnN1cHBvcnRlZCBlbmNvZGluZzpcIix0KSxbXCJMaW5lYXJcIixcIiggdmFsdWUgKVwiXX19ZnVuY3Rpb24gYXModCxlLG4pe2NvbnN0IGk9dC5nZXRTaGFkZXJQYXJhbWV0ZXIoZSwzNTcxMykscj10LmdldFNoYWRlckluZm9Mb2coZSkudHJpbSgpO3JldHVybiBpJiZcIlwiPT09cj9cIlwiOm4udG9VcHBlckNhc2UoKStcIlxcblxcblwiK3IrXCJcXG5cXG5cIitmdW5jdGlvbih0KXtjb25zdCBlPXQuc3BsaXQoXCJcXG5cIik7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspZVt0XT10KzErXCI6IFwiK2VbdF07cmV0dXJuIGUuam9pbihcIlxcblwiKX0odC5nZXRTaGFkZXJTb3VyY2UoZSkpfWZ1bmN0aW9uIG9zKHQsZSl7Y29uc3Qgbj1zcyhlKTtyZXR1cm5cInZlYzQgXCIrdCtcIiggdmVjNCB2YWx1ZSApIHsgcmV0dXJuIFwiK25bMF0rXCJUb0xpbmVhclwiK25bMV0rXCI7IH1cIn1mdW5jdGlvbiBscyh0LGUpe2NvbnN0IG49c3MoZSk7cmV0dXJuXCJ2ZWM0IFwiK3QrXCIoIHZlYzQgdmFsdWUgKSB7IHJldHVybiBMaW5lYXJUb1wiK25bMF0rblsxXStcIjsgfVwifWZ1bmN0aW9uIGNzKHQsZSl7bGV0IG47c3dpdGNoKGUpe2Nhc2UgMTpuPVwiTGluZWFyXCI7YnJlYWs7Y2FzZSAyOm49XCJSZWluaGFyZFwiO2JyZWFrO2Nhc2UgMzpuPVwiT3B0aW1pemVkQ2luZW9uXCI7YnJlYWs7Y2FzZSA0Om49XCJBQ0VTRmlsbWljXCI7YnJlYWs7Y2FzZSA1Om49XCJDdXN0b21cIjticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUHJvZ3JhbTogVW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6XCIsZSksbj1cIkxpbmVhclwifXJldHVyblwidmVjMyBcIit0K1wiKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gXCIrbitcIlRvbmVNYXBwaW5nKCBjb2xvciApOyB9XCJ9ZnVuY3Rpb24gaHModCl7cmV0dXJuXCJcIiE9PXR9ZnVuY3Rpb24gdXModCxlKXtyZXR1cm4gdC5yZXBsYWNlKC9OVU1fRElSX0xJR0hUUy9nLGUubnVtRGlyTGlnaHRzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVFMvZyxlLm51bVNwb3RMaWdodHMpLnJlcGxhY2UoL05VTV9SRUNUX0FSRUFfTElHSFRTL2csZS5udW1SZWN0QXJlYUxpZ2h0cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUUy9nLGUubnVtUG9pbnRMaWdodHMpLnJlcGxhY2UoL05VTV9IRU1JX0xJR0hUUy9nLGUubnVtSGVtaUxpZ2h0cykucmVwbGFjZSgvTlVNX0RJUl9MSUdIVF9TSEFET1dTL2csZS5udW1EaXJMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUX1NIQURPV1MvZyxlLm51bVNwb3RMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9QT0lOVF9MSUdIVF9TSEFET1dTL2csZS5udW1Qb2ludExpZ2h0U2hhZG93cyl9ZnVuY3Rpb24gZHModCxlKXtyZXR1cm4gdC5yZXBsYWNlKC9OVU1fQ0xJUFBJTkdfUExBTkVTL2csZS5udW1DbGlwcGluZ1BsYW5lcykucmVwbGFjZSgvVU5JT05fQ0xJUFBJTkdfUExBTkVTL2csZS5udW1DbGlwcGluZ1BsYW5lcy1lLm51bUNsaXBJbnRlcnNlY3Rpb24pfWNvbnN0IHBzPS9eWyBcXHRdKiNpbmNsdWRlICs8KFtcXHdcXGQuL10rKT4vZ207ZnVuY3Rpb24gbXModCl7cmV0dXJuIHQucmVwbGFjZShwcyxmcyl9ZnVuY3Rpb24gZnModCxlKXtjb25zdCBuPWhpW2VdO2lmKHZvaWQgMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZXNvbHZlICNpbmNsdWRlIDxcIitlK1wiPlwiKTtyZXR1cm4gbXMobil9Y29uc3QgZ3M9LyNwcmFnbWEgdW5yb2xsX2xvb3BbXFxzXSs/Zm9yIFxcKCBpbnQgaSBcXD0gKFxcZCspXFw7IGkgPCAoXFxkKylcXDsgaSBcXCtcXCsgXFwpIFxceyhbXFxzXFxTXSs/KSg/PVxcfSlcXH0vZyx2cz0vI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxccytmb3JcXHMqXFwoXFxzKmludFxccytpXFxzKj1cXHMqKFxcZCspXFxzKjtcXHMqaVxccyo8XFxzKihcXGQrKVxccyo7XFxzKmlcXHMqXFwrXFwrXFxzKlxcKVxccyp7KFtcXHNcXFNdKz8pfVxccysjcHJhZ21hIHVucm9sbF9sb29wX2VuZC9nO2Z1bmN0aW9uIHlzKHQpe3JldHVybiB0LnJlcGxhY2UodnMsYnMpLnJlcGxhY2UoZ3MseHMpfWZ1bmN0aW9uIHhzKHQsZSxuLGkpe3JldHVybiBjb25zb2xlLndhcm4oXCJXZWJHTFByb2dyYW06ICNwcmFnbWEgdW5yb2xsX2xvb3Agc2hhZGVyIHN5bnRheCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnQgc3ludGF4IGluc3RlYWQuXCIpLGJzKHQsZSxuLGkpfWZ1bmN0aW9uIGJzKHQsZSxuLGkpe2xldCByPVwiXCI7Zm9yKGxldCB0PXBhcnNlSW50KGUpO3Q8cGFyc2VJbnQobik7dCsrKXIrPWkucmVwbGFjZSgvXFxbXFxzKmlcXHMqXFxdL2csXCJbIFwiK3QrXCIgXVwiKS5yZXBsYWNlKC9VTlJPTExFRF9MT09QX0lOREVYL2csdCk7cmV0dXJuIHJ9ZnVuY3Rpb24gd3ModCl7bGV0IGU9XCJwcmVjaXNpb24gXCIrdC5wcmVjaXNpb24rXCIgZmxvYXQ7XFxucHJlY2lzaW9uIFwiK3QucHJlY2lzaW9uK1wiIGludDtcIjtyZXR1cm5cImhpZ2hwXCI9PT10LnByZWNpc2lvbj9lKz1cIlxcbiNkZWZpbmUgSElHSF9QUkVDSVNJT05cIjpcIm1lZGl1bXBcIj09PXQucHJlY2lzaW9uP2UrPVwiXFxuI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OXCI6XCJsb3dwXCI9PT10LnByZWNpc2lvbiYmKGUrPVwiXFxuI2RlZmluZSBMT1dfUFJFQ0lTSU9OXCIpLGV9ZnVuY3Rpb24gX3ModCxlLG4saSl7Y29uc3Qgcj10LmdldENvbnRleHQoKSxzPW4uZGVmaW5lcztsZXQgYT1uLnZlcnRleFNoYWRlcixvPW4uZnJhZ21lbnRTaGFkZXI7Y29uc3QgbD1mdW5jdGlvbih0KXtsZXQgZT1cIlNIQURPV01BUF9UWVBFX0JBU0lDXCI7cmV0dXJuIDE9PT10LnNoYWRvd01hcFR5cGU/ZT1cIlNIQURPV01BUF9UWVBFX1BDRlwiOjI9PT10LnNoYWRvd01hcFR5cGU/ZT1cIlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUXCI6Mz09PXQuc2hhZG93TWFwVHlwZSYmKGU9XCJTSEFET1dNQVBfVFlQRV9WU01cIiksZX0obiksYz1mdW5jdGlvbih0KXtsZXQgZT1cIkVOVk1BUF9UWVBFX0NVQkVcIjtpZih0LmVudk1hcClzd2l0Y2godC5lbnZNYXBNb2RlKXtjYXNlIDMwMTpjYXNlIDMwMjplPVwiRU5WTUFQX1RZUEVfQ1VCRVwiO2JyZWFrO2Nhc2UgMzA2OmNhc2UgMzA3OmU9XCJFTlZNQVBfVFlQRV9DVUJFX1VWXCJ9cmV0dXJuIGV9KG4pLGg9ZnVuY3Rpb24odCl7bGV0IGU9XCJFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXCI7aWYodC5lbnZNYXApc3dpdGNoKHQuZW52TWFwTW9kZSl7Y2FzZSAzMDI6Y2FzZSAzMDc6ZT1cIkVOVk1BUF9NT0RFX1JFRlJBQ1RJT05cIn1yZXR1cm4gZX0obiksdT1mdW5jdGlvbih0KXtsZXQgZT1cIkVOVk1BUF9CTEVORElOR19OT05FXCI7aWYodC5lbnZNYXApc3dpdGNoKHQuY29tYmluZSl7Y2FzZSAwOmU9XCJFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcIjticmVhaztjYXNlIDE6ZT1cIkVOVk1BUF9CTEVORElOR19NSVhcIjticmVhaztjYXNlIDI6ZT1cIkVOVk1BUF9CTEVORElOR19BRERcIn1yZXR1cm4gZX0obiksZD10LmdhbW1hRmFjdG9yPjA/dC5nYW1tYUZhY3RvcjoxLHA9bi5pc1dlYkdMMj9cIlwiOmZ1bmN0aW9uKHQpe3JldHVyblt0LmV4dGVuc2lvbkRlcml2YXRpdmVzfHx0LmVudk1hcEN1YmVVVnx8dC5idW1wTWFwfHx0LnRhbmdlbnRTcGFjZU5vcm1hbE1hcHx8dC5jbGVhcmNvYXROb3JtYWxNYXB8fHQuZmxhdFNoYWRpbmd8fFwicGh5c2ljYWxcIj09PXQuc2hhZGVySUQ/XCIjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVwiOlwiXCIsKHQuZXh0ZW5zaW9uRnJhZ0RlcHRofHx0LmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpJiZ0LnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoP1wiI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVwiOlwiXCIsdC5leHRlbnNpb25EcmF3QnVmZmVycyYmdC5yZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzP1wiI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZVwiOlwiXCIsKHQuZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRHx8dC5lbnZNYXB8fHQudHJhbnNtaXNzaW9uKSYmdC5yZW5kZXJlckV4dGVuc2lvblNoYWRlclRleHR1cmVMb2Q/XCIjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcIjpcIlwiXS5maWx0ZXIoaHMpLmpvaW4oXCJcXG5cIil9KG4pLG09ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IoY29uc3QgbiBpbiB0KXtjb25zdCBpPXRbbl07ITEhPT1pJiZlLnB1c2goXCIjZGVmaW5lIFwiK24rXCIgXCIraSl9cmV0dXJuIGUuam9pbihcIlxcblwiKX0ocyksZj1yLmNyZWF0ZVByb2dyYW0oKTtsZXQgZyx2LHk9bi5nbHNsVmVyc2lvbj9cIiN2ZXJzaW9uIFwiK24uZ2xzbFZlcnNpb24rXCJcXG5cIjpcIlwiO24uaXNSYXdTaGFkZXJNYXRlcmlhbD8oZz1bbV0uZmlsdGVyKGhzKS5qb2luKFwiXFxuXCIpLGcubGVuZ3RoPjAmJihnKz1cIlxcblwiKSx2PVtwLG1dLmZpbHRlcihocykuam9pbihcIlxcblwiKSx2Lmxlbmd0aD4wJiYodis9XCJcXG5cIikpOihnPVt3cyhuKSxcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIrbi5zaGFkZXJOYW1lLG0sbi5pbnN0YW5jaW5nP1wiI2RlZmluZSBVU0VfSU5TVEFOQ0lOR1wiOlwiXCIsbi5pbnN0YW5jaW5nQ29sb3I/XCIjZGVmaW5lIFVTRV9JTlNUQU5DSU5HX0NPTE9SXCI6XCJcIixuLnN1cHBvcnRzVmVydGV4VGV4dHVyZXM/XCIjZGVmaW5lIFZFUlRFWF9URVhUVVJFU1wiOlwiXCIsXCIjZGVmaW5lIEdBTU1BX0ZBQ1RPUiBcIitkLFwiI2RlZmluZSBNQVhfQk9ORVMgXCIrbi5tYXhCb25lcyxuLnVzZUZvZyYmbi5mb2c/XCIjZGVmaW5lIFVTRV9GT0dcIjpcIlwiLG4udXNlRm9nJiZuLmZvZ0V4cDI/XCIjZGVmaW5lIEZPR19FWFAyXCI6XCJcIixuLm1hcD9cIiNkZWZpbmUgVVNFX01BUFwiOlwiXCIsbi5lbnZNYXA/XCIjZGVmaW5lIFVTRV9FTlZNQVBcIjpcIlwiLG4uZW52TWFwP1wiI2RlZmluZSBcIitoOlwiXCIsbi5saWdodE1hcD9cIiNkZWZpbmUgVVNFX0xJR0hUTUFQXCI6XCJcIixuLmFvTWFwP1wiI2RlZmluZSBVU0VfQU9NQVBcIjpcIlwiLG4uZW1pc3NpdmVNYXA/XCIjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUFwiOlwiXCIsbi5idW1wTWFwP1wiI2RlZmluZSBVU0VfQlVNUE1BUFwiOlwiXCIsbi5ub3JtYWxNYXA/XCIjZGVmaW5lIFVTRV9OT1JNQUxNQVBcIjpcIlwiLG4ubm9ybWFsTWFwJiZuLm9iamVjdFNwYWNlTm9ybWFsTWFwP1wiI2RlZmluZSBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcIjpcIlwiLG4ubm9ybWFsTWFwJiZuLnRhbmdlbnRTcGFjZU5vcm1hbE1hcD9cIiNkZWZpbmUgVEFOR0VOVFNQQUNFX05PUk1BTE1BUFwiOlwiXCIsbi5jbGVhcmNvYXRNYXA/XCIjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVBcIjpcIlwiLG4uY2xlYXJjb2F0Um91Z2huZXNzTWFwP1wiI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFwiOlwiXCIsbi5jbGVhcmNvYXROb3JtYWxNYXA/XCIjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXCI6XCJcIixuLmRpc3BsYWNlbWVudE1hcCYmbi5zdXBwb3J0c1ZlcnRleFRleHR1cmVzP1wiI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQXCI6XCJcIixuLnNwZWN1bGFyTWFwP1wiI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVBcIjpcIlwiLG4uc3BlY3VsYXJJbnRlbnNpdHlNYXA/XCIjZGVmaW5lIFVTRV9TUEVDVUxBUklOVEVOU0lUWU1BUFwiOlwiXCIsbi5zcGVjdWxhclRpbnRNYXA/XCIjZGVmaW5lIFVTRV9TUEVDVUxBUlRJTlRNQVBcIjpcIlwiLG4ucm91Z2huZXNzTWFwP1wiI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQXCI6XCJcIixuLm1ldGFsbmVzc01hcD9cIiNkZWZpbmUgVVNFX01FVEFMTkVTU01BUFwiOlwiXCIsbi5hbHBoYU1hcD9cIiNkZWZpbmUgVVNFX0FMUEhBTUFQXCI6XCJcIixuLnRyYW5zbWlzc2lvbj9cIiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTlwiOlwiXCIsbi50cmFuc21pc3Npb25NYXA/XCIjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVBcIjpcIlwiLG4udGhpY2tuZXNzTWFwP1wiI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQXCI6XCJcIixuLnZlcnRleFRhbmdlbnRzP1wiI2RlZmluZSBVU0VfVEFOR0VOVFwiOlwiXCIsbi52ZXJ0ZXhDb2xvcnM/XCIjZGVmaW5lIFVTRV9DT0xPUlwiOlwiXCIsbi52ZXJ0ZXhBbHBoYXM/XCIjZGVmaW5lIFVTRV9DT0xPUl9BTFBIQVwiOlwiXCIsbi52ZXJ0ZXhVdnM/XCIjZGVmaW5lIFVTRV9VVlwiOlwiXCIsbi51dnNWZXJ0ZXhPbmx5P1wiI2RlZmluZSBVVlNfVkVSVEVYX09OTFlcIjpcIlwiLG4uZmxhdFNoYWRpbmc/XCIjZGVmaW5lIEZMQVRfU0hBREVEXCI6XCJcIixuLnNraW5uaW5nP1wiI2RlZmluZSBVU0VfU0tJTk5JTkdcIjpcIlwiLG4udXNlVmVydGV4VGV4dHVyZT9cIiNkZWZpbmUgQk9ORV9URVhUVVJFXCI6XCJcIixuLm1vcnBoVGFyZ2V0cz9cIiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUU1wiOlwiXCIsbi5tb3JwaE5vcm1hbHMmJiExPT09bi5mbGF0U2hhZGluZz9cIiNkZWZpbmUgVVNFX01PUlBITk9STUFMU1wiOlwiXCIsbi5tb3JwaFRhcmdldHMmJm4uaXNXZWJHTDI/XCIjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFXCI6XCJcIixuLm1vcnBoVGFyZ2V0cyYmbi5pc1dlYkdMMj9cIiNkZWZpbmUgTU9SUEhUQVJHRVRTX0NPVU5UIFwiK24ubW9ycGhUYXJnZXRzQ291bnQ6XCJcIixuLmRvdWJsZVNpZGVkP1wiI2RlZmluZSBET1VCTEVfU0lERURcIjpcIlwiLG4uZmxpcFNpZGVkP1wiI2RlZmluZSBGTElQX1NJREVEXCI6XCJcIixuLnNoYWRvd01hcEVuYWJsZWQ/XCIjZGVmaW5lIFVTRV9TSEFET1dNQVBcIjpcIlwiLG4uc2hhZG93TWFwRW5hYmxlZD9cIiNkZWZpbmUgXCIrbDpcIlwiLG4uc2l6ZUF0dGVudWF0aW9uP1wiI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OXCI6XCJcIixuLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI/XCIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRlwiOlwiXCIsbi5sb2dhcml0aG1pY0RlcHRoQnVmZmVyJiZuLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoP1wiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUXCI6XCJcIixcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcIixcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXCJ1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcIixcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFwidW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcIixcInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjtcIixcInVuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYztcIixcIiNpZmRlZiBVU0VfSU5TVEFOQ0lOR1wiLFwiXFx0YXR0cmlidXRlIG1hdDQgaW5zdGFuY2VNYXRyaXg7XCIsXCIjZW5kaWZcIixcIiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUlwiLFwiXFx0YXR0cmlidXRlIHZlYzMgaW5zdGFuY2VDb2xvcjtcIixcIiNlbmRpZlwiLFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXCJhdHRyaWJ1dGUgdmVjMyBub3JtYWw7XCIsXCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcIiNpZmRlZiBVU0VfVEFOR0VOVFwiLFwiXFx0YXR0cmlidXRlIHZlYzQgdGFuZ2VudDtcIixcIiNlbmRpZlwiLFwiI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXCIsXCJcXHRhdHRyaWJ1dGUgdmVjNCBjb2xvcjtcIixcIiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXCIsXCJcXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcIixcIiNlbmRpZlwiLFwiI2lmICggZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApICYmICEgZGVmaW5lZCggTU9SUEhUQVJHRVRTX1RFWFRVUkUgKSApXCIsXCJcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7XCIsXCJcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7XCIsXCJcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7XCIsXCJcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7XCIsXCJcXHQjaWZkZWYgVVNFX01PUlBITk9STUFMU1wiLFwiXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwO1wiLFwiXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxO1wiLFwiXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyO1wiLFwiXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzO1wiLFwiXFx0I2Vsc2VcIixcIlxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDtcIixcIlxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTtcIixcIlxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjtcIixcIlxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NztcIixcIlxcdCNlbmRpZlwiLFwiI2VuZGlmXCIsXCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXCJcXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7XCIsXCJcXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0O1wiLFwiI2VuZGlmXCIsXCJcXG5cIl0uZmlsdGVyKGhzKS5qb2luKFwiXFxuXCIpLHY9W3Asd3MobiksXCIjZGVmaW5lIFNIQURFUl9OQU1FIFwiK24uc2hhZGVyTmFtZSxtLFwiI2RlZmluZSBHQU1NQV9GQUNUT1IgXCIrZCxuLnVzZUZvZyYmbi5mb2c/XCIjZGVmaW5lIFVTRV9GT0dcIjpcIlwiLG4udXNlRm9nJiZuLmZvZ0V4cDI/XCIjZGVmaW5lIEZPR19FWFAyXCI6XCJcIixuLm1hcD9cIiNkZWZpbmUgVVNFX01BUFwiOlwiXCIsbi5tYXRjYXA/XCIjZGVmaW5lIFVTRV9NQVRDQVBcIjpcIlwiLG4uZW52TWFwP1wiI2RlZmluZSBVU0VfRU5WTUFQXCI6XCJcIixuLmVudk1hcD9cIiNkZWZpbmUgXCIrYzpcIlwiLG4uZW52TWFwP1wiI2RlZmluZSBcIitoOlwiXCIsbi5lbnZNYXA/XCIjZGVmaW5lIFwiK3U6XCJcIixuLmxpZ2h0TWFwP1wiI2RlZmluZSBVU0VfTElHSFRNQVBcIjpcIlwiLG4uYW9NYXA/XCIjZGVmaW5lIFVTRV9BT01BUFwiOlwiXCIsbi5lbWlzc2l2ZU1hcD9cIiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQXCI6XCJcIixuLmJ1bXBNYXA/XCIjZGVmaW5lIFVTRV9CVU1QTUFQXCI6XCJcIixuLm5vcm1hbE1hcD9cIiNkZWZpbmUgVVNFX05PUk1BTE1BUFwiOlwiXCIsbi5ub3JtYWxNYXAmJm4ub2JqZWN0U3BhY2VOb3JtYWxNYXA/XCIjZGVmaW5lIE9CSkVDVFNQQUNFX05PUk1BTE1BUFwiOlwiXCIsbi5ub3JtYWxNYXAmJm4udGFuZ2VudFNwYWNlTm9ybWFsTWFwP1wiI2RlZmluZSBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQXCI6XCJcIixuLmNsZWFyY29hdD9cIiNkZWZpbmUgVVNFX0NMRUFSQ09BVFwiOlwiXCIsbi5jbGVhcmNvYXRNYXA/XCIjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVBcIjpcIlwiLG4uY2xlYXJjb2F0Um91Z2huZXNzTWFwP1wiI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFwiOlwiXCIsbi5jbGVhcmNvYXROb3JtYWxNYXA/XCIjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXCI6XCJcIixuLnNwZWN1bGFyTWFwP1wiI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVBcIjpcIlwiLG4uc3BlY3VsYXJJbnRlbnNpdHlNYXA/XCIjZGVmaW5lIFVTRV9TUEVDVUxBUklOVEVOU0lUWU1BUFwiOlwiXCIsbi5zcGVjdWxhclRpbnRNYXA/XCIjZGVmaW5lIFVTRV9TUEVDVUxBUlRJTlRNQVBcIjpcIlwiLG4ucm91Z2huZXNzTWFwP1wiI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQXCI6XCJcIixuLm1ldGFsbmVzc01hcD9cIiNkZWZpbmUgVVNFX01FVEFMTkVTU01BUFwiOlwiXCIsbi5hbHBoYU1hcD9cIiNkZWZpbmUgVVNFX0FMUEhBTUFQXCI6XCJcIixuLmFscGhhVGVzdD9cIiNkZWZpbmUgVVNFX0FMUEhBVEVTVFwiOlwiXCIsbi5zaGVlbj9cIiNkZWZpbmUgVVNFX1NIRUVOXCI6XCJcIixuLnRyYW5zbWlzc2lvbj9cIiNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTlwiOlwiXCIsbi50cmFuc21pc3Npb25NYXA/XCIjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVBcIjpcIlwiLG4udGhpY2tuZXNzTWFwP1wiI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQXCI6XCJcIixuLnZlcnRleFRhbmdlbnRzP1wiI2RlZmluZSBVU0VfVEFOR0VOVFwiOlwiXCIsbi52ZXJ0ZXhDb2xvcnN8fG4uaW5zdGFuY2luZ0NvbG9yP1wiI2RlZmluZSBVU0VfQ09MT1JcIjpcIlwiLG4udmVydGV4QWxwaGFzP1wiI2RlZmluZSBVU0VfQ09MT1JfQUxQSEFcIjpcIlwiLG4udmVydGV4VXZzP1wiI2RlZmluZSBVU0VfVVZcIjpcIlwiLG4udXZzVmVydGV4T25seT9cIiNkZWZpbmUgVVZTX1ZFUlRFWF9PTkxZXCI6XCJcIixuLmdyYWRpZW50TWFwP1wiI2RlZmluZSBVU0VfR1JBRElFTlRNQVBcIjpcIlwiLG4uZmxhdFNoYWRpbmc/XCIjZGVmaW5lIEZMQVRfU0hBREVEXCI6XCJcIixuLmRvdWJsZVNpZGVkP1wiI2RlZmluZSBET1VCTEVfU0lERURcIjpcIlwiLG4uZmxpcFNpZGVkP1wiI2RlZmluZSBGTElQX1NJREVEXCI6XCJcIixuLnNoYWRvd01hcEVuYWJsZWQ/XCIjZGVmaW5lIFVTRV9TSEFET1dNQVBcIjpcIlwiLG4uc2hhZG93TWFwRW5hYmxlZD9cIiNkZWZpbmUgXCIrbDpcIlwiLG4ucHJlbXVsdGlwbGllZEFscGhhP1wiI2RlZmluZSBQUkVNVUxUSVBMSUVEX0FMUEhBXCI6XCJcIixuLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzP1wiI2RlZmluZSBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXCI6XCJcIixuLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI/XCIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRlwiOlwiXCIsbi5sb2dhcml0aG1pY0RlcHRoQnVmZmVyJiZuLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoP1wiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUXCI6XCJcIiwobi5leHRlbnNpb25TaGFkZXJUZXh0dXJlTE9EfHxuLmVudk1hcCkmJm4ucmVuZGVyZXJFeHRlbnNpb25TaGFkZXJUZXh0dXJlTG9kP1wiI2RlZmluZSBURVhUVVJFX0xPRF9FWFRcIjpcIlwiLFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXCJ1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XCIsXCJ1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7XCIsMCE9PW4udG9uZU1hcHBpbmc/XCIjZGVmaW5lIFRPTkVfTUFQUElOR1wiOlwiXCIsMCE9PW4udG9uZU1hcHBpbmc/aGkudG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDpcIlwiLDAhPT1uLnRvbmVNYXBwaW5nP2NzKFwidG9uZU1hcHBpbmdcIixuLnRvbmVNYXBwaW5nKTpcIlwiLG4uZGl0aGVyaW5nP1wiI2RlZmluZSBESVRIRVJJTkdcIjpcIlwiLDEwMjI9PT1uLmZvcm1hdD9cIiNkZWZpbmUgT1BBUVVFXCI6XCJcIixoaS5lbmNvZGluZ3NfcGFyc19mcmFnbWVudCxuLm1hcD9vcyhcIm1hcFRleGVsVG9MaW5lYXJcIixuLm1hcEVuY29kaW5nKTpcIlwiLG4ubWF0Y2FwP29zKFwibWF0Y2FwVGV4ZWxUb0xpbmVhclwiLG4ubWF0Y2FwRW5jb2RpbmcpOlwiXCIsbi5lbnZNYXA/b3MoXCJlbnZNYXBUZXhlbFRvTGluZWFyXCIsbi5lbnZNYXBFbmNvZGluZyk6XCJcIixuLmVtaXNzaXZlTWFwP29zKFwiZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyXCIsbi5lbWlzc2l2ZU1hcEVuY29kaW5nKTpcIlwiLG4uc3BlY3VsYXJUaW50TWFwP29zKFwic3BlY3VsYXJUaW50TWFwVGV4ZWxUb0xpbmVhclwiLG4uc3BlY3VsYXJUaW50TWFwRW5jb2RpbmcpOlwiXCIsbi5saWdodE1hcD9vcyhcImxpZ2h0TWFwVGV4ZWxUb0xpbmVhclwiLG4ubGlnaHRNYXBFbmNvZGluZyk6XCJcIixscyhcImxpbmVhclRvT3V0cHV0VGV4ZWxcIixuLm91dHB1dEVuY29kaW5nKSxuLmRlcHRoUGFja2luZz9cIiNkZWZpbmUgREVQVEhfUEFDS0lORyBcIituLmRlcHRoUGFja2luZzpcIlwiLFwiXFxuXCJdLmZpbHRlcihocykuam9pbihcIlxcblwiKSksYT1tcyhhKSxhPXVzKGEsbiksYT1kcyhhLG4pLG89bXMobyksbz11cyhvLG4pLG89ZHMobyxuKSxhPXlzKGEpLG89eXMobyksbi5pc1dlYkdMMiYmITAhPT1uLmlzUmF3U2hhZGVyTWF0ZXJpYWwmJih5PVwiI3ZlcnNpb24gMzAwIGVzXFxuXCIsZz1bXCJwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkRBcnJheTtcIixcIiNkZWZpbmUgYXR0cmlidXRlIGluXCIsXCIjZGVmaW5lIHZhcnlpbmcgb3V0XCIsXCIjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlXCJdLmpvaW4oXCJcXG5cIikrXCJcXG5cIitnLHY9W1wiI2RlZmluZSB2YXJ5aW5nIGluXCIsXCIzMDAgZXNcIj09PW4uZ2xzbFZlcnNpb24/XCJcIjpcIm91dCBoaWdocCB2ZWM0IHBjX2ZyYWdDb2xvcjtcIixcIjMwMCBlc1wiPT09bi5nbHNsVmVyc2lvbj9cIlwiOlwiI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yXCIsXCIjZGVmaW5lIGdsX0ZyYWdEZXB0aEVYVCBnbF9GcmFnRGVwdGhcIixcIiNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmVcIixcIiNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZVwiLFwiI2RlZmluZSB0ZXh0dXJlMkRQcm9qIHRleHR1cmVQcm9qXCIsXCIjZGVmaW5lIHRleHR1cmUyRExvZEVYVCB0ZXh0dXJlTG9kXCIsXCIjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2RcIixcIiNkZWZpbmUgdGV4dHVyZUN1YmVMb2RFWFQgdGV4dHVyZUxvZFwiLFwiI2RlZmluZSB0ZXh0dXJlMkRHcmFkRVhUIHRleHR1cmVHcmFkXCIsXCIjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZFwiLFwiI2RlZmluZSB0ZXh0dXJlQ3ViZUdyYWRFWFQgdGV4dHVyZUdyYWRcIl0uam9pbihcIlxcblwiKStcIlxcblwiK3YpO2NvbnN0IHg9eSt2K28sYj1pcyhyLDM1NjMzLHkrZythKSx3PWlzKHIsMzU2MzIseCk7aWYoci5hdHRhY2hTaGFkZXIoZixiKSxyLmF0dGFjaFNoYWRlcihmLHcpLHZvaWQgMCE9PW4uaW5kZXgwQXR0cmlidXRlTmFtZT9yLmJpbmRBdHRyaWJMb2NhdGlvbihmLDAsbi5pbmRleDBBdHRyaWJ1dGVOYW1lKTohMD09PW4ubW9ycGhUYXJnZXRzJiZyLmJpbmRBdHRyaWJMb2NhdGlvbihmLDAsXCJwb3NpdGlvblwiKSxyLmxpbmtQcm9ncmFtKGYpLHQuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMpe2NvbnN0IHQ9ci5nZXRQcm9ncmFtSW5mb0xvZyhmKS50cmltKCksZT1yLmdldFNoYWRlckluZm9Mb2coYikudHJpbSgpLG49ci5nZXRTaGFkZXJJbmZvTG9nKHcpLnRyaW0oKTtsZXQgaT0hMCxzPSEwO2lmKCExPT09ci5nZXRQcm9ncmFtUGFyYW1ldGVyKGYsMzU3MTQpKXtpPSExO2NvbnN0IGU9YXMocixiLFwidmVydGV4XCIpLG49YXMocix3LFwiZnJhZ21lbnRcIik7Y29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUHJvZ3JhbTogU2hhZGVyIEVycm9yIFwiK3IuZ2V0RXJyb3IoKStcIiAtIFZBTElEQVRFX1NUQVRVUyBcIityLmdldFByb2dyYW1QYXJhbWV0ZXIoZiwzNTcxNSkrXCJcXG5cXG5Qcm9ncmFtIEluZm8gTG9nOiBcIit0K1wiXFxuXCIrZStcIlxcblwiK24pfWVsc2VcIlwiIT09dD9jb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFByb2dyYW06IFByb2dyYW0gSW5mbyBMb2c6XCIsdCk6XCJcIiE9PWUmJlwiXCIhPT1ufHwocz0hMSk7cyYmKHRoaXMuZGlhZ25vc3RpY3M9e3J1bm5hYmxlOmkscHJvZ3JhbUxvZzp0LHZlcnRleFNoYWRlcjp7bG9nOmUscHJlZml4Omd9LGZyYWdtZW50U2hhZGVyOntsb2c6bixwcmVmaXg6dn19KX1sZXQgXyxNO3JldHVybiByLmRlbGV0ZVNoYWRlcihiKSxyLmRlbGV0ZVNoYWRlcih3KSx0aGlzLmdldFVuaWZvcm1zPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PV8mJihfPW5ldyBucyhyLGYpKSxffSx0aGlzLmdldEF0dHJpYnV0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09TSYmKE09ZnVuY3Rpb24odCxlKXtjb25zdCBuPXt9LGk9dC5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsMzU3MjEpO2ZvcihsZXQgcj0wO3I8aTtyKyspe2NvbnN0IGk9dC5nZXRBY3RpdmVBdHRyaWIoZSxyKSxzPWkubmFtZTtsZXQgYT0xOzM1Njc0PT09aS50eXBlJiYoYT0yKSwzNTY3NT09PWkudHlwZSYmKGE9MyksMzU2NzY9PT1pLnR5cGUmJihhPTQpLG5bc109e3R5cGU6aS50eXBlLGxvY2F0aW9uOnQuZ2V0QXR0cmliTG9jYXRpb24oZSxzKSxsb2NhdGlvblNpemU6YX19cmV0dXJuIG59KHIsZikpLE19LHRoaXMuZGVzdHJveT1mdW5jdGlvbigpe2kucmVsZWFzZVN0YXRlc09mUHJvZ3JhbSh0aGlzKSxyLmRlbGV0ZVByb2dyYW0oZiksdGhpcy5wcm9ncmFtPXZvaWQgMH0sdGhpcy5uYW1lPW4uc2hhZGVyTmFtZSx0aGlzLmlkPXJzKyssdGhpcy5jYWNoZUtleT1lLHRoaXMudXNlZFRpbWVzPTEsdGhpcy5wcm9ncmFtPWYsdGhpcy52ZXJ0ZXhTaGFkZXI9Yix0aGlzLmZyYWdtZW50U2hhZGVyPXcsdGhpc31mdW5jdGlvbiBNcyh0LGUsbixpLHIscyxhKXtjb25zdCBvPVtdLGw9ci5pc1dlYkdMMixjPXIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixoPXIuZmxvYXRWZXJ0ZXhUZXh0dXJlcyx1PXIubWF4VmVydGV4VW5pZm9ybXMsZD1yLnZlcnRleFRleHR1cmVzO2xldCBwPXIucHJlY2lzaW9uO2NvbnN0IG09e01lc2hEZXB0aE1hdGVyaWFsOlwiZGVwdGhcIixNZXNoRGlzdGFuY2VNYXRlcmlhbDpcImRpc3RhbmNlUkdCQVwiLE1lc2hOb3JtYWxNYXRlcmlhbDpcIm5vcm1hbFwiLE1lc2hCYXNpY01hdGVyaWFsOlwiYmFzaWNcIixNZXNoTGFtYmVydE1hdGVyaWFsOlwibGFtYmVydFwiLE1lc2hQaG9uZ01hdGVyaWFsOlwicGhvbmdcIixNZXNoVG9vbk1hdGVyaWFsOlwidG9vblwiLE1lc2hTdGFuZGFyZE1hdGVyaWFsOlwicGh5c2ljYWxcIixNZXNoUGh5c2ljYWxNYXRlcmlhbDpcInBoeXNpY2FsXCIsTWVzaE1hdGNhcE1hdGVyaWFsOlwibWF0Y2FwXCIsTGluZUJhc2ljTWF0ZXJpYWw6XCJiYXNpY1wiLExpbmVEYXNoZWRNYXRlcmlhbDpcImRhc2hlZFwiLFBvaW50c01hdGVyaWFsOlwicG9pbnRzXCIsU2hhZG93TWF0ZXJpYWw6XCJzaGFkb3dcIixTcHJpdGVNYXRlcmlhbDpcInNwcml0ZVwifSxmPVtcInByZWNpc2lvblwiLFwiaXNXZWJHTDJcIixcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIixcIm91dHB1dEVuY29kaW5nXCIsXCJpbnN0YW5jaW5nXCIsXCJpbnN0YW5jaW5nQ29sb3JcIixcIm1hcFwiLFwibWFwRW5jb2RpbmdcIixcIm1hdGNhcFwiLFwibWF0Y2FwRW5jb2RpbmdcIixcImVudk1hcFwiLFwiZW52TWFwTW9kZVwiLFwiZW52TWFwRW5jb2RpbmdcIixcImVudk1hcEN1YmVVVlwiLFwibGlnaHRNYXBcIixcImxpZ2h0TWFwRW5jb2RpbmdcIixcImFvTWFwXCIsXCJlbWlzc2l2ZU1hcFwiLFwiZW1pc3NpdmVNYXBFbmNvZGluZ1wiLFwiYnVtcE1hcFwiLFwibm9ybWFsTWFwXCIsXCJvYmplY3RTcGFjZU5vcm1hbE1hcFwiLFwidGFuZ2VudFNwYWNlTm9ybWFsTWFwXCIsXCJjbGVhcmNvYXRcIixcImNsZWFyY29hdE1hcFwiLFwiY2xlYXJjb2F0Um91Z2huZXNzTWFwXCIsXCJjbGVhcmNvYXROb3JtYWxNYXBcIixcImRpc3BsYWNlbWVudE1hcFwiLFwic3BlY3VsYXJNYXBcIixcInNwZWN1bGFySW50ZW5zaXR5TWFwXCIsXCJzcGVjdWxhclRpbnRNYXBcIixcInNwZWN1bGFyVGludE1hcEVuY29kaW5nXCIsXCJyb3VnaG5lc3NNYXBcIixcIm1ldGFsbmVzc01hcFwiLFwiZ3JhZGllbnRNYXBcIixcImFscGhhTWFwXCIsXCJhbHBoYVRlc3RcIixcImNvbWJpbmVcIixcInZlcnRleENvbG9yc1wiLFwidmVydGV4QWxwaGFzXCIsXCJ2ZXJ0ZXhUYW5nZW50c1wiLFwidmVydGV4VXZzXCIsXCJ1dnNWZXJ0ZXhPbmx5XCIsXCJmb2dcIixcInVzZUZvZ1wiLFwiZm9nRXhwMlwiLFwiZmxhdFNoYWRpbmdcIixcInNpemVBdHRlbnVhdGlvblwiLFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclwiLFwic2tpbm5pbmdcIixcIm1heEJvbmVzXCIsXCJ1c2VWZXJ0ZXhUZXh0dXJlXCIsXCJtb3JwaFRhcmdldHNcIixcIm1vcnBoTm9ybWFsc1wiLFwibW9ycGhUYXJnZXRzQ291bnRcIixcInByZW11bHRpcGxpZWRBbHBoYVwiLFwibnVtRGlyTGlnaHRzXCIsXCJudW1Qb2ludExpZ2h0c1wiLFwibnVtU3BvdExpZ2h0c1wiLFwibnVtSGVtaUxpZ2h0c1wiLFwibnVtUmVjdEFyZWFMaWdodHNcIixcIm51bURpckxpZ2h0U2hhZG93c1wiLFwibnVtUG9pbnRMaWdodFNoYWRvd3NcIixcIm51bVNwb3RMaWdodFNoYWRvd3NcIixcInNoYWRvd01hcEVuYWJsZWRcIixcInNoYWRvd01hcFR5cGVcIixcInRvbmVNYXBwaW5nXCIsXCJwaHlzaWNhbGx5Q29ycmVjdExpZ2h0c1wiLFwiZG91YmxlU2lkZWRcIixcImZsaXBTaWRlZFwiLFwibnVtQ2xpcHBpbmdQbGFuZXNcIixcIm51bUNsaXBJbnRlcnNlY3Rpb25cIixcImRlcHRoUGFja2luZ1wiLFwiZGl0aGVyaW5nXCIsXCJmb3JtYXRcIixcInNoZWVuXCIsXCJ0cmFuc21pc3Npb25cIixcInRyYW5zbWlzc2lvbk1hcFwiLFwidGhpY2tuZXNzTWFwXCJdO2Z1bmN0aW9uIGcodCl7bGV0IGU7cmV0dXJuIHQmJnQuaXNUZXh0dXJlP2U9dC5lbmNvZGluZzp0JiZ0LmlzV2ViR0xSZW5kZXJUYXJnZXQ/KGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUHJvZ3JhbXMuZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcDogZG9uJ3QgdXNlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiksZT10LnRleHR1cmUuZW5jb2RpbmcpOmU9M2UzLGwmJnQmJnQuaXNUZXh0dXJlJiYxMDIzPT09dC5mb3JtYXQmJjEwMDk9PT10LnR5cGUmJjMwMDE9PT10LmVuY29kaW5nJiYoZT0zZTMpLGV9cmV0dXJue2dldFBhcmFtZXRlcnM6ZnVuY3Rpb24ocyxvLGYsdix5KXtjb25zdCB4PXYuZm9nLGI9cy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP3YuZW52aXJvbm1lbnQ6bnVsbCx3PShzLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/bjplKS5nZXQocy5lbnZNYXB8fGIpLF89bVtzLnR5cGVdLE09eS5pc1NraW5uZWRNZXNoP2Z1bmN0aW9uKHQpe2NvbnN0IGU9dC5za2VsZXRvbi5ib25lcztpZihoKXJldHVybiAxMDI0O3tjb25zdCB0PXUsbj1NYXRoLmZsb29yKCh0LTIwKS80KSxpPU1hdGgubWluKG4sZS5sZW5ndGgpO3JldHVybiBpPGUubGVuZ3RoPyhjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBTa2VsZXRvbiBoYXMgXCIrZS5sZW5ndGgrXCIgYm9uZXMuIFRoaXMgR1BVIHN1cHBvcnRzIFwiK2krXCIuXCIpLDApOml9fSh5KTowO2xldCBTLFQ7aWYobnVsbCE9PXMucHJlY2lzaW9uJiYocD1yLmdldE1heFByZWNpc2lvbihzLnByZWNpc2lvbikscCE9PXMucHJlY2lzaW9uJiZjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczpcIixzLnByZWNpc2lvbixcIm5vdCBzdXBwb3J0ZWQsIHVzaW5nXCIscCxcImluc3RlYWQuXCIpKSxfKXtjb25zdCB0PWRpW19dO1M9dC52ZXJ0ZXhTaGFkZXIsVD10LmZyYWdtZW50U2hhZGVyfWVsc2UgUz1zLnZlcnRleFNoYWRlcixUPXMuZnJhZ21lbnRTaGFkZXI7Y29uc3QgRT10LmdldFJlbmRlclRhcmdldCgpLEE9cy5hbHBoYVRlc3Q+MCxMPXMuY2xlYXJjb2F0PjA7cmV0dXJue2lzV2ViR0wyOmwsc2hhZGVySUQ6XyxzaGFkZXJOYW1lOnMudHlwZSx2ZXJ0ZXhTaGFkZXI6UyxmcmFnbWVudFNoYWRlcjpULGRlZmluZXM6cy5kZWZpbmVzLGlzUmF3U2hhZGVyTWF0ZXJpYWw6ITA9PT1zLmlzUmF3U2hhZGVyTWF0ZXJpYWwsZ2xzbFZlcnNpb246cy5nbHNsVmVyc2lvbixwcmVjaXNpb246cCxpbnN0YW5jaW5nOiEwPT09eS5pc0luc3RhbmNlZE1lc2gsaW5zdGFuY2luZ0NvbG9yOiEwPT09eS5pc0luc3RhbmNlZE1lc2gmJm51bGwhPT15Lmluc3RhbmNlQ29sb3Isc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczpkLG91dHB1dEVuY29kaW5nOm51bGwhPT1FP2coRS50ZXh0dXJlKTp0Lm91dHB1dEVuY29kaW5nLG1hcDohIXMubWFwLG1hcEVuY29kaW5nOmcocy5tYXApLG1hdGNhcDohIXMubWF0Y2FwLG1hdGNhcEVuY29kaW5nOmcocy5tYXRjYXApLGVudk1hcDohIXcsZW52TWFwTW9kZTp3JiZ3Lm1hcHBpbmcsZW52TWFwRW5jb2Rpbmc6Zyh3KSxlbnZNYXBDdWJlVVY6ISF3JiYoMzA2PT09dy5tYXBwaW5nfHwzMDc9PT13Lm1hcHBpbmcpLGxpZ2h0TWFwOiEhcy5saWdodE1hcCxsaWdodE1hcEVuY29kaW5nOmcocy5saWdodE1hcCksYW9NYXA6ISFzLmFvTWFwLGVtaXNzaXZlTWFwOiEhcy5lbWlzc2l2ZU1hcCxlbWlzc2l2ZU1hcEVuY29kaW5nOmcocy5lbWlzc2l2ZU1hcCksYnVtcE1hcDohIXMuYnVtcE1hcCxub3JtYWxNYXA6ISFzLm5vcm1hbE1hcCxvYmplY3RTcGFjZU5vcm1hbE1hcDoxPT09cy5ub3JtYWxNYXBUeXBlLHRhbmdlbnRTcGFjZU5vcm1hbE1hcDowPT09cy5ub3JtYWxNYXBUeXBlLGNsZWFyY29hdDpMLGNsZWFyY29hdE1hcDpMJiYhIXMuY2xlYXJjb2F0TWFwLGNsZWFyY29hdFJvdWdobmVzc01hcDpMJiYhIXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLGNsZWFyY29hdE5vcm1hbE1hcDpMJiYhIXMuY2xlYXJjb2F0Tm9ybWFsTWFwLGRpc3BsYWNlbWVudE1hcDohIXMuZGlzcGxhY2VtZW50TWFwLHJvdWdobmVzc01hcDohIXMucm91Z2huZXNzTWFwLG1ldGFsbmVzc01hcDohIXMubWV0YWxuZXNzTWFwLHNwZWN1bGFyTWFwOiEhcy5zcGVjdWxhck1hcCxzcGVjdWxhckludGVuc2l0eU1hcDohIXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAsc3BlY3VsYXJUaW50TWFwOiEhcy5zcGVjdWxhclRpbnRNYXAsc3BlY3VsYXJUaW50TWFwRW5jb2Rpbmc6ZyhzLnNwZWN1bGFyVGludE1hcCksYWxwaGFNYXA6ISFzLmFscGhhTWFwLGFscGhhVGVzdDpBLGdyYWRpZW50TWFwOiEhcy5ncmFkaWVudE1hcCxzaGVlbjpzLnNoZWVuPjAsdHJhbnNtaXNzaW9uOnMudHJhbnNtaXNzaW9uPjAsdHJhbnNtaXNzaW9uTWFwOiEhcy50cmFuc21pc3Npb25NYXAsdGhpY2tuZXNzTWFwOiEhcy50aGlja25lc3NNYXAsY29tYmluZTpzLmNvbWJpbmUsdmVydGV4VGFuZ2VudHM6ISFzLm5vcm1hbE1hcCYmISF5Lmdlb21ldHJ5JiYhIXkuZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50LHZlcnRleENvbG9yczpzLnZlcnRleENvbG9ycyx2ZXJ0ZXhBbHBoYXM6ITA9PT1zLnZlcnRleENvbG9ycyYmISF5Lmdlb21ldHJ5JiYhIXkuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciYmND09PXkuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSx2ZXJ0ZXhVdnM6ISEocy5tYXB8fHMuYnVtcE1hcHx8cy5ub3JtYWxNYXB8fHMuc3BlY3VsYXJNYXB8fHMuYWxwaGFNYXB8fHMuZW1pc3NpdmVNYXB8fHMucm91Z2huZXNzTWFwfHxzLm1ldGFsbmVzc01hcHx8cy5jbGVhcmNvYXRNYXB8fHMuY2xlYXJjb2F0Um91Z2huZXNzTWFwfHxzLmNsZWFyY29hdE5vcm1hbE1hcHx8cy5kaXNwbGFjZW1lbnRNYXB8fHMudHJhbnNtaXNzaW9uTWFwfHxzLnRoaWNrbmVzc01hcHx8cy5zcGVjdWxhckludGVuc2l0eU1hcHx8cy5zcGVjdWxhclRpbnRNYXApLHV2c1ZlcnRleE9ubHk6IShzLm1hcHx8cy5idW1wTWFwfHxzLm5vcm1hbE1hcHx8cy5zcGVjdWxhck1hcHx8cy5hbHBoYU1hcHx8cy5lbWlzc2l2ZU1hcHx8cy5yb3VnaG5lc3NNYXB8fHMubWV0YWxuZXNzTWFwfHxzLmNsZWFyY29hdE5vcm1hbE1hcHx8cy50cmFuc21pc3Npb24+MHx8cy50cmFuc21pc3Npb25NYXB8fHMudGhpY2tuZXNzTWFwfHxzLnNwZWN1bGFySW50ZW5zaXR5TWFwfHxzLnNwZWN1bGFyVGludE1hcHx8IXMuZGlzcGxhY2VtZW50TWFwKSxmb2c6ISF4LHVzZUZvZzpzLmZvZyxmb2dFeHAyOngmJnguaXNGb2dFeHAyLGZsYXRTaGFkaW5nOiEhcy5mbGF0U2hhZGluZyxzaXplQXR0ZW51YXRpb246cy5zaXplQXR0ZW51YXRpb24sbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjpjLHNraW5uaW5nOiEwPT09eS5pc1NraW5uZWRNZXNoJiZNPjAsbWF4Qm9uZXM6TSx1c2VWZXJ0ZXhUZXh0dXJlOmgsbW9ycGhUYXJnZXRzOiEheS5nZW9tZXRyeSYmISF5Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbixtb3JwaE5vcm1hbHM6ISF5Lmdlb21ldHJ5JiYhIXkuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCxtb3JwaFRhcmdldHNDb3VudDp5Lmdlb21ldHJ5JiZ5Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbj95Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGg6MCxudW1EaXJMaWdodHM6by5kaXJlY3Rpb25hbC5sZW5ndGgsbnVtUG9pbnRMaWdodHM6by5wb2ludC5sZW5ndGgsbnVtU3BvdExpZ2h0czpvLnNwb3QubGVuZ3RoLG51bVJlY3RBcmVhTGlnaHRzOm8ucmVjdEFyZWEubGVuZ3RoLG51bUhlbWlMaWdodHM6by5oZW1pLmxlbmd0aCxudW1EaXJMaWdodFNoYWRvd3M6by5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGgsbnVtUG9pbnRMaWdodFNoYWRvd3M6by5wb2ludFNoYWRvd01hcC5sZW5ndGgsbnVtU3BvdExpZ2h0U2hhZG93czpvLnNwb3RTaGFkb3dNYXAubGVuZ3RoLG51bUNsaXBwaW5nUGxhbmVzOmEubnVtUGxhbmVzLG51bUNsaXBJbnRlcnNlY3Rpb246YS5udW1JbnRlcnNlY3Rpb24sZm9ybWF0OnMuZm9ybWF0LGRpdGhlcmluZzpzLmRpdGhlcmluZyxzaGFkb3dNYXBFbmFibGVkOnQuc2hhZG93TWFwLmVuYWJsZWQmJmYubGVuZ3RoPjAsc2hhZG93TWFwVHlwZTp0LnNoYWRvd01hcC50eXBlLHRvbmVNYXBwaW5nOnMudG9uZU1hcHBlZD90LnRvbmVNYXBwaW5nOjAscGh5c2ljYWxseUNvcnJlY3RMaWdodHM6dC5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyxwcmVtdWx0aXBsaWVkQWxwaGE6cy5wcmVtdWx0aXBsaWVkQWxwaGEsZG91YmxlU2lkZWQ6Mj09PXMuc2lkZSxmbGlwU2lkZWQ6MT09PXMuc2lkZSxkZXB0aFBhY2tpbmc6dm9pZCAwIT09cy5kZXB0aFBhY2tpbmcmJnMuZGVwdGhQYWNraW5nLGluZGV4MEF0dHJpYnV0ZU5hbWU6cy5pbmRleDBBdHRyaWJ1dGVOYW1lLGV4dGVuc2lvbkRlcml2YXRpdmVzOnMuZXh0ZW5zaW9ucyYmcy5leHRlbnNpb25zLmRlcml2YXRpdmVzLGV4dGVuc2lvbkZyYWdEZXB0aDpzLmV4dGVuc2lvbnMmJnMuZXh0ZW5zaW9ucy5mcmFnRGVwdGgsZXh0ZW5zaW9uRHJhd0J1ZmZlcnM6cy5leHRlbnNpb25zJiZzLmV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMsZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRDpzLmV4dGVuc2lvbnMmJnMuZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9ELHJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoOmx8fGkuaGFzKFwiRVhUX2ZyYWdfZGVwdGhcIikscmVuZGVyZXJFeHRlbnNpb25EcmF3QnVmZmVyczpsfHxpLmhhcyhcIldFQkdMX2RyYXdfYnVmZmVyc1wiKSxyZW5kZXJlckV4dGVuc2lvblNoYWRlclRleHR1cmVMb2Q6bHx8aS5oYXMoXCJFWFRfc2hhZGVyX3RleHR1cmVfbG9kXCIpLGN1c3RvbVByb2dyYW1DYWNoZUtleTpzLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpfX0sZ2V0UHJvZ3JhbUNhY2hlS2V5OmZ1bmN0aW9uKGUpe2NvbnN0IG49W107aWYoZS5zaGFkZXJJRD9uLnB1c2goZS5zaGFkZXJJRCk6KG4ucHVzaChlLmZyYWdtZW50U2hhZGVyKSxuLnB1c2goZS52ZXJ0ZXhTaGFkZXIpKSx2b2lkIDAhPT1lLmRlZmluZXMpZm9yKGNvbnN0IHQgaW4gZS5kZWZpbmVzKW4ucHVzaCh0KSxuLnB1c2goZS5kZWZpbmVzW3RdKTtpZighMT09PWUuaXNSYXdTaGFkZXJNYXRlcmlhbCl7Zm9yKGxldCB0PTA7dDxmLmxlbmd0aDt0Kyspbi5wdXNoKGVbZlt0XV0pO24ucHVzaCh0Lm91dHB1dEVuY29kaW5nKSxuLnB1c2godC5nYW1tYUZhY3Rvcil9cmV0dXJuIG4ucHVzaChlLmN1c3RvbVByb2dyYW1DYWNoZUtleSksbi5qb2luKCl9LGdldFVuaWZvcm1zOmZ1bmN0aW9uKHQpe2NvbnN0IGU9bVt0LnR5cGVdO2xldCBuO2lmKGUpe2NvbnN0IHQ9ZGlbZV07bj1Ybi5jbG9uZSh0LnVuaWZvcm1zKX1lbHNlIG49dC51bmlmb3JtcztyZXR1cm4gbn0sYWNxdWlyZVByb2dyYW06ZnVuY3Rpb24oZSxuKXtsZXQgaTtmb3IobGV0IHQ9MCxlPW8ubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9b1t0XTtpZihlLmNhY2hlS2V5PT09bil7aT1lLCsraS51c2VkVGltZXM7YnJlYWt9fXJldHVybiB2b2lkIDA9PT1pJiYoaT1uZXcgX3ModCxuLGUscyksby5wdXNoKGkpKSxpfSxyZWxlYXNlUHJvZ3JhbTpmdW5jdGlvbih0KXtpZigwPT0tLXQudXNlZFRpbWVzKXtjb25zdCBlPW8uaW5kZXhPZih0KTtvW2VdPW9bby5sZW5ndGgtMV0sby5wb3AoKSx0LmRlc3Ryb3koKX19LHByb2dyYW1zOm99fWZ1bmN0aW9uIFNzKCl7bGV0IHQ9bmV3IFdlYWtNYXA7cmV0dXJue2dldDpmdW5jdGlvbihlKXtsZXQgbj10LmdldChlKTtyZXR1cm4gdm9pZCAwPT09biYmKG49e30sdC5zZXQoZSxuKSksbn0scmVtb3ZlOmZ1bmN0aW9uKGUpe3QuZGVsZXRlKGUpfSx1cGRhdGU6ZnVuY3Rpb24oZSxuLGkpe3QuZ2V0KGUpW25dPWl9LGRpc3Bvc2U6ZnVuY3Rpb24oKXt0PW5ldyBXZWFrTWFwfX19ZnVuY3Rpb24gVHModCxlKXtyZXR1cm4gdC5ncm91cE9yZGVyIT09ZS5ncm91cE9yZGVyP3QuZ3JvdXBPcmRlci1lLmdyb3VwT3JkZXI6dC5yZW5kZXJPcmRlciE9PWUucmVuZGVyT3JkZXI/dC5yZW5kZXJPcmRlci1lLnJlbmRlck9yZGVyOnQucHJvZ3JhbSE9PWUucHJvZ3JhbT90LnByb2dyYW0uaWQtZS5wcm9ncmFtLmlkOnQubWF0ZXJpYWwuaWQhPT1lLm1hdGVyaWFsLmlkP3QubWF0ZXJpYWwuaWQtZS5tYXRlcmlhbC5pZDp0LnohPT1lLno/dC56LWUuejp0LmlkLWUuaWR9ZnVuY3Rpb24gRXModCxlKXtyZXR1cm4gdC5ncm91cE9yZGVyIT09ZS5ncm91cE9yZGVyP3QuZ3JvdXBPcmRlci1lLmdyb3VwT3JkZXI6dC5yZW5kZXJPcmRlciE9PWUucmVuZGVyT3JkZXI/dC5yZW5kZXJPcmRlci1lLnJlbmRlck9yZGVyOnQueiE9PWUuej9lLnotdC56OnQuaWQtZS5pZH1mdW5jdGlvbiBBcyh0KXtjb25zdCBlPVtdO2xldCBuPTA7Y29uc3QgaT1bXSxyPVtdLHM9W10sYT17aWQ6LTF9O2Z1bmN0aW9uIG8oaSxyLHMsbyxsLGMpe2xldCBoPWVbbl07Y29uc3QgdT10LmdldChzKTtyZXR1cm4gdm9pZCAwPT09aD8oaD17aWQ6aS5pZCxvYmplY3Q6aSxnZW9tZXRyeTpyLG1hdGVyaWFsOnMscHJvZ3JhbTp1LnByb2dyYW18fGEsZ3JvdXBPcmRlcjpvLHJlbmRlck9yZGVyOmkucmVuZGVyT3JkZXIsejpsLGdyb3VwOmN9LGVbbl09aCk6KGguaWQ9aS5pZCxoLm9iamVjdD1pLGguZ2VvbWV0cnk9cixoLm1hdGVyaWFsPXMsaC5wcm9ncmFtPXUucHJvZ3JhbXx8YSxoLmdyb3VwT3JkZXI9byxoLnJlbmRlck9yZGVyPWkucmVuZGVyT3JkZXIsaC56PWwsaC5ncm91cD1jKSxuKyssaH1yZXR1cm57b3BhcXVlOmksdHJhbnNtaXNzaXZlOnIsdHJhbnNwYXJlbnQ6cyxpbml0OmZ1bmN0aW9uKCl7bj0wLGkubGVuZ3RoPTAsci5sZW5ndGg9MCxzLmxlbmd0aD0wfSxwdXNoOmZ1bmN0aW9uKHQsZSxuLGEsbCxjKXtjb25zdCBoPW8odCxlLG4sYSxsLGMpO24udHJhbnNtaXNzaW9uPjA/ci5wdXNoKGgpOiEwPT09bi50cmFuc3BhcmVudD9zLnB1c2goaCk6aS5wdXNoKGgpfSx1bnNoaWZ0OmZ1bmN0aW9uKHQsZSxuLGEsbCxjKXtjb25zdCBoPW8odCxlLG4sYSxsLGMpO24udHJhbnNtaXNzaW9uPjA/ci51bnNoaWZ0KGgpOiEwPT09bi50cmFuc3BhcmVudD9zLnVuc2hpZnQoaCk6aS51bnNoaWZ0KGgpfSxmaW5pc2g6ZnVuY3Rpb24oKXtmb3IobGV0IHQ9bixpPWUubGVuZ3RoO3Q8aTt0Kyspe2NvbnN0IG49ZVt0XTtpZihudWxsPT09bi5pZClicmVhaztuLmlkPW51bGwsbi5vYmplY3Q9bnVsbCxuLmdlb21ldHJ5PW51bGwsbi5tYXRlcmlhbD1udWxsLG4ucHJvZ3JhbT1udWxsLG4uZ3JvdXA9bnVsbH19LHNvcnQ6ZnVuY3Rpb24odCxlKXtpLmxlbmd0aD4xJiZpLnNvcnQodHx8VHMpLHIubGVuZ3RoPjEmJnIuc29ydChlfHxFcykscy5sZW5ndGg+MSYmcy5zb3J0KGV8fEVzKX19fWZ1bmN0aW9uIExzKHQpe2xldCBlPW5ldyBXZWFrTWFwO3JldHVybntnZXQ6ZnVuY3Rpb24obixpKXtsZXQgcjtyZXR1cm4hMT09PWUuaGFzKG4pPyhyPW5ldyBBcyh0KSxlLnNldChuLFtyXSkpOmk+PWUuZ2V0KG4pLmxlbmd0aD8ocj1uZXcgQXModCksZS5nZXQobikucHVzaChyKSk6cj1lLmdldChuKVtpXSxyfSxkaXNwb3NlOmZ1bmN0aW9uKCl7ZT1uZXcgV2Vha01hcH19fWZ1bmN0aW9uIFJzKCl7Y29uc3QgdD17fTtyZXR1cm57Z2V0OmZ1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PXRbZS5pZF0pcmV0dXJuIHRbZS5pZF07bGV0IG47c3dpdGNoKGUudHlwZSl7Y2FzZVwiRGlyZWN0aW9uYWxMaWdodFwiOm49e2RpcmVjdGlvbjpuZXcgQnQsY29sb3I6bmV3IGNufTticmVhaztjYXNlXCJTcG90TGlnaHRcIjpuPXtwb3NpdGlvbjpuZXcgQnQsZGlyZWN0aW9uOm5ldyBCdCxjb2xvcjpuZXcgY24sZGlzdGFuY2U6MCxjb25lQ29zOjAscGVudW1icmFDb3M6MCxkZWNheTowfTticmVhaztjYXNlXCJQb2ludExpZ2h0XCI6bj17cG9zaXRpb246bmV3IEJ0LGNvbG9yOm5ldyBjbixkaXN0YW5jZTowLGRlY2F5OjB9O2JyZWFrO2Nhc2VcIkhlbWlzcGhlcmVMaWdodFwiOm49e2RpcmVjdGlvbjpuZXcgQnQsc2t5Q29sb3I6bmV3IGNuLGdyb3VuZENvbG9yOm5ldyBjbn07YnJlYWs7Y2FzZVwiUmVjdEFyZWFMaWdodFwiOm49e2NvbG9yOm5ldyBjbixwb3NpdGlvbjpuZXcgQnQsaGFsZldpZHRoOm5ldyBCdCxoYWxmSGVpZ2h0Om5ldyBCdH19cmV0dXJuIHRbZS5pZF09bixufX19bGV0IENzPTA7ZnVuY3Rpb24gUHModCxlKXtyZXR1cm4oZS5jYXN0U2hhZG93PzE6MCktKHQuY2FzdFNoYWRvdz8xOjApfWZ1bmN0aW9uIElzKHQsZSl7Y29uc3Qgbj1uZXcgUnMsaT1mdW5jdGlvbigpe2NvbnN0IHQ9e307cmV0dXJue2dldDpmdW5jdGlvbihlKXtpZih2b2lkIDAhPT10W2UuaWRdKXJldHVybiB0W2UuaWRdO2xldCBuO3N3aXRjaChlLnR5cGUpe2Nhc2VcIkRpcmVjdGlvbmFsTGlnaHRcIjpjYXNlXCJTcG90TGlnaHRcIjpuPXtzaGFkb3dCaWFzOjAsc2hhZG93Tm9ybWFsQmlhczowLHNoYWRvd1JhZGl1czoxLHNoYWRvd01hcFNpemU6bmV3IEF0fTticmVhaztjYXNlXCJQb2ludExpZ2h0XCI6bj17c2hhZG93QmlhczowLHNoYWRvd05vcm1hbEJpYXM6MCxzaGFkb3dSYWRpdXM6MSxzaGFkb3dNYXBTaXplOm5ldyBBdCxzaGFkb3dDYW1lcmFOZWFyOjEsc2hhZG93Q2FtZXJhRmFyOjFlM319cmV0dXJuIHRbZS5pZF09bixufX19KCkscj17dmVyc2lvbjowLGhhc2g6e2RpcmVjdGlvbmFsTGVuZ3RoOi0xLHBvaW50TGVuZ3RoOi0xLHNwb3RMZW5ndGg6LTEscmVjdEFyZWFMZW5ndGg6LTEsaGVtaUxlbmd0aDotMSxudW1EaXJlY3Rpb25hbFNoYWRvd3M6LTEsbnVtUG9pbnRTaGFkb3dzOi0xLG51bVNwb3RTaGFkb3dzOi0xfSxhbWJpZW50OlswLDAsMF0scHJvYmU6W10sZGlyZWN0aW9uYWw6W10sZGlyZWN0aW9uYWxTaGFkb3c6W10sZGlyZWN0aW9uYWxTaGFkb3dNYXA6W10sZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6W10sc3BvdDpbXSxzcG90U2hhZG93OltdLHNwb3RTaGFkb3dNYXA6W10sc3BvdFNoYWRvd01hdHJpeDpbXSxyZWN0QXJlYTpbXSxyZWN0QXJlYUxUQzE6bnVsbCxyZWN0QXJlYUxUQzI6bnVsbCxwb2ludDpbXSxwb2ludFNoYWRvdzpbXSxwb2ludFNoYWRvd01hcDpbXSxwb2ludFNoYWRvd01hdHJpeDpbXSxoZW1pOltdfTtmb3IobGV0IHQ9MDt0PDk7dCsrKXIucHJvYmUucHVzaChuZXcgQnQpO2NvbnN0IHM9bmV3IEJ0LGE9bmV3IHZlLG89bmV3IHZlO3JldHVybntzZXR1cDpmdW5jdGlvbihzLGEpe2xldCBvPTAsbD0wLGM9MDtmb3IobGV0IHQ9MDt0PDk7dCsrKXIucHJvYmVbdF0uc2V0KDAsMCwwKTtsZXQgaD0wLHU9MCxkPTAscD0wLG09MCxmPTAsZz0wLHY9MDtzLnNvcnQoUHMpO2NvbnN0IHk9ITAhPT1hP01hdGguUEk6MTtmb3IobGV0IHQ9MCxlPXMubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9c1t0XSxhPWUuY29sb3IseD1lLmludGVuc2l0eSxiPWUuZGlzdGFuY2Usdz1lLnNoYWRvdyYmZS5zaGFkb3cubWFwP2Uuc2hhZG93Lm1hcC50ZXh0dXJlOm51bGw7aWYoZS5pc0FtYmllbnRMaWdodClvKz1hLnIqeCp5LGwrPWEuZyp4KnksYys9YS5iKngqeTtlbHNlIGlmKGUuaXNMaWdodFByb2JlKWZvcihsZXQgdD0wO3Q8OTt0Kyspci5wcm9iZVt0XS5hZGRTY2FsZWRWZWN0b3IoZS5zaC5jb2VmZmljaWVudHNbdF0seCk7ZWxzZSBpZihlLmlzRGlyZWN0aW9uYWxMaWdodCl7Y29uc3QgdD1uLmdldChlKTtpZih0LmNvbG9yLmNvcHkoZS5jb2xvcikubXVsdGlwbHlTY2FsYXIoZS5pbnRlbnNpdHkqeSksZS5jYXN0U2hhZG93KXtjb25zdCB0PWUuc2hhZG93LG49aS5nZXQoZSk7bi5zaGFkb3dCaWFzPXQuYmlhcyxuLnNoYWRvd05vcm1hbEJpYXM9dC5ub3JtYWxCaWFzLG4uc2hhZG93UmFkaXVzPXQucmFkaXVzLG4uc2hhZG93TWFwU2l6ZT10Lm1hcFNpemUsci5kaXJlY3Rpb25hbFNoYWRvd1toXT1uLHIuZGlyZWN0aW9uYWxTaGFkb3dNYXBbaF09dyxyLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4W2hdPWUuc2hhZG93Lm1hdHJpeCxmKyt9ci5kaXJlY3Rpb25hbFtoXT10LGgrK31lbHNlIGlmKGUuaXNTcG90TGlnaHQpe2NvbnN0IHQ9bi5nZXQoZSk7aWYodC5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS5tYXRyaXhXb3JsZCksdC5jb2xvci5jb3B5KGEpLm11bHRpcGx5U2NhbGFyKHgqeSksdC5kaXN0YW5jZT1iLHQuY29uZUNvcz1NYXRoLmNvcyhlLmFuZ2xlKSx0LnBlbnVtYnJhQ29zPU1hdGguY29zKGUuYW5nbGUqKDEtZS5wZW51bWJyYSkpLHQuZGVjYXk9ZS5kZWNheSxlLmNhc3RTaGFkb3cpe2NvbnN0IHQ9ZS5zaGFkb3csbj1pLmdldChlKTtuLnNoYWRvd0JpYXM9dC5iaWFzLG4uc2hhZG93Tm9ybWFsQmlhcz10Lm5vcm1hbEJpYXMsbi5zaGFkb3dSYWRpdXM9dC5yYWRpdXMsbi5zaGFkb3dNYXBTaXplPXQubWFwU2l6ZSxyLnNwb3RTaGFkb3dbZF09bixyLnNwb3RTaGFkb3dNYXBbZF09dyxyLnNwb3RTaGFkb3dNYXRyaXhbZF09ZS5zaGFkb3cubWF0cml4LHYrK31yLnNwb3RbZF09dCxkKyt9ZWxzZSBpZihlLmlzUmVjdEFyZWFMaWdodCl7Y29uc3QgdD1uLmdldChlKTt0LmNvbG9yLmNvcHkoYSkubXVsdGlwbHlTY2FsYXIoeCksdC5oYWxmV2lkdGguc2V0KC41KmUud2lkdGgsMCwwKSx0LmhhbGZIZWlnaHQuc2V0KDAsLjUqZS5oZWlnaHQsMCksci5yZWN0QXJlYVtwXT10LHArK31lbHNlIGlmKGUuaXNQb2ludExpZ2h0KXtjb25zdCB0PW4uZ2V0KGUpO2lmKHQuY29sb3IuY29weShlLmNvbG9yKS5tdWx0aXBseVNjYWxhcihlLmludGVuc2l0eSp5KSx0LmRpc3RhbmNlPWUuZGlzdGFuY2UsdC5kZWNheT1lLmRlY2F5LGUuY2FzdFNoYWRvdyl7Y29uc3QgdD1lLnNoYWRvdyxuPWkuZ2V0KGUpO24uc2hhZG93Qmlhcz10LmJpYXMsbi5zaGFkb3dOb3JtYWxCaWFzPXQubm9ybWFsQmlhcyxuLnNoYWRvd1JhZGl1cz10LnJhZGl1cyxuLnNoYWRvd01hcFNpemU9dC5tYXBTaXplLG4uc2hhZG93Q2FtZXJhTmVhcj10LmNhbWVyYS5uZWFyLG4uc2hhZG93Q2FtZXJhRmFyPXQuY2FtZXJhLmZhcixyLnBvaW50U2hhZG93W3VdPW4sci5wb2ludFNoYWRvd01hcFt1XT13LHIucG9pbnRTaGFkb3dNYXRyaXhbdV09ZS5zaGFkb3cubWF0cml4LGcrK31yLnBvaW50W3VdPXQsdSsrfWVsc2UgaWYoZS5pc0hlbWlzcGhlcmVMaWdodCl7Y29uc3QgdD1uLmdldChlKTt0LnNreUNvbG9yLmNvcHkoZS5jb2xvcikubXVsdGlwbHlTY2FsYXIoeCp5KSx0Lmdyb3VuZENvbG9yLmNvcHkoZS5ncm91bmRDb2xvcikubXVsdGlwbHlTY2FsYXIoeCp5KSxyLmhlbWlbbV09dCxtKyt9fXA+MCYmKGUuaXNXZWJHTDJ8fCEwPT09dC5oYXMoXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIik/KHIucmVjdEFyZWFMVEMxPXVpLkxUQ19GTE9BVF8xLHIucmVjdEFyZWFMVEMyPXVpLkxUQ19GTE9BVF8yKTohMD09PXQuaGFzKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIik/KHIucmVjdEFyZWFMVEMxPXVpLkxUQ19IQUxGXzEsci5yZWN0QXJlYUxUQzI9dWkuTFRDX0hBTEZfMik6Y29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVuYWJsZSB0byB1c2UgUmVjdEFyZWFMaWdodC4gTWlzc2luZyBXZWJHTCBleHRlbnNpb25zLlwiKSksci5hbWJpZW50WzBdPW8sci5hbWJpZW50WzFdPWwsci5hbWJpZW50WzJdPWM7Y29uc3QgeD1yLmhhc2g7eC5kaXJlY3Rpb25hbExlbmd0aD09PWgmJngucG9pbnRMZW5ndGg9PT11JiZ4LnNwb3RMZW5ndGg9PT1kJiZ4LnJlY3RBcmVhTGVuZ3RoPT09cCYmeC5oZW1pTGVuZ3RoPT09bSYmeC5udW1EaXJlY3Rpb25hbFNoYWRvd3M9PT1mJiZ4Lm51bVBvaW50U2hhZG93cz09PWcmJngubnVtU3BvdFNoYWRvd3M9PT12fHwoci5kaXJlY3Rpb25hbC5sZW5ndGg9aCxyLnNwb3QubGVuZ3RoPWQsci5yZWN0QXJlYS5sZW5ndGg9cCxyLnBvaW50Lmxlbmd0aD11LHIuaGVtaS5sZW5ndGg9bSxyLmRpcmVjdGlvbmFsU2hhZG93Lmxlbmd0aD1mLHIuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoPWYsci5wb2ludFNoYWRvdy5sZW5ndGg9ZyxyLnBvaW50U2hhZG93TWFwLmxlbmd0aD1nLHIuc3BvdFNoYWRvdy5sZW5ndGg9dixyLnNwb3RTaGFkb3dNYXAubGVuZ3RoPXYsci5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC5sZW5ndGg9ZixyLnBvaW50U2hhZG93TWF0cml4Lmxlbmd0aD1nLHIuc3BvdFNoYWRvd01hdHJpeC5sZW5ndGg9dix4LmRpcmVjdGlvbmFsTGVuZ3RoPWgseC5wb2ludExlbmd0aD11LHguc3BvdExlbmd0aD1kLHgucmVjdEFyZWFMZW5ndGg9cCx4LmhlbWlMZW5ndGg9bSx4Lm51bURpcmVjdGlvbmFsU2hhZG93cz1mLHgubnVtUG9pbnRTaGFkb3dzPWcseC5udW1TcG90U2hhZG93cz12LHIudmVyc2lvbj1DcysrKX0sc2V0dXBWaWV3OmZ1bmN0aW9uKHQsZSl7bGV0IG49MCxpPTAsbD0wLGM9MCxoPTA7Y29uc3QgdT1lLm1hdHJpeFdvcmxkSW52ZXJzZTtmb3IobGV0IGU9MCxkPXQubGVuZ3RoO2U8ZDtlKyspe2NvbnN0IGQ9dFtlXTtpZihkLmlzRGlyZWN0aW9uYWxMaWdodCl7Y29uc3QgdD1yLmRpcmVjdGlvbmFsW25dO3QuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihkLm1hdHJpeFdvcmxkKSxzLnNldEZyb21NYXRyaXhQb3NpdGlvbihkLnRhcmdldC5tYXRyaXhXb3JsZCksdC5kaXJlY3Rpb24uc3ViKHMpLHQuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih1KSxuKyt9ZWxzZSBpZihkLmlzU3BvdExpZ2h0KXtjb25zdCB0PXIuc3BvdFtsXTt0LnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihkLm1hdHJpeFdvcmxkKSx0LnBvc2l0aW9uLmFwcGx5TWF0cml4NCh1KSx0LmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oZC5tYXRyaXhXb3JsZCkscy5zZXRGcm9tTWF0cml4UG9zaXRpb24oZC50YXJnZXQubWF0cml4V29ybGQpLHQuZGlyZWN0aW9uLnN1YihzKSx0LmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odSksbCsrfWVsc2UgaWYoZC5pc1JlY3RBcmVhTGlnaHQpe2NvbnN0IHQ9ci5yZWN0QXJlYVtjXTt0LnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihkLm1hdHJpeFdvcmxkKSx0LnBvc2l0aW9uLmFwcGx5TWF0cml4NCh1KSxvLmlkZW50aXR5KCksYS5jb3B5KGQubWF0cml4V29ybGQpLGEucHJlbXVsdGlwbHkodSksby5leHRyYWN0Um90YXRpb24oYSksdC5oYWxmV2lkdGguc2V0KC41KmQud2lkdGgsMCwwKSx0LmhhbGZIZWlnaHQuc2V0KDAsLjUqZC5oZWlnaHQsMCksdC5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KG8pLHQuaGFsZkhlaWdodC5hcHBseU1hdHJpeDQobyksYysrfWVsc2UgaWYoZC5pc1BvaW50TGlnaHQpe2NvbnN0IHQ9ci5wb2ludFtpXTt0LnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihkLm1hdHJpeFdvcmxkKSx0LnBvc2l0aW9uLmFwcGx5TWF0cml4NCh1KSxpKyt9ZWxzZSBpZihkLmlzSGVtaXNwaGVyZUxpZ2h0KXtjb25zdCB0PXIuaGVtaVtoXTt0LmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oZC5tYXRyaXhXb3JsZCksdC5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKHUpLHQuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpLGgrK319fSxzdGF0ZTpyfX1mdW5jdGlvbiBEcyh0LGUpe2NvbnN0IG49bmV3IElzKHQsZSksaT1bXSxyPVtdO3JldHVybntpbml0OmZ1bmN0aW9uKCl7aS5sZW5ndGg9MCxyLmxlbmd0aD0wfSxzdGF0ZTp7bGlnaHRzQXJyYXk6aSxzaGFkb3dzQXJyYXk6cixsaWdodHM6bn0sc2V0dXBMaWdodHM6ZnVuY3Rpb24odCl7bi5zZXR1cChpLHQpfSxzZXR1cExpZ2h0c1ZpZXc6ZnVuY3Rpb24odCl7bi5zZXR1cFZpZXcoaSx0KX0scHVzaExpZ2h0OmZ1bmN0aW9uKHQpe2kucHVzaCh0KX0scHVzaFNoYWRvdzpmdW5jdGlvbih0KXtyLnB1c2godCl9fX1mdW5jdGlvbiBOcyh0LGUpe2xldCBuPW5ldyBXZWFrTWFwO3JldHVybntnZXQ6ZnVuY3Rpb24oaSxyPTApe2xldCBzO3JldHVybiExPT09bi5oYXMoaSk/KHM9bmV3IERzKHQsZSksbi5zZXQoaSxbc10pKTpyPj1uLmdldChpKS5sZW5ndGg/KHM9bmV3IERzKHQsZSksbi5nZXQoaSkucHVzaChzKSk6cz1uLmdldChpKVtyXSxzfSxkaXNwb3NlOmZ1bmN0aW9uKCl7bj1uZXcgV2Vha01hcH19fWNsYXNzIEZzIGV4dGVuZHMgZW57Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJNZXNoRGVwdGhNYXRlcmlhbFwiLHRoaXMuZGVwdGhQYWNraW5nPTMyMDAsdGhpcy5tYXA9bnVsbCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLmZvZz0hMSx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuZGVwdGhQYWNraW5nPXQuZGVwdGhQYWNraW5nLHRoaXMubWFwPXQubWFwLHRoaXMuYWxwaGFNYXA9dC5hbHBoYU1hcCx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLndpcmVmcmFtZT10LndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD10LndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzfX1Gcy5wcm90b3R5cGUuaXNNZXNoRGVwdGhNYXRlcmlhbD0hMDtjbGFzcyBPcyBleHRlbmRzIGVue2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50eXBlPVwiTWVzaERpc3RhbmNlTWF0ZXJpYWxcIix0aGlzLnJlZmVyZW5jZVBvc2l0aW9uPW5ldyBCdCx0aGlzLm5lYXJEaXN0YW5jZT0xLHRoaXMuZmFyRGlzdGFuY2U9MWUzLHRoaXMubWFwPW51bGwsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuZGlzcGxhY2VtZW50TWFwPW51bGwsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT0xLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz0wLHRoaXMuZm9nPSExLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5yZWZlcmVuY2VQb3NpdGlvbi5jb3B5KHQucmVmZXJlbmNlUG9zaXRpb24pLHRoaXMubmVhckRpc3RhbmNlPXQubmVhckRpc3RhbmNlLHRoaXMuZmFyRGlzdGFuY2U9dC5mYXJEaXN0YW5jZSx0aGlzLm1hcD10Lm1hcCx0aGlzLmFscGhhTWFwPXQuYWxwaGFNYXAsdGhpcy5kaXNwbGFjZW1lbnRNYXA9dC5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT10LmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz10LmRpc3BsYWNlbWVudEJpYXMsdGhpc319T3MucHJvdG90eXBlLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWw9ITA7ZnVuY3Rpb24gVXModCxlLG4pe2xldCBpPW5ldyBhaTtjb25zdCByPW5ldyBBdCxzPW5ldyBBdCxhPW5ldyBPdCxvPW5ldyBGcyh7ZGVwdGhQYWNraW5nOjMyMDF9KSxsPW5ldyBPcyxjPXt9LGg9bi5tYXhUZXh0dXJlU2l6ZSx1PXswOjEsMTowLDI6Mn0sZD1uZXcgWW4oe3VuaWZvcm1zOntzaGFkb3dfcGFzczp7dmFsdWU6bnVsbH0scmVzb2x1dGlvbjp7dmFsdWU6bmV3IEF0fSxyYWRpdXM6e3ZhbHVlOjR9LHNhbXBsZXM6e3ZhbHVlOjh9fSx2ZXJ0ZXhTaGFkZXI6XCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiLGZyYWdtZW50U2hhZGVyOlwidW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93X3Bhc3M7XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCByYWRpdXM7XFxudW5pZm9ybSBmbG9hdCBzYW1wbGVzO1xcbiNpbmNsdWRlIDxwYWNraW5nPlxcbnZvaWQgbWFpbigpIHtcXG5cXHRmbG9hdCBtZWFuID0gMC4wO1xcblxcdGZsb2F0IHNxdWFyZWRfbWVhbiA9IDAuMDtcXG5cXHRmbG9hdCB1dlN0cmlkZSA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogMi4wIC8gKCBzYW1wbGVzIC0gMS4wICk7XFxuXFx0ZmxvYXQgdXZTdGFydCA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogLSAxLjA7XFxuXFx0Zm9yICggZmxvYXQgaSA9IDAuMDsgaSA8IHNhbXBsZXM7IGkgKysgKSB7XFxuXFx0XFx0ZmxvYXQgdXZPZmZzZXQgPSB1dlN0YXJ0ICsgaSAqIHV2U3RyaWRlO1xcblxcdFxcdCNpZmRlZiBIT1JJWk9OVEFMX1BBU1NcXG5cXHRcXHRcXHR2ZWMyIGRpc3RyaWJ1dGlvbiA9IHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIHV2T2Zmc2V0LCAwLjAgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0XFx0XFx0bWVhbiArPSBkaXN0cmlidXRpb24ueDtcXG5cXHRcXHRcXHRzcXVhcmVkX21lYW4gKz0gZGlzdHJpYnV0aW9uLnkgKiBkaXN0cmlidXRpb24ueSArIGRpc3RyaWJ1dGlvbi54ICogZGlzdHJpYnV0aW9uLng7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRmbG9hdCBkZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIDAuMCwgdXZPZmZzZXQgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0XFx0XFx0bWVhbiArPSBkZXB0aDtcXG5cXHRcXHRcXHRzcXVhcmVkX21lYW4gKz0gZGVwdGggKiBkZXB0aDtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0bWVhbiA9IG1lYW4gLyBzYW1wbGVzO1xcblxcdHNxdWFyZWRfbWVhbiA9IHNxdWFyZWRfbWVhbiAvIHNhbXBsZXM7XFxuXFx0ZmxvYXQgc3RkX2RldiA9IHNxcnQoIHNxdWFyZWRfbWVhbiAtIG1lYW4gKiBtZWFuICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKCB2ZWMyKCBtZWFuLCBzdGRfZGV2ICkgKTtcXG59XCJ9KSxwPWQuY2xvbmUoKTtwLmRlZmluZXMuSE9SSVpPTlRBTF9QQVNTPTE7Y29uc3QgbT1uZXcgU247bS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBwbihuZXcgRmxvYXQzMkFycmF5KFstMSwtMSwuNSwzLC0xLC41LC0xLDMsLjVdKSwzKSk7Y29uc3QgZj1uZXcgVm4obSxkKSxnPXRoaXM7ZnVuY3Rpb24gdihuLGkpe2NvbnN0IHI9ZS51cGRhdGUoZik7ZC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZT1uLm1hcC50ZXh0dXJlLGQudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZT1uLm1hcFNpemUsZC51bmlmb3Jtcy5yYWRpdXMudmFsdWU9bi5yYWRpdXMsZC51bmlmb3Jtcy5zYW1wbGVzLnZhbHVlPW4uYmx1clNhbXBsZXMsdC5zZXRSZW5kZXJUYXJnZXQobi5tYXBQYXNzKSx0LmNsZWFyKCksdC5yZW5kZXJCdWZmZXJEaXJlY3QoaSxudWxsLHIsZCxmLG51bGwpLHAudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWU9bi5tYXBQYXNzLnRleHR1cmUscC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlPW4ubWFwU2l6ZSxwLnVuaWZvcm1zLnJhZGl1cy52YWx1ZT1uLnJhZGl1cyxwLnVuaWZvcm1zLnNhbXBsZXMudmFsdWU9bi5ibHVyU2FtcGxlcyx0LnNldFJlbmRlclRhcmdldChuLm1hcCksdC5jbGVhcigpLHQucmVuZGVyQnVmZmVyRGlyZWN0KGksbnVsbCxyLHAsZixudWxsKX1mdW5jdGlvbiB5KGUsbixpLHIscyxhLGgpe2xldCBkPW51bGw7Y29uc3QgcD0hMD09PXIuaXNQb2ludExpZ2h0P2UuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDplLmN1c3RvbURlcHRoTWF0ZXJpYWw7aWYoZD12b2lkIDAhPT1wP3A6ITA9PT1yLmlzUG9pbnRMaWdodD9sOm8sdC5sb2NhbENsaXBwaW5nRW5hYmxlZCYmITA9PT1pLmNsaXBTaGFkb3dzJiYwIT09aS5jbGlwcGluZ1BsYW5lcy5sZW5ndGh8fGkuZGlzcGxhY2VtZW50TWFwJiYwIT09aS5kaXNwbGFjZW1lbnRTY2FsZXx8aS5hbHBoYU1hcCYmaS5hbHBoYVRlc3Q+MCl7Y29uc3QgdD1kLnV1aWQsZT1pLnV1aWQ7bGV0IG49Y1t0XTt2b2lkIDA9PT1uJiYobj17fSxjW3RdPW4pO2xldCByPW5bZV07dm9pZCAwPT09ciYmKHI9ZC5jbG9uZSgpLG5bZV09ciksZD1yfXJldHVybiBkLnZpc2libGU9aS52aXNpYmxlLGQud2lyZWZyYW1lPWkud2lyZWZyYW1lLGQuc2lkZT0zPT09aD9udWxsIT09aS5zaGFkb3dTaWRlP2kuc2hhZG93U2lkZTppLnNpZGU6bnVsbCE9PWkuc2hhZG93U2lkZT9pLnNoYWRvd1NpZGU6dVtpLnNpZGVdLGQuYWxwaGFNYXA9aS5hbHBoYU1hcCxkLmFscGhhVGVzdD1pLmFscGhhVGVzdCxkLmNsaXBTaGFkb3dzPWkuY2xpcFNoYWRvd3MsZC5jbGlwcGluZ1BsYW5lcz1pLmNsaXBwaW5nUGxhbmVzLGQuY2xpcEludGVyc2VjdGlvbj1pLmNsaXBJbnRlcnNlY3Rpb24sZC5kaXNwbGFjZW1lbnRNYXA9aS5kaXNwbGFjZW1lbnRNYXAsZC5kaXNwbGFjZW1lbnRTY2FsZT1pLmRpc3BsYWNlbWVudFNjYWxlLGQuZGlzcGxhY2VtZW50Qmlhcz1pLmRpc3BsYWNlbWVudEJpYXMsZC53aXJlZnJhbWVMaW5ld2lkdGg9aS53aXJlZnJhbWVMaW5ld2lkdGgsZC5saW5ld2lkdGg9aS5saW5ld2lkdGgsITA9PT1yLmlzUG9pbnRMaWdodCYmITA9PT1kLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwmJihkLnJlZmVyZW5jZVBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihyLm1hdHJpeFdvcmxkKSxkLm5lYXJEaXN0YW5jZT1zLGQuZmFyRGlzdGFuY2U9YSksZH1mdW5jdGlvbiB4KG4scixzLGEsbyl7aWYoITE9PT1uLnZpc2libGUpcmV0dXJuO2lmKG4ubGF5ZXJzLnRlc3Qoci5sYXllcnMpJiYobi5pc01lc2h8fG4uaXNMaW5lfHxuLmlzUG9pbnRzKSYmKG4uY2FzdFNoYWRvd3x8bi5yZWNlaXZlU2hhZG93JiYzPT09bykmJighbi5mcnVzdHVtQ3VsbGVkfHxpLmludGVyc2VjdHNPYmplY3QobikpKXtuLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKHMubWF0cml4V29ybGRJbnZlcnNlLG4ubWF0cml4V29ybGQpO2NvbnN0IGk9ZS51cGRhdGUobikscj1uLm1hdGVyaWFsO2lmKEFycmF5LmlzQXJyYXkocikpe2NvbnN0IGU9aS5ncm91cHM7Zm9yKGxldCBsPTAsYz1lLmxlbmd0aDtsPGM7bCsrKXtjb25zdCBjPWVbbF0saD1yW2MubWF0ZXJpYWxJbmRleF07aWYoaCYmaC52aXNpYmxlKXtjb25zdCBlPXkobiwwLGgsYSxzLm5lYXIscy5mYXIsbyk7dC5yZW5kZXJCdWZmZXJEaXJlY3QocyxudWxsLGksZSxuLGMpfX19ZWxzZSBpZihyLnZpc2libGUpe2NvbnN0IGU9eShuLDAscixhLHMubmVhcixzLmZhcixvKTt0LnJlbmRlckJ1ZmZlckRpcmVjdChzLG51bGwsaSxlLG4sbnVsbCl9fWNvbnN0IGw9bi5jaGlsZHJlbjtmb3IobGV0IHQ9MCxlPWwubGVuZ3RoO3Q8ZTt0KyspeChsW3RdLHIscyxhLG8pfXRoaXMuZW5hYmxlZD0hMSx0aGlzLmF1dG9VcGRhdGU9ITAsdGhpcy5uZWVkc1VwZGF0ZT0hMSx0aGlzLnR5cGU9MSx0aGlzLnJlbmRlcj1mdW5jdGlvbihlLG4sbyl7aWYoITE9PT1nLmVuYWJsZWQpcmV0dXJuO2lmKCExPT09Zy5hdXRvVXBkYXRlJiYhMT09PWcubmVlZHNVcGRhdGUpcmV0dXJuO2lmKDA9PT1lLmxlbmd0aClyZXR1cm47Y29uc3QgbD10LmdldFJlbmRlclRhcmdldCgpLGM9dC5nZXRBY3RpdmVDdWJlRmFjZSgpLHU9dC5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLGQ9dC5zdGF0ZTtkLnNldEJsZW5kaW5nKDApLGQuYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLDEsMSwxKSxkLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCghMCksZC5zZXRTY2lzc29yVGVzdCghMSk7Zm9yKGxldCBsPTAsYz1lLmxlbmd0aDtsPGM7bCsrKXtjb25zdCBjPWVbbF0sdT1jLnNoYWRvdztpZih2b2lkIDA9PT11KXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFNoYWRvd01hcDpcIixjLFwiaGFzIG5vIHNoYWRvdy5cIik7Y29udGludWV9aWYoITE9PT11LmF1dG9VcGRhdGUmJiExPT09dS5uZWVkc1VwZGF0ZSljb250aW51ZTtyLmNvcHkodS5tYXBTaXplKTtjb25zdCBwPXUuZ2V0RnJhbWVFeHRlbnRzKCk7aWYoci5tdWx0aXBseShwKSxzLmNvcHkodS5tYXBTaXplKSwoci54Pmh8fHIueT5oKSYmKHIueD5oJiYocy54PU1hdGguZmxvb3IoaC9wLngpLHIueD1zLngqcC54LHUubWFwU2l6ZS54PXMueCksci55PmgmJihzLnk9TWF0aC5mbG9vcihoL3AueSksci55PXMueSpwLnksdS5tYXBTaXplLnk9cy55KSksbnVsbD09PXUubWFwJiYhdS5pc1BvaW50TGlnaHRTaGFkb3cmJjM9PT10aGlzLnR5cGUpe2NvbnN0IHQ9e21pbkZpbHRlcjoxMDA2LG1hZ0ZpbHRlcjoxMDA2LGZvcm1hdDoxMDIzfTt1Lm1hcD1uZXcgVXQoci54LHIueSx0KSx1Lm1hcC50ZXh0dXJlLm5hbWU9Yy5uYW1lK1wiLnNoYWRvd01hcFwiLHUubWFwUGFzcz1uZXcgVXQoci54LHIueSx0KSx1LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9aWYobnVsbD09PXUubWFwKXtjb25zdCB0PXttaW5GaWx0ZXI6MTAwMyxtYWdGaWx0ZXI6MTAwMyxmb3JtYXQ6MTAyM307dS5tYXA9bmV3IFV0KHIueCxyLnksdCksdS5tYXAudGV4dHVyZS5uYW1lPWMubmFtZStcIi5zaGFkb3dNYXBcIix1LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9dC5zZXRSZW5kZXJUYXJnZXQodS5tYXApLHQuY2xlYXIoKTtjb25zdCBtPXUuZ2V0Vmlld3BvcnRDb3VudCgpO2ZvcihsZXQgdD0wO3Q8bTt0Kyspe2NvbnN0IGU9dS5nZXRWaWV3cG9ydCh0KTthLnNldChzLngqZS54LHMueSplLnkscy54KmUueixzLnkqZS53KSxkLnZpZXdwb3J0KGEpLHUudXBkYXRlTWF0cmljZXMoYyx0KSxpPXUuZ2V0RnJ1c3R1bSgpLHgobixvLHUuY2FtZXJhLGMsdGhpcy50eXBlKX11LmlzUG9pbnRMaWdodFNoYWRvd3x8MyE9PXRoaXMudHlwZXx8dih1LG8pLHUubmVlZHNVcGRhdGU9ITF9Zy5uZWVkc1VwZGF0ZT0hMSx0LnNldFJlbmRlclRhcmdldChsLGMsdSl9fWZ1bmN0aW9uIGtzKHQsZSxuKXtjb25zdCBpPW4uaXNXZWJHTDI7Y29uc3Qgcj1uZXcgZnVuY3Rpb24oKXtsZXQgZT0hMTtjb25zdCBuPW5ldyBPdDtsZXQgaT1udWxsO2NvbnN0IHI9bmV3IE90KDAsMCwwLDApO3JldHVybntzZXRNYXNrOmZ1bmN0aW9uKG4pe2k9PT1ufHxlfHwodC5jb2xvck1hc2sobixuLG4sbiksaT1uKX0sc2V0TG9ja2VkOmZ1bmN0aW9uKHQpe2U9dH0sc2V0Q2xlYXI6ZnVuY3Rpb24oZSxpLHMsYSxvKXshMD09PW8mJihlKj1hLGkqPWEscyo9YSksbi5zZXQoZSxpLHMsYSksITE9PT1yLmVxdWFscyhuKSYmKHQuY2xlYXJDb2xvcihlLGkscyxhKSxyLmNvcHkobikpfSxyZXNldDpmdW5jdGlvbigpe2U9ITEsaT1udWxsLHIuc2V0KC0xLDAsMCwwKX19fSxzPW5ldyBmdW5jdGlvbigpe2xldCBlPSExLG49bnVsbCxpPW51bGwscj1udWxsO3JldHVybntzZXRUZXN0OmZ1bmN0aW9uKHQpe3Q/VSgyOTI5KTprKDI5MjkpfSxzZXRNYXNrOmZ1bmN0aW9uKGkpe249PT1pfHxlfHwodC5kZXB0aE1hc2soaSksbj1pKX0sc2V0RnVuYzpmdW5jdGlvbihlKXtpZihpIT09ZSl7aWYoZSlzd2l0Y2goZSl7Y2FzZSAwOnQuZGVwdGhGdW5jKDUxMik7YnJlYWs7Y2FzZSAxOnQuZGVwdGhGdW5jKDUxOSk7YnJlYWs7Y2FzZSAyOnQuZGVwdGhGdW5jKDUxMyk7YnJlYWs7ZGVmYXVsdDp0LmRlcHRoRnVuYyg1MTUpO2JyZWFrO2Nhc2UgNDp0LmRlcHRoRnVuYyg1MTQpO2JyZWFrO2Nhc2UgNTp0LmRlcHRoRnVuYyg1MTgpO2JyZWFrO2Nhc2UgNjp0LmRlcHRoRnVuYyg1MTYpO2JyZWFrO2Nhc2UgNzp0LmRlcHRoRnVuYyg1MTcpfWVsc2UgdC5kZXB0aEZ1bmMoNTE1KTtpPWV9fSxzZXRMb2NrZWQ6ZnVuY3Rpb24odCl7ZT10fSxzZXRDbGVhcjpmdW5jdGlvbihlKXtyIT09ZSYmKHQuY2xlYXJEZXB0aChlKSxyPWUpfSxyZXNldDpmdW5jdGlvbigpe2U9ITEsbj1udWxsLGk9bnVsbCxyPW51bGx9fX0sYT1uZXcgZnVuY3Rpb24oKXtsZXQgZT0hMSxuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsYT1udWxsLG89bnVsbCxsPW51bGwsYz1udWxsO3JldHVybntzZXRUZXN0OmZ1bmN0aW9uKHQpe2V8fCh0P1UoMjk2MCk6aygyOTYwKSl9LHNldE1hc2s6ZnVuY3Rpb24oaSl7bj09PWl8fGV8fCh0LnN0ZW5jaWxNYXNrKGkpLG49aSl9LHNldEZ1bmM6ZnVuY3Rpb24oZSxuLGEpe2k9PT1lJiZyPT09biYmcz09PWF8fCh0LnN0ZW5jaWxGdW5jKGUsbixhKSxpPWUscj1uLHM9YSl9LHNldE9wOmZ1bmN0aW9uKGUsbixpKXthPT09ZSYmbz09PW4mJmw9PT1pfHwodC5zdGVuY2lsT3AoZSxuLGkpLGE9ZSxvPW4sbD1pKX0sc2V0TG9ja2VkOmZ1bmN0aW9uKHQpe2U9dH0sc2V0Q2xlYXI6ZnVuY3Rpb24oZSl7YyE9PWUmJih0LmNsZWFyU3RlbmNpbChlKSxjPWUpfSxyZXNldDpmdW5jdGlvbigpe2U9ITEsbj1udWxsLGk9bnVsbCxyPW51bGwscz1udWxsLGE9bnVsbCxvPW51bGwsbD1udWxsLGM9bnVsbH19fTtsZXQgbz17fSxsPW51bGwsYz17fSxoPW51bGwsdT0hMSxkPW51bGwscD1udWxsLG09bnVsbCxmPW51bGwsZz1udWxsLHY9bnVsbCx5PW51bGwseD0hMSxiPW51bGwsdz1udWxsLF89bnVsbCxNPW51bGwsUz1udWxsO2NvbnN0IFQ9dC5nZXRQYXJhbWV0ZXIoMzU2NjEpO2xldCBFPSExLEE9MDtjb25zdCBMPXQuZ2V0UGFyYW1ldGVyKDc5MzgpOy0xIT09TC5pbmRleE9mKFwiV2ViR0xcIik/KEE9cGFyc2VGbG9hdCgvXldlYkdMIChcXGQpLy5leGVjKEwpWzFdKSxFPUE+PTEpOi0xIT09TC5pbmRleE9mKFwiT3BlbkdMIEVTXCIpJiYoQT1wYXJzZUZsb2F0KC9eT3BlbkdMIEVTIChcXGQpLy5leGVjKEwpWzFdKSxFPUE+PTIpO2xldCBSPW51bGwsQz17fTtjb25zdCBQPXQuZ2V0UGFyYW1ldGVyKDMwODgpLEk9dC5nZXRQYXJhbWV0ZXIoMjk3OCksRD0obmV3IE90KS5mcm9tQXJyYXkoUCksTj0obmV3IE90KS5mcm9tQXJyYXkoSSk7ZnVuY3Rpb24gRihlLG4saSl7Y29uc3Qgcj1uZXcgVWludDhBcnJheSg0KSxzPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUoZSxzKSx0LnRleFBhcmFtZXRlcmkoZSwxMDI0MSw5NzI4KSx0LnRleFBhcmFtZXRlcmkoZSwxMDI0MCw5NzI4KTtmb3IobGV0IGU9MDtlPGk7ZSsrKXQudGV4SW1hZ2UyRChuK2UsMCw2NDA4LDEsMSwwLDY0MDgsNTEyMSxyKTtyZXR1cm4gc31jb25zdCBPPXt9O2Z1bmN0aW9uIFUoZSl7ITAhPT1vW2VdJiYodC5lbmFibGUoZSksb1tlXT0hMCl9ZnVuY3Rpb24gayhlKXshMSE9PW9bZV0mJih0LmRpc2FibGUoZSksb1tlXT0hMSl9T1szNTUzXT1GKDM1NTMsMzU1MywxKSxPWzM0MDY3XT1GKDM0MDY3LDM0MDY5LDYpLHIuc2V0Q2xlYXIoMCwwLDAsMSkscy5zZXRDbGVhcigxKSxhLnNldENsZWFyKDApLFUoMjkyOSkscy5zZXRGdW5jKDMpLFYoITEpLEcoMSksVSgyODg0KSxIKDApO2NvbnN0IHo9ezEwMDozMjc3NCwxMDE6MzI3NzgsMTAyOjMyNzc5fTtpZihpKXpbMTAzXT0zMjc3NSx6WzEwNF09MzI3NzY7ZWxzZXtjb25zdCB0PWUuZ2V0KFwiRVhUX2JsZW5kX21pbm1heFwiKTtudWxsIT09dCYmKHpbMTAzXT10Lk1JTl9FWFQselsxMDRdPXQuTUFYX0VYVCl9Y29uc3QgQj17MjAwOjAsMjAxOjEsMjAyOjc2OCwyMDQ6NzcwLDIxMDo3NzYsMjA4Ojc3NCwyMDY6NzcyLDIwMzo3NjksMjA1Ojc3MSwyMDk6Nzc1LDIwNzo3NzN9O2Z1bmN0aW9uIEgoZSxuLGkscixzLGEsbyxsKXtpZigwIT09ZSl7aWYoITE9PT11JiYoVSgzMDQyKSx1PSEwKSw1PT09ZSlzPXN8fG4sYT1hfHxpLG89b3x8cixuPT09cCYmcz09PWd8fCh0LmJsZW5kRXF1YXRpb25TZXBhcmF0ZSh6W25dLHpbc10pLHA9bixnPXMpLGk9PT1tJiZyPT09ZiYmYT09PXYmJm89PT15fHwodC5ibGVuZEZ1bmNTZXBhcmF0ZShCW2ldLEJbcl0sQlthXSxCW29dKSxtPWksZj1yLHY9YSx5PW8pLGQ9ZSx4PW51bGw7ZWxzZSBpZihlIT09ZHx8bCE9PXgpe2lmKDEwMD09PXAmJjEwMD09PWd8fCh0LmJsZW5kRXF1YXRpb24oMzI3NzQpLHA9MTAwLGc9MTAwKSxsKXN3aXRjaChlKXtjYXNlIDE6dC5ibGVuZEZ1bmNTZXBhcmF0ZSgxLDc3MSwxLDc3MSk7YnJlYWs7Y2FzZSAyOnQuYmxlbmRGdW5jKDEsMSk7YnJlYWs7Y2FzZSAzOnQuYmxlbmRGdW5jU2VwYXJhdGUoMCwwLDc2OSw3NzEpO2JyZWFrO2Nhc2UgNDp0LmJsZW5kRnVuY1NlcGFyYXRlKDAsNzY4LDAsNzcwKTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiBcIixlKX1lbHNlIHN3aXRjaChlKXtjYXNlIDE6dC5ibGVuZEZ1bmNTZXBhcmF0ZSg3NzAsNzcxLDEsNzcxKTticmVhaztjYXNlIDI6dC5ibGVuZEZ1bmMoNzcwLDEpO2JyZWFrO2Nhc2UgMzp0LmJsZW5kRnVuYygwLDc2OSk7YnJlYWs7Y2FzZSA0OnQuYmxlbmRGdW5jKDAsNzY4KTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiBcIixlKX1tPW51bGwsZj1udWxsLHY9bnVsbCx5PW51bGwsZD1lLHg9bH19ZWxzZSEwPT09dSYmKGsoMzA0MiksdT0hMSl9ZnVuY3Rpb24gVihlKXtiIT09ZSYmKGU/dC5mcm9udEZhY2UoMjMwNCk6dC5mcm9udEZhY2UoMjMwNSksYj1lKX1mdW5jdGlvbiBHKGUpezAhPT1lPyhVKDI4ODQpLGUhPT13JiYoMT09PWU/dC5jdWxsRmFjZSgxMDI5KToyPT09ZT90LmN1bGxGYWNlKDEwMjgpOnQuY3VsbEZhY2UoMTAzMikpKTprKDI4ODQpLHc9ZX1mdW5jdGlvbiBXKGUsbixpKXtlPyhVKDMyODIzKSxNPT09biYmUz09PWl8fCh0LnBvbHlnb25PZmZzZXQobixpKSxNPW4sUz1pKSk6aygzMjgyMyl9ZnVuY3Rpb24gaihlKXt2b2lkIDA9PT1lJiYoZT0zMzk4NCtULTEpLFIhPT1lJiYodC5hY3RpdmVUZXh0dXJlKGUpLFI9ZSl9cmV0dXJue2J1ZmZlcnM6e2NvbG9yOnIsZGVwdGg6cyxzdGVuY2lsOmF9LGVuYWJsZTpVLGRpc2FibGU6ayxiaW5kRnJhbWVidWZmZXI6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbnVsbD09PW4mJm51bGwhPT1sJiYobj1sKSxjW2VdIT09biYmKHQuYmluZEZyYW1lYnVmZmVyKGUsbiksY1tlXT1uLGkmJigzNjAwOT09PWUmJihjWzM2MTYwXT1uKSwzNjE2MD09PWUmJihjWzM2MDA5XT1uKSksITApfSxiaW5kWFJGcmFtZWJ1ZmZlcjpmdW5jdGlvbihlKXtlIT09bCYmKHQuYmluZEZyYW1lYnVmZmVyKDM2MTYwLGUpLGw9ZSl9LHVzZVByb2dyYW06ZnVuY3Rpb24oZSl7cmV0dXJuIGghPT1lJiYodC51c2VQcm9ncmFtKGUpLGg9ZSwhMCl9LHNldEJsZW5kaW5nOkgsc2V0TWF0ZXJpYWw6ZnVuY3Rpb24odCxlKXsyPT09dC5zaWRlP2soMjg4NCk6VSgyODg0KTtsZXQgbj0xPT09dC5zaWRlO2UmJihuPSFuKSxWKG4pLDE9PT10LmJsZW5kaW5nJiYhMT09PXQudHJhbnNwYXJlbnQ/SCgwKTpIKHQuYmxlbmRpbmcsdC5ibGVuZEVxdWF0aW9uLHQuYmxlbmRTcmMsdC5ibGVuZERzdCx0LmJsZW5kRXF1YXRpb25BbHBoYSx0LmJsZW5kU3JjQWxwaGEsdC5ibGVuZERzdEFscGhhLHQucHJlbXVsdGlwbGllZEFscGhhKSxzLnNldEZ1bmModC5kZXB0aEZ1bmMpLHMuc2V0VGVzdCh0LmRlcHRoVGVzdCkscy5zZXRNYXNrKHQuZGVwdGhXcml0ZSksci5zZXRNYXNrKHQuY29sb3JXcml0ZSk7Y29uc3QgaT10LnN0ZW5jaWxXcml0ZTthLnNldFRlc3QoaSksaSYmKGEuc2V0TWFzayh0LnN0ZW5jaWxXcml0ZU1hc2spLGEuc2V0RnVuYyh0LnN0ZW5jaWxGdW5jLHQuc3RlbmNpbFJlZix0LnN0ZW5jaWxGdW5jTWFzayksYS5zZXRPcCh0LnN0ZW5jaWxGYWlsLHQuc3RlbmNpbFpGYWlsLHQuc3RlbmNpbFpQYXNzKSksVyh0LnBvbHlnb25PZmZzZXQsdC5wb2x5Z29uT2Zmc2V0RmFjdG9yLHQucG9seWdvbk9mZnNldFVuaXRzKSwhMD09PXQuYWxwaGFUb0NvdmVyYWdlP1UoMzI5MjYpOmsoMzI5MjYpfSxzZXRGbGlwU2lkZWQ6VixzZXRDdWxsRmFjZTpHLHNldExpbmVXaWR0aDpmdW5jdGlvbihlKXtlIT09XyYmKEUmJnQubGluZVdpZHRoKGUpLF89ZSl9LHNldFBvbHlnb25PZmZzZXQ6VyxzZXRTY2lzc29yVGVzdDpmdW5jdGlvbih0KXt0P1UoMzA4OSk6aygzMDg5KX0sYWN0aXZlVGV4dHVyZTpqLGJpbmRUZXh0dXJlOmZ1bmN0aW9uKGUsbil7bnVsbD09PVImJmooKTtsZXQgaT1DW1JdO3ZvaWQgMD09PWkmJihpPXt0eXBlOnZvaWQgMCx0ZXh0dXJlOnZvaWQgMH0sQ1tSXT1pKSxpLnR5cGU9PT1lJiZpLnRleHR1cmU9PT1ufHwodC5iaW5kVGV4dHVyZShlLG58fE9bZV0pLGkudHlwZT1lLGkudGV4dHVyZT1uKX0sdW5iaW5kVGV4dHVyZTpmdW5jdGlvbigpe2NvbnN0IGU9Q1tSXTt2b2lkIDAhPT1lJiZ2b2lkIDAhPT1lLnR5cGUmJih0LmJpbmRUZXh0dXJlKGUudHlwZSxudWxsKSxlLnR5cGU9dm9pZCAwLGUudGV4dHVyZT12b2lkIDApfSxjb21wcmVzc2VkVGV4SW1hZ2UyRDpmdW5jdGlvbigpe3RyeXt0LmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KHQsYXJndW1lbnRzKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIix0KX19LHRleEltYWdlMkQ6ZnVuY3Rpb24oKXt0cnl7dC50ZXhJbWFnZTJELmFwcGx5KHQsYXJndW1lbnRzKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIix0KX19LHRleEltYWdlM0Q6ZnVuY3Rpb24oKXt0cnl7dC50ZXhJbWFnZTNELmFwcGx5KHQsYXJndW1lbnRzKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xTdGF0ZTpcIix0KX19LHNjaXNzb3I6ZnVuY3Rpb24oZSl7ITE9PT1ELmVxdWFscyhlKSYmKHQuc2Npc3NvcihlLngsZS55LGUueixlLncpLEQuY29weShlKSl9LHZpZXdwb3J0OmZ1bmN0aW9uKGUpeyExPT09Ti5lcXVhbHMoZSkmJih0LnZpZXdwb3J0KGUueCxlLnksZS56LGUudyksTi5jb3B5KGUpKX0scmVzZXQ6ZnVuY3Rpb24oKXt0LmRpc2FibGUoMzA0MiksdC5kaXNhYmxlKDI4ODQpLHQuZGlzYWJsZSgyOTI5KSx0LmRpc2FibGUoMzI4MjMpLHQuZGlzYWJsZSgzMDg5KSx0LmRpc2FibGUoMjk2MCksdC5kaXNhYmxlKDMyOTI2KSx0LmJsZW5kRXF1YXRpb24oMzI3NzQpLHQuYmxlbmRGdW5jKDEsMCksdC5ibGVuZEZ1bmNTZXBhcmF0ZSgxLDAsMSwwKSx0LmNvbG9yTWFzayghMCwhMCwhMCwhMCksdC5jbGVhckNvbG9yKDAsMCwwLDApLHQuZGVwdGhNYXNrKCEwKSx0LmRlcHRoRnVuYyg1MTMpLHQuY2xlYXJEZXB0aCgxKSx0LnN0ZW5jaWxNYXNrKDQyOTQ5NjcyOTUpLHQuc3RlbmNpbEZ1bmMoNTE5LDAsNDI5NDk2NzI5NSksdC5zdGVuY2lsT3AoNzY4MCw3NjgwLDc2ODApLHQuY2xlYXJTdGVuY2lsKDApLHQuY3VsbEZhY2UoMTAyOSksdC5mcm9udEZhY2UoMjMwNSksdC5wb2x5Z29uT2Zmc2V0KDAsMCksdC5hY3RpdmVUZXh0dXJlKDMzOTg0KSx0LmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCxudWxsKSwhMD09PWkmJih0LmJpbmRGcmFtZWJ1ZmZlcigzNjAwOSxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcigzNjAwOCxudWxsKSksdC51c2VQcm9ncmFtKG51bGwpLHQubGluZVdpZHRoKDEpLHQuc2Npc3NvcigwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KSx0LnZpZXdwb3J0KDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpLG89e30sUj1udWxsLEM9e30sbD1udWxsLGM9e30saD1udWxsLHU9ITEsZD1udWxsLHA9bnVsbCxtPW51bGwsZj1udWxsLGc9bnVsbCx2PW51bGwseT1udWxsLHg9ITEsYj1udWxsLHc9bnVsbCxfPW51bGwsTT1udWxsLFM9bnVsbCxELnNldCgwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KSxOLnNldCgwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KSxyLnJlc2V0KCkscy5yZXNldCgpLGEucmVzZXQoKX19fWZ1bmN0aW9uIHpzKHQsZSxuLGkscixzLGEpe2NvbnN0IG89ci5pc1dlYkdMMixsPXIubWF4VGV4dHVyZXMsYz1yLm1heEN1YmVtYXBTaXplLGg9ci5tYXhUZXh0dXJlU2l6ZSx1PXIubWF4U2FtcGxlcyxkPW5ldyBXZWFrTWFwO2xldCBwLG09ITE7dHJ5e209XCJ1bmRlZmluZWRcIiE9dHlwZW9mIE9mZnNjcmVlbkNhbnZhcyYmbnVsbCE9PW5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKS5nZXRDb250ZXh0KFwiMmRcIil9Y2F0Y2godCl7fWZ1bmN0aW9uIGYodCxlKXtyZXR1cm4gbT9uZXcgT2Zmc2NyZWVuQ2FudmFzKHQsZSk6Q3QoXCJjYW52YXNcIil9ZnVuY3Rpb24gZyh0LGUsbixpKXtsZXQgcj0xO2lmKCh0LndpZHRoPml8fHQuaGVpZ2h0PmkpJiYocj1pL01hdGgubWF4KHQud2lkdGgsdC5oZWlnaHQpKSxyPDF8fCEwPT09ZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQmJnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50fHxcInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQmJnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEltYWdlQml0bWFwJiZ0IGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApe2NvbnN0IGk9ZT9UdDpNYXRoLmZsb29yLHM9aShyKnQud2lkdGgpLGE9aShyKnQuaGVpZ2h0KTt2b2lkIDA9PT1wJiYocD1mKHMsYSkpO2NvbnN0IG89bj9mKHMsYSk6cDtvLndpZHRoPXMsby5oZWlnaHQ9YTtyZXR1cm4gby5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKHQsMCwwLHMsYSksY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBoYXMgYmVlbiByZXNpemVkIGZyb20gKFwiK3Qud2lkdGgrXCJ4XCIrdC5oZWlnaHQrXCIpIHRvIChcIitzK1wieFwiK2ErXCIpLlwiKSxvfXJldHVyblwiZGF0YVwiaW4gdCYmY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogSW1hZ2UgaW4gRGF0YVRleHR1cmUgaXMgdG9vIGJpZyAoXCIrdC53aWR0aCtcInhcIit0LmhlaWdodCtcIikuXCIpLHR9cmV0dXJuIHR9ZnVuY3Rpb24gdih0KXtyZXR1cm4gTXQodC53aWR0aCkmJk10KHQuaGVpZ2h0KX1mdW5jdGlvbiB5KHQsZSl7cmV0dXJuIHQuZ2VuZXJhdGVNaXBtYXBzJiZlJiYxMDAzIT09dC5taW5GaWx0ZXImJjEwMDYhPT10Lm1pbkZpbHRlcn1mdW5jdGlvbiB4KGUsbixyLHMsYT0xKXt0LmdlbmVyYXRlTWlwbWFwKGUpO2kuZ2V0KG4pLl9fbWF4TWlwTGV2ZWw9TWF0aC5sb2cyKE1hdGgubWF4KHIscyxhKSl9ZnVuY3Rpb24gYihuLGkscixzKXtpZighMT09PW8pcmV0dXJuIGk7aWYobnVsbCE9PW4pe2lmKHZvaWQgMCE9PXRbbl0pcmV0dXJuIHRbbl07Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byB1c2Ugbm9uLWV4aXN0aW5nIFdlYkdMIGludGVybmFsIGZvcm1hdCAnXCIrbitcIidcIil9bGV0IGE9aTtyZXR1cm4gNjQwMz09PWkmJig1MTI2PT09ciYmKGE9MzMzMjYpLDUxMzE9PT1yJiYoYT0zMzMyNSksNTEyMT09PXImJihhPTMzMzIxKSksNjQwNz09PWkmJig1MTI2PT09ciYmKGE9MzQ4MzcpLDUxMzE9PT1yJiYoYT0zNDg0MyksNTEyMT09PXImJihhPTMyODQ5KSksNjQwOD09PWkmJig1MTI2PT09ciYmKGE9MzQ4MzYpLDUxMzE9PT1yJiYoYT0zNDg0MiksNTEyMT09PXImJihhPTMwMDE9PT1zPzM1OTA3OjMyODU2KSksMzMzMjUhPT1hJiYzMzMyNiE9PWEmJjM0ODQyIT09YSYmMzQ4MzYhPT1hfHxlLmdldChcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIiksYX1mdW5jdGlvbiB3KHQpe3JldHVybiAxMDAzPT09dHx8MTAwND09PXR8fDEwMDU9PT10Pzk3Mjg6OTcyOX1mdW5jdGlvbiBfKGUpe2NvbnN0IG49ZS50YXJnZXQ7bi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLF8pLGZ1bmN0aW9uKGUpe2NvbnN0IG49aS5nZXQoZSk7aWYodm9pZCAwPT09bi5fX3dlYmdsSW5pdClyZXR1cm47dC5kZWxldGVUZXh0dXJlKG4uX193ZWJnbFRleHR1cmUpLGkucmVtb3ZlKGUpfShuKSxuLmlzVmlkZW9UZXh0dXJlJiZkLmRlbGV0ZShuKSxhLm1lbW9yeS50ZXh0dXJlcy0tfWZ1bmN0aW9uIE0oZSl7Y29uc3Qgbj1lLnRhcmdldDtuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsTSksZnVuY3Rpb24oZSl7Y29uc3Qgbj1lLnRleHR1cmUscj1pLmdldChlKSxzPWkuZ2V0KG4pO2lmKCFlKXJldHVybjt2b2lkIDAhPT1zLl9fd2ViZ2xUZXh0dXJlJiYodC5kZWxldGVUZXh0dXJlKHMuX193ZWJnbFRleHR1cmUpLGEubWVtb3J5LnRleHR1cmVzLS0pO2UuZGVwdGhUZXh0dXJlJiZlLmRlcHRoVGV4dHVyZS5kaXNwb3NlKCk7aWYoZS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldClmb3IobGV0IGU9MDtlPDY7ZSsrKXQuZGVsZXRlRnJhbWVidWZmZXIoci5fX3dlYmdsRnJhbWVidWZmZXJbZV0pLHIuX193ZWJnbERlcHRoYnVmZmVyJiZ0LmRlbGV0ZVJlbmRlcmJ1ZmZlcihyLl9fd2ViZ2xEZXB0aGJ1ZmZlcltlXSk7ZWxzZSB0LmRlbGV0ZUZyYW1lYnVmZmVyKHIuX193ZWJnbEZyYW1lYnVmZmVyKSxyLl9fd2ViZ2xEZXB0aGJ1ZmZlciYmdC5kZWxldGVSZW5kZXJidWZmZXIoci5fX3dlYmdsRGVwdGhidWZmZXIpLHIuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyJiZ0LmRlbGV0ZUZyYW1lYnVmZmVyKHIuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSxyLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlciYmdC5kZWxldGVSZW5kZXJidWZmZXIoci5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIpLHIuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyJiZ0LmRlbGV0ZVJlbmRlcmJ1ZmZlcihyLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlcik7aWYoZS5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzKWZvcihsZXQgZT0wLHI9bi5sZW5ndGg7ZTxyO2UrKyl7Y29uc3Qgcj1pLmdldChuW2VdKTtyLl9fd2ViZ2xUZXh0dXJlJiYodC5kZWxldGVUZXh0dXJlKHIuX193ZWJnbFRleHR1cmUpLGEubWVtb3J5LnRleHR1cmVzLS0pLGkucmVtb3ZlKG5bZV0pfWkucmVtb3ZlKG4pLGkucmVtb3ZlKGUpfShuKX1sZXQgUz0wO2Z1bmN0aW9uIFQodCxlKXtjb25zdCByPWkuZ2V0KHQpO2lmKHQuaXNWaWRlb1RleHR1cmUmJmZ1bmN0aW9uKHQpe2NvbnN0IGU9YS5yZW5kZXIuZnJhbWU7ZC5nZXQodCkhPT1lJiYoZC5zZXQodCxlKSx0LnVwZGF0ZSgpKX0odCksdC52ZXJzaW9uPjAmJnIuX192ZXJzaW9uIT09dC52ZXJzaW9uKXtjb25zdCBuPXQuaW1hZ2U7aWYodm9pZCAwPT09biljb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWRcIik7ZWxzZXtpZighMSE9PW4uY29tcGxldGUpcmV0dXJuIHZvaWQgUChyLHQsZSk7Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZVwiKX19bi5hY3RpdmVUZXh0dXJlKDMzOTg0K2UpLG4uYmluZFRleHR1cmUoMzU1MyxyLl9fd2ViZ2xUZXh0dXJlKX1mdW5jdGlvbiBFKGUscil7Y29uc3QgYT1pLmdldChlKTtlLnZlcnNpb24+MCYmYS5fX3ZlcnNpb24hPT1lLnZlcnNpb24/ZnVuY3Rpb24oZSxpLHIpe2lmKDYhPT1pLmltYWdlLmxlbmd0aClyZXR1cm47QyhlLGkpLG4uYWN0aXZlVGV4dHVyZSgzMzk4NCtyKSxuLmJpbmRUZXh0dXJlKDM0MDY3LGUuX193ZWJnbFRleHR1cmUpLHQucGl4ZWxTdG9yZWkoMzc0NDAsaS5mbGlwWSksdC5waXhlbFN0b3JlaSgzNzQ0MSxpLnByZW11bHRpcGx5QWxwaGEpLHQucGl4ZWxTdG9yZWkoMzMxNyxpLnVucGFja0FsaWdubWVudCksdC5waXhlbFN0b3JlaSgzNzQ0MywwKTtjb25zdCBhPWkmJihpLmlzQ29tcHJlc3NlZFRleHR1cmV8fGkuaW1hZ2VbMF0uaXNDb21wcmVzc2VkVGV4dHVyZSksbD1pLmltYWdlWzBdJiZpLmltYWdlWzBdLmlzRGF0YVRleHR1cmUsaD1bXTtmb3IobGV0IHQ9MDt0PDY7dCsrKWhbdF09YXx8bD9sP2kuaW1hZ2VbdF0uaW1hZ2U6aS5pbWFnZVt0XTpnKGkuaW1hZ2VbdF0sITEsITAsYyk7Y29uc3QgdT1oWzBdLGQ9dih1KXx8byxwPXMuY29udmVydChpLmZvcm1hdCksbT1zLmNvbnZlcnQoaS50eXBlKSxmPWIoaS5pbnRlcm5hbEZvcm1hdCxwLG0saS5lbmNvZGluZyk7bGV0IHc7aWYoUigzNDA2NyxpLGQpLGEpe2ZvcihsZXQgdD0wO3Q8Njt0Kyspe3c9aFt0XS5taXBtYXBzO2ZvcihsZXQgZT0wO2U8dy5sZW5ndGg7ZSsrKXtjb25zdCByPXdbZV07MTAyMyE9PWkuZm9ybWF0JiYxMDIyIT09aS5mb3JtYXQ/bnVsbCE9PXA/bi5jb21wcmVzc2VkVGV4SW1hZ2UyRCgzNDA2OSt0LGUsZixyLndpZHRoLHIuaGVpZ2h0LDAsci5kYXRhKTpjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0VGV4dHVyZUN1YmUoKVwiKTpuLnRleEltYWdlMkQoMzQwNjkrdCxlLGYsci53aWR0aCxyLmhlaWdodCwwLHAsbSxyLmRhdGEpfX1lLl9fbWF4TWlwTGV2ZWw9dy5sZW5ndGgtMX1lbHNle3c9aS5taXBtYXBzO2ZvcihsZXQgdD0wO3Q8Njt0KyspaWYobCl7bi50ZXhJbWFnZTJEKDM0MDY5K3QsMCxmLGhbdF0ud2lkdGgsaFt0XS5oZWlnaHQsMCxwLG0saFt0XS5kYXRhKTtmb3IobGV0IGU9MDtlPHcubGVuZ3RoO2UrKyl7Y29uc3QgaT13W2VdLmltYWdlW3RdLmltYWdlO24udGV4SW1hZ2UyRCgzNDA2OSt0LGUrMSxmLGkud2lkdGgsaS5oZWlnaHQsMCxwLG0saS5kYXRhKX19ZWxzZXtuLnRleEltYWdlMkQoMzQwNjkrdCwwLGYscCxtLGhbdF0pO2ZvcihsZXQgZT0wO2U8dy5sZW5ndGg7ZSsrKXtjb25zdCBpPXdbZV07bi50ZXhJbWFnZTJEKDM0MDY5K3QsZSsxLGYscCxtLGkuaW1hZ2VbdF0pfX1lLl9fbWF4TWlwTGV2ZWw9dy5sZW5ndGh9eShpLGQpJiZ4KDM0MDY3LGksdS53aWR0aCx1LmhlaWdodCk7ZS5fX3ZlcnNpb249aS52ZXJzaW9uLGkub25VcGRhdGUmJmkub25VcGRhdGUoaSl9KGEsZSxyKToobi5hY3RpdmVUZXh0dXJlKDMzOTg0K3IpLG4uYmluZFRleHR1cmUoMzQwNjcsYS5fX3dlYmdsVGV4dHVyZSkpfWNvbnN0IEE9ezFlMzoxMDQ5NywxMDAxOjMzMDcxLDEwMDI6MzM2NDh9LEw9ezEwMDM6OTcyOCwxMDA0Ojk5ODQsMTAwNTo5OTg2LDEwMDY6OTcyOSwxMDA3Ojk5ODUsMTAwODo5OTg3fTtmdW5jdGlvbiBSKG4scyxhKXtpZihhPyh0LnRleFBhcmFtZXRlcmkobiwxMDI0MixBW3Mud3JhcFNdKSx0LnRleFBhcmFtZXRlcmkobiwxMDI0MyxBW3Mud3JhcFRdKSwzMjg3OSE9PW4mJjM1ODY2IT09bnx8dC50ZXhQYXJhbWV0ZXJpKG4sMzI4ODIsQVtzLndyYXBSXSksdC50ZXhQYXJhbWV0ZXJpKG4sMTAyNDAsTFtzLm1hZ0ZpbHRlcl0pLHQudGV4UGFyYW1ldGVyaShuLDEwMjQxLExbcy5taW5GaWx0ZXJdKSk6KHQudGV4UGFyYW1ldGVyaShuLDEwMjQyLDMzMDcxKSx0LnRleFBhcmFtZXRlcmkobiwxMDI0MywzMzA3MSksMzI4NzkhPT1uJiYzNTg2NiE9PW58fHQudGV4UGFyYW1ldGVyaShuLDMyODgyLDMzMDcxKSwxMDAxPT09cy53cmFwUyYmMTAwMT09PXMud3JhcFR8fGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuXCIpLHQudGV4UGFyYW1ldGVyaShuLDEwMjQwLHcocy5tYWdGaWx0ZXIpKSx0LnRleFBhcmFtZXRlcmkobiwxMDI0MSx3KHMubWluRmlsdGVyKSksMTAwMyE9PXMubWluRmlsdGVyJiYxMDA2IT09cy5taW5GaWx0ZXImJmNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci5cIikpLCEwPT09ZS5oYXMoXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpe2NvbnN0IGE9ZS5nZXQoXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIik7aWYoMTAxNT09PXMudHlwZSYmITE9PT1lLmhhcyhcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSlyZXR1cm47aWYoITE9PT1vJiYxMDE2PT09cy50eXBlJiYhMT09PWUuaGFzKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIikpcmV0dXJuOyhzLmFuaXNvdHJvcHk+MXx8aS5nZXQocykuX19jdXJyZW50QW5pc290cm9weSkmJih0LnRleFBhcmFtZXRlcmYobixhLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULE1hdGgubWluKHMuYW5pc290cm9weSxyLmdldE1heEFuaXNvdHJvcHkoKSkpLGkuZ2V0KHMpLl9fY3VycmVudEFuaXNvdHJvcHk9cy5hbmlzb3Ryb3B5KX19ZnVuY3Rpb24gQyhlLG4pe3ZvaWQgMD09PWUuX193ZWJnbEluaXQmJihlLl9fd2ViZ2xJbml0PSEwLG4uYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixfKSxlLl9fd2ViZ2xUZXh0dXJlPXQuY3JlYXRlVGV4dHVyZSgpLGEubWVtb3J5LnRleHR1cmVzKyspfWZ1bmN0aW9uIFAoZSxpLHIpe2xldCBhPTM1NTM7aS5pc0RhdGFUZXh0dXJlMkRBcnJheSYmKGE9MzU4NjYpLGkuaXNEYXRhVGV4dHVyZTNEJiYoYT0zMjg3OSksQyhlLGkpLG4uYWN0aXZlVGV4dHVyZSgzMzk4NCtyKSxuLmJpbmRUZXh0dXJlKGEsZS5fX3dlYmdsVGV4dHVyZSksdC5waXhlbFN0b3JlaSgzNzQ0MCxpLmZsaXBZKSx0LnBpeGVsU3RvcmVpKDM3NDQxLGkucHJlbXVsdGlwbHlBbHBoYSksdC5waXhlbFN0b3JlaSgzMzE3LGkudW5wYWNrQWxpZ25tZW50KSx0LnBpeGVsU3RvcmVpKDM3NDQzLDApO2NvbnN0IGw9ZnVuY3Rpb24odCl7cmV0dXJuIW8mJigxMDAxIT09dC53cmFwU3x8MTAwMSE9PXQud3JhcFR8fDEwMDMhPT10Lm1pbkZpbHRlciYmMTAwNiE9PXQubWluRmlsdGVyKX0oaSkmJiExPT09dihpLmltYWdlKSxjPWcoaS5pbWFnZSxsLCExLGgpLHU9dihjKXx8byxkPXMuY29udmVydChpLmZvcm1hdCk7bGV0IHAsbT1zLmNvbnZlcnQoaS50eXBlKSxmPWIoaS5pbnRlcm5hbEZvcm1hdCxkLG0saS5lbmNvZGluZyk7UihhLGksdSk7Y29uc3Qgdz1pLm1pcG1hcHM7aWYoaS5pc0RlcHRoVGV4dHVyZSlmPTY0MDIsbz9mPTEwMTU9PT1pLnR5cGU/MzYwMTI6MTAxND09PWkudHlwZT8zMzE5MDoxMDIwPT09aS50eXBlPzM1MDU2OjMzMTg5OjEwMTU9PT1pLnR5cGUmJmNvbnNvbGUuZXJyb3IoXCJXZWJHTFJlbmRlcmVyOiBGbG9hdGluZyBwb2ludCBkZXB0aCB0ZXh0dXJlIHJlcXVpcmVzIFdlYkdMMi5cIiksMTAyNj09PWkuZm9ybWF0JiY2NDAyPT09ZiYmMTAxMiE9PWkudHlwZSYmMTAxNCE9PWkudHlwZSYmKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZFNob3J0VHlwZSBvciBVbnNpZ25lZEludFR5cGUgZm9yIERlcHRoRm9ybWF0IERlcHRoVGV4dHVyZS5cIiksaS50eXBlPTEwMTIsbT1zLmNvbnZlcnQoaS50eXBlKSksMTAyNz09PWkuZm9ybWF0JiY2NDAyPT09ZiYmKGY9MzQwNDEsMTAyMCE9PWkudHlwZSYmKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZEludDI0OFR5cGUgZm9yIERlcHRoU3RlbmNpbEZvcm1hdCBEZXB0aFRleHR1cmUuXCIpLGkudHlwZT0xMDIwLG09cy5jb252ZXJ0KGkudHlwZSkpKSxuLnRleEltYWdlMkQoMzU1MywwLGYsYy53aWR0aCxjLmhlaWdodCwwLGQsbSxudWxsKTtlbHNlIGlmKGkuaXNEYXRhVGV4dHVyZSlpZih3Lmxlbmd0aD4wJiZ1KXtmb3IobGV0IHQ9MCxlPXcubGVuZ3RoO3Q8ZTt0KyspcD13W3RdLG4udGV4SW1hZ2UyRCgzNTUzLHQsZixwLndpZHRoLHAuaGVpZ2h0LDAsZCxtLHAuZGF0YSk7aS5nZW5lcmF0ZU1pcG1hcHM9ITEsZS5fX21heE1pcExldmVsPXcubGVuZ3RoLTF9ZWxzZSBuLnRleEltYWdlMkQoMzU1MywwLGYsYy53aWR0aCxjLmhlaWdodCwwLGQsbSxjLmRhdGEpLGUuX19tYXhNaXBMZXZlbD0wO2Vsc2UgaWYoaS5pc0NvbXByZXNzZWRUZXh0dXJlKXtmb3IobGV0IHQ9MCxlPXcubGVuZ3RoO3Q8ZTt0KyspcD13W3RdLDEwMjMhPT1pLmZvcm1hdCYmMTAyMiE9PWkuZm9ybWF0P251bGwhPT1kP24uY29tcHJlc3NlZFRleEltYWdlMkQoMzU1Myx0LGYscC53aWR0aCxwLmhlaWdodCwwLHAuZGF0YSk6Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiKTpuLnRleEltYWdlMkQoMzU1Myx0LGYscC53aWR0aCxwLmhlaWdodCwwLGQsbSxwLmRhdGEpO2UuX19tYXhNaXBMZXZlbD13Lmxlbmd0aC0xfWVsc2UgaWYoaS5pc0RhdGFUZXh0dXJlMkRBcnJheSluLnRleEltYWdlM0QoMzU4NjYsMCxmLGMud2lkdGgsYy5oZWlnaHQsYy5kZXB0aCwwLGQsbSxjLmRhdGEpLGUuX19tYXhNaXBMZXZlbD0wO2Vsc2UgaWYoaS5pc0RhdGFUZXh0dXJlM0Qpbi50ZXhJbWFnZTNEKDMyODc5LDAsZixjLndpZHRoLGMuaGVpZ2h0LGMuZGVwdGgsMCxkLG0sYy5kYXRhKSxlLl9fbWF4TWlwTGV2ZWw9MDtlbHNlIGlmKHcubGVuZ3RoPjAmJnUpe2ZvcihsZXQgdD0wLGU9dy5sZW5ndGg7dDxlO3QrKylwPXdbdF0sbi50ZXhJbWFnZTJEKDM1NTMsdCxmLGQsbSxwKTtpLmdlbmVyYXRlTWlwbWFwcz0hMSxlLl9fbWF4TWlwTGV2ZWw9dy5sZW5ndGgtMX1lbHNlIG4udGV4SW1hZ2UyRCgzNTUzLDAsZixkLG0sYyksZS5fX21heE1pcExldmVsPTA7eShpLHUpJiZ4KGEsaSxjLndpZHRoLGMuaGVpZ2h0KSxlLl9fdmVyc2lvbj1pLnZlcnNpb24saS5vblVwZGF0ZSYmaS5vblVwZGF0ZShpKX1mdW5jdGlvbiBJKGUscixhLG8sbCl7Y29uc3QgYz1zLmNvbnZlcnQoYS5mb3JtYXQpLGg9cy5jb252ZXJ0KGEudHlwZSksdT1iKGEuaW50ZXJuYWxGb3JtYXQsYyxoLGEuZW5jb2RpbmcpOzMyODc5PT09bHx8MzU4NjY9PT1sP24udGV4SW1hZ2UzRChsLDAsdSxyLndpZHRoLHIuaGVpZ2h0LHIuZGVwdGgsMCxjLGgsbnVsbCk6bi50ZXhJbWFnZTJEKGwsMCx1LHIud2lkdGgsci5oZWlnaHQsMCxjLGgsbnVsbCksbi5iaW5kRnJhbWVidWZmZXIoMzYxNjAsZSksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCxvLGwsaS5nZXQoYSkuX193ZWJnbFRleHR1cmUsMCksbi5iaW5kRnJhbWVidWZmZXIoMzYxNjAsbnVsbCl9ZnVuY3Rpb24gRChlLG4saSl7aWYodC5iaW5kUmVuZGVyYnVmZmVyKDM2MTYxLGUpLG4uZGVwdGhCdWZmZXImJiFuLnN0ZW5jaWxCdWZmZXIpe2xldCByPTMzMTg5O2lmKGkpe2NvbnN0IGU9bi5kZXB0aFRleHR1cmU7ZSYmZS5pc0RlcHRoVGV4dHVyZSYmKDEwMTU9PT1lLnR5cGU/cj0zNjAxMjoxMDE0PT09ZS50eXBlJiYocj0zMzE5MCkpO2NvbnN0IGk9RihuKTt0LnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSgzNjE2MSxpLHIsbi53aWR0aCxuLmhlaWdodCl9ZWxzZSB0LnJlbmRlcmJ1ZmZlclN0b3JhZ2UoMzYxNjEscixuLndpZHRoLG4uaGVpZ2h0KTt0LmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKDM2MTYwLDM2MDk2LDM2MTYxLGUpfWVsc2UgaWYobi5kZXB0aEJ1ZmZlciYmbi5zdGVuY2lsQnVmZmVyKXtpZihpKXtjb25zdCBlPUYobik7dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoMzYxNjEsZSwzNTA1NixuLndpZHRoLG4uaGVpZ2h0KX1lbHNlIHQucmVuZGVyYnVmZmVyU3RvcmFnZSgzNjE2MSwzNDA0MSxuLndpZHRoLG4uaGVpZ2h0KTt0LmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKDM2MTYwLDMzMzA2LDM2MTYxLGUpfWVsc2V7Y29uc3QgZT0hMD09PW4uaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cz9uLnRleHR1cmVbMF06bi50ZXh0dXJlLHI9cy5jb252ZXJ0KGUuZm9ybWF0KSxhPXMuY29udmVydChlLnR5cGUpLG89YihlLmludGVybmFsRm9ybWF0LHIsYSxlLmVuY29kaW5nKTtpZihpKXtjb25zdCBlPUYobik7dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoMzYxNjEsZSxvLG4ud2lkdGgsbi5oZWlnaHQpfWVsc2UgdC5yZW5kZXJidWZmZXJTdG9yYWdlKDM2MTYxLG8sbi53aWR0aCxuLmhlaWdodCl9dC5iaW5kUmVuZGVyYnVmZmVyKDM2MTYxLG51bGwpfWZ1bmN0aW9uIE4oZSl7Y29uc3Qgcj1pLmdldChlKSxzPSEwPT09ZS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldDtpZihlLmRlcHRoVGV4dHVyZSl7aWYocyl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQuZGVwdGhUZXh0dXJlIG5vdCBzdXBwb3J0ZWQgaW4gQ3ViZSByZW5kZXIgdGFyZ2V0c1wiKTshZnVuY3Rpb24oZSxyKXtpZihyJiZyLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KXRocm93IG5ldyBFcnJvcihcIkRlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYobi5iaW5kRnJhbWVidWZmZXIoMzYxNjAsZSksIXIuZGVwdGhUZXh0dXJlfHwhci5kZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUpdGhyb3cgbmV3IEVycm9yKFwicmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFRIUkVFLkRlcHRoVGV4dHVyZVwiKTtpLmdldChyLmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmUmJnIuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoPT09ci53aWR0aCYmci5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0PT09ci5oZWlnaHR8fChyLmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aD1yLndpZHRoLHIuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodD1yLmhlaWdodCxyLmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZT0hMCksVChyLmRlcHRoVGV4dHVyZSwwKTtjb25zdCBzPWkuZ2V0KHIuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZTtpZigxMDI2PT09ci5kZXB0aFRleHR1cmUuZm9ybWF0KXQuZnJhbWVidWZmZXJUZXh0dXJlMkQoMzYxNjAsMzYwOTYsMzU1MyxzLDApO2Vsc2V7aWYoMTAyNyE9PXIuZGVwdGhUZXh0dXJlLmZvcm1hdCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXRcIik7dC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCwzMzMwNiwzNTUzLHMsMCl9fShyLl9fd2ViZ2xGcmFtZWJ1ZmZlcixlKX1lbHNlIGlmKHMpe3IuX193ZWJnbERlcHRoYnVmZmVyPVtdO2ZvcihsZXQgaT0wO2k8NjtpKyspbi5iaW5kRnJhbWVidWZmZXIoMzYxNjAsci5fX3dlYmdsRnJhbWVidWZmZXJbaV0pLHIuX193ZWJnbERlcHRoYnVmZmVyW2ldPXQuY3JlYXRlUmVuZGVyYnVmZmVyKCksRChyLl9fd2ViZ2xEZXB0aGJ1ZmZlcltpXSxlLCExKX1lbHNlIG4uYmluZEZyYW1lYnVmZmVyKDM2MTYwLHIuX193ZWJnbEZyYW1lYnVmZmVyKSxyLl9fd2ViZ2xEZXB0aGJ1ZmZlcj10LmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLEQoci5fX3dlYmdsRGVwdGhidWZmZXIsZSwhMSk7bi5iaW5kRnJhbWVidWZmZXIoMzYxNjAsbnVsbCl9ZnVuY3Rpb24gRih0KXtyZXR1cm4gbyYmdC5pc1dlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ/TWF0aC5taW4odSx0LnNhbXBsZXMpOjB9bGV0IE89ITEsVT0hMTt0aGlzLmFsbG9jYXRlVGV4dHVyZVVuaXQ9ZnVuY3Rpb24oKXtjb25zdCB0PVM7cmV0dXJuIHQ+PWwmJmNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMVGV4dHVyZXM6IFRyeWluZyB0byB1c2UgXCIrdCtcIiB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgXCIrbCksUys9MSx0fSx0aGlzLnJlc2V0VGV4dHVyZVVuaXRzPWZ1bmN0aW9uKCl7Uz0wfSx0aGlzLnNldFRleHR1cmUyRD1ULHRoaXMuc2V0VGV4dHVyZTJEQXJyYXk9ZnVuY3Rpb24odCxlKXtjb25zdCByPWkuZ2V0KHQpO3QudmVyc2lvbj4wJiZyLl9fdmVyc2lvbiE9PXQudmVyc2lvbj9QKHIsdCxlKToobi5hY3RpdmVUZXh0dXJlKDMzOTg0K2UpLG4uYmluZFRleHR1cmUoMzU4NjYsci5fX3dlYmdsVGV4dHVyZSkpfSx0aGlzLnNldFRleHR1cmUzRD1mdW5jdGlvbih0LGUpe2NvbnN0IHI9aS5nZXQodCk7dC52ZXJzaW9uPjAmJnIuX192ZXJzaW9uIT09dC52ZXJzaW9uP1Aocix0LGUpOihuLmFjdGl2ZVRleHR1cmUoMzM5ODQrZSksbi5iaW5kVGV4dHVyZSgzMjg3OSxyLl9fd2ViZ2xUZXh0dXJlKSl9LHRoaXMuc2V0VGV4dHVyZUN1YmU9RSx0aGlzLnNldHVwUmVuZGVyVGFyZ2V0PWZ1bmN0aW9uKGUpe2NvbnN0IGw9ZS50ZXh0dXJlLGM9aS5nZXQoZSksaD1pLmdldChsKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsTSksITAhPT1lLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMmJihoLl9fd2ViZ2xUZXh0dXJlPXQuY3JlYXRlVGV4dHVyZSgpLGguX192ZXJzaW9uPWwudmVyc2lvbixhLm1lbW9yeS50ZXh0dXJlcysrKTtjb25zdCB1PSEwPT09ZS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCxkPSEwPT09ZS5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzLHA9ITA9PT1lLmlzV2ViR0xNdWx0aXNhbXBsZVJlbmRlclRhcmdldCxtPWwuaXNEYXRhVGV4dHVyZTNEfHxsLmlzRGF0YVRleHR1cmUyREFycmF5LGY9dihlKXx8bztpZighb3x8MTAyMiE9PWwuZm9ybWF0fHwxMDE1IT09bC50eXBlJiYxMDE2IT09bC50eXBlfHwobC5mb3JtYXQ9MTAyMyxjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBSZW5kZXJpbmcgdG8gdGV4dHVyZXMgd2l0aCBSR0IgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuIFVzaW5nIFJHQkEgZm9ybWF0IGluc3RlYWQuXCIpKSx1KXtjLl9fd2ViZ2xGcmFtZWJ1ZmZlcj1bXTtmb3IobGV0IGU9MDtlPDY7ZSsrKWMuX193ZWJnbEZyYW1lYnVmZmVyW2VdPXQuY3JlYXRlRnJhbWVidWZmZXIoKX1lbHNlIGlmKGMuX193ZWJnbEZyYW1lYnVmZmVyPXQuY3JlYXRlRnJhbWVidWZmZXIoKSxkKWlmKHIuZHJhd0J1ZmZlcnMpe2NvbnN0IG49ZS50ZXh0dXJlO2ZvcihsZXQgZT0wLHI9bi5sZW5ndGg7ZTxyO2UrKyl7Y29uc3Qgcj1pLmdldChuW2VdKTt2b2lkIDA9PT1yLl9fd2ViZ2xUZXh0dXJlJiYoci5fX3dlYmdsVGV4dHVyZT10LmNyZWF0ZVRleHR1cmUoKSxhLm1lbW9yeS50ZXh0dXJlcysrKX19ZWxzZSBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wyIG9yIFdFQkdMX2RyYXdfYnVmZmVycyBleHRlbnNpb24uXCIpO2Vsc2UgaWYocClpZihvKXtjLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcj10LmNyZWF0ZUZyYW1lYnVmZmVyKCksYy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXI9dC5jcmVhdGVSZW5kZXJidWZmZXIoKSx0LmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsYy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIpO2NvbnN0IGk9cy5jb252ZXJ0KGwuZm9ybWF0KSxyPXMuY29udmVydChsLnR5cGUpLGE9YihsLmludGVybmFsRm9ybWF0LGkscixsLmVuY29kaW5nKSxvPUYoZSk7dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoMzYxNjEsbyxhLGUud2lkdGgsZS5oZWlnaHQpLG4uYmluZEZyYW1lYnVmZmVyKDM2MTYwLGMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSx0LmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKDM2MTYwLDM2MDY0LDM2MTYxLGMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyKSx0LmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsbnVsbCksZS5kZXB0aEJ1ZmZlciYmKGMuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyPXQuY3JlYXRlUmVuZGVyYnVmZmVyKCksRChjLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlcixlLCEwKSksbi5iaW5kRnJhbWVidWZmZXIoMzYxNjAsbnVsbCl9ZWxzZSBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuXCIpO2lmKHUpe24uYmluZFRleHR1cmUoMzQwNjcsaC5fX3dlYmdsVGV4dHVyZSksUigzNDA2NyxsLGYpO2ZvcihsZXQgdD0wO3Q8Njt0KyspSShjLl9fd2ViZ2xGcmFtZWJ1ZmZlclt0XSxlLGwsMzYwNjQsMzQwNjkrdCk7eShsLGYpJiZ4KDM0MDY3LGwsZS53aWR0aCxlLmhlaWdodCksbi51bmJpbmRUZXh0dXJlKCl9ZWxzZSBpZihkKXtjb25zdCB0PWUudGV4dHVyZTtmb3IobGV0IHI9MCxzPXQubGVuZ3RoO3I8cztyKyspe2NvbnN0IHM9dFtyXSxhPWkuZ2V0KHMpO24uYmluZFRleHR1cmUoMzU1MyxhLl9fd2ViZ2xUZXh0dXJlKSxSKDM1NTMscyxmKSxJKGMuX193ZWJnbEZyYW1lYnVmZmVyLGUscywzNjA2NCtyLDM1NTMpLHkocyxmKSYmeCgzNTUzLHMsZS53aWR0aCxlLmhlaWdodCl9bi51bmJpbmRUZXh0dXJlKCl9ZWxzZXtsZXQgdD0zNTUzO2lmKG0paWYobyl7dD1sLmlzRGF0YVRleHR1cmUzRD8zMjg3OTozNTg2Nn1lbHNlIGNvbnNvbGUud2FybihcIlRIUkVFLkRhdGFUZXh0dXJlM0QgYW5kIFRIUkVFLkRhdGFUZXh0dXJlMkRBcnJheSBvbmx5IHN1cHBvcnRlZCB3aXRoIFdlYkdMMi5cIik7bi5iaW5kVGV4dHVyZSh0LGguX193ZWJnbFRleHR1cmUpLFIodCxsLGYpLEkoYy5fX3dlYmdsRnJhbWVidWZmZXIsZSxsLDM2MDY0LHQpLHkobCxmKSYmeCh0LGwsZS53aWR0aCxlLmhlaWdodCxlLmRlcHRoKSxuLnVuYmluZFRleHR1cmUoKX1lLmRlcHRoQnVmZmVyJiZOKGUpfSx0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcD1mdW5jdGlvbih0KXtjb25zdCBlPXYodCl8fG8scj0hMD09PXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cz90LnRleHR1cmU6W3QudGV4dHVyZV07Zm9yKGxldCBzPTAsYT1yLmxlbmd0aDtzPGE7cysrKXtjb25zdCBhPXJbc107aWYoeShhLGUpKXtjb25zdCBlPXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ/MzQwNjc6MzU1MyxyPWkuZ2V0KGEpLl9fd2ViZ2xUZXh0dXJlO24uYmluZFRleHR1cmUoZSxyKSx4KGUsYSx0LndpZHRoLHQuaGVpZ2h0KSxuLnVuYmluZFRleHR1cmUoKX19fSx0aGlzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0PWZ1bmN0aW9uKGUpe2lmKGUuaXNXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KWlmKG8pe2NvbnN0IHI9ZS53aWR0aCxzPWUuaGVpZ2h0O2xldCBhPTE2Mzg0O2UuZGVwdGhCdWZmZXImJihhfD0yNTYpLGUuc3RlbmNpbEJ1ZmZlciYmKGF8PTEwMjQpO2NvbnN0IG89aS5nZXQoZSk7bi5iaW5kRnJhbWVidWZmZXIoMzYwMDgsby5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpLG4uYmluZEZyYW1lYnVmZmVyKDM2MDA5LG8uX193ZWJnbEZyYW1lYnVmZmVyKSx0LmJsaXRGcmFtZWJ1ZmZlcigwLDAscixzLDAsMCxyLHMsYSw5NzI4KSxuLmJpbmRGcmFtZWJ1ZmZlcigzNjAwOCxudWxsKSxuLmJpbmRGcmFtZWJ1ZmZlcigzNjAwOSxvLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcil9ZWxzZSBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuXCIpfSx0aGlzLnNhZmVTZXRUZXh0dXJlMkQ9ZnVuY3Rpb24odCxlKXt0JiZ0LmlzV2ViR0xSZW5kZXJUYXJnZXQmJighMT09PU8mJihjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFRleHR1cmVzLnNhZmVTZXRUZXh0dXJlMkQ6IGRvbid0IHVzZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXCIpLE89ITApLHQ9dC50ZXh0dXJlKSxUKHQsZSl9LHRoaXMuc2FmZVNldFRleHR1cmVDdWJlPWZ1bmN0aW9uKHQsZSl7dCYmdC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCYmKCExPT09VSYmKGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMVGV4dHVyZXMuc2FmZVNldFRleHR1cmVDdWJlOiBkb24ndCB1c2UgY3ViZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXCIpLFU9ITApLHQ9dC50ZXh0dXJlKSxFKHQsZSl9fWZ1bmN0aW9uIEJzKHQsZSxuKXtjb25zdCBpPW4uaXNXZWJHTDI7cmV0dXJue2NvbnZlcnQ6ZnVuY3Rpb24odCl7bGV0IG47aWYoMTAwOT09PXQpcmV0dXJuIDUxMjE7aWYoMTAxNz09PXQpcmV0dXJuIDMyODE5O2lmKDEwMTg9PT10KXJldHVybiAzMjgyMDtpZigxMDE5PT09dClyZXR1cm4gMzM2MzU7aWYoMTAxMD09PXQpcmV0dXJuIDUxMjA7aWYoMTAxMT09PXQpcmV0dXJuIDUxMjI7aWYoMTAxMj09PXQpcmV0dXJuIDUxMjM7aWYoMTAxMz09PXQpcmV0dXJuIDUxMjQ7aWYoMTAxND09PXQpcmV0dXJuIDUxMjU7aWYoMTAxNT09PXQpcmV0dXJuIDUxMjY7aWYoMTAxNj09PXQpcmV0dXJuIGk/NTEzMToobj1lLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksbnVsbCE9PW4/bi5IQUxGX0ZMT0FUX09FUzpudWxsKTtpZigxMDIxPT09dClyZXR1cm4gNjQwNjtpZigxMDIyPT09dClyZXR1cm4gNjQwNztpZigxMDIzPT09dClyZXR1cm4gNjQwODtpZigxMDI0PT09dClyZXR1cm4gNjQwOTtpZigxMDI1PT09dClyZXR1cm4gNjQxMDtpZigxMDI2PT09dClyZXR1cm4gNjQwMjtpZigxMDI3PT09dClyZXR1cm4gMzQwNDE7aWYoMTAyOD09PXQpcmV0dXJuIDY0MDM7aWYoMTAyOT09PXQpcmV0dXJuIDM2MjQ0O2lmKDEwMzA9PT10KXJldHVybiAzMzMxOTtpZigxMDMxPT09dClyZXR1cm4gMzMzMjA7aWYoMTAzMj09PXQpcmV0dXJuIDM2MjQ4O2lmKDEwMzM9PT10KXJldHVybiAzNjI0OTtpZigzMzc3Nj09PXR8fDMzNzc3PT09dHx8MzM3Nzg9PT10fHwzMzc3OT09PXQpe2lmKG49ZS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSxudWxsPT09bilyZXR1cm4gbnVsbDtpZigzMzc3Nj09PXQpcmV0dXJuIG4uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtpZigzMzc3Nz09PXQpcmV0dXJuIG4uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7aWYoMzM3Nzg9PT10KXJldHVybiBuLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO2lmKDMzNzc5PT09dClyZXR1cm4gbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVH1pZigzNTg0MD09PXR8fDM1ODQxPT09dHx8MzU4NDI9PT10fHwzNTg0Mz09PXQpe2lmKG49ZS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIiksbnVsbD09PW4pcmV0dXJuIG51bGw7aWYoMzU4NDA9PT10KXJldHVybiBuLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7aWYoMzU4NDE9PT10KXJldHVybiBuLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7aWYoMzU4NDI9PT10KXJldHVybiBuLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO2lmKDM1ODQzPT09dClyZXR1cm4gbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNR31pZigzNjE5Nj09PXQpcmV0dXJuIG49ZS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSxudWxsIT09bj9uLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0w6bnVsbDtpZigoMzc0OTI9PT10fHwzNzQ5Nj09PXQpJiYobj1lLmdldChcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGNcIiksbnVsbCE9PW4pKXtpZigzNzQ5Mj09PXQpcmV0dXJuIG4uQ09NUFJFU1NFRF9SR0I4X0VUQzI7aWYoMzc0OTY9PT10KXJldHVybiBuLkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUN9cmV0dXJuIDM3ODA4PT09dHx8Mzc4MDk9PT10fHwzNzgxMD09PXR8fDM3ODExPT09dHx8Mzc4MTI9PT10fHwzNzgxMz09PXR8fDM3ODE0PT09dHx8Mzc4MTU9PT10fHwzNzgxNj09PXR8fDM3ODE3PT09dHx8Mzc4MTg9PT10fHwzNzgxOT09PXR8fDM3ODIwPT09dHx8Mzc4MjE9PT10fHwzNzg0MD09PXR8fDM3ODQxPT09dHx8Mzc4NDI9PT10fHwzNzg0Mz09PXR8fDM3ODQ0PT09dHx8Mzc4NDU9PT10fHwzNzg0Nj09PXR8fDM3ODQ3PT09dHx8Mzc4NDg9PT10fHwzNzg0OT09PXR8fDM3ODUwPT09dHx8Mzc4NTE9PT10fHwzNzg1Mj09PXR8fDM3ODUzPT09dD8obj1lLmdldChcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjXCIpLG51bGwhPT1uP3Q6bnVsbCk6MzY0OTI9PT10PyhuPWUuZ2V0KFwiRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0Y1wiKSxudWxsIT09bj90Om51bGwpOjEwMjA9PT10P2k/MzQwNDI6KG49ZS5nZXQoXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIpLG51bGwhPT1uP24uVU5TSUdORURfSU5UXzI0XzhfV0VCR0w6bnVsbCk6dm9pZCAwfX19Y2xhc3MgSHMgZXh0ZW5kcyBKbntjb25zdHJ1Y3Rvcih0PVtdKXtzdXBlcigpLHRoaXMuY2FtZXJhcz10fX1Icy5wcm90b3R5cGUuaXNBcnJheUNhbWVyYT0hMDtjbGFzcyBWcyBleHRlbmRzIFZle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJHcm91cFwifX1Wcy5wcm90b3R5cGUuaXNHcm91cD0hMDtjb25zdCBHcz17dHlwZTpcIm1vdmVcIn07Y2xhc3MgV3N7Y29uc3RydWN0b3IoKXt0aGlzLl90YXJnZXRSYXk9bnVsbCx0aGlzLl9ncmlwPW51bGwsdGhpcy5faGFuZD1udWxsfWdldEhhbmRTcGFjZSgpe3JldHVybiBudWxsPT09dGhpcy5faGFuZCYmKHRoaXMuX2hhbmQ9bmV3IFZzLHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZT0hMSx0aGlzLl9oYW5kLnZpc2libGU9ITEsdGhpcy5faGFuZC5qb2ludHM9e30sdGhpcy5faGFuZC5pbnB1dFN0YXRlPXtwaW5jaGluZzohMX0pLHRoaXMuX2hhbmR9Z2V0VGFyZ2V0UmF5U3BhY2UoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3RhcmdldFJheSYmKHRoaXMuX3RhcmdldFJheT1uZXcgVnMsdGhpcy5fdGFyZ2V0UmF5Lm1hdHJpeEF1dG9VcGRhdGU9ITEsdGhpcy5fdGFyZ2V0UmF5LnZpc2libGU9ITEsdGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5PSExLHRoaXMuX3RhcmdldFJheS5saW5lYXJWZWxvY2l0eT1uZXcgQnQsdGhpcy5fdGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSx0aGlzLl90YXJnZXRSYXkuYW5ndWxhclZlbG9jaXR5PW5ldyBCdCksdGhpcy5fdGFyZ2V0UmF5fWdldEdyaXBTcGFjZSgpe3JldHVybiBudWxsPT09dGhpcy5fZ3JpcCYmKHRoaXMuX2dyaXA9bmV3IFZzLHRoaXMuX2dyaXAubWF0cml4QXV0b1VwZGF0ZT0hMSx0aGlzLl9ncmlwLnZpc2libGU9ITEsdGhpcy5fZ3JpcC5oYXNMaW5lYXJWZWxvY2l0eT0hMSx0aGlzLl9ncmlwLmxpbmVhclZlbG9jaXR5PW5ldyBCdCx0aGlzLl9ncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMSx0aGlzLl9ncmlwLmFuZ3VsYXJWZWxvY2l0eT1uZXcgQnQpLHRoaXMuX2dyaXB9ZGlzcGF0Y2hFdmVudCh0KXtyZXR1cm4gbnVsbCE9PXRoaXMuX3RhcmdldFJheSYmdGhpcy5fdGFyZ2V0UmF5LmRpc3BhdGNoRXZlbnQodCksbnVsbCE9PXRoaXMuX2dyaXAmJnRoaXMuX2dyaXAuZGlzcGF0Y2hFdmVudCh0KSxudWxsIT09dGhpcy5faGFuZCYmdGhpcy5faGFuZC5kaXNwYXRjaEV2ZW50KHQpLHRoaXN9ZGlzY29ubmVjdCh0KXtyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZGlzY29ubmVjdGVkXCIsZGF0YTp0fSksbnVsbCE9PXRoaXMuX3RhcmdldFJheSYmKHRoaXMuX3RhcmdldFJheS52aXNpYmxlPSExKSxudWxsIT09dGhpcy5fZ3JpcCYmKHRoaXMuX2dyaXAudmlzaWJsZT0hMSksbnVsbCE9PXRoaXMuX2hhbmQmJih0aGlzLl9oYW5kLnZpc2libGU9ITEpLHRoaXN9dXBkYXRlKHQsZSxuKXtsZXQgaT1udWxsLHI9bnVsbCxzPW51bGw7Y29uc3QgYT10aGlzLl90YXJnZXRSYXksbz10aGlzLl9ncmlwLGw9dGhpcy5faGFuZDtpZih0JiZcInZpc2libGUtYmx1cnJlZFwiIT09ZS5zZXNzaW9uLnZpc2liaWxpdHlTdGF0ZSlpZihudWxsIT09YSYmKGk9ZS5nZXRQb3NlKHQudGFyZ2V0UmF5U3BhY2UsbiksbnVsbCE9PWkmJihhLm1hdHJpeC5mcm9tQXJyYXkoaS50cmFuc2Zvcm0ubWF0cml4KSxhLm1hdHJpeC5kZWNvbXBvc2UoYS5wb3NpdGlvbixhLnJvdGF0aW9uLGEuc2NhbGUpLGkubGluZWFyVmVsb2NpdHk/KGEuaGFzTGluZWFyVmVsb2NpdHk9ITAsYS5saW5lYXJWZWxvY2l0eS5jb3B5KGkubGluZWFyVmVsb2NpdHkpKTphLmhhc0xpbmVhclZlbG9jaXR5PSExLGkuYW5ndWxhclZlbG9jaXR5PyhhLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMCxhLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KGkuYW5ndWxhclZlbG9jaXR5KSk6YS5oYXNBbmd1bGFyVmVsb2NpdHk9ITEsdGhpcy5kaXNwYXRjaEV2ZW50KEdzKSkpLGwmJnQuaGFuZCl7cz0hMDtmb3IoY29uc3QgaSBvZiB0LmhhbmQudmFsdWVzKCkpe2NvbnN0IHQ9ZS5nZXRKb2ludFBvc2UoaSxuKTtpZih2b2lkIDA9PT1sLmpvaW50c1tpLmpvaW50TmFtZV0pe2NvbnN0IHQ9bmV3IFZzO3QubWF0cml4QXV0b1VwZGF0ZT0hMSx0LnZpc2libGU9ITEsbC5qb2ludHNbaS5qb2ludE5hbWVdPXQsbC5hZGQodCl9Y29uc3Qgcj1sLmpvaW50c1tpLmpvaW50TmFtZV07bnVsbCE9PXQmJihyLm1hdHJpeC5mcm9tQXJyYXkodC50cmFuc2Zvcm0ubWF0cml4KSxyLm1hdHJpeC5kZWNvbXBvc2Uoci5wb3NpdGlvbixyLnJvdGF0aW9uLHIuc2NhbGUpLHIuam9pbnRSYWRpdXM9dC5yYWRpdXMpLHIudmlzaWJsZT1udWxsIT09dH1jb25zdCBpPWwuam9pbnRzW1wiaW5kZXgtZmluZ2VyLXRpcFwiXSxyPWwuam9pbnRzW1widGh1bWItdGlwXCJdLGE9aS5wb3NpdGlvbi5kaXN0YW5jZVRvKHIucG9zaXRpb24pLG89LjAyLGM9LjAwNTtsLmlucHV0U3RhdGUucGluY2hpbmcmJmE+bytjPyhsLmlucHV0U3RhdGUucGluY2hpbmc9ITEsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwicGluY2hlbmRcIixoYW5kZWRuZXNzOnQuaGFuZGVkbmVzcyx0YXJnZXQ6dGhpc30pKTohbC5pbnB1dFN0YXRlLnBpbmNoaW5nJiZhPD1vLWMmJihsLmlucHV0U3RhdGUucGluY2hpbmc9ITAsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwicGluY2hzdGFydFwiLGhhbmRlZG5lc3M6dC5oYW5kZWRuZXNzLHRhcmdldDp0aGlzfSkpfWVsc2UgbnVsbCE9PW8mJnQuZ3JpcFNwYWNlJiYocj1lLmdldFBvc2UodC5ncmlwU3BhY2UsbiksbnVsbCE9PXImJihvLm1hdHJpeC5mcm9tQXJyYXkoci50cmFuc2Zvcm0ubWF0cml4KSxvLm1hdHJpeC5kZWNvbXBvc2Uoby5wb3NpdGlvbixvLnJvdGF0aW9uLG8uc2NhbGUpLHIubGluZWFyVmVsb2NpdHk/KG8uaGFzTGluZWFyVmVsb2NpdHk9ITAsby5saW5lYXJWZWxvY2l0eS5jb3B5KHIubGluZWFyVmVsb2NpdHkpKTpvLmhhc0xpbmVhclZlbG9jaXR5PSExLHIuYW5ndWxhclZlbG9jaXR5PyhvLmhhc0FuZ3VsYXJWZWxvY2l0eT0hMCxvLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KHIuYW5ndWxhclZlbG9jaXR5KSk6by5oYXNBbmd1bGFyVmVsb2NpdHk9ITEpKTtyZXR1cm4gbnVsbCE9PWEmJihhLnZpc2libGU9bnVsbCE9PWkpLG51bGwhPT1vJiYoby52aXNpYmxlPW51bGwhPT1yKSxudWxsIT09bCYmKGwudmlzaWJsZT1udWxsIT09cyksdGhpc319Y2xhc3MganMgZXh0ZW5kcyBwdHtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCk7Y29uc3Qgbj10aGlzLGk9dC5zdGF0ZTtsZXQgcj1udWxsLHM9MSxhPW51bGwsbz1cImxvY2FsLWZsb29yXCIsbD1udWxsLGM9bnVsbCxoPW51bGwsdT1udWxsLGQ9bnVsbCxwPSExLG09bnVsbCxmPW51bGwsZz1udWxsLHY9bnVsbCx5PW51bGwseD1udWxsO2NvbnN0IGI9W10sdz1uZXcgTWFwLF89bmV3IEpuO18ubGF5ZXJzLmVuYWJsZSgxKSxfLnZpZXdwb3J0PW5ldyBPdDtjb25zdCBNPW5ldyBKbjtNLmxheWVycy5lbmFibGUoMiksTS52aWV3cG9ydD1uZXcgT3Q7Y29uc3QgUz1bXyxNXSxUPW5ldyBIcztULmxheWVycy5lbmFibGUoMSksVC5sYXllcnMuZW5hYmxlKDIpO2xldCBFPW51bGwsQT1udWxsO2Z1bmN0aW9uIEwodCl7Y29uc3QgZT13LmdldCh0LmlucHV0U291cmNlKTtlJiZlLmRpc3BhdGNoRXZlbnQoe3R5cGU6dC50eXBlLGRhdGE6dC5pbnB1dFNvdXJjZX0pfWZ1bmN0aW9uIFIoKXt3LmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7dC5kaXNjb25uZWN0KGUpfSkpLHcuY2xlYXIoKSxFPW51bGwsQT1udWxsLGkuYmluZFhSRnJhbWVidWZmZXIobnVsbCksdC5zZXRSZW5kZXJUYXJnZXQodC5nZXRSZW5kZXJUYXJnZXQoKSksaCYmZS5kZWxldGVGcmFtZWJ1ZmZlcihoKSxtJiZlLmRlbGV0ZUZyYW1lYnVmZmVyKG0pLGYmJmUuZGVsZXRlUmVuZGVyYnVmZmVyKGYpLGcmJmUuZGVsZXRlUmVuZGVyYnVmZmVyKGcpLGg9bnVsbCxtPW51bGwsZj1udWxsLGc9bnVsbCxkPW51bGwsdT1udWxsLGM9bnVsbCxyPW51bGwsRi5zdG9wKCksbi5pc1ByZXNlbnRpbmc9ITEsbi5kaXNwYXRjaEV2ZW50KHt0eXBlOlwic2Vzc2lvbmVuZFwifSl9ZnVuY3Rpb24gQyh0KXtjb25zdCBlPXIuaW5wdXRTb3VyY2VzO2ZvcihsZXQgdD0wO3Q8Yi5sZW5ndGg7dCsrKXcuc2V0KGVbdF0sYlt0XSk7Zm9yKGxldCBlPTA7ZTx0LnJlbW92ZWQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10LnJlbW92ZWRbZV0saT13LmdldChuKTtpJiYoaS5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZGlzY29ubmVjdGVkXCIsZGF0YTpufSksdy5kZWxldGUobikpfWZvcihsZXQgZT0wO2U8dC5hZGRlZC5sZW5ndGg7ZSsrKXtjb25zdCBuPXQuYWRkZWRbZV0saT13LmdldChuKTtpJiZpLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJjb25uZWN0ZWRcIixkYXRhOm59KX19dGhpcy5jYW1lcmFBdXRvVXBkYXRlPSEwLHRoaXMuZW5hYmxlZD0hMSx0aGlzLmlzUHJlc2VudGluZz0hMSx0aGlzLmdldENvbnRyb2xsZXI9ZnVuY3Rpb24odCl7bGV0IGU9Ylt0XTtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9bmV3IFdzLGJbdF09ZSksZS5nZXRUYXJnZXRSYXlTcGFjZSgpfSx0aGlzLmdldENvbnRyb2xsZXJHcmlwPWZ1bmN0aW9uKHQpe2xldCBlPWJbdF07cmV0dXJuIHZvaWQgMD09PWUmJihlPW5ldyBXcyxiW3RdPWUpLGUuZ2V0R3JpcFNwYWNlKCl9LHRoaXMuZ2V0SGFuZD1mdW5jdGlvbih0KXtsZXQgZT1iW3RdO3JldHVybiB2b2lkIDA9PT1lJiYoZT1uZXcgV3MsYlt0XT1lKSxlLmdldEhhbmRTcGFjZSgpfSx0aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3I9ZnVuY3Rpb24odCl7cz10LCEwPT09bi5pc1ByZXNlbnRpbmcmJmNvbnNvbGUud2FybihcIlRIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzY2FsZSB3aGlsZSBwcmVzZW50aW5nLlwiKX0sdGhpcy5zZXRSZWZlcmVuY2VTcGFjZVR5cGU9ZnVuY3Rpb24odCl7bz10LCEwPT09bi5pc1ByZXNlbnRpbmcmJmNvbnNvbGUud2FybihcIlRIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSByZWZlcmVuY2Ugc3BhY2UgdHlwZSB3aGlsZSBwcmVzZW50aW5nLlwiKX0sdGhpcy5nZXRSZWZlcmVuY2VTcGFjZT1mdW5jdGlvbigpe3JldHVybiBhfSx0aGlzLmdldEJhc2VMYXllcj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dT91OmR9LHRoaXMuZ2V0QmluZGluZz1mdW5jdGlvbigpe3JldHVybiBjfSx0aGlzLmdldEZyYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHZ9LHRoaXMuZ2V0U2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybiByfSx0aGlzLnNldFNlc3Npb249YXN5bmMgZnVuY3Rpb24odCl7aWYocj10LG51bGwhPT1yKXtyLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RcIixMKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLEwpLHIuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGVuZFwiLEwpLHIuYWRkRXZlbnRMaXN0ZW5lcihcInNxdWVlemVcIixMKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJzcXVlZXplc3RhcnRcIixMKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJzcXVlZXplZW5kXCIsTCksci5hZGRFdmVudExpc3RlbmVyKFwiZW5kXCIsUiksci5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRzb3VyY2VzY2hhbmdlXCIsQyk7Y29uc3QgdD1lLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7aWYoITAhPT10LnhyQ29tcGF0aWJsZSYmYXdhaXQgZS5tYWtlWFJDb21wYXRpYmxlKCksdm9pZCAwPT09ci5yZW5kZXJTdGF0ZS5sYXllcnMpe2NvbnN0IG49e2FudGlhbGlhczp0LmFudGlhbGlhcyxhbHBoYTp0LmFscGhhLGRlcHRoOnQuZGVwdGgsc3RlbmNpbDp0LnN0ZW5jaWwsZnJhbWVidWZmZXJTY2FsZUZhY3RvcjpzfTtkPW5ldyBYUldlYkdMTGF5ZXIocixlLG4pLHIudXBkYXRlUmVuZGVyU3RhdGUoe2Jhc2VMYXllcjpkfSl9ZWxzZSBpZihlIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KXtjb25zdCBuPXthbnRpYWxpYXM6ITAsYWxwaGE6dC5hbHBoYSxkZXB0aDp0LmRlcHRoLHN0ZW5jaWw6dC5zdGVuY2lsLGZyYW1lYnVmZmVyU2NhbGVGYWN0b3I6c307ZD1uZXcgWFJXZWJHTExheWVyKHIsZSxuKSxyLnVwZGF0ZVJlbmRlclN0YXRlKHtsYXllcnM6W2RdfSl9ZWxzZXtwPXQuYW50aWFsaWFzO2xldCBuPW51bGw7dC5kZXB0aCYmKHg9MjU2LHQuc3RlbmNpbCYmKHh8PTEwMjQpLHk9dC5zdGVuY2lsPzMzMzA2OjM2MDk2LG49dC5zdGVuY2lsPzM1MDU2OjMzMTkwKTtjb25zdCBhPXtjb2xvckZvcm1hdDp0LmFscGhhPzMyODU2OjMyODQ5LGRlcHRoRm9ybWF0Om4sc2NhbGVGYWN0b3I6c307Yz1uZXcgWFJXZWJHTEJpbmRpbmcocixlKSx1PWMuY3JlYXRlUHJvamVjdGlvbkxheWVyKGEpLGg9ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpLHIudXBkYXRlUmVuZGVyU3RhdGUoe2xheWVyczpbdV19KSxwJiYobT1lLmNyZWF0ZUZyYW1lYnVmZmVyKCksZj1lLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLGUuYmluZFJlbmRlcmJ1ZmZlcigzNjE2MSxmKSxlLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSgzNjE2MSw0LDMyODU2LHUudGV4dHVyZVdpZHRoLHUudGV4dHVyZUhlaWdodCksaS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsbSksZS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcigzNjE2MCwzNjA2NCwzNjE2MSxmKSxlLmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsbnVsbCksbnVsbCE9PW4mJihnPWUuY3JlYXRlUmVuZGVyYnVmZmVyKCksZS5iaW5kUmVuZGVyYnVmZmVyKDM2MTYxLGcpLGUucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKDM2MTYxLDQsbix1LnRleHR1cmVXaWR0aCx1LnRleHR1cmVIZWlnaHQpLGUuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoMzYxNjAseSwzNjE2MSxnKSxlLmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsbnVsbCkpLGkuYmluZEZyYW1lYnVmZmVyKDM2MTYwLG51bGwpKX1hPWF3YWl0IHIucmVxdWVzdFJlZmVyZW5jZVNwYWNlKG8pLEYuc2V0Q29udGV4dChyKSxGLnN0YXJ0KCksbi5pc1ByZXNlbnRpbmc9ITAsbi5kaXNwYXRjaEV2ZW50KHt0eXBlOlwic2Vzc2lvbnN0YXJ0XCJ9KX19O2NvbnN0IFA9bmV3IEJ0LEk9bmV3IEJ0O2Z1bmN0aW9uIEQodCxlKXtudWxsPT09ZT90Lm1hdHJpeFdvcmxkLmNvcHkodC5tYXRyaXgpOnQubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhlLm1hdHJpeFdvcmxkLHQubWF0cml4KSx0Lm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KHQubWF0cml4V29ybGQpLmludmVydCgpfXRoaXMudXBkYXRlQ2FtZXJhPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT1yKXJldHVybjtULm5lYXI9TS5uZWFyPV8ubmVhcj10Lm5lYXIsVC5mYXI9TS5mYXI9Xy5mYXI9dC5mYXIsRT09PVQubmVhciYmQT09PVQuZmFyfHwoci51cGRhdGVSZW5kZXJTdGF0ZSh7ZGVwdGhOZWFyOlQubmVhcixkZXB0aEZhcjpULmZhcn0pLEU9VC5uZWFyLEE9VC5mYXIpO2NvbnN0IGU9dC5wYXJlbnQsbj1ULmNhbWVyYXM7RChULGUpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKUQoblt0XSxlKTtULm1hdHJpeFdvcmxkLmRlY29tcG9zZShULnBvc2l0aW9uLFQucXVhdGVybmlvbixULnNjYWxlKSx0LnBvc2l0aW9uLmNvcHkoVC5wb3NpdGlvbiksdC5xdWF0ZXJuaW9uLmNvcHkoVC5xdWF0ZXJuaW9uKSx0LnNjYWxlLmNvcHkoVC5zY2FsZSksdC5tYXRyaXguY29weShULm1hdHJpeCksdC5tYXRyaXhXb3JsZC5jb3B5KFQubWF0cml4V29ybGQpO2NvbnN0IGk9dC5jaGlsZHJlbjtmb3IobGV0IHQ9MCxlPWkubGVuZ3RoO3Q8ZTt0KyspaVt0XS51cGRhdGVNYXRyaXhXb3JsZCghMCk7Mj09PW4ubGVuZ3RoP2Z1bmN0aW9uKHQsZSxuKXtQLnNldEZyb21NYXRyaXhQb3NpdGlvbihlLm1hdHJpeFdvcmxkKSxJLnNldEZyb21NYXRyaXhQb3NpdGlvbihuLm1hdHJpeFdvcmxkKTtjb25zdCBpPVAuZGlzdGFuY2VUbyhJKSxyPWUucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyxzPW4ucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyxhPXJbMTRdLyhyWzEwXS0xKSxvPXJbMTRdLyhyWzEwXSsxKSxsPShyWzldKzEpL3JbNV0sYz0ocls5XS0xKS9yWzVdLGg9KHJbOF0tMSkvclswXSx1PShzWzhdKzEpL3NbMF0sZD1hKmgscD1hKnUsbT1pLygtaCt1KSxmPW0qLWg7ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UodC5wb3NpdGlvbix0LnF1YXRlcm5pb24sdC5zY2FsZSksdC50cmFuc2xhdGVYKGYpLHQudHJhbnNsYXRlWihtKSx0Lm1hdHJpeFdvcmxkLmNvbXBvc2UodC5wb3NpdGlvbix0LnF1YXRlcm5pb24sdC5zY2FsZSksdC5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtjb25zdCBnPWErbSx2PW8rbSx5PWQtZix4PXArKGktZiksYj1sKm8vdipnLHc9YypvL3YqZzt0LnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKHkseCxiLHcsZyx2KX0oVCxfLE0pOlQucHJvamVjdGlvbk1hdHJpeC5jb3B5KF8ucHJvamVjdGlvbk1hdHJpeCl9LHRoaXMuZ2V0Q2FtZXJhPWZ1bmN0aW9uKCl7cmV0dXJuIFR9LHRoaXMuZ2V0Rm92ZWF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT11P3UuZml4ZWRGb3ZlYXRpb246bnVsbCE9PWQ/ZC5maXhlZEZvdmVhdGlvbjp2b2lkIDB9LHRoaXMuc2V0Rm92ZWF0aW9uPWZ1bmN0aW9uKHQpe251bGwhPT11JiYodS5maXhlZEZvdmVhdGlvbj10KSxudWxsIT09ZCYmdm9pZCAwIT09ZC5maXhlZEZvdmVhdGlvbiYmKGQuZml4ZWRGb3ZlYXRpb249dCl9O2xldCBOPW51bGw7Y29uc3QgRj1uZXcgb2k7Ri5zZXRBbmltYXRpb25Mb29wKChmdW5jdGlvbih0LG4pe2lmKGw9bi5nZXRWaWV3ZXJQb3NlKGEpLHY9bixudWxsIT09bCl7Y29uc3QgdD1sLnZpZXdzO251bGwhPT1kJiZpLmJpbmRYUkZyYW1lYnVmZmVyKGQuZnJhbWVidWZmZXIpO2xldCBuPSExO3QubGVuZ3RoIT09VC5jYW1lcmFzLmxlbmd0aCYmKFQuY2FtZXJhcy5sZW5ndGg9MCxuPSEwKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3Qgcz10W3JdO2xldCBhPW51bGw7aWYobnVsbCE9PWQpYT1kLmdldFZpZXdwb3J0KHMpO2Vsc2V7Y29uc3QgdD1jLmdldFZpZXdTdWJJbWFnZSh1LHMpO2kuYmluZFhSRnJhbWVidWZmZXIoaCksdm9pZCAwIT09dC5kZXB0aFN0ZW5jaWxUZXh0dXJlJiZlLmZyYW1lYnVmZmVyVGV4dHVyZTJEKDM2MTYwLHksMzU1Myx0LmRlcHRoU3RlbmNpbFRleHR1cmUsMCksZS5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCwzNjA2NCwzNTUzLHQuY29sb3JUZXh0dXJlLDApLGE9dC52aWV3cG9ydH1jb25zdCBvPVNbcl07by5tYXRyaXguZnJvbUFycmF5KHMudHJhbnNmb3JtLm1hdHJpeCksby5wcm9qZWN0aW9uTWF0cml4LmZyb21BcnJheShzLnByb2plY3Rpb25NYXRyaXgpLG8udmlld3BvcnQuc2V0KGEueCxhLnksYS53aWR0aCxhLmhlaWdodCksMD09PXImJlQubWF0cml4LmNvcHkoby5tYXRyaXgpLCEwPT09biYmVC5jYW1lcmFzLnB1c2gobyl9cCYmKGkuYmluZFhSRnJhbWVidWZmZXIobSksbnVsbCE9PXgmJmUuY2xlYXIoeCkpfWNvbnN0IHM9ci5pbnB1dFNvdXJjZXM7Zm9yKGxldCB0PTA7dDxiLmxlbmd0aDt0Kyspe2NvbnN0IGU9Ylt0XSxpPXNbdF07ZS51cGRhdGUoaSxuLGEpfWlmKE4mJk4odCxuKSxwKXtjb25zdCB0PXUudGV4dHVyZVdpZHRoLG49dS50ZXh0dXJlSGVpZ2h0O2kuYmluZEZyYW1lYnVmZmVyKDM2MDA4LG0pLGkuYmluZEZyYW1lYnVmZmVyKDM2MDA5LGgpLGUuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKDM2MDA4LFt5XSksZS5pbnZhbGlkYXRlRnJhbWVidWZmZXIoMzYwMDksW3ldKSxlLmJsaXRGcmFtZWJ1ZmZlcigwLDAsdCxuLDAsMCx0LG4sMTYzODQsOTcyOCksZS5pbnZhbGlkYXRlRnJhbWVidWZmZXIoMzYwMDgsWzM2MDY0XSksaS5iaW5kRnJhbWVidWZmZXIoMzYwMDgsbnVsbCksaS5iaW5kRnJhbWVidWZmZXIoMzYwMDksbnVsbCksaS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsbSl9dj1udWxsfSkpLHRoaXMuc2V0QW5pbWF0aW9uTG9vcD1mdW5jdGlvbih0KXtOPXR9LHRoaXMuZGlzcG9zZT1mdW5jdGlvbigpe319fWZ1bmN0aW9uIHFzKHQpe2Z1bmN0aW9uIGUoZSxuKXtlLm9wYWNpdHkudmFsdWU9bi5vcGFjaXR5LG4uY29sb3ImJmUuZGlmZnVzZS52YWx1ZS5jb3B5KG4uY29sb3IpLG4uZW1pc3NpdmUmJmUuZW1pc3NpdmUudmFsdWUuY29weShuLmVtaXNzaXZlKS5tdWx0aXBseVNjYWxhcihuLmVtaXNzaXZlSW50ZW5zaXR5KSxuLm1hcCYmKGUubWFwLnZhbHVlPW4ubWFwKSxuLmFscGhhTWFwJiYoZS5hbHBoYU1hcC52YWx1ZT1uLmFscGhhTWFwKSxuLnNwZWN1bGFyTWFwJiYoZS5zcGVjdWxhck1hcC52YWx1ZT1uLnNwZWN1bGFyTWFwKSxuLmFscGhhVGVzdD4wJiYoZS5hbHBoYVRlc3QudmFsdWU9bi5hbHBoYVRlc3QpO2NvbnN0IGk9dC5nZXQobikuZW52TWFwO2lmKGkpe2UuZW52TWFwLnZhbHVlPWksZS5mbGlwRW52TWFwLnZhbHVlPWkuaXNDdWJlVGV4dHVyZSYmITE9PT1pLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT8tMToxLGUucmVmbGVjdGl2aXR5LnZhbHVlPW4ucmVmbGVjdGl2aXR5LGUuaW9yLnZhbHVlPW4uaW9yLGUucmVmcmFjdGlvblJhdGlvLnZhbHVlPW4ucmVmcmFjdGlvblJhdGlvO2NvbnN0IHI9dC5nZXQoaSkuX19tYXhNaXBMZXZlbDt2b2lkIDAhPT1yJiYoZS5tYXhNaXBMZXZlbC52YWx1ZT1yKX1sZXQgcixzO24ubGlnaHRNYXAmJihlLmxpZ2h0TWFwLnZhbHVlPW4ubGlnaHRNYXAsZS5saWdodE1hcEludGVuc2l0eS52YWx1ZT1uLmxpZ2h0TWFwSW50ZW5zaXR5KSxuLmFvTWFwJiYoZS5hb01hcC52YWx1ZT1uLmFvTWFwLGUuYW9NYXBJbnRlbnNpdHkudmFsdWU9bi5hb01hcEludGVuc2l0eSksbi5tYXA/cj1uLm1hcDpuLnNwZWN1bGFyTWFwP3I9bi5zcGVjdWxhck1hcDpuLmRpc3BsYWNlbWVudE1hcD9yPW4uZGlzcGxhY2VtZW50TWFwOm4ubm9ybWFsTWFwP3I9bi5ub3JtYWxNYXA6bi5idW1wTWFwP3I9bi5idW1wTWFwOm4ucm91Z2huZXNzTWFwP3I9bi5yb3VnaG5lc3NNYXA6bi5tZXRhbG5lc3NNYXA/cj1uLm1ldGFsbmVzc01hcDpuLmFscGhhTWFwP3I9bi5hbHBoYU1hcDpuLmVtaXNzaXZlTWFwP3I9bi5lbWlzc2l2ZU1hcDpuLmNsZWFyY29hdE1hcD9yPW4uY2xlYXJjb2F0TWFwOm4uY2xlYXJjb2F0Tm9ybWFsTWFwP3I9bi5jbGVhcmNvYXROb3JtYWxNYXA6bi5jbGVhcmNvYXRSb3VnaG5lc3NNYXA/cj1uLmNsZWFyY29hdFJvdWdobmVzc01hcDpuLnNwZWN1bGFySW50ZW5zaXR5TWFwP3I9bi5zcGVjdWxhckludGVuc2l0eU1hcDpuLnNwZWN1bGFyVGludE1hcD9yPW4uc3BlY3VsYXJUaW50TWFwOm4udHJhbnNtaXNzaW9uTWFwP3I9bi50cmFuc21pc3Npb25NYXA6bi50aGlja25lc3NNYXAmJihyPW4udGhpY2tuZXNzTWFwKSx2b2lkIDAhPT1yJiYoci5pc1dlYkdMUmVuZGVyVGFyZ2V0JiYocj1yLnRleHR1cmUpLCEwPT09ci5tYXRyaXhBdXRvVXBkYXRlJiZyLnVwZGF0ZU1hdHJpeCgpLGUudXZUcmFuc2Zvcm0udmFsdWUuY29weShyLm1hdHJpeCkpLG4uYW9NYXA/cz1uLmFvTWFwOm4ubGlnaHRNYXAmJihzPW4ubGlnaHRNYXApLHZvaWQgMCE9PXMmJihzLmlzV2ViR0xSZW5kZXJUYXJnZXQmJihzPXMudGV4dHVyZSksITA9PT1zLm1hdHJpeEF1dG9VcGRhdGUmJnMudXBkYXRlTWF0cml4KCksZS51djJUcmFuc2Zvcm0udmFsdWUuY29weShzLm1hdHJpeCkpfWZ1bmN0aW9uIG4oZSxuKXtlLnJvdWdobmVzcy52YWx1ZT1uLnJvdWdobmVzcyxlLm1ldGFsbmVzcy52YWx1ZT1uLm1ldGFsbmVzcyxuLnJvdWdobmVzc01hcCYmKGUucm91Z2huZXNzTWFwLnZhbHVlPW4ucm91Z2huZXNzTWFwKSxuLm1ldGFsbmVzc01hcCYmKGUubWV0YWxuZXNzTWFwLnZhbHVlPW4ubWV0YWxuZXNzTWFwKSxuLmVtaXNzaXZlTWFwJiYoZS5lbWlzc2l2ZU1hcC52YWx1ZT1uLmVtaXNzaXZlTWFwKSxuLmJ1bXBNYXAmJihlLmJ1bXBNYXAudmFsdWU9bi5idW1wTWFwLGUuYnVtcFNjYWxlLnZhbHVlPW4uYnVtcFNjYWxlLDE9PT1uLnNpZGUmJihlLmJ1bXBTY2FsZS52YWx1ZSo9LTEpKSxuLm5vcm1hbE1hcCYmKGUubm9ybWFsTWFwLnZhbHVlPW4ubm9ybWFsTWFwLGUubm9ybWFsU2NhbGUudmFsdWUuY29weShuLm5vcm1hbFNjYWxlKSwxPT09bi5zaWRlJiZlLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKSxuLmRpc3BsYWNlbWVudE1hcCYmKGUuZGlzcGxhY2VtZW50TWFwLnZhbHVlPW4uZGlzcGxhY2VtZW50TWFwLGUuZGlzcGxhY2VtZW50U2NhbGUudmFsdWU9bi5kaXNwbGFjZW1lbnRTY2FsZSxlLmRpc3BsYWNlbWVudEJpYXMudmFsdWU9bi5kaXNwbGFjZW1lbnRCaWFzKTt0LmdldChuKS5lbnZNYXAmJihlLmVudk1hcEludGVuc2l0eS52YWx1ZT1uLmVudk1hcEludGVuc2l0eSl9cmV0dXJue3JlZnJlc2hGb2dVbmlmb3JtczpmdW5jdGlvbih0LGUpe3QuZm9nQ29sb3IudmFsdWUuY29weShlLmNvbG9yKSxlLmlzRm9nPyh0LmZvZ05lYXIudmFsdWU9ZS5uZWFyLHQuZm9nRmFyLnZhbHVlPWUuZmFyKTplLmlzRm9nRXhwMiYmKHQuZm9nRGVuc2l0eS52YWx1ZT1lLmRlbnNpdHkpfSxyZWZyZXNoTWF0ZXJpYWxVbmlmb3JtczpmdW5jdGlvbih0LGkscixzLGEpe2kuaXNNZXNoQmFzaWNNYXRlcmlhbD9lKHQsaSk6aS5pc01lc2hMYW1iZXJ0TWF0ZXJpYWw/KGUodCxpKSxmdW5jdGlvbih0LGUpe2UuZW1pc3NpdmVNYXAmJih0LmVtaXNzaXZlTWFwLnZhbHVlPWUuZW1pc3NpdmVNYXApfSh0LGkpKTppLmlzTWVzaFRvb25NYXRlcmlhbD8oZSh0LGkpLGZ1bmN0aW9uKHQsZSl7ZS5ncmFkaWVudE1hcCYmKHQuZ3JhZGllbnRNYXAudmFsdWU9ZS5ncmFkaWVudE1hcCk7ZS5lbWlzc2l2ZU1hcCYmKHQuZW1pc3NpdmVNYXAudmFsdWU9ZS5lbWlzc2l2ZU1hcCk7ZS5idW1wTWFwJiYodC5idW1wTWFwLnZhbHVlPWUuYnVtcE1hcCx0LmJ1bXBTY2FsZS52YWx1ZT1lLmJ1bXBTY2FsZSwxPT09ZS5zaWRlJiYodC5idW1wU2NhbGUudmFsdWUqPS0xKSk7ZS5ub3JtYWxNYXAmJih0Lm5vcm1hbE1hcC52YWx1ZT1lLm5vcm1hbE1hcCx0Lm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoZS5ub3JtYWxTY2FsZSksMT09PWUuc2lkZSYmdC5ub3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKSk7ZS5kaXNwbGFjZW1lbnRNYXAmJih0LmRpc3BsYWNlbWVudE1hcC52YWx1ZT1lLmRpc3BsYWNlbWVudE1hcCx0LmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlPWUuZGlzcGxhY2VtZW50U2NhbGUsdC5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlPWUuZGlzcGxhY2VtZW50Qmlhcyl9KHQsaSkpOmkuaXNNZXNoUGhvbmdNYXRlcmlhbD8oZSh0LGkpLGZ1bmN0aW9uKHQsZSl7dC5zcGVjdWxhci52YWx1ZS5jb3B5KGUuc3BlY3VsYXIpLHQuc2hpbmluZXNzLnZhbHVlPU1hdGgubWF4KGUuc2hpbmluZXNzLDFlLTQpLGUuZW1pc3NpdmVNYXAmJih0LmVtaXNzaXZlTWFwLnZhbHVlPWUuZW1pc3NpdmVNYXApO2UuYnVtcE1hcCYmKHQuYnVtcE1hcC52YWx1ZT1lLmJ1bXBNYXAsdC5idW1wU2NhbGUudmFsdWU9ZS5idW1wU2NhbGUsMT09PWUuc2lkZSYmKHQuYnVtcFNjYWxlLnZhbHVlKj0tMSkpO2Uubm9ybWFsTWFwJiYodC5ub3JtYWxNYXAudmFsdWU9ZS5ub3JtYWxNYXAsdC5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KGUubm9ybWFsU2NhbGUpLDE9PT1lLnNpZGUmJnQubm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCkpO2UuZGlzcGxhY2VtZW50TWFwJiYodC5kaXNwbGFjZW1lbnRNYXAudmFsdWU9ZS5kaXNwbGFjZW1lbnRNYXAsdC5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZT1lLmRpc3BsYWNlbWVudFNjYWxlLHQuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZT1lLmRpc3BsYWNlbWVudEJpYXMpfSh0LGkpKTppLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/KGUodCxpKSxpLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWw/ZnVuY3Rpb24odCxlLGkpe24odCxlKSx0Lmlvci52YWx1ZT1lLmlvcixlLnNoZWVuPjAmJih0LnNoZWVuVGludC52YWx1ZS5jb3B5KGUuc2hlZW5UaW50KS5tdWx0aXBseVNjYWxhcihlLnNoZWVuKSx0LnNoZWVuUm91Z2huZXNzLnZhbHVlPWUuc2hlZW5Sb3VnaG5lc3MpO2UuY2xlYXJjb2F0PjAmJih0LmNsZWFyY29hdC52YWx1ZT1lLmNsZWFyY29hdCx0LmNsZWFyY29hdFJvdWdobmVzcy52YWx1ZT1lLmNsZWFyY29hdFJvdWdobmVzcyxlLmNsZWFyY29hdE1hcCYmKHQuY2xlYXJjb2F0TWFwLnZhbHVlPWUuY2xlYXJjb2F0TWFwKSxlLmNsZWFyY29hdFJvdWdobmVzc01hcCYmKHQuY2xlYXJjb2F0Um91Z2huZXNzTWFwLnZhbHVlPWUuY2xlYXJjb2F0Um91Z2huZXNzTWFwKSxlLmNsZWFyY29hdE5vcm1hbE1hcCYmKHQuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUuY29weShlLmNsZWFyY29hdE5vcm1hbFNjYWxlKSx0LmNsZWFyY29hdE5vcm1hbE1hcC52YWx1ZT1lLmNsZWFyY29hdE5vcm1hbE1hcCwxPT09ZS5zaWRlJiZ0LmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKSk7ZS50cmFuc21pc3Npb24+MCYmKHQudHJhbnNtaXNzaW9uLnZhbHVlPWUudHJhbnNtaXNzaW9uLHQudHJhbnNtaXNzaW9uU2FtcGxlck1hcC52YWx1ZT1pLnRleHR1cmUsdC50cmFuc21pc3Npb25TYW1wbGVyU2l6ZS52YWx1ZS5zZXQoaS53aWR0aCxpLmhlaWdodCksZS50cmFuc21pc3Npb25NYXAmJih0LnRyYW5zbWlzc2lvbk1hcC52YWx1ZT1lLnRyYW5zbWlzc2lvbk1hcCksdC50aGlja25lc3MudmFsdWU9ZS50aGlja25lc3MsZS50aGlja25lc3NNYXAmJih0LnRoaWNrbmVzc01hcC52YWx1ZT1lLnRoaWNrbmVzc01hcCksdC5hdHRlbnVhdGlvbkRpc3RhbmNlLnZhbHVlPWUuYXR0ZW51YXRpb25EaXN0YW5jZSx0LmF0dGVudWF0aW9uVGludC52YWx1ZS5jb3B5KGUuYXR0ZW51YXRpb25UaW50KSk7dC5zcGVjdWxhckludGVuc2l0eS52YWx1ZT1lLnNwZWN1bGFySW50ZW5zaXR5LHQuc3BlY3VsYXJUaW50LnZhbHVlLmNvcHkoZS5zcGVjdWxhclRpbnQpLGUuc3BlY3VsYXJJbnRlbnNpdHlNYXAmJih0LnNwZWN1bGFySW50ZW5zaXR5TWFwLnZhbHVlPWUuc3BlY3VsYXJJbnRlbnNpdHlNYXApO2Uuc3BlY3VsYXJUaW50TWFwJiYodC5zcGVjdWxhclRpbnRNYXAudmFsdWU9ZS5zcGVjdWxhclRpbnRNYXApfSh0LGksYSk6bih0LGkpKTppLmlzTWVzaE1hdGNhcE1hdGVyaWFsPyhlKHQsaSksZnVuY3Rpb24odCxlKXtlLm1hdGNhcCYmKHQubWF0Y2FwLnZhbHVlPWUubWF0Y2FwKTtlLmJ1bXBNYXAmJih0LmJ1bXBNYXAudmFsdWU9ZS5idW1wTWFwLHQuYnVtcFNjYWxlLnZhbHVlPWUuYnVtcFNjYWxlLDE9PT1lLnNpZGUmJih0LmJ1bXBTY2FsZS52YWx1ZSo9LTEpKTtlLm5vcm1hbE1hcCYmKHQubm9ybWFsTWFwLnZhbHVlPWUubm9ybWFsTWFwLHQubm9ybWFsU2NhbGUudmFsdWUuY29weShlLm5vcm1hbFNjYWxlKSwxPT09ZS5zaWRlJiZ0Lm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKTtlLmRpc3BsYWNlbWVudE1hcCYmKHQuZGlzcGxhY2VtZW50TWFwLnZhbHVlPWUuZGlzcGxhY2VtZW50TWFwLHQuZGlzcGxhY2VtZW50U2NhbGUudmFsdWU9ZS5kaXNwbGFjZW1lbnRTY2FsZSx0LmRpc3BsYWNlbWVudEJpYXMudmFsdWU9ZS5kaXNwbGFjZW1lbnRCaWFzKX0odCxpKSk6aS5pc01lc2hEZXB0aE1hdGVyaWFsPyhlKHQsaSksZnVuY3Rpb24odCxlKXtlLmRpc3BsYWNlbWVudE1hcCYmKHQuZGlzcGxhY2VtZW50TWFwLnZhbHVlPWUuZGlzcGxhY2VtZW50TWFwLHQuZGlzcGxhY2VtZW50U2NhbGUudmFsdWU9ZS5kaXNwbGFjZW1lbnRTY2FsZSx0LmRpc3BsYWNlbWVudEJpYXMudmFsdWU9ZS5kaXNwbGFjZW1lbnRCaWFzKX0odCxpKSk6aS5pc01lc2hEaXN0YW5jZU1hdGVyaWFsPyhlKHQsaSksZnVuY3Rpb24odCxlKXtlLmRpc3BsYWNlbWVudE1hcCYmKHQuZGlzcGxhY2VtZW50TWFwLnZhbHVlPWUuZGlzcGxhY2VtZW50TWFwLHQuZGlzcGxhY2VtZW50U2NhbGUudmFsdWU9ZS5kaXNwbGFjZW1lbnRTY2FsZSx0LmRpc3BsYWNlbWVudEJpYXMudmFsdWU9ZS5kaXNwbGFjZW1lbnRCaWFzKTt0LnJlZmVyZW5jZVBvc2l0aW9uLnZhbHVlLmNvcHkoZS5yZWZlcmVuY2VQb3NpdGlvbiksdC5uZWFyRGlzdGFuY2UudmFsdWU9ZS5uZWFyRGlzdGFuY2UsdC5mYXJEaXN0YW5jZS52YWx1ZT1lLmZhckRpc3RhbmNlfSh0LGkpKTppLmlzTWVzaE5vcm1hbE1hdGVyaWFsPyhlKHQsaSksZnVuY3Rpb24odCxlKXtlLmJ1bXBNYXAmJih0LmJ1bXBNYXAudmFsdWU9ZS5idW1wTWFwLHQuYnVtcFNjYWxlLnZhbHVlPWUuYnVtcFNjYWxlLDE9PT1lLnNpZGUmJih0LmJ1bXBTY2FsZS52YWx1ZSo9LTEpKTtlLm5vcm1hbE1hcCYmKHQubm9ybWFsTWFwLnZhbHVlPWUubm9ybWFsTWFwLHQubm9ybWFsU2NhbGUudmFsdWUuY29weShlLm5vcm1hbFNjYWxlKSwxPT09ZS5zaWRlJiZ0Lm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpKTtlLmRpc3BsYWNlbWVudE1hcCYmKHQuZGlzcGxhY2VtZW50TWFwLnZhbHVlPWUuZGlzcGxhY2VtZW50TWFwLHQuZGlzcGxhY2VtZW50U2NhbGUudmFsdWU9ZS5kaXNwbGFjZW1lbnRTY2FsZSx0LmRpc3BsYWNlbWVudEJpYXMudmFsdWU9ZS5kaXNwbGFjZW1lbnRCaWFzKX0odCxpKSk6aS5pc0xpbmVCYXNpY01hdGVyaWFsPyhmdW5jdGlvbih0LGUpe3QuZGlmZnVzZS52YWx1ZS5jb3B5KGUuY29sb3IpLHQub3BhY2l0eS52YWx1ZT1lLm9wYWNpdHl9KHQsaSksaS5pc0xpbmVEYXNoZWRNYXRlcmlhbCYmZnVuY3Rpb24odCxlKXt0LmRhc2hTaXplLnZhbHVlPWUuZGFzaFNpemUsdC50b3RhbFNpemUudmFsdWU9ZS5kYXNoU2l6ZStlLmdhcFNpemUsdC5zY2FsZS52YWx1ZT1lLnNjYWxlfSh0LGkpKTppLmlzUG9pbnRzTWF0ZXJpYWw/ZnVuY3Rpb24odCxlLG4saSl7dC5kaWZmdXNlLnZhbHVlLmNvcHkoZS5jb2xvciksdC5vcGFjaXR5LnZhbHVlPWUub3BhY2l0eSx0LnNpemUudmFsdWU9ZS5zaXplKm4sdC5zY2FsZS52YWx1ZT0uNSppLGUubWFwJiYodC5tYXAudmFsdWU9ZS5tYXApO2UuYWxwaGFNYXAmJih0LmFscGhhTWFwLnZhbHVlPWUuYWxwaGFNYXApO2UuYWxwaGFUZXN0PjAmJih0LmFscGhhVGVzdC52YWx1ZT1lLmFscGhhVGVzdCk7bGV0IHI7ZS5tYXA/cj1lLm1hcDplLmFscGhhTWFwJiYocj1lLmFscGhhTWFwKTt2b2lkIDAhPT1yJiYoITA9PT1yLm1hdHJpeEF1dG9VcGRhdGUmJnIudXBkYXRlTWF0cml4KCksdC51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KHIubWF0cml4KSl9KHQsaSxyLHMpOmkuaXNTcHJpdGVNYXRlcmlhbD9mdW5jdGlvbih0LGUpe3QuZGlmZnVzZS52YWx1ZS5jb3B5KGUuY29sb3IpLHQub3BhY2l0eS52YWx1ZT1lLm9wYWNpdHksdC5yb3RhdGlvbi52YWx1ZT1lLnJvdGF0aW9uLGUubWFwJiYodC5tYXAudmFsdWU9ZS5tYXApO2UuYWxwaGFNYXAmJih0LmFscGhhTWFwLnZhbHVlPWUuYWxwaGFNYXApO2UuYWxwaGFUZXN0PjAmJih0LmFscGhhVGVzdC52YWx1ZT1lLmFscGhhVGVzdCk7bGV0IG47ZS5tYXA/bj1lLm1hcDplLmFscGhhTWFwJiYobj1lLmFscGhhTWFwKTt2b2lkIDAhPT1uJiYoITA9PT1uLm1hdHJpeEF1dG9VcGRhdGUmJm4udXBkYXRlTWF0cml4KCksdC51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KG4ubWF0cml4KSl9KHQsaSk6aS5pc1NoYWRvd01hdGVyaWFsPyh0LmNvbG9yLnZhbHVlLmNvcHkoaS5jb2xvciksdC5vcGFjaXR5LnZhbHVlPWkub3BhY2l0eSk6aS5pc1NoYWRlck1hdGVyaWFsJiYoaS51bmlmb3Jtc05lZWRVcGRhdGU9ITEpfX19ZnVuY3Rpb24gWHModD17fSl7Y29uc3QgZT12b2lkIDAhPT10LmNhbnZhcz90LmNhbnZhczpmdW5jdGlvbigpe2NvbnN0IHQ9Q3QoXCJjYW52YXNcIik7cmV0dXJuIHQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdH0oKSxuPXZvaWQgMCE9PXQuY29udGV4dD90LmNvbnRleHQ6bnVsbCxpPXZvaWQgMCE9PXQuYWxwaGEmJnQuYWxwaGEscj12b2lkIDA9PT10LmRlcHRofHx0LmRlcHRoLHM9dm9pZCAwPT09dC5zdGVuY2lsfHx0LnN0ZW5jaWwsYT12b2lkIDAhPT10LmFudGlhbGlhcyYmdC5hbnRpYWxpYXMsbz12b2lkIDA9PT10LnByZW11bHRpcGxpZWRBbHBoYXx8dC5wcmVtdWx0aXBsaWVkQWxwaGEsbD12b2lkIDAhPT10LnByZXNlcnZlRHJhd2luZ0J1ZmZlciYmdC5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsYz12b2lkIDAhPT10LnBvd2VyUHJlZmVyZW5jZT90LnBvd2VyUHJlZmVyZW5jZTpcImRlZmF1bHRcIixoPXZvaWQgMCE9PXQuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCYmdC5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0O2xldCB1PW51bGwsZD1udWxsO2NvbnN0IHA9W10sbT1bXTt0aGlzLmRvbUVsZW1lbnQ9ZSx0aGlzLmRlYnVnPXtjaGVja1NoYWRlckVycm9yczohMH0sdGhpcy5hdXRvQ2xlYXI9ITAsdGhpcy5hdXRvQ2xlYXJDb2xvcj0hMCx0aGlzLmF1dG9DbGVhckRlcHRoPSEwLHRoaXMuYXV0b0NsZWFyU3RlbmNpbD0hMCx0aGlzLnNvcnRPYmplY3RzPSEwLHRoaXMuY2xpcHBpbmdQbGFuZXM9W10sdGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZD0hMSx0aGlzLmdhbW1hRmFjdG9yPTIsdGhpcy5vdXRwdXRFbmNvZGluZz0zZTMsdGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cz0hMSx0aGlzLnRvbmVNYXBwaW5nPTAsdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlPTE7Y29uc3QgZj10aGlzO2xldCBnPSExLHY9MCx5PTAseD1udWxsLGI9LTEsdz1udWxsO2NvbnN0IF89bmV3IE90LE09bmV3IE90O2xldCBTPW51bGwsVD1lLndpZHRoLEU9ZS5oZWlnaHQsQT0xLEw9bnVsbCxSPW51bGw7Y29uc3QgQz1uZXcgT3QoMCwwLFQsRSksUD1uZXcgT3QoMCwwLFQsRSk7bGV0IEk9ITE7Y29uc3QgRD1bXSxOPW5ldyBhaTtsZXQgRj0hMSxPPSExLFU9bnVsbDtjb25zdCBrPW5ldyB2ZSx6PW5ldyBCdCxCPXtiYWNrZ3JvdW5kOm51bGwsZm9nOm51bGwsZW52aXJvbm1lbnQ6bnVsbCxvdmVycmlkZU1hdGVyaWFsOm51bGwsaXNTY2VuZTohMH07ZnVuY3Rpb24gSCgpe3JldHVybiBudWxsPT09eD9BOjF9bGV0IFYsRyxXLGoscSxYLFksWixKLCQsSyxRLHR0LGV0LG50LGl0LHJ0LHN0LGF0LG90LGx0LGN0LGh0LHV0PW47ZnVuY3Rpb24gZHQodCxuKXtmb3IobGV0IGk9MDtpPHQubGVuZ3RoO2krKyl7Y29uc3Qgcj10W2ldLHM9ZS5nZXRDb250ZXh0KHIsbik7aWYobnVsbCE9PXMpcmV0dXJuIHN9cmV0dXJuIG51bGx9dHJ5e2NvbnN0IHQ9e2FscGhhOmksZGVwdGg6cixzdGVuY2lsOnMsYW50aWFsaWFzOmEscHJlbXVsdGlwbGllZEFscGhhOm8scHJlc2VydmVEcmF3aW5nQnVmZmVyOmwscG93ZXJQcmVmZXJlbmNlOmMsZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDpofTtpZihlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsZnQsITEpLGUuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsZ3QsITEpLG51bGw9PT11dCl7Y29uc3QgZT1bXCJ3ZWJnbDJcIixcIndlYmdsXCIsXCJleHBlcmltZW50YWwtd2ViZ2xcIl07aWYoITA9PT1mLmlzV2ViR0wxUmVuZGVyZXImJmUuc2hpZnQoKSx1dD1kdChlLHQpLG51bGw9PT11dCl0aHJvdyBkdChlKT9uZXcgRXJyb3IoXCJFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLlwiKTpuZXcgRXJyb3IoXCJFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0LlwiKX12b2lkIDA9PT11dC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQmJih1dC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm57cmFuZ2VNaW46MSxyYW5nZU1heDoxLHByZWNpc2lvbjoxfX0pfWNhdGNoKHQpe3Rocm93IGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBcIit0Lm1lc3NhZ2UpLHR9ZnVuY3Rpb24gcHQoKXtWPW5ldyBXaSh1dCksRz1uZXcgZ2kodXQsVix0KSxWLmluaXQoRyksY3Q9bmV3IEJzKHV0LFYsRyksVz1uZXcga3ModXQsVixHKSxEWzBdPTEwMjksaj1uZXcgWGkodXQpLHE9bmV3IFNzLFg9bmV3IHpzKHV0LFYsVyxxLEcsY3QsaiksWT1uZXcgeWkoZiksWj1uZXcgR2koZiksSj1uZXcgbGkodXQsRyksaHQ9bmV3IG1pKHV0LFYsSixHKSwkPW5ldyBqaSh1dCxKLGosaHQpLEs9bmV3IFFpKHV0LCQsSixqKSxhdD1uZXcgS2kodXQsRyxYKSxpdD1uZXcgdmkocSksUT1uZXcgTXMoZixZLFosVixHLGh0LGl0KSx0dD1uZXcgcXMocSksZXQ9bmV3IExzKHEpLG50PW5ldyBOcyhWLEcpLHN0PW5ldyBwaShmLFksVyxLLG8pLHJ0PW5ldyBVcyhmLEssRyksb3Q9bmV3IGZpKHV0LFYsaixHKSxsdD1uZXcgcWkodXQsVixqLEcpLGoucHJvZ3JhbXM9US5wcm9ncmFtcyxmLmNhcGFiaWxpdGllcz1HLGYuZXh0ZW5zaW9ucz1WLGYucHJvcGVydGllcz1xLGYucmVuZGVyTGlzdHM9ZXQsZi5zaGFkb3dNYXA9cnQsZi5zdGF0ZT1XLGYuaW5mbz1qfXB0KCk7Y29uc3QgbXQ9bmV3IGpzKGYsdXQpO2Z1bmN0aW9uIGZ0KHQpe3QucHJldmVudERlZmF1bHQoKSxjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgTG9zdC5cIiksZz0hMH1mdW5jdGlvbiBndCgpe2NvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC5cIiksZz0hMTtjb25zdCB0PWouYXV0b1Jlc2V0LGU9cnQuZW5hYmxlZCxuPXJ0LmF1dG9VcGRhdGUsaT1ydC5uZWVkc1VwZGF0ZSxyPXJ0LnR5cGU7cHQoKSxqLmF1dG9SZXNldD10LHJ0LmVuYWJsZWQ9ZSxydC5hdXRvVXBkYXRlPW4scnQubmVlZHNVcGRhdGU9aSxydC50eXBlPXJ9ZnVuY3Rpb24gdnQodCl7Y29uc3QgZT10LnRhcmdldDtlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsdnQpLGZ1bmN0aW9uKHQpeyhmdW5jdGlvbih0KXtjb25zdCBlPXEuZ2V0KHQpLnByb2dyYW1zO3ZvaWQgMCE9PWUmJmUuZm9yRWFjaCgoZnVuY3Rpb24odCl7US5yZWxlYXNlUHJvZ3JhbSh0KX0pKX0pKHQpLHEucmVtb3ZlKHQpfShlKX10aGlzLnhyPW10LHRoaXMuZ2V0Q29udGV4dD1mdW5jdGlvbigpe3JldHVybiB1dH0sdGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcz1mdW5jdGlvbigpe3JldHVybiB1dC5nZXRDb250ZXh0QXR0cmlidXRlcygpfSx0aGlzLmZvcmNlQ29udGV4dExvc3M9ZnVuY3Rpb24oKXtjb25zdCB0PVYuZ2V0KFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO3QmJnQubG9zZUNvbnRleHQoKX0sdGhpcy5mb3JjZUNvbnRleHRSZXN0b3JlPWZ1bmN0aW9uKCl7Y29uc3QgdD1WLmdldChcIldFQkdMX2xvc2VfY29udGV4dFwiKTt0JiZ0LnJlc3RvcmVDb250ZXh0KCl9LHRoaXMuZ2V0UGl4ZWxSYXRpbz1mdW5jdGlvbigpe3JldHVybiBBfSx0aGlzLnNldFBpeGVsUmF0aW89ZnVuY3Rpb24odCl7dm9pZCAwIT09dCYmKEE9dCx0aGlzLnNldFNpemUoVCxFLCExKSl9LHRoaXMuZ2V0U2l6ZT1mdW5jdGlvbih0KXtyZXR1cm4gdC5zZXQoVCxFKX0sdGhpcy5zZXRTaXplPWZ1bmN0aW9uKHQsbixpKXttdC5pc1ByZXNlbnRpbmc/Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQ2FuJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuXCIpOihUPXQsRT1uLGUud2lkdGg9TWF0aC5mbG9vcih0KkEpLGUuaGVpZ2h0PU1hdGguZmxvb3IobipBKSwhMSE9PWkmJihlLnN0eWxlLndpZHRoPXQrXCJweFwiLGUuc3R5bGUuaGVpZ2h0PW4rXCJweFwiKSx0aGlzLnNldFZpZXdwb3J0KDAsMCx0LG4pKX0sdGhpcy5nZXREcmF3aW5nQnVmZmVyU2l6ZT1mdW5jdGlvbih0KXtyZXR1cm4gdC5zZXQoVCpBLEUqQSkuZmxvb3IoKX0sdGhpcy5zZXREcmF3aW5nQnVmZmVyU2l6ZT1mdW5jdGlvbih0LG4saSl7VD10LEU9bixBPWksZS53aWR0aD1NYXRoLmZsb29yKHQqaSksZS5oZWlnaHQ9TWF0aC5mbG9vcihuKmkpLHRoaXMuc2V0Vmlld3BvcnQoMCwwLHQsbil9LHRoaXMuZ2V0Q3VycmVudFZpZXdwb3J0PWZ1bmN0aW9uKHQpe3JldHVybiB0LmNvcHkoXyl9LHRoaXMuZ2V0Vmlld3BvcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQuY29weShDKX0sdGhpcy5zZXRWaWV3cG9ydD1mdW5jdGlvbih0LGUsbixpKXt0LmlzVmVjdG9yND9DLnNldCh0LngsdC55LHQueix0LncpOkMuc2V0KHQsZSxuLGkpLFcudmlld3BvcnQoXy5jb3B5KEMpLm11bHRpcGx5U2NhbGFyKEEpLmZsb29yKCkpfSx0aGlzLmdldFNjaXNzb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHQuY29weShQKX0sdGhpcy5zZXRTY2lzc29yPWZ1bmN0aW9uKHQsZSxuLGkpe3QuaXNWZWN0b3I0P1Auc2V0KHQueCx0LnksdC56LHQudyk6UC5zZXQodCxlLG4saSksVy5zY2lzc29yKE0uY29weShQKS5tdWx0aXBseVNjYWxhcihBKS5mbG9vcigpKX0sdGhpcy5nZXRTY2lzc29yVGVzdD1mdW5jdGlvbigpe3JldHVybiBJfSx0aGlzLnNldFNjaXNzb3JUZXN0PWZ1bmN0aW9uKHQpe1cuc2V0U2Npc3NvclRlc3QoST10KX0sdGhpcy5zZXRPcGFxdWVTb3J0PWZ1bmN0aW9uKHQpe0w9dH0sdGhpcy5zZXRUcmFuc3BhcmVudFNvcnQ9ZnVuY3Rpb24odCl7Uj10fSx0aGlzLmdldENsZWFyQ29sb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHQuY29weShzdC5nZXRDbGVhckNvbG9yKCkpfSx0aGlzLnNldENsZWFyQ29sb3I9ZnVuY3Rpb24oKXtzdC5zZXRDbGVhckNvbG9yLmFwcGx5KHN0LGFyZ3VtZW50cyl9LHRoaXMuZ2V0Q2xlYXJBbHBoYT1mdW5jdGlvbigpe3JldHVybiBzdC5nZXRDbGVhckFscGhhKCl9LHRoaXMuc2V0Q2xlYXJBbHBoYT1mdW5jdGlvbigpe3N0LnNldENsZWFyQWxwaGEuYXBwbHkoc3QsYXJndW1lbnRzKX0sdGhpcy5jbGVhcj1mdW5jdGlvbih0LGUsbil7bGV0IGk9MDsodm9pZCAwPT09dHx8dCkmJihpfD0xNjM4NCksKHZvaWQgMD09PWV8fGUpJiYoaXw9MjU2KSwodm9pZCAwPT09bnx8bikmJihpfD0xMDI0KSx1dC5jbGVhcihpKX0sdGhpcy5jbGVhckNvbG9yPWZ1bmN0aW9uKCl7dGhpcy5jbGVhcighMCwhMSwhMSl9LHRoaXMuY2xlYXJEZXB0aD1mdW5jdGlvbigpe3RoaXMuY2xlYXIoITEsITAsITEpfSx0aGlzLmNsZWFyU3RlbmNpbD1mdW5jdGlvbigpe3RoaXMuY2xlYXIoITEsITEsITApfSx0aGlzLmRpc3Bvc2U9ZnVuY3Rpb24oKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsZnQsITEpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsZ3QsITEpLGV0LmRpc3Bvc2UoKSxudC5kaXNwb3NlKCkscS5kaXNwb3NlKCksWS5kaXNwb3NlKCksWi5kaXNwb3NlKCksSy5kaXNwb3NlKCksaHQuZGlzcG9zZSgpLG10LmRpc3Bvc2UoKSxtdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vzc2lvbnN0YXJ0XCIseHQpLG10LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZXNzaW9uZW5kXCIsYnQpLFUmJihVLmRpc3Bvc2UoKSxVPW51bGwpLHd0LnN0b3AoKX0sdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGU9ZnVuY3Rpb24odCxlKXtodC5pbml0QXR0cmlidXRlcygpO2NvbnN0IG49cS5nZXQodCk7dC5oYXNQb3NpdGlvbnMmJiFuLnBvc2l0aW9uJiYobi5wb3NpdGlvbj11dC5jcmVhdGVCdWZmZXIoKSksdC5oYXNOb3JtYWxzJiYhbi5ub3JtYWwmJihuLm5vcm1hbD11dC5jcmVhdGVCdWZmZXIoKSksdC5oYXNVdnMmJiFuLnV2JiYobi51dj11dC5jcmVhdGVCdWZmZXIoKSksdC5oYXNDb2xvcnMmJiFuLmNvbG9yJiYobi5jb2xvcj11dC5jcmVhdGVCdWZmZXIoKSk7Y29uc3QgaT1lLmdldEF0dHJpYnV0ZXMoKTt0Lmhhc1Bvc2l0aW9ucyYmKHV0LmJpbmRCdWZmZXIoMzQ5NjIsbi5wb3NpdGlvbiksdXQuYnVmZmVyRGF0YSgzNDk2Mix0LnBvc2l0aW9uQXJyYXksMzUwNDgpLGh0LmVuYWJsZUF0dHJpYnV0ZShpLnBvc2l0aW9uLmxvY2F0aW9uKSx1dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGkucG9zaXRpb24ubG9jYXRpb24sMyw1MTI2LCExLDAsMCkpLHQuaGFzTm9ybWFscyYmKHV0LmJpbmRCdWZmZXIoMzQ5NjIsbi5ub3JtYWwpLHV0LmJ1ZmZlckRhdGEoMzQ5NjIsdC5ub3JtYWxBcnJheSwzNTA0OCksaHQuZW5hYmxlQXR0cmlidXRlKGkubm9ybWFsLmxvY2F0aW9uKSx1dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGkubm9ybWFsLmxvY2F0aW9uLDMsNTEyNiwhMSwwLDApKSx0Lmhhc1V2cyYmKHV0LmJpbmRCdWZmZXIoMzQ5NjIsbi51diksdXQuYnVmZmVyRGF0YSgzNDk2Mix0LnV2QXJyYXksMzUwNDgpLGh0LmVuYWJsZUF0dHJpYnV0ZShpLnV2LmxvY2F0aW9uKSx1dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGkudXYubG9jYXRpb24sMiw1MTI2LCExLDAsMCkpLHQuaGFzQ29sb3JzJiYodXQuYmluZEJ1ZmZlcigzNDk2MixuLmNvbG9yKSx1dC5idWZmZXJEYXRhKDM0OTYyLHQuY29sb3JBcnJheSwzNTA0OCksaHQuZW5hYmxlQXR0cmlidXRlKGkuY29sb3IubG9jYXRpb24pLHV0LnZlcnRleEF0dHJpYlBvaW50ZXIoaS5jb2xvci5sb2NhdGlvbiwzLDUxMjYsITEsMCwwKSksaHQuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSx1dC5kcmF3QXJyYXlzKDQsMCx0LmNvdW50KSx0LmNvdW50PTB9LHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0PWZ1bmN0aW9uKHQsZSxuLGkscixzKXtudWxsPT09ZSYmKGU9Qik7Y29uc3QgYT1yLmlzTWVzaCYmci5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpPDAsbz1MdCh0LGUsbixpLHIpO1cuc2V0TWF0ZXJpYWwoaSxhKTtsZXQgbD1uLmluZGV4O2NvbnN0IGM9bi5hdHRyaWJ1dGVzLnBvc2l0aW9uO2lmKG51bGw9PT1sKXtpZih2b2lkIDA9PT1jfHwwPT09Yy5jb3VudClyZXR1cm59ZWxzZSBpZigwPT09bC5jb3VudClyZXR1cm47bGV0IGgsdT0xOyEwPT09aS53aXJlZnJhbWUmJihsPSQuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKG4pLHU9MiksaHQuc2V0dXAocixpLG8sbixsKTtsZXQgZD1vdDtudWxsIT09bCYmKGg9Si5nZXQobCksZD1sdCxkLnNldEluZGV4KGgpKTtjb25zdCBwPW51bGwhPT1sP2wuY291bnQ6Yy5jb3VudCxtPW4uZHJhd1JhbmdlLnN0YXJ0KnUsZj1uLmRyYXdSYW5nZS5jb3VudCp1LGc9bnVsbCE9PXM/cy5zdGFydCp1OjAsdj1udWxsIT09cz9zLmNvdW50KnU6MS8wLHk9TWF0aC5tYXgobSxnKSx4PU1hdGgubWluKHAsbStmLGcrdiktMSxiPU1hdGgubWF4KDAseC15KzEpO2lmKDAhPT1iKXtpZihyLmlzTWVzaCkhMD09PWkud2lyZWZyYW1lPyhXLnNldExpbmVXaWR0aChpLndpcmVmcmFtZUxpbmV3aWR0aCpIKCkpLGQuc2V0TW9kZSgxKSk6ZC5zZXRNb2RlKDQpO2Vsc2UgaWYoci5pc0xpbmUpe2xldCB0PWkubGluZXdpZHRoO3ZvaWQgMD09PXQmJih0PTEpLFcuc2V0TGluZVdpZHRoKHQqSCgpKSxyLmlzTGluZVNlZ21lbnRzP2Quc2V0TW9kZSgxKTpyLmlzTGluZUxvb3A/ZC5zZXRNb2RlKDIpOmQuc2V0TW9kZSgzKX1lbHNlIHIuaXNQb2ludHM/ZC5zZXRNb2RlKDApOnIuaXNTcHJpdGUmJmQuc2V0TW9kZSg0KTtpZihyLmlzSW5zdGFuY2VkTWVzaClkLnJlbmRlckluc3RhbmNlcyh5LGIsci5jb3VudCk7ZWxzZSBpZihuLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpe2NvbnN0IHQ9TWF0aC5taW4obi5pbnN0YW5jZUNvdW50LG4uX21heEluc3RhbmNlQ291bnQpO2QucmVuZGVySW5zdGFuY2VzKHksYix0KX1lbHNlIGQucmVuZGVyKHksYil9fSx0aGlzLmNvbXBpbGU9ZnVuY3Rpb24odCxlKXtkPW50LmdldCh0KSxkLmluaXQoKSxtLnB1c2goZCksdC50cmF2ZXJzZVZpc2libGUoKGZ1bmN0aW9uKHQpe3QuaXNMaWdodCYmdC5sYXllcnMudGVzdChlLmxheWVycykmJihkLnB1c2hMaWdodCh0KSx0LmNhc3RTaGFkb3cmJmQucHVzaFNoYWRvdyh0KSl9KSksZC5zZXR1cExpZ2h0cyhmLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzKSx0LnRyYXZlcnNlKChmdW5jdGlvbihlKXtjb25zdCBuPWUubWF0ZXJpYWw7aWYobilpZihBcnJheS5pc0FycmF5KG4pKWZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKXtFdChuW2ldLHQsZSl9ZWxzZSBFdChuLHQsZSl9KSksbS5wb3AoKSxkPW51bGx9O2xldCB5dD1udWxsO2Z1bmN0aW9uIHh0KCl7d3Quc3RvcCgpfWZ1bmN0aW9uIGJ0KCl7d3Quc3RhcnQoKX1jb25zdCB3dD1uZXcgb2k7ZnVuY3Rpb24gX3QodCxlLG4saSl7aWYoITE9PT10LnZpc2libGUpcmV0dXJuO2lmKHQubGF5ZXJzLnRlc3QoZS5sYXllcnMpKWlmKHQuaXNHcm91cCluPXQucmVuZGVyT3JkZXI7ZWxzZSBpZih0LmlzTE9EKSEwPT09dC5hdXRvVXBkYXRlJiZ0LnVwZGF0ZShlKTtlbHNlIGlmKHQuaXNMaWdodClkLnB1c2hMaWdodCh0KSx0LmNhc3RTaGFkb3cmJmQucHVzaFNoYWRvdyh0KTtlbHNlIGlmKHQuaXNTcHJpdGUpe2lmKCF0LmZydXN0dW1DdWxsZWR8fE4uaW50ZXJzZWN0c1Nwcml0ZSh0KSl7aSYmei5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KGspO2NvbnN0IGU9Sy51cGRhdGUodCkscj10Lm1hdGVyaWFsO3IudmlzaWJsZSYmdS5wdXNoKHQsZSxyLG4sei56LG51bGwpfX1lbHNlIGlmKHQuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QpaSYmei5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KGspLHUucHVzaCh0LG51bGwsdC5tYXRlcmlhbCxuLHoueixudWxsKTtlbHNlIGlmKCh0LmlzTWVzaHx8dC5pc0xpbmV8fHQuaXNQb2ludHMpJiYodC5pc1NraW5uZWRNZXNoJiZ0LnNrZWxldG9uLmZyYW1lIT09ai5yZW5kZXIuZnJhbWUmJih0LnNrZWxldG9uLnVwZGF0ZSgpLHQuc2tlbGV0b24uZnJhbWU9ai5yZW5kZXIuZnJhbWUpLCF0LmZydXN0dW1DdWxsZWR8fE4uaW50ZXJzZWN0c09iamVjdCh0KSkpe2kmJnouc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NChrKTtjb25zdCBlPUsudXBkYXRlKHQpLHI9dC5tYXRlcmlhbDtpZihBcnJheS5pc0FycmF5KHIpKXtjb25zdCBpPWUuZ3JvdXBzO2ZvcihsZXQgcz0wLGE9aS5sZW5ndGg7czxhO3MrKyl7Y29uc3QgYT1pW3NdLG89clthLm1hdGVyaWFsSW5kZXhdO28mJm8udmlzaWJsZSYmdS5wdXNoKHQsZSxvLG4sei56LGEpfX1lbHNlIHIudmlzaWJsZSYmdS5wdXNoKHQsZSxyLG4sei56LG51bGwpfWNvbnN0IHI9dC5jaGlsZHJlbjtmb3IobGV0IHQ9MCxzPXIubGVuZ3RoO3Q8czt0KyspX3Qoclt0XSxlLG4saSl9ZnVuY3Rpb24gTXQodCxlLG4saSl7Y29uc3Qgcj10Lm9wYXF1ZSxzPXQudHJhbnNtaXNzaXZlLG89dC50cmFuc3BhcmVudDtkLnNldHVwTGlnaHRzVmlldyhuKSxzLmxlbmd0aD4wJiZmdW5jdGlvbih0LGUsbil7aWYobnVsbD09PVUpe2NvbnN0IHQ9ITA9PT1hJiYhMD09PUcuaXNXZWJHTDI7VT1uZXcodD9rdDpVdCkoMTAyNCwxMDI0LHtnZW5lcmF0ZU1pcG1hcHM6ITAsdHlwZTpudWxsIT09Y3QuY29udmVydCgxMDE2KT8xMDE2OjEwMDksbWluRmlsdGVyOjEwMDgsbWFnRmlsdGVyOjEwMDMsd3JhcFM6MTAwMSx3cmFwVDoxMDAxfSl9Y29uc3QgaT1mLmdldFJlbmRlclRhcmdldCgpO2Yuc2V0UmVuZGVyVGFyZ2V0KFUpLGYuY2xlYXIoKTtjb25zdCByPWYudG9uZU1hcHBpbmc7Zi50b25lTWFwcGluZz0wLFN0KHQsZSxuKSxmLnRvbmVNYXBwaW5nPXIsWC51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChVKSxYLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChVKSxmLnNldFJlbmRlclRhcmdldChpKX0ocixlLG4pLGkmJlcudmlld3BvcnQoXy5jb3B5KGkpKSxyLmxlbmd0aD4wJiZTdChyLGUsbikscy5sZW5ndGg+MCYmU3QocyxlLG4pLG8ubGVuZ3RoPjAmJlN0KG8sZSxuKX1mdW5jdGlvbiBTdCh0LGUsbil7Y29uc3QgaT0hMD09PWUuaXNTY2VuZT9lLm92ZXJyaWRlTWF0ZXJpYWw6bnVsbDtmb3IobGV0IHI9MCxzPXQubGVuZ3RoO3I8cztyKyspe2NvbnN0IHM9dFtyXSxhPXMub2JqZWN0LG89cy5nZW9tZXRyeSxsPW51bGw9PT1pP3MubWF0ZXJpYWw6aSxjPXMuZ3JvdXA7YS5sYXllcnMudGVzdChuLmxheWVycykmJlR0KGEsZSxuLG8sbCxjKX19ZnVuY3Rpb24gVHQodCxlLG4saSxyLHMpe2lmKHQub25CZWZvcmVSZW5kZXIoZixlLG4saSxyLHMpLHQubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMobi5tYXRyaXhXb3JsZEludmVyc2UsdC5tYXRyaXhXb3JsZCksdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KHQubW9kZWxWaWV3TWF0cml4KSxyLm9uQmVmb3JlUmVuZGVyKGYsZSxuLGksdCxzKSx0LmlzSW1tZWRpYXRlUmVuZGVyT2JqZWN0KXtjb25zdCBzPUx0KG4sZSxpLHIsdCk7Vy5zZXRNYXRlcmlhbChyKSxodC5yZXNldCgpLGZ1bmN0aW9uKHQsZSl7dC5yZW5kZXIoKGZ1bmN0aW9uKHQpe2YucmVuZGVyQnVmZmVySW1tZWRpYXRlKHQsZSl9KSl9KHQscyl9ZWxzZSEwPT09ci50cmFuc3BhcmVudCYmMj09PXIuc2lkZT8oci5zaWRlPTEsci5uZWVkc1VwZGF0ZT0hMCxmLnJlbmRlckJ1ZmZlckRpcmVjdChuLGUsaSxyLHQscyksci5zaWRlPTAsci5uZWVkc1VwZGF0ZT0hMCxmLnJlbmRlckJ1ZmZlckRpcmVjdChuLGUsaSxyLHQscyksci5zaWRlPTIpOmYucmVuZGVyQnVmZmVyRGlyZWN0KG4sZSxpLHIsdCxzKTt0Lm9uQWZ0ZXJSZW5kZXIoZixlLG4saSxyLHMpfWZ1bmN0aW9uIEV0KHQsZSxuKXshMCE9PWUuaXNTY2VuZSYmKGU9Qik7Y29uc3QgaT1xLmdldCh0KSxyPWQuc3RhdGUubGlnaHRzLHM9ZC5zdGF0ZS5zaGFkb3dzQXJyYXksYT1yLnN0YXRlLnZlcnNpb24sbz1RLmdldFBhcmFtZXRlcnModCxyLnN0YXRlLHMsZSxuKSxsPVEuZ2V0UHJvZ3JhbUNhY2hlS2V5KG8pO2xldCBjPWkucHJvZ3JhbXM7aS5lbnZpcm9ubWVudD10LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/ZS5lbnZpcm9ubWVudDpudWxsLGkuZm9nPWUuZm9nLGkuZW52TWFwPSh0LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWw/WjpZKS5nZXQodC5lbnZNYXB8fGkuZW52aXJvbm1lbnQpLHZvaWQgMD09PWMmJih0LmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsdnQpLGM9bmV3IE1hcCxpLnByb2dyYW1zPWMpO2xldCBoPWMuZ2V0KGwpO2lmKHZvaWQgMCE9PWgpe2lmKGkuY3VycmVudFByb2dyYW09PT1oJiZpLmxpZ2h0c1N0YXRlVmVyc2lvbj09PWEpcmV0dXJuIEF0KHQsbyksaH1lbHNlIG8udW5pZm9ybXM9US5nZXRVbmlmb3Jtcyh0KSx0Lm9uQnVpbGQobyxmKSx0Lm9uQmVmb3JlQ29tcGlsZShvLGYpLGg9US5hY3F1aXJlUHJvZ3JhbShvLGwpLGMuc2V0KGwsaCksaS51bmlmb3Jtcz1vLnVuaWZvcm1zO2NvbnN0IHU9aS51bmlmb3JtczsodC5pc1NoYWRlck1hdGVyaWFsfHx0LmlzUmF3U2hhZGVyTWF0ZXJpYWwpJiYhMCE9PXQuY2xpcHBpbmd8fCh1LmNsaXBwaW5nUGxhbmVzPWl0LnVuaWZvcm0pLEF0KHQsbyksaS5uZWVkc0xpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gdC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWx8fHQuaXNNZXNoVG9vbk1hdGVyaWFsfHx0LmlzTWVzaFBob25nTWF0ZXJpYWx8fHQuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbHx8dC5pc1NoYWRvd01hdGVyaWFsfHx0LmlzU2hhZGVyTWF0ZXJpYWwmJiEwPT09dC5saWdodHN9KHQpLGkubGlnaHRzU3RhdGVWZXJzaW9uPWEsaS5uZWVkc0xpZ2h0cyYmKHUuYW1iaWVudExpZ2h0Q29sb3IudmFsdWU9ci5zdGF0ZS5hbWJpZW50LHUubGlnaHRQcm9iZS52YWx1ZT1yLnN0YXRlLnByb2JlLHUuZGlyZWN0aW9uYWxMaWdodHMudmFsdWU9ci5zdGF0ZS5kaXJlY3Rpb25hbCx1LmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLnZhbHVlPXIuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3csdS5zcG90TGlnaHRzLnZhbHVlPXIuc3RhdGUuc3BvdCx1LnNwb3RMaWdodFNoYWRvd3MudmFsdWU9ci5zdGF0ZS5zcG90U2hhZG93LHUucmVjdEFyZWFMaWdodHMudmFsdWU9ci5zdGF0ZS5yZWN0QXJlYSx1Lmx0Y18xLnZhbHVlPXIuc3RhdGUucmVjdEFyZWFMVEMxLHUubHRjXzIudmFsdWU9ci5zdGF0ZS5yZWN0QXJlYUxUQzIsdS5wb2ludExpZ2h0cy52YWx1ZT1yLnN0YXRlLnBvaW50LHUucG9pbnRMaWdodFNoYWRvd3MudmFsdWU9ci5zdGF0ZS5wb2ludFNoYWRvdyx1LmhlbWlzcGhlcmVMaWdodHMudmFsdWU9ci5zdGF0ZS5oZW1pLHUuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWU9ci5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcCx1LmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlPXIuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgsdS5zcG90U2hhZG93TWFwLnZhbHVlPXIuc3RhdGUuc3BvdFNoYWRvd01hcCx1LnNwb3RTaGFkb3dNYXRyaXgudmFsdWU9ci5zdGF0ZS5zcG90U2hhZG93TWF0cml4LHUucG9pbnRTaGFkb3dNYXAudmFsdWU9ci5zdGF0ZS5wb2ludFNoYWRvd01hcCx1LnBvaW50U2hhZG93TWF0cml4LnZhbHVlPXIuc3RhdGUucG9pbnRTaGFkb3dNYXRyaXgpO2NvbnN0IHA9aC5nZXRVbmlmb3JtcygpLG09bnMuc2VxV2l0aFZhbHVlKHAuc2VxLHUpO3JldHVybiBpLmN1cnJlbnRQcm9ncmFtPWgsaS51bmlmb3Jtc0xpc3Q9bSxofWZ1bmN0aW9uIEF0KHQsZSl7Y29uc3Qgbj1xLmdldCh0KTtuLm91dHB1dEVuY29kaW5nPWUub3V0cHV0RW5jb2Rpbmcsbi5pbnN0YW5jaW5nPWUuaW5zdGFuY2luZyxuLnNraW5uaW5nPWUuc2tpbm5pbmcsbi5tb3JwaFRhcmdldHM9ZS5tb3JwaFRhcmdldHMsbi5tb3JwaE5vcm1hbHM9ZS5tb3JwaE5vcm1hbHMsbi5tb3JwaFRhcmdldHNDb3VudD1lLm1vcnBoVGFyZ2V0c0NvdW50LG4ubnVtQ2xpcHBpbmdQbGFuZXM9ZS5udW1DbGlwcGluZ1BsYW5lcyxuLm51bUludGVyc2VjdGlvbj1lLm51bUNsaXBJbnRlcnNlY3Rpb24sbi52ZXJ0ZXhBbHBoYXM9ZS52ZXJ0ZXhBbHBoYXMsbi52ZXJ0ZXhUYW5nZW50cz1lLnZlcnRleFRhbmdlbnRzfWZ1bmN0aW9uIEx0KHQsZSxuLGkscil7ITAhPT1lLmlzU2NlbmUmJihlPUIpLFgucmVzZXRUZXh0dXJlVW5pdHMoKTtjb25zdCBzPWUuZm9nLGE9aS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsP2UuZW52aXJvbm1lbnQ6bnVsbCxvPW51bGw9PT14P2Yub3V0cHV0RW5jb2Rpbmc6eC50ZXh0dXJlLmVuY29kaW5nLGw9KGkuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD9aOlkpLmdldChpLmVudk1hcHx8YSksYz0hMD09PWkudmVydGV4Q29sb3JzJiYhIW4mJiEhbi5hdHRyaWJ1dGVzLmNvbG9yJiY0PT09bi5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplLGg9ISFpLm5vcm1hbE1hcCYmISFuJiYhIW4uYXR0cmlidXRlcy50YW5nZW50LHU9ISFuJiYhIW4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLHA9ISFuJiYhIW4ubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCxtPW4mJm4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uP24ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aDowLGc9cS5nZXQoaSksdj1kLnN0YXRlLmxpZ2h0cztpZighMD09PUYmJighMD09PU98fHQhPT13KSl7Y29uc3QgZT10PT09dyYmaS5pZD09PWI7aXQuc2V0U3RhdGUoaSx0LGUpfWxldCB5PSExO2kudmVyc2lvbj09PWcuX192ZXJzaW9uP2cubmVlZHNMaWdodHMmJmcubGlnaHRzU3RhdGVWZXJzaW9uIT09di5zdGF0ZS52ZXJzaW9ufHxnLm91dHB1dEVuY29kaW5nIT09b3x8ci5pc0luc3RhbmNlZE1lc2gmJiExPT09Zy5pbnN0YW5jaW5nP3k9ITA6ci5pc0luc3RhbmNlZE1lc2h8fCEwIT09Zy5pbnN0YW5jaW5nP3IuaXNTa2lubmVkTWVzaCYmITE9PT1nLnNraW5uaW5nP3k9ITA6ci5pc1NraW5uZWRNZXNofHwhMCE9PWcuc2tpbm5pbmc/Zy5lbnZNYXAhPT1sfHxpLmZvZyYmZy5mb2chPT1zP3k9ITA6dm9pZCAwPT09Zy5udW1DbGlwcGluZ1BsYW5lc3x8Zy5udW1DbGlwcGluZ1BsYW5lcz09PWl0Lm51bVBsYW5lcyYmZy5udW1JbnRlcnNlY3Rpb249PT1pdC5udW1JbnRlcnNlY3Rpb24/KGcudmVydGV4QWxwaGFzIT09Y3x8Zy52ZXJ0ZXhUYW5nZW50cyE9PWh8fGcubW9ycGhUYXJnZXRzIT09dXx8Zy5tb3JwaE5vcm1hbHMhPT1wfHwhMD09PUcuaXNXZWJHTDImJmcubW9ycGhUYXJnZXRzQ291bnQhPT1tKSYmKHk9ITApOnk9ITA6eT0hMDp5PSEwOih5PSEwLGcuX192ZXJzaW9uPWkudmVyc2lvbik7bGV0IF89Zy5jdXJyZW50UHJvZ3JhbTshMD09PXkmJihfPUV0KGksZSxyKSk7bGV0IE09ITEsUz0hMSxUPSExO2NvbnN0IEw9Xy5nZXRVbmlmb3JtcygpLFI9Zy51bmlmb3JtcztpZihXLnVzZVByb2dyYW0oXy5wcm9ncmFtKSYmKE09ITAsUz0hMCxUPSEwKSxpLmlkIT09YiYmKGI9aS5pZCxTPSEwKSxNfHx3IT09dCl7aWYoTC5zZXRWYWx1ZSh1dCxcInByb2plY3Rpb25NYXRyaXhcIix0LnByb2plY3Rpb25NYXRyaXgpLEcubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciYmTC5zZXRWYWx1ZSh1dCxcImxvZ0RlcHRoQnVmRkNcIiwyLyhNYXRoLmxvZyh0LmZhcisxKS9NYXRoLkxOMikpLHchPT10JiYodz10LFM9ITAsVD0hMCksaS5pc1NoYWRlck1hdGVyaWFsfHxpLmlzTWVzaFBob25nTWF0ZXJpYWx8fGkuaXNNZXNoVG9vbk1hdGVyaWFsfHxpLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWx8fGkuZW52TWFwKXtjb25zdCBlPUwubWFwLmNhbWVyYVBvc2l0aW9uO3ZvaWQgMCE9PWUmJmUuc2V0VmFsdWUodXQsei5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCkpfShpLmlzTWVzaFBob25nTWF0ZXJpYWx8fGkuaXNNZXNoVG9vbk1hdGVyaWFsfHxpLmlzTWVzaExhbWJlcnRNYXRlcmlhbHx8aS5pc01lc2hCYXNpY01hdGVyaWFsfHxpLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWx8fGkuaXNTaGFkZXJNYXRlcmlhbCkmJkwuc2V0VmFsdWUodXQsXCJpc09ydGhvZ3JhcGhpY1wiLCEwPT09dC5pc09ydGhvZ3JhcGhpY0NhbWVyYSksKGkuaXNNZXNoUGhvbmdNYXRlcmlhbHx8aS5pc01lc2hUb29uTWF0ZXJpYWx8fGkuaXNNZXNoTGFtYmVydE1hdGVyaWFsfHxpLmlzTWVzaEJhc2ljTWF0ZXJpYWx8fGkuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbHx8aS5pc1NoYWRlck1hdGVyaWFsfHxpLmlzU2hhZG93TWF0ZXJpYWx8fHIuaXNTa2lubmVkTWVzaCkmJkwuc2V0VmFsdWUodXQsXCJ2aWV3TWF0cml4XCIsdC5tYXRyaXhXb3JsZEludmVyc2UpfWlmKHIuaXNTa2lubmVkTWVzaCl7TC5zZXRPcHRpb25hbCh1dCxyLFwiYmluZE1hdHJpeFwiKSxMLnNldE9wdGlvbmFsKHV0LHIsXCJiaW5kTWF0cml4SW52ZXJzZVwiKTtjb25zdCB0PXIuc2tlbGV0b247dCYmKEcuZmxvYXRWZXJ0ZXhUZXh0dXJlcz8obnVsbD09PXQuYm9uZVRleHR1cmUmJnQuY29tcHV0ZUJvbmVUZXh0dXJlKCksTC5zZXRWYWx1ZSh1dCxcImJvbmVUZXh0dXJlXCIsdC5ib25lVGV4dHVyZSxYKSxMLnNldFZhbHVlKHV0LFwiYm9uZVRleHR1cmVTaXplXCIsdC5ib25lVGV4dHVyZVNpemUpKTpMLnNldE9wdGlvbmFsKHV0LHQsXCJib25lTWF0cmljZXNcIikpfXZhciBDLFA7cmV0dXJuIW58fHZvaWQgMD09PW4ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uJiZ2b2lkIDA9PT1uLm1vcnBoQXR0cmlidXRlcy5ub3JtYWx8fGF0LnVwZGF0ZShyLG4saSxfKSwoU3x8Zy5yZWNlaXZlU2hhZG93IT09ci5yZWNlaXZlU2hhZG93KSYmKGcucmVjZWl2ZVNoYWRvdz1yLnJlY2VpdmVTaGFkb3csTC5zZXRWYWx1ZSh1dCxcInJlY2VpdmVTaGFkb3dcIixyLnJlY2VpdmVTaGFkb3cpKSxTJiYoTC5zZXRWYWx1ZSh1dCxcInRvbmVNYXBwaW5nRXhwb3N1cmVcIixmLnRvbmVNYXBwaW5nRXhwb3N1cmUpLGcubmVlZHNMaWdodHMmJihQPVQsKEM9UikuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGU9UCxDLmxpZ2h0UHJvYmUubmVlZHNVcGRhdGU9UCxDLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlPVAsQy5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZT1QLEMucG9pbnRMaWdodHMubmVlZHNVcGRhdGU9UCxDLnBvaW50TGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlPVAsQy5zcG90TGlnaHRzLm5lZWRzVXBkYXRlPVAsQy5zcG90TGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlPVAsQy5yZWN0QXJlYUxpZ2h0cy5uZWVkc1VwZGF0ZT1QLEMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZT1QKSxzJiZpLmZvZyYmdHQucmVmcmVzaEZvZ1VuaWZvcm1zKFIscyksdHQucmVmcmVzaE1hdGVyaWFsVW5pZm9ybXMoUixpLEEsRSxVKSxucy51cGxvYWQodXQsZy51bmlmb3Jtc0xpc3QsUixYKSksaS5pc1NoYWRlck1hdGVyaWFsJiYhMD09PWkudW5pZm9ybXNOZWVkVXBkYXRlJiYobnMudXBsb2FkKHV0LGcudW5pZm9ybXNMaXN0LFIsWCksaS51bmlmb3Jtc05lZWRVcGRhdGU9ITEpLGkuaXNTcHJpdGVNYXRlcmlhbCYmTC5zZXRWYWx1ZSh1dCxcImNlbnRlclwiLHIuY2VudGVyKSxMLnNldFZhbHVlKHV0LFwibW9kZWxWaWV3TWF0cml4XCIsci5tb2RlbFZpZXdNYXRyaXgpLEwuc2V0VmFsdWUodXQsXCJub3JtYWxNYXRyaXhcIixyLm5vcm1hbE1hdHJpeCksTC5zZXRWYWx1ZSh1dCxcIm1vZGVsTWF0cml4XCIsci5tYXRyaXhXb3JsZCksX313dC5zZXRBbmltYXRpb25Mb29wKChmdW5jdGlvbih0KXt5dCYmeXQodCl9KSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd3Quc2V0Q29udGV4dCh3aW5kb3cpLHRoaXMuc2V0QW5pbWF0aW9uTG9vcD1mdW5jdGlvbih0KXt5dD10LG10LnNldEFuaW1hdGlvbkxvb3AodCksbnVsbD09PXQ/d3Quc3RvcCgpOnd0LnN0YXJ0KCl9LG10LmFkZEV2ZW50TGlzdGVuZXIoXCJzZXNzaW9uc3RhcnRcIix4dCksbXQuYWRkRXZlbnRMaXN0ZW5lcihcInNlc3Npb25lbmRcIixidCksdGhpcy5yZW5kZXI9ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT1lJiYhMCE9PWUuaXNDYW1lcmEpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS5cIik7aWYoITA9PT1nKXJldHVybjshMD09PXQuYXV0b1VwZGF0ZSYmdC51cGRhdGVNYXRyaXhXb3JsZCgpLG51bGw9PT1lLnBhcmVudCYmZS51cGRhdGVNYXRyaXhXb3JsZCgpLCEwPT09bXQuZW5hYmxlZCYmITA9PT1tdC5pc1ByZXNlbnRpbmcmJighMD09PW10LmNhbWVyYUF1dG9VcGRhdGUmJm10LnVwZGF0ZUNhbWVyYShlKSxlPW10LmdldENhbWVyYSgpKSwhMD09PXQuaXNTY2VuZSYmdC5vbkJlZm9yZVJlbmRlcihmLHQsZSx4KSxkPW50LmdldCh0LG0ubGVuZ3RoKSxkLmluaXQoKSxtLnB1c2goZCksay5tdWx0aXBseU1hdHJpY2VzKGUucHJvamVjdGlvbk1hdHJpeCxlLm1hdHJpeFdvcmxkSW52ZXJzZSksTi5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChrKSxPPXRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQsRj1pdC5pbml0KHRoaXMuY2xpcHBpbmdQbGFuZXMsTyxlKSx1PWV0LmdldCh0LHAubGVuZ3RoKSx1LmluaXQoKSxwLnB1c2godSksX3QodCxlLDAsZi5zb3J0T2JqZWN0cyksdS5maW5pc2goKSwhMD09PWYuc29ydE9iamVjdHMmJnUuc29ydChMLFIpLCEwPT09RiYmaXQuYmVnaW5TaGFkb3dzKCk7Y29uc3Qgbj1kLnN0YXRlLnNoYWRvd3NBcnJheTtpZihydC5yZW5kZXIobix0LGUpLCEwPT09RiYmaXQuZW5kU2hhZG93cygpLCEwPT09dGhpcy5pbmZvLmF1dG9SZXNldCYmdGhpcy5pbmZvLnJlc2V0KCksc3QucmVuZGVyKHUsdCksZC5zZXR1cExpZ2h0cyhmLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzKSxlLmlzQXJyYXlDYW1lcmEpe2NvbnN0IG49ZS5jYW1lcmFzO2ZvcihsZXQgZT0wLGk9bi5sZW5ndGg7ZTxpO2UrKyl7Y29uc3QgaT1uW2VdO010KHUsdCxpLGkudmlld3BvcnQpfX1lbHNlIE10KHUsdCxlKTtudWxsIT09eCYmKFgudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoeCksWC51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoeCkpLCEwPT09dC5pc1NjZW5lJiZ0Lm9uQWZ0ZXJSZW5kZXIoZix0LGUpLFcuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCEwKSxXLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayghMCksVy5idWZmZXJzLmNvbG9yLnNldE1hc2soITApLFcuc2V0UG9seWdvbk9mZnNldCghMSksaHQucmVzZXREZWZhdWx0U3RhdGUoKSxiPS0xLHc9bnVsbCxtLnBvcCgpLGQ9bS5sZW5ndGg+MD9tW20ubGVuZ3RoLTFdOm51bGwscC5wb3AoKSx1PXAubGVuZ3RoPjA/cFtwLmxlbmd0aC0xXTpudWxsfSx0aGlzLmdldEFjdGl2ZUN1YmVGYWNlPWZ1bmN0aW9uKCl7cmV0dXJuIHZ9LHRoaXMuZ2V0QWN0aXZlTWlwbWFwTGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4geX0sdGhpcy5nZXRSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4geH0sdGhpcy5zZXRSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24odCxlPTAsbj0wKXt4PXQsdj1lLHk9bix0JiZ2b2lkIDA9PT1xLmdldCh0KS5fX3dlYmdsRnJhbWVidWZmZXImJlguc2V0dXBSZW5kZXJUYXJnZXQodCk7bGV0IGk9bnVsbCxyPSExLHM9ITE7aWYodCl7Y29uc3Qgbj10LnRleHR1cmU7KG4uaXNEYXRhVGV4dHVyZTNEfHxuLmlzRGF0YVRleHR1cmUyREFycmF5KSYmKHM9ITApO2NvbnN0IGE9cS5nZXQodCkuX193ZWJnbEZyYW1lYnVmZmVyO3QuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ/KGk9YVtlXSxyPSEwKTppPXQuaXNXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0P3EuZ2V0KHQpLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcjphLF8uY29weSh0LnZpZXdwb3J0KSxNLmNvcHkodC5zY2lzc29yKSxTPXQuc2Npc3NvclRlc3R9ZWxzZSBfLmNvcHkoQykubXVsdGlwbHlTY2FsYXIoQSkuZmxvb3IoKSxNLmNvcHkoUCkubXVsdGlwbHlTY2FsYXIoQSkuZmxvb3IoKSxTPUk7aWYoVy5iaW5kRnJhbWVidWZmZXIoMzYxNjAsaSkmJkcuZHJhd0J1ZmZlcnMpe2xldCBlPSExO2lmKHQpaWYodC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzKXtjb25zdCBuPXQudGV4dHVyZTtpZihELmxlbmd0aCE9PW4ubGVuZ3RofHwzNjA2NCE9PURbMF0pe2ZvcihsZXQgdD0wLGU9bi5sZW5ndGg7dDxlO3QrKylEW3RdPTM2MDY0K3Q7RC5sZW5ndGg9bi5sZW5ndGgsZT0hMH19ZWxzZSAxPT09RC5sZW5ndGgmJjM2MDY0PT09RFswXXx8KERbMF09MzYwNjQsRC5sZW5ndGg9MSxlPSEwKTtlbHNlIDE9PT1ELmxlbmd0aCYmMTAyOT09PURbMF18fChEWzBdPTEwMjksRC5sZW5ndGg9MSxlPSEwKTtlJiYoRy5pc1dlYkdMMj91dC5kcmF3QnVmZmVycyhEKTpWLmdldChcIldFQkdMX2RyYXdfYnVmZmVyc1wiKS5kcmF3QnVmZmVyc1dFQkdMKEQpKX1pZihXLnZpZXdwb3J0KF8pLFcuc2Npc3NvcihNKSxXLnNldFNjaXNzb3JUZXN0KFMpLHIpe2NvbnN0IGk9cS5nZXQodC50ZXh0dXJlKTt1dC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCwzNjA2NCwzNDA2OStlLGkuX193ZWJnbFRleHR1cmUsbil9ZWxzZSBpZihzKXtjb25zdCBpPXEuZ2V0KHQudGV4dHVyZSkscj1lfHwwO3V0LmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKDM2MTYwLDM2MDY0LGkuX193ZWJnbFRleHR1cmUsbnx8MCxyKX1iPS0xfSx0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM9ZnVuY3Rpb24odCxlLG4saSxyLHMsYSl7aWYoIXR8fCF0LmlzV2ViR0xSZW5kZXJUYXJnZXQpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5cIik7bGV0IG89cS5nZXQodCkuX193ZWJnbEZyYW1lYnVmZmVyO2lmKHQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQmJnZvaWQgMCE9PWEmJihvPW9bYV0pLG8pe1cuYmluZEZyYW1lYnVmZmVyKDM2MTYwLG8pO3RyeXtjb25zdCBhPXQudGV4dHVyZSxvPWEuZm9ybWF0LGw9YS50eXBlO2lmKDEwMjMhPT1vJiZjdC5jb252ZXJ0KG8pIT09dXQuZ2V0UGFyYW1ldGVyKDM1NzM5KSlyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuXCIpO2NvbnN0IGM9MTAxNj09PWwmJihWLmhhcyhcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKXx8Ry5pc1dlYkdMMiYmVi5oYXMoXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKTtpZighKDEwMDk9PT1sfHxjdC5jb252ZXJ0KGwpPT09dXQuZ2V0UGFyYW1ldGVyKDM1NzM4KXx8MTAxNT09PWwmJihHLmlzV2ViR0wyfHxWLmhhcyhcIk9FU190ZXh0dXJlX2Zsb2F0XCIpfHxWLmhhcyhcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSl8fGMpKXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuXCIpOzM2MDUzPT09dXQuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cygzNjE2MCk/ZT49MCYmZTw9dC53aWR0aC1pJiZuPj0wJiZuPD10LmhlaWdodC1yJiZ1dC5yZWFkUGl4ZWxzKGUsbixpLHIsY3QuY29udmVydChvKSxjdC5jb252ZXJ0KGwpLHMpOmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuXCIpfWZpbmFsbHl7Y29uc3QgdD1udWxsIT09eD9xLmdldCh4KS5fX3dlYmdsRnJhbWVidWZmZXI6bnVsbDtXLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCx0KX19fSx0aGlzLmNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZT1mdW5jdGlvbih0LGUsbj0wKXtjb25zdCBpPU1hdGgucG93KDIsLW4pLHI9TWF0aC5mbG9vcihlLmltYWdlLndpZHRoKmkpLHM9TWF0aC5mbG9vcihlLmltYWdlLmhlaWdodCppKTtsZXQgYT1jdC5jb252ZXJ0KGUuZm9ybWF0KTtHLmlzV2ViR0wyJiYoNjQwNz09PWEmJihhPTMyODQ5KSw2NDA4PT09YSYmKGE9MzI4NTYpKSxYLnNldFRleHR1cmUyRChlLDApLHV0LmNvcHlUZXhJbWFnZTJEKDM1NTMsbixhLHQueCx0LnkscixzLDApLFcudW5iaW5kVGV4dHVyZSgpfSx0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLGk9MCl7Y29uc3Qgcj1lLmltYWdlLndpZHRoLHM9ZS5pbWFnZS5oZWlnaHQsYT1jdC5jb252ZXJ0KG4uZm9ybWF0KSxvPWN0LmNvbnZlcnQobi50eXBlKTtYLnNldFRleHR1cmUyRChuLDApLHV0LnBpeGVsU3RvcmVpKDM3NDQwLG4uZmxpcFkpLHV0LnBpeGVsU3RvcmVpKDM3NDQxLG4ucHJlbXVsdGlwbHlBbHBoYSksdXQucGl4ZWxTdG9yZWkoMzMxNyxuLnVucGFja0FsaWdubWVudCksZS5pc0RhdGFUZXh0dXJlP3V0LnRleFN1YkltYWdlMkQoMzU1MyxpLHQueCx0LnkscixzLGEsbyxlLmltYWdlLmRhdGEpOmUuaXNDb21wcmVzc2VkVGV4dHVyZT91dC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCgzNTUzLGksdC54LHQueSxlLm1pcG1hcHNbMF0ud2lkdGgsZS5taXBtYXBzWzBdLmhlaWdodCxhLGUubWlwbWFwc1swXS5kYXRhKTp1dC50ZXhTdWJJbWFnZTJEKDM1NTMsaSx0LngsdC55LGEsbyxlLmltYWdlKSwwPT09aSYmbi5nZW5lcmF0ZU1pcG1hcHMmJnV0LmdlbmVyYXRlTWlwbWFwKDM1NTMpLFcudW5iaW5kVGV4dHVyZSgpfSx0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q9ZnVuY3Rpb24odCxlLG4saSxyPTApe2lmKGYuaXNXZWJHTDFSZW5kZXJlcilyZXR1cm4gdm9pZCBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuXCIpO2NvbnN0IHM9dC5tYXgueC10Lm1pbi54KzEsYT10Lm1heC55LXQubWluLnkrMSxvPXQubWF4LnotdC5taW4ueisxLGw9Y3QuY29udmVydChpLmZvcm1hdCksYz1jdC5jb252ZXJ0KGkudHlwZSk7bGV0IGg7aWYoaS5pc0RhdGFUZXh0dXJlM0QpWC5zZXRUZXh0dXJlM0QoaSwwKSxoPTMyODc5O2Vsc2V7aWYoIWkuaXNEYXRhVGV4dHVyZTJEQXJyYXkpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiBvbmx5IHN1cHBvcnRzIFRIUkVFLkRhdGFUZXh0dXJlM0QgYW5kIFRIUkVFLkRhdGFUZXh0dXJlMkRBcnJheS5cIik7WC5zZXRUZXh0dXJlMkRBcnJheShpLDApLGg9MzU4NjZ9dXQucGl4ZWxTdG9yZWkoMzc0NDAsaS5mbGlwWSksdXQucGl4ZWxTdG9yZWkoMzc0NDEsaS5wcmVtdWx0aXBseUFscGhhKSx1dC5waXhlbFN0b3JlaSgzMzE3LGkudW5wYWNrQWxpZ25tZW50KTtjb25zdCB1PXV0LmdldFBhcmFtZXRlcigzMzE0KSxkPXV0LmdldFBhcmFtZXRlcigzMjg3OCkscD11dC5nZXRQYXJhbWV0ZXIoMzMxNiksbT11dC5nZXRQYXJhbWV0ZXIoMzMxNSksZz11dC5nZXRQYXJhbWV0ZXIoMzI4NzcpLHY9bi5pc0NvbXByZXNzZWRUZXh0dXJlP24ubWlwbWFwc1swXTpuLmltYWdlO3V0LnBpeGVsU3RvcmVpKDMzMTQsdi53aWR0aCksdXQucGl4ZWxTdG9yZWkoMzI4Nzgsdi5oZWlnaHQpLHV0LnBpeGVsU3RvcmVpKDMzMTYsdC5taW4ueCksdXQucGl4ZWxTdG9yZWkoMzMxNSx0Lm1pbi55KSx1dC5waXhlbFN0b3JlaSgzMjg3Nyx0Lm1pbi56KSxuLmlzRGF0YVRleHR1cmV8fG4uaXNEYXRhVGV4dHVyZTNEP3V0LnRleFN1YkltYWdlM0QoaCxyLGUueCxlLnksZS56LHMsYSxvLGwsYyx2LmRhdGEpOm4uaXNDb21wcmVzc2VkVGV4dHVyZT8oY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiB1bnRlc3RlZCBzdXBwb3J0IGZvciBjb21wcmVzc2VkIHNyY1RleHR1cmUuXCIpLHV0LmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKGgscixlLngsZS55LGUueixzLGEsbyxsLHYuZGF0YSkpOnV0LnRleFN1YkltYWdlM0QoaCxyLGUueCxlLnksZS56LHMsYSxvLGwsYyx2KSx1dC5waXhlbFN0b3JlaSgzMzE0LHUpLHV0LnBpeGVsU3RvcmVpKDMyODc4LGQpLHV0LnBpeGVsU3RvcmVpKDMzMTYscCksdXQucGl4ZWxTdG9yZWkoMzMxNSxtKSx1dC5waXhlbFN0b3JlaSgzMjg3NyxnKSwwPT09ciYmaS5nZW5lcmF0ZU1pcG1hcHMmJnV0LmdlbmVyYXRlTWlwbWFwKGgpLFcudW5iaW5kVGV4dHVyZSgpfSx0aGlzLmluaXRUZXh0dXJlPWZ1bmN0aW9uKHQpe1guc2V0VGV4dHVyZTJEKHQsMCksVy51bmJpbmRUZXh0dXJlKCl9LHRoaXMucmVzZXRTdGF0ZT1mdW5jdGlvbigpe3Y9MCx5PTAseD1udWxsLFcucmVzZXQoKSxodC5yZXNldCgpfSxcInVuZGVmaW5lZFwiIT10eXBlb2YgX19USFJFRV9ERVZUT09MU19fJiZfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJvYnNlcnZlXCIse2RldGFpbDp0aGlzfSkpfShjbGFzcyBleHRlbmRzIFhze30pLnByb3RvdHlwZS5pc1dlYkdMMVJlbmRlcmVyPSEwO2NsYXNzIFlzIGV4dGVuZHMgVmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMudHlwZT1cIlNjZW5lXCIsdGhpcy5iYWNrZ3JvdW5kPW51bGwsdGhpcy5lbnZpcm9ubWVudD1udWxsLHRoaXMuZm9nPW51bGwsdGhpcy5vdmVycmlkZU1hdGVyaWFsPW51bGwsdGhpcy5hdXRvVXBkYXRlPSEwLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18mJl9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIm9ic2VydmVcIix7ZGV0YWlsOnRoaXN9KSl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksbnVsbCE9PXQuYmFja2dyb3VuZCYmKHRoaXMuYmFja2dyb3VuZD10LmJhY2tncm91bmQuY2xvbmUoKSksbnVsbCE9PXQuZW52aXJvbm1lbnQmJih0aGlzLmVudmlyb25tZW50PXQuZW52aXJvbm1lbnQuY2xvbmUoKSksbnVsbCE9PXQuZm9nJiYodGhpcy5mb2c9dC5mb2cuY2xvbmUoKSksbnVsbCE9PXQub3ZlcnJpZGVNYXRlcmlhbCYmKHRoaXMub3ZlcnJpZGVNYXRlcmlhbD10Lm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKSksdGhpcy5hdXRvVXBkYXRlPXQuYXV0b1VwZGF0ZSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9dC5tYXRyaXhBdXRvVXBkYXRlLHRoaXN9dG9KU09OKHQpe2NvbnN0IGU9c3VwZXIudG9KU09OKHQpO3JldHVybiBudWxsIT09dGhpcy5mb2cmJihlLm9iamVjdC5mb2c9dGhpcy5mb2cudG9KU09OKCkpLGV9fVlzLnByb3RvdHlwZS5pc1NjZW5lPSEwO2NsYXNzIFpze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5hcnJheT10LHRoaXMuc3RyaWRlPWUsdGhpcy5jb3VudD12b2lkIDAhPT10P3QubGVuZ3RoL2U6MCx0aGlzLnVzYWdlPTM1MDQ0LHRoaXMudXBkYXRlUmFuZ2U9e29mZnNldDowLGNvdW50Oi0xfSx0aGlzLnZlcnNpb249MCx0aGlzLnV1aWQ9eHQoKX1vblVwbG9hZENhbGxiYWNrKCl7fXNldCBuZWVkc1VwZGF0ZSh0KXshMD09PXQmJnRoaXMudmVyc2lvbisrfXNldFVzYWdlKHQpe3JldHVybiB0aGlzLnVzYWdlPXQsdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLmFycmF5PW5ldyB0LmFycmF5LmNvbnN0cnVjdG9yKHQuYXJyYXkpLHRoaXMuY291bnQ9dC5jb3VudCx0aGlzLnN0cmlkZT10LnN0cmlkZSx0aGlzLnVzYWdlPXQudXNhZ2UsdGhpc31jb3B5QXQodCxlLG4pe3QqPXRoaXMuc3RyaWRlLG4qPWUuc3RyaWRlO2ZvcihsZXQgaT0wLHI9dGhpcy5zdHJpZGU7aTxyO2krKyl0aGlzLmFycmF5W3QraV09ZS5hcnJheVtuK2ldO3JldHVybiB0aGlzfXNldCh0LGU9MCl7cmV0dXJuIHRoaXMuYXJyYXkuc2V0KHQsZSksdGhpc31jbG9uZSh0KXt2b2lkIDA9PT10LmFycmF5QnVmZmVycyYmKHQuYXJyYXlCdWZmZXJzPXt9KSx2b2lkIDA9PT10aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCYmKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkPXh0KCkpLHZvaWQgMD09PXQuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSYmKHQuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXT10aGlzLmFycmF5LnNsaWNlKDApLmJ1ZmZlcik7Y29uc3QgZT1uZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3Rvcih0LmFycmF5QnVmZmVyc1t0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZF0pLG49bmV3IHRoaXMuY29uc3RydWN0b3IoZSx0aGlzLnN0cmlkZSk7cmV0dXJuIG4uc2V0VXNhZ2UodGhpcy51c2FnZSksbn1vblVwbG9hZCh0KXtyZXR1cm4gdGhpcy5vblVwbG9hZENhbGxiYWNrPXQsdGhpc310b0pTT04odCl7cmV0dXJuIHZvaWQgMD09PXQuYXJyYXlCdWZmZXJzJiYodC5hcnJheUJ1ZmZlcnM9e30pLHZvaWQgMD09PXRoaXMuYXJyYXkuYnVmZmVyLl91dWlkJiYodGhpcy5hcnJheS5idWZmZXIuX3V1aWQ9eHQoKSksdm9pZCAwPT09dC5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdJiYodC5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5LmJ1ZmZlcikpKSx7dXVpZDp0aGlzLnV1aWQsYnVmZmVyOnRoaXMuYXJyYXkuYnVmZmVyLl91dWlkLHR5cGU6dGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLHN0cmlkZTp0aGlzLnN0cmlkZX19fVpzLnByb3RvdHlwZS5pc0ludGVybGVhdmVkQnVmZmVyPSEwO2NvbnN0IEpzPW5ldyBCdDtjbGFzcyAkc3tjb25zdHJ1Y3Rvcih0LGUsbixpPSExKXt0aGlzLm5hbWU9XCJcIix0aGlzLmRhdGE9dCx0aGlzLml0ZW1TaXplPWUsdGhpcy5vZmZzZXQ9bix0aGlzLm5vcm1hbGl6ZWQ9ITA9PT1pfWdldCBjb3VudCgpe3JldHVybiB0aGlzLmRhdGEuY291bnR9Z2V0IGFycmF5KCl7cmV0dXJuIHRoaXMuZGF0YS5hcnJheX1zZXQgbmVlZHNVcGRhdGUodCl7dGhpcy5kYXRhLm5lZWRzVXBkYXRlPXR9YXBwbHlNYXRyaXg0KHQpe2ZvcihsZXQgZT0wLG49dGhpcy5kYXRhLmNvdW50O2U8bjtlKyspSnMueD10aGlzLmdldFgoZSksSnMueT10aGlzLmdldFkoZSksSnMuej10aGlzLmdldFooZSksSnMuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0WFlaKGUsSnMueCxKcy55LEpzLnopO3JldHVybiB0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KHQpe2ZvcihsZXQgZT0wLG49dGhpcy5jb3VudDtlPG47ZSsrKUpzLng9dGhpcy5nZXRYKGUpLEpzLnk9dGhpcy5nZXRZKGUpLEpzLno9dGhpcy5nZXRaKGUpLEpzLmFwcGx5Tm9ybWFsTWF0cml4KHQpLHRoaXMuc2V0WFlaKGUsSnMueCxKcy55LEpzLnopO3JldHVybiB0aGlzfXRyYW5zZm9ybURpcmVjdGlvbih0KXtmb3IobGV0IGU9MCxuPXRoaXMuY291bnQ7ZTxuO2UrKylKcy54PXRoaXMuZ2V0WChlKSxKcy55PXRoaXMuZ2V0WShlKSxKcy56PXRoaXMuZ2V0WihlKSxKcy50cmFuc2Zvcm1EaXJlY3Rpb24odCksdGhpcy5zZXRYWVooZSxKcy54LEpzLnksSnMueik7cmV0dXJuIHRoaXN9c2V0WCh0LGUpe3JldHVybiB0aGlzLmRhdGEuYXJyYXlbdCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0XT1lLHRoaXN9c2V0WSh0LGUpe3JldHVybiB0aGlzLmRhdGEuYXJyYXlbdCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0KzFdPWUsdGhpc31zZXRaKHQsZSl7cmV0dXJuIHRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrMl09ZSx0aGlzfXNldFcodCxlKXtyZXR1cm4gdGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCszXT1lLHRoaXN9Z2V0WCh0KXtyZXR1cm4gdGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldF19Z2V0WSh0KXtyZXR1cm4gdGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCsxXX1nZXRaKHQpe3JldHVybiB0aGlzLmRhdGEuYXJyYXlbdCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0KzJdfWdldFcodCl7cmV0dXJuIHRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrM119c2V0WFkodCxlLG4pe3JldHVybiB0PXQqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCx0aGlzLmRhdGEuYXJyYXlbdCswXT1lLHRoaXMuZGF0YS5hcnJheVt0KzFdPW4sdGhpc31zZXRYWVoodCxlLG4saSl7cmV0dXJuIHQ9dCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0LHRoaXMuZGF0YS5hcnJheVt0KzBdPWUsdGhpcy5kYXRhLmFycmF5W3QrMV09bix0aGlzLmRhdGEuYXJyYXlbdCsyXT1pLHRoaXN9c2V0WFlaVyh0LGUsbixpLHIpe3JldHVybiB0PXQqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCx0aGlzLmRhdGEuYXJyYXlbdCswXT1lLHRoaXMuZGF0YS5hcnJheVt0KzFdPW4sdGhpcy5kYXRhLmFycmF5W3QrMl09aSx0aGlzLmRhdGEuYXJyYXlbdCszXT1yLHRoaXN9Y2xvbmUodCl7aWYodm9pZCAwPT09dCl7Y29uc29sZS5sb2coXCJUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5jbG9uZSgpOiBDbG9uaW5nIGFuIGludGVybGF2ZWQgYnVmZmVyIGF0dHJpYnV0ZSB3aWxsIGRlaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS5cIik7Y29uc3QgdD1bXTtmb3IobGV0IGU9MDtlPHRoaXMuY291bnQ7ZSsrKXtjb25zdCBuPWUqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldDtmb3IobGV0IGU9MDtlPHRoaXMuaXRlbVNpemU7ZSsrKXQucHVzaCh0aGlzLmRhdGEuYXJyYXlbbitlXSl9cmV0dXJuIG5ldyBwbihuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3Rvcih0KSx0aGlzLml0ZW1TaXplLHRoaXMubm9ybWFsaXplZCl9cmV0dXJuIHZvaWQgMD09PXQuaW50ZXJsZWF2ZWRCdWZmZXJzJiYodC5pbnRlcmxlYXZlZEJ1ZmZlcnM9e30pLHZvaWQgMD09PXQuaW50ZXJsZWF2ZWRCdWZmZXJzW3RoaXMuZGF0YS51dWlkXSYmKHQuaW50ZXJsZWF2ZWRCdWZmZXJzW3RoaXMuZGF0YS51dWlkXT10aGlzLmRhdGEuY2xvbmUodCkpLG5ldyAkcyh0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0sdGhpcy5pdGVtU2l6ZSx0aGlzLm9mZnNldCx0aGlzLm5vcm1hbGl6ZWQpfXRvSlNPTih0KXtpZih2b2lkIDA9PT10KXtjb25zb2xlLmxvZyhcIlRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnRvSlNPTigpOiBTZXJpYWxpemluZyBhbiBpbnRlcmxhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZWludGVybGVhdmUgYnVmZmVyIGRhdGEuXCIpO2NvbnN0IHQ9W107Zm9yKGxldCBlPTA7ZTx0aGlzLmNvdW50O2UrKyl7Y29uc3Qgbj1lKnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQ7Zm9yKGxldCBlPTA7ZTx0aGlzLml0ZW1TaXplO2UrKyl0LnB1c2godGhpcy5kYXRhLmFycmF5W24rZV0pfXJldHVybntpdGVtU2l6ZTp0aGlzLml0ZW1TaXplLHR5cGU6dGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLGFycmF5OnQsbm9ybWFsaXplZDp0aGlzLm5vcm1hbGl6ZWR9fXJldHVybiB2b2lkIDA9PT10LmludGVybGVhdmVkQnVmZmVycyYmKHQuaW50ZXJsZWF2ZWRCdWZmZXJzPXt9KSx2b2lkIDA9PT10LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0mJih0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF09dGhpcy5kYXRhLnRvSlNPTih0KSkse2lzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6ITAsaXRlbVNpemU6dGhpcy5pdGVtU2l6ZSxkYXRhOnRoaXMuZGF0YS51dWlkLG9mZnNldDp0aGlzLm9mZnNldCxub3JtYWxpemVkOnRoaXMubm9ybWFsaXplZH19fSRzLnByb3RvdHlwZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlPSEwO2NsYXNzIEtzIGV4dGVuZHMgZW57Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJTcHJpdGVNYXRlcmlhbFwiLHRoaXMuY29sb3I9bmV3IGNuKDE2Nzc3MjE1KSx0aGlzLm1hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLnJvdGF0aW9uPTAsdGhpcy5zaXplQXR0ZW51YXRpb249ITAsdGhpcy50cmFuc3BhcmVudD0hMCx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuY29sb3IuY29weSh0LmNvbG9yKSx0aGlzLm1hcD10Lm1hcCx0aGlzLmFscGhhTWFwPXQuYWxwaGFNYXAsdGhpcy5yb3RhdGlvbj10LnJvdGF0aW9uLHRoaXMuc2l6ZUF0dGVudWF0aW9uPXQuc2l6ZUF0dGVudWF0aW9uLHRoaXN9fWxldCBRcztLcy5wcm90b3R5cGUuaXNTcHJpdGVNYXRlcmlhbD0hMDtjb25zdCB0YT1uZXcgQnQsZWE9bmV3IEJ0LG5hPW5ldyBCdCxpYT1uZXcgQXQscmE9bmV3IEF0LHNhPW5ldyB2ZSxhYT1uZXcgQnQsb2E9bmV3IEJ0LGxhPW5ldyBCdCxjYT1uZXcgQXQsaGE9bmV3IEF0LHVhPW5ldyBBdDtmdW5jdGlvbiBkYSh0LGUsbixpLHIscyl7aWEuc3ViVmVjdG9ycyh0LG4pLmFkZFNjYWxhciguNSkubXVsdGlwbHkoaSksdm9pZCAwIT09cj8ocmEueD1zKmlhLngtcippYS55LHJhLnk9cippYS54K3MqaWEueSk6cmEuY29weShpYSksdC5jb3B5KGUpLHQueCs9cmEueCx0LnkrPXJhLnksdC5hcHBseU1hdHJpeDQoc2EpfShjbGFzcyBleHRlbmRzIFZle2NvbnN0cnVjdG9yKHQpe2lmKHN1cGVyKCksdGhpcy50eXBlPVwiU3ByaXRlXCIsdm9pZCAwPT09UXMpe1FzPW5ldyBTbjtjb25zdCB0PW5ldyBGbG9hdDMyQXJyYXkoWy0uNSwtLjUsMCwwLDAsLjUsLS41LDAsMSwwLC41LC41LDAsMSwxLC0uNSwuNSwwLDAsMV0pLGU9bmV3IFpzKHQsNSk7UXMuc2V0SW5kZXgoWzAsMSwyLDAsMiwzXSksUXMuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgJHMoZSwzLDAsITEpKSxRcy5zZXRBdHRyaWJ1dGUoXCJ1dlwiLG5ldyAkcyhlLDIsMywhMSkpfXRoaXMuZ2VvbWV0cnk9UXMsdGhpcy5tYXRlcmlhbD12b2lkIDAhPT10P3Q6bmV3IEtzLHRoaXMuY2VudGVyPW5ldyBBdCguNSwuNSl9cmF5Y2FzdCh0LGUpe251bGw9PT10LmNhbWVyYSYmY29uc29sZS5lcnJvcignVEhSRUUuU3ByaXRlOiBcIlJheWNhc3Rlci5jYW1lcmFcIiBuZWVkcyB0byBiZSBzZXQgaW4gb3JkZXIgdG8gcmF5Y2FzdCBhZ2FpbnN0IHNwcml0ZXMuJyksZWEuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMubWF0cml4V29ybGQpLHNhLmNvcHkodC5jYW1lcmEubWF0cml4V29ybGQpLHRoaXMubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXModC5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLHRoaXMubWF0cml4V29ybGQpLG5hLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1vZGVsVmlld01hdHJpeCksdC5jYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSYmITE9PT10aGlzLm1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiYmZWEubXVsdGlwbHlTY2FsYXIoLW5hLnopO2NvbnN0IG49dGhpcy5tYXRlcmlhbC5yb3RhdGlvbjtsZXQgaSxyOzAhPT1uJiYocj1NYXRoLmNvcyhuKSxpPU1hdGguc2luKG4pKTtjb25zdCBzPXRoaXMuY2VudGVyO2RhKGFhLnNldCgtLjUsLS41LDApLG5hLHMsZWEsaSxyKSxkYShvYS5zZXQoLjUsLS41LDApLG5hLHMsZWEsaSxyKSxkYShsYS5zZXQoLjUsLjUsMCksbmEscyxlYSxpLHIpLGNhLnNldCgwLDApLGhhLnNldCgxLDApLHVhLnNldCgxLDEpO2xldCBhPXQucmF5LmludGVyc2VjdFRyaWFuZ2xlKGFhLG9hLGxhLCExLHRhKTtpZihudWxsPT09YSYmKGRhKG9hLnNldCgtLjUsLjUsMCksbmEscyxlYSxpLHIpLGhhLnNldCgwLDEpLGE9dC5yYXkuaW50ZXJzZWN0VHJpYW5nbGUoYWEsbGEsb2EsITEsdGEpLG51bGw9PT1hKSlyZXR1cm47Y29uc3Qgbz10LnJheS5vcmlnaW4uZGlzdGFuY2VUbyh0YSk7bzx0Lm5lYXJ8fG8+dC5mYXJ8fGUucHVzaCh7ZGlzdGFuY2U6byxwb2ludDp0YS5jbG9uZSgpLHV2OlFlLmdldFVWKHRhLGFhLG9hLGxhLGNhLGhhLHVhLG5ldyBBdCksZmFjZTpudWxsLG9iamVjdDp0aGlzfSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx2b2lkIDAhPT10LmNlbnRlciYmdGhpcy5jZW50ZXIuY29weSh0LmNlbnRlciksdGhpcy5tYXRlcmlhbD10Lm1hdGVyaWFsLHRoaXN9fSkucHJvdG90eXBlLmlzU3ByaXRlPSEwO2NvbnN0IHBhPW5ldyBCdCxtYT1uZXcgT3QsZmE9bmV3IE90LGdhPW5ldyBCdCx2YT1uZXcgdmU7Y2xhc3MgeWEgZXh0ZW5kcyBWbntjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQsZSksdGhpcy50eXBlPVwiU2tpbm5lZE1lc2hcIix0aGlzLmJpbmRNb2RlPVwiYXR0YWNoZWRcIix0aGlzLmJpbmRNYXRyaXg9bmV3IHZlLHRoaXMuYmluZE1hdHJpeEludmVyc2U9bmV3IHZlfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5iaW5kTW9kZT10LmJpbmRNb2RlLHRoaXMuYmluZE1hdHJpeC5jb3B5KHQuYmluZE1hdHJpeCksdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KHQuYmluZE1hdHJpeEludmVyc2UpLHRoaXMuc2tlbGV0b249dC5za2VsZXRvbix0aGlzfWJpbmQodCxlKXt0aGlzLnNrZWxldG9uPXQsdm9pZCAwPT09ZSYmKHRoaXMudXBkYXRlTWF0cml4V29ybGQoITApLHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKSxlPXRoaXMubWF0cml4V29ybGQpLHRoaXMuYmluZE1hdHJpeC5jb3B5KGUpLHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weShlKS5pbnZlcnQoKX1wb3NlKCl7dGhpcy5za2VsZXRvbi5wb3NlKCl9bm9ybWFsaXplU2tpbldlaWdodHMoKXtjb25zdCB0PW5ldyBPdCxlPXRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O2ZvcihsZXQgbj0wLGk9ZS5jb3VudDtuPGk7bisrKXt0Lng9ZS5nZXRYKG4pLHQueT1lLmdldFkobiksdC56PWUuZ2V0WihuKSx0Lnc9ZS5nZXRXKG4pO2NvbnN0IGk9MS90Lm1hbmhhdHRhbkxlbmd0aCgpO2khPT0xLzA/dC5tdWx0aXBseVNjYWxhcihpKTp0LnNldCgxLDAsMCwwKSxlLnNldFhZWlcobix0LngsdC55LHQueix0LncpfX11cGRhdGVNYXRyaXhXb3JsZCh0KXtzdXBlci51cGRhdGVNYXRyaXhXb3JsZCh0KSxcImF0dGFjaGVkXCI9PT10aGlzLmJpbmRNb2RlP3RoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTpcImRldGFjaGVkXCI9PT10aGlzLmJpbmRNb2RlP3RoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSh0aGlzLmJpbmRNYXRyaXgpLmludmVydCgpOmNvbnNvbGUud2FybihcIlRIUkVFLlNraW5uZWRNZXNoOiBVbnJlY29nbml6ZWQgYmluZE1vZGU6IFwiK3RoaXMuYmluZE1vZGUpfWJvbmVUcmFuc2Zvcm0odCxlKXtjb25zdCBuPXRoaXMuc2tlbGV0b24saT10aGlzLmdlb21ldHJ5O21hLmZyb21CdWZmZXJBdHRyaWJ1dGUoaS5hdHRyaWJ1dGVzLnNraW5JbmRleCx0KSxmYS5mcm9tQnVmZmVyQXR0cmlidXRlKGkuYXR0cmlidXRlcy5za2luV2VpZ2h0LHQpLHBhLmNvcHkoZSkuYXBwbHlNYXRyaXg0KHRoaXMuYmluZE1hdHJpeCksZS5zZXQoMCwwLDApO2ZvcihsZXQgdD0wO3Q8NDt0Kyspe2NvbnN0IGk9ZmEuZ2V0Q29tcG9uZW50KHQpO2lmKDAhPT1pKXtjb25zdCByPW1hLmdldENvbXBvbmVudCh0KTt2YS5tdWx0aXBseU1hdHJpY2VzKG4uYm9uZXNbcl0ubWF0cml4V29ybGQsbi5ib25lSW52ZXJzZXNbcl0pLGUuYWRkU2NhbGVkVmVjdG9yKGdhLmNvcHkocGEpLmFwcGx5TWF0cml4NCh2YSksaSl9fXJldHVybiBlLmFwcGx5TWF0cml4NCh0aGlzLmJpbmRNYXRyaXhJbnZlcnNlKX19eWEucHJvdG90eXBlLmlzU2tpbm5lZE1lc2g9ITA7Y2xhc3MgeGEgZXh0ZW5kcyBWZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy50eXBlPVwiQm9uZVwifX14YS5wcm90b3R5cGUuaXNCb25lPSEwO2NsYXNzIGJhIGV4dGVuZHMgTnR7Y29uc3RydWN0b3IodD1udWxsLGU9MSxuPTEsaSxyLHMsYSxvLGw9MTAwMyxjPTEwMDMsaCx1KXtzdXBlcihudWxsLHMsYSxvLGwsYyxpLHIsaCx1KSx0aGlzLmltYWdlPXtkYXRhOnQsd2lkdGg6ZSxoZWlnaHQ6bn0sdGhpcy5tYWdGaWx0ZXI9bCx0aGlzLm1pbkZpbHRlcj1jLHRoaXMuZ2VuZXJhdGVNaXBtYXBzPSExLHRoaXMuZmxpcFk9ITEsdGhpcy51bnBhY2tBbGlnbm1lbnQ9MSx0aGlzLm5lZWRzVXBkYXRlPSEwfX1iYS5wcm90b3R5cGUuaXNEYXRhVGV4dHVyZT0hMDtjb25zdCB3YT1uZXcgdmUsX2E9bmV3IHZlO2NsYXNzIE1he2NvbnN0cnVjdG9yKHQ9W10sZT1bXSl7dGhpcy51dWlkPXh0KCksdGhpcy5ib25lcz10LnNsaWNlKDApLHRoaXMuYm9uZUludmVyc2VzPWUsdGhpcy5ib25lTWF0cmljZXM9bnVsbCx0aGlzLmJvbmVUZXh0dXJlPW51bGwsdGhpcy5ib25lVGV4dHVyZVNpemU9MCx0aGlzLmZyYW1lPS0xLHRoaXMuaW5pdCgpfWluaXQoKXtjb25zdCB0PXRoaXMuYm9uZXMsZT10aGlzLmJvbmVJbnZlcnNlcztpZih0aGlzLmJvbmVNYXRyaWNlcz1uZXcgRmxvYXQzMkFycmF5KDE2KnQubGVuZ3RoKSwwPT09ZS5sZW5ndGgpdGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO2Vsc2UgaWYodC5sZW5ndGghPT1lLmxlbmd0aCl7Y29uc29sZS53YXJuKFwiVEhSRUUuU2tlbGV0b246IE51bWJlciBvZiBpbnZlcnNlIGJvbmUgbWF0cmljZXMgZG9lcyBub3QgbWF0Y2ggYW1vdW50IG9mIGJvbmVzLlwiKSx0aGlzLmJvbmVJbnZlcnNlcz1bXTtmb3IobGV0IHQ9MCxlPXRoaXMuYm9uZXMubGVuZ3RoO3Q8ZTt0KyspdGhpcy5ib25lSW52ZXJzZXMucHVzaChuZXcgdmUpfX1jYWxjdWxhdGVJbnZlcnNlcygpe3RoaXMuYm9uZUludmVyc2VzLmxlbmd0aD0wO2ZvcihsZXQgdD0wLGU9dGhpcy5ib25lcy5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT1uZXcgdmU7dGhpcy5ib25lc1t0XSYmZS5jb3B5KHRoaXMuYm9uZXNbdF0ubWF0cml4V29ybGQpLmludmVydCgpLHRoaXMuYm9uZUludmVyc2VzLnB1c2goZSl9fXBvc2UoKXtmb3IobGV0IHQ9MCxlPXRoaXMuYm9uZXMubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9dGhpcy5ib25lc1t0XTtlJiZlLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5ib25lSW52ZXJzZXNbdF0pLmludmVydCgpfWZvcihsZXQgdD0wLGU9dGhpcy5ib25lcy5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT10aGlzLmJvbmVzW3RdO2UmJihlLnBhcmVudCYmZS5wYXJlbnQuaXNCb25lPyhlLm1hdHJpeC5jb3B5KGUucGFyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKSxlLm1hdHJpeC5tdWx0aXBseShlLm1hdHJpeFdvcmxkKSk6ZS5tYXRyaXguY29weShlLm1hdHJpeFdvcmxkKSxlLm1hdHJpeC5kZWNvbXBvc2UoZS5wb3NpdGlvbixlLnF1YXRlcm5pb24sZS5zY2FsZSkpfX11cGRhdGUoKXtjb25zdCB0PXRoaXMuYm9uZXMsZT10aGlzLmJvbmVJbnZlcnNlcyxuPXRoaXMuYm9uZU1hdHJpY2VzLGk9dGhpcy5ib25lVGV4dHVyZTtmb3IobGV0IGk9MCxyPXQubGVuZ3RoO2k8cjtpKyspe2NvbnN0IHI9dFtpXT90W2ldLm1hdHJpeFdvcmxkOl9hO3dhLm11bHRpcGx5TWF0cmljZXMocixlW2ldKSx3YS50b0FycmF5KG4sMTYqaSl9bnVsbCE9PWkmJihpLm5lZWRzVXBkYXRlPSEwKX1jbG9uZSgpe3JldHVybiBuZXcgTWEodGhpcy5ib25lcyx0aGlzLmJvbmVJbnZlcnNlcyl9Y29tcHV0ZUJvbmVUZXh0dXJlKCl7bGV0IHQ9TWF0aC5zcXJ0KDQqdGhpcy5ib25lcy5sZW5ndGgpO3Q9U3QodCksdD1NYXRoLm1heCh0LDQpO2NvbnN0IGU9bmV3IEZsb2F0MzJBcnJheSh0KnQqNCk7ZS5zZXQodGhpcy5ib25lTWF0cmljZXMpO2NvbnN0IG49bmV3IGJhKGUsdCx0LDEwMjMsMTAxNSk7cmV0dXJuIHRoaXMuYm9uZU1hdHJpY2VzPWUsdGhpcy5ib25lVGV4dHVyZT1uLHRoaXMuYm9uZVRleHR1cmVTaXplPXQsdGhpc31nZXRCb25lQnlOYW1lKHQpe2ZvcihsZXQgZT0wLG49dGhpcy5ib25lcy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10aGlzLmJvbmVzW2VdO2lmKG4ubmFtZT09PXQpcmV0dXJuIG59fWRpc3Bvc2UoKXtudWxsIT09dGhpcy5ib25lVGV4dHVyZSYmKHRoaXMuYm9uZVRleHR1cmUuZGlzcG9zZSgpLHRoaXMuYm9uZVRleHR1cmU9bnVsbCl9ZnJvbUpTT04odCxlKXt0aGlzLnV1aWQ9dC51dWlkO2ZvcihsZXQgbj0wLGk9dC5ib25lcy5sZW5ndGg7bjxpO24rKyl7Y29uc3QgaT10LmJvbmVzW25dO2xldCByPWVbaV07dm9pZCAwPT09ciYmKGNvbnNvbGUud2FybihcIlRIUkVFLlNrZWxldG9uOiBObyBib25lIGZvdW5kIHdpdGggVVVJRDpcIixpKSxyPW5ldyB4YSksdGhpcy5ib25lcy5wdXNoKHIpLHRoaXMuYm9uZUludmVyc2VzLnB1c2goKG5ldyB2ZSkuZnJvbUFycmF5KHQuYm9uZUludmVyc2VzW25dKSl9cmV0dXJuIHRoaXMuaW5pdCgpLHRoaXN9dG9KU09OKCl7Y29uc3QgdD17bWV0YWRhdGE6e3ZlcnNpb246NC41LHR5cGU6XCJTa2VsZXRvblwiLGdlbmVyYXRvcjpcIlNrZWxldG9uLnRvSlNPTlwifSxib25lczpbXSxib25lSW52ZXJzZXM6W119O3QudXVpZD10aGlzLnV1aWQ7Y29uc3QgZT10aGlzLmJvbmVzLG49dGhpcy5ib25lSW52ZXJzZXM7Zm9yKGxldCBpPTAscj1lLmxlbmd0aDtpPHI7aSsrKXtjb25zdCByPWVbaV07dC5ib25lcy5wdXNoKHIudXVpZCk7Y29uc3Qgcz1uW2ldO3QuYm9uZUludmVyc2VzLnB1c2gocy50b0FycmF5KCkpfXJldHVybiB0fX1jbGFzcyBTYSBleHRlbmRzIHBue2NvbnN0cnVjdG9yKHQsZSxuLGk9MSl7XCJudW1iZXJcIj09dHlwZW9mIG4mJihpPW4sbj0hMSxjb25zb2xlLmVycm9yKFwiVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlOiBUaGUgY29uc3RydWN0b3Igbm93IGV4cGVjdHMgbm9ybWFsaXplZCBhcyB0aGUgdGhpcmQgYXJndW1lbnQuXCIpKSxzdXBlcih0LGUsbiksdGhpcy5tZXNoUGVyQXR0cmlidXRlPWl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLm1lc2hQZXJBdHRyaWJ1dGU9dC5tZXNoUGVyQXR0cmlidXRlLHRoaXN9dG9KU09OKCl7Y29uc3QgdD1zdXBlci50b0pTT04oKTtyZXR1cm4gdC5tZXNoUGVyQXR0cmlidXRlPXRoaXMubWVzaFBlckF0dHJpYnV0ZSx0LmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlPSEwLHR9fVNhLnByb3RvdHlwZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZT0hMDtjb25zdCBUYT1uZXcgdmUsRWE9bmV3IHZlLEFhPVtdLExhPW5ldyBWbjsoY2xhc3MgZXh0ZW5kcyBWbntjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIodCxlKSx0aGlzLmluc3RhbmNlTWF0cml4PW5ldyBTYShuZXcgRmxvYXQzMkFycmF5KDE2Km4pLDE2KSx0aGlzLmluc3RhbmNlQ29sb3I9bnVsbCx0aGlzLmNvdW50PW4sdGhpcy5mcnVzdHVtQ3VsbGVkPSExfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5pbnN0YW5jZU1hdHJpeC5jb3B5KHQuaW5zdGFuY2VNYXRyaXgpLG51bGwhPT10Lmluc3RhbmNlQ29sb3ImJih0aGlzLmluc3RhbmNlQ29sb3I9dC5pbnN0YW5jZUNvbG9yLmNsb25lKCkpLHRoaXMuY291bnQ9dC5jb3VudCx0aGlzfWdldENvbG9yQXQodCxlKXtlLmZyb21BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksMyp0KX1nZXRNYXRyaXhBdCh0LGUpe2UuZnJvbUFycmF5KHRoaXMuaW5zdGFuY2VNYXRyaXguYXJyYXksMTYqdCl9cmF5Y2FzdCh0LGUpe2NvbnN0IG49dGhpcy5tYXRyaXhXb3JsZCxpPXRoaXMuY291bnQ7aWYoTGEuZ2VvbWV0cnk9dGhpcy5nZW9tZXRyeSxMYS5tYXRlcmlhbD10aGlzLm1hdGVyaWFsLHZvaWQgMCE9PUxhLm1hdGVyaWFsKWZvcihsZXQgcj0wO3I8aTtyKyspe3RoaXMuZ2V0TWF0cml4QXQocixUYSksRWEubXVsdGlwbHlNYXRyaWNlcyhuLFRhKSxMYS5tYXRyaXhXb3JsZD1FYSxMYS5yYXljYXN0KHQsQWEpO2ZvcihsZXQgdD0wLG49QWEubGVuZ3RoO3Q8bjt0Kyspe2NvbnN0IG49QWFbdF07bi5pbnN0YW5jZUlkPXIsbi5vYmplY3Q9dGhpcyxlLnB1c2gobil9QWEubGVuZ3RoPTB9fXNldENvbG9yQXQodCxlKXtudWxsPT09dGhpcy5pbnN0YW5jZUNvbG9yJiYodGhpcy5pbnN0YW5jZUNvbG9yPW5ldyBTYShuZXcgRmxvYXQzMkFycmF5KDMqdGhpcy5pbnN0YW5jZU1hdHJpeC5jb3VudCksMykpLGUudG9BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksMyp0KX1zZXRNYXRyaXhBdCh0LGUpe2UudG9BcnJheSh0aGlzLmluc3RhbmNlTWF0cml4LmFycmF5LDE2KnQpfXVwZGF0ZU1vcnBoVGFyZ2V0cygpe31kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZGlzcG9zZVwifSl9fSkucHJvdG90eXBlLmlzSW5zdGFuY2VkTWVzaD0hMDtjbGFzcyBSYSBleHRlbmRzIGVue2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50eXBlPVwiTGluZUJhc2ljTWF0ZXJpYWxcIix0aGlzLmNvbG9yPW5ldyBjbigxNjc3NzIxNSksdGhpcy5saW5ld2lkdGg9MSx0aGlzLmxpbmVjYXA9XCJyb3VuZFwiLHRoaXMubGluZWpvaW49XCJyb3VuZFwiLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jb2xvci5jb3B5KHQuY29sb3IpLHRoaXMubGluZXdpZHRoPXQubGluZXdpZHRoLHRoaXMubGluZWNhcD10LmxpbmVjYXAsdGhpcy5saW5lam9pbj10LmxpbmVqb2luLHRoaXN9fVJhLnByb3RvdHlwZS5pc0xpbmVCYXNpY01hdGVyaWFsPSEwO2NvbnN0IENhPW5ldyBCdCxQYT1uZXcgQnQsSWE9bmV3IHZlLERhPW5ldyBnZSxOYT1uZXcgbGU7Y2xhc3MgRmEgZXh0ZW5kcyBWZXtjb25zdHJ1Y3Rvcih0PW5ldyBTbixlPW5ldyBSYSl7c3VwZXIoKSx0aGlzLnR5cGU9XCJMaW5lXCIsdGhpcy5nZW9tZXRyeT10LHRoaXMubWF0ZXJpYWw9ZSx0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5tYXRlcmlhbD10Lm1hdGVyaWFsLHRoaXMuZ2VvbWV0cnk9dC5nZW9tZXRyeSx0aGlzfWNvbXB1dGVMaW5lRGlzdGFuY2VzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5O2lmKHQuaXNCdWZmZXJHZW9tZXRyeSlpZihudWxsPT09dC5pbmRleCl7Y29uc3QgZT10LmF0dHJpYnV0ZXMucG9zaXRpb24sbj1bMF07Zm9yKGxldCB0PTEsaT1lLmNvdW50O3Q8aTt0KyspQ2EuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQtMSksUGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLG5bdF09blt0LTFdLG5bdF0rPUNhLmRpc3RhbmNlVG8oUGEpO3Quc2V0QXR0cmlidXRlKFwibGluZURpc3RhbmNlXCIsbmV3IGduKG4sMSkpfWVsc2UgY29uc29sZS53YXJuKFwiVEhSRUUuTGluZS5jb21wdXRlTGluZURpc3RhbmNlcygpOiBDb21wdXRhdGlvbiBvbmx5IHBvc3NpYmxlIHdpdGggbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnkuXCIpO2Vsc2UgdC5pc0dlb21ldHJ5JiZjb25zb2xlLmVycm9yKFwiVEhSRUUuTGluZS5jb21wdXRlTGluZURpc3RhbmNlcygpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuXCIpO3JldHVybiB0aGlzfXJheWNhc3QodCxlKXtjb25zdCBuPXRoaXMuZ2VvbWV0cnksaT10aGlzLm1hdHJpeFdvcmxkLHI9dC5wYXJhbXMuTGluZS50aHJlc2hvbGQscz1uLmRyYXdSYW5nZTtpZihudWxsPT09bi5ib3VuZGluZ1NwaGVyZSYmbi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxOYS5jb3B5KG4uYm91bmRpbmdTcGhlcmUpLE5hLmFwcGx5TWF0cml4NChpKSxOYS5yYWRpdXMrPXIsITE9PT10LnJheS5pbnRlcnNlY3RzU3BoZXJlKE5hKSlyZXR1cm47SWEuY29weShpKS5pbnZlcnQoKSxEYS5jb3B5KHQucmF5KS5hcHBseU1hdHJpeDQoSWEpO2NvbnN0IGE9ci8oKHRoaXMuc2NhbGUueCt0aGlzLnNjYWxlLnkrdGhpcy5zY2FsZS56KS8zKSxvPWEqYSxsPW5ldyBCdCxjPW5ldyBCdCxoPW5ldyBCdCx1PW5ldyBCdCxkPXRoaXMuaXNMaW5lU2VnbWVudHM/MjoxO2lmKG4uaXNCdWZmZXJHZW9tZXRyeSl7Y29uc3QgaT1uLmluZGV4LHI9bi5hdHRyaWJ1dGVzLnBvc2l0aW9uO2lmKG51bGwhPT1pKXtmb3IobGV0IG49TWF0aC5tYXgoMCxzLnN0YXJ0KSxhPU1hdGgubWluKGkuY291bnQscy5zdGFydCtzLmNvdW50KS0xO248YTtuKz1kKXtjb25zdCBzPWkuZ2V0WChuKSxhPWkuZ2V0WChuKzEpO2wuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLHMpLGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLGEpO2lmKERhLmRpc3RhbmNlU3FUb1NlZ21lbnQobCxjLHUsaCk+byljb250aW51ZTt1LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtjb25zdCBkPXQucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKHUpO2Q8dC5uZWFyfHxkPnQuZmFyfHxlLnB1c2goe2Rpc3RhbmNlOmQscG9pbnQ6aC5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxpbmRleDpuLGZhY2U6bnVsbCxmYWNlSW5kZXg6bnVsbCxvYmplY3Q6dGhpc30pfX1lbHNle2ZvcihsZXQgbj1NYXRoLm1heCgwLHMuc3RhcnQpLGk9TWF0aC5taW4oci5jb3VudCxzLnN0YXJ0K3MuY291bnQpLTE7bjxpO24rPWQpe2wuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLG4pLGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLG4rMSk7aWYoRGEuZGlzdGFuY2VTcVRvU2VnbWVudChsLGMsdSxoKT5vKWNvbnRpbnVlO3UuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO2NvbnN0IGk9dC5yYXkub3JpZ2luLmRpc3RhbmNlVG8odSk7aTx0Lm5lYXJ8fGk+dC5mYXJ8fGUucHVzaCh7ZGlzdGFuY2U6aSxwb2ludDpoLmNsb25lKCkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpLGluZGV4Om4sZmFjZTpudWxsLGZhY2VJbmRleDpudWxsLG9iamVjdDp0aGlzfSl9fX1lbHNlIG4uaXNHZW9tZXRyeSYmY29uc29sZS5lcnJvcihcIlRIUkVFLkxpbmUucmF5Y2FzdCgpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuXCIpfXVwZGF0ZU1vcnBoVGFyZ2V0cygpe2NvbnN0IHQ9dGhpcy5nZW9tZXRyeTtpZih0LmlzQnVmZmVyR2VvbWV0cnkpe2NvbnN0IGU9dC5tb3JwaEF0dHJpYnV0ZXMsbj1PYmplY3Qua2V5cyhlKTtpZihuLmxlbmd0aD4wKXtjb25zdCB0PWVbblswXV07aWYodm9pZCAwIT09dCl7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM9W10sdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnk9e307Zm9yKGxldCBlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXtjb25zdCBuPXRbZV0ubmFtZXx8U3RyaW5nKGUpO3RoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goMCksdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbbl09ZX19fX1lbHNle2NvbnN0IGU9dC5tb3JwaFRhcmdldHM7dm9pZCAwIT09ZSYmZS5sZW5ndGg+MCYmY29uc29sZS5lcnJvcihcIlRIUkVFLkxpbmUudXBkYXRlTW9ycGhUYXJnZXRzKCkgZG9lcyBub3Qgc3VwcG9ydCBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuXCIpfX19RmEucHJvdG90eXBlLmlzTGluZT0hMDtjb25zdCBPYT1uZXcgQnQsVWE9bmV3IEJ0O2NsYXNzIGthIGV4dGVuZHMgRmF7Y29uc3RydWN0b3IodCxlKXtzdXBlcih0LGUpLHRoaXMudHlwZT1cIkxpbmVTZWdtZW50c1wifWNvbXB1dGVMaW5lRGlzdGFuY2VzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5O2lmKHQuaXNCdWZmZXJHZW9tZXRyeSlpZihudWxsPT09dC5pbmRleCl7Y29uc3QgZT10LmF0dHJpYnV0ZXMucG9zaXRpb24sbj1bXTtmb3IobGV0IHQ9MCxpPWUuY291bnQ7dDxpO3QrPTIpT2EuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLHQpLFVhLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSx0KzEpLG5bdF09MD09PXQ/MDpuW3QtMV0sblt0KzFdPW5bdF0rT2EuZGlzdGFuY2VUbyhVYSk7dC5zZXRBdHRyaWJ1dGUoXCJsaW5lRGlzdGFuY2VcIixuZXcgZ24obiwxKSl9ZWxzZSBjb25zb2xlLndhcm4oXCJUSFJFRS5MaW5lU2VnbWVudHMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LlwiKTtlbHNlIHQuaXNHZW9tZXRyeSYmY29uc29sZS5lcnJvcihcIlRIUkVFLkxpbmVTZWdtZW50cy5jb21wdXRlTGluZURpc3RhbmNlcygpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuXCIpO3JldHVybiB0aGlzfX1rYS5wcm90b3R5cGUuaXNMaW5lU2VnbWVudHM9ITA7Y2xhc3MgemEgZXh0ZW5kcyBGYXtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQsZSksdGhpcy50eXBlPVwiTGluZUxvb3BcIn19emEucHJvdG90eXBlLmlzTGluZUxvb3A9ITA7Y2xhc3MgQmEgZXh0ZW5kcyBlbntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMudHlwZT1cIlBvaW50c01hdGVyaWFsXCIsdGhpcy5jb2xvcj1uZXcgY24oMTY3NzcyMTUpLHRoaXMubWFwPW51bGwsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuc2l6ZT0xLHRoaXMuc2l6ZUF0dGVudWF0aW9uPSEwLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jb2xvci5jb3B5KHQuY29sb3IpLHRoaXMubWFwPXQubWFwLHRoaXMuYWxwaGFNYXA9dC5hbHBoYU1hcCx0aGlzLnNpemU9dC5zaXplLHRoaXMuc2l6ZUF0dGVudWF0aW9uPXQuc2l6ZUF0dGVudWF0aW9uLHRoaXN9fUJhLnByb3RvdHlwZS5pc1BvaW50c01hdGVyaWFsPSEwO2NvbnN0IEhhPW5ldyB2ZSxWYT1uZXcgZ2UsR2E9bmV3IGxlLFdhPW5ldyBCdDtjbGFzcyBqYSBleHRlbmRzIFZle2NvbnN0cnVjdG9yKHQ9bmV3IFNuLGU9bmV3IEJhKXtzdXBlcigpLHRoaXMudHlwZT1cIlBvaW50c1wiLHRoaXMuZ2VvbWV0cnk9dCx0aGlzLm1hdGVyaWFsPWUsdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMubWF0ZXJpYWw9dC5tYXRlcmlhbCx0aGlzLmdlb21ldHJ5PXQuZ2VvbWV0cnksdGhpc31yYXljYXN0KHQsZSl7Y29uc3Qgbj10aGlzLmdlb21ldHJ5LGk9dGhpcy5tYXRyaXhXb3JsZCxyPXQucGFyYW1zLlBvaW50cy50aHJlc2hvbGQscz1uLmRyYXdSYW5nZTtpZihudWxsPT09bi5ib3VuZGluZ1NwaGVyZSYmbi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKSxHYS5jb3B5KG4uYm91bmRpbmdTcGhlcmUpLEdhLmFwcGx5TWF0cml4NChpKSxHYS5yYWRpdXMrPXIsITE9PT10LnJheS5pbnRlcnNlY3RzU3BoZXJlKEdhKSlyZXR1cm47SGEuY29weShpKS5pbnZlcnQoKSxWYS5jb3B5KHQucmF5KS5hcHBseU1hdHJpeDQoSGEpO2NvbnN0IGE9ci8oKHRoaXMuc2NhbGUueCt0aGlzLnNjYWxlLnkrdGhpcy5zY2FsZS56KS8zKSxvPWEqYTtpZihuLmlzQnVmZmVyR2VvbWV0cnkpe2NvbnN0IHI9bi5pbmRleCxhPW4uYXR0cmlidXRlcy5wb3NpdGlvbjtpZihudWxsIT09cil7Zm9yKGxldCBuPU1hdGgubWF4KDAscy5zdGFydCksbD1NYXRoLm1pbihyLmNvdW50LHMuc3RhcnQrcy5jb3VudCk7bjxsO24rKyl7Y29uc3Qgcz1yLmdldFgobik7V2EuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhLHMpLHFhKFdhLHMsbyxpLHQsZSx0aGlzKX19ZWxzZXtmb3IobGV0IG49TWF0aC5tYXgoMCxzLnN0YXJ0KSxyPU1hdGgubWluKGEuY291bnQscy5zdGFydCtzLmNvdW50KTtuPHI7bisrKVdhLmZyb21CdWZmZXJBdHRyaWJ1dGUoYSxuKSxxYShXYSxuLG8saSx0LGUsdGhpcyl9fWVsc2UgY29uc29sZS5lcnJvcihcIlRIUkVFLlBvaW50cy5yYXljYXN0KCkgbm8gbG9uZ2VyIHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC5cIil9dXBkYXRlTW9ycGhUYXJnZXRzKCl7Y29uc3QgdD10aGlzLmdlb21ldHJ5O2lmKHQuaXNCdWZmZXJHZW9tZXRyeSl7Y29uc3QgZT10Lm1vcnBoQXR0cmlidXRlcyxuPU9iamVjdC5rZXlzKGUpO2lmKG4ubGVuZ3RoPjApe2NvbnN0IHQ9ZVtuWzBdXTtpZih2b2lkIDAhPT10KXt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1bXSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeT17fTtmb3IobGV0IGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49dFtlXS5uYW1lfHxTdHJpbmcoZSk7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKSx0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtuXT1lfX19fWVsc2V7Y29uc3QgZT10Lm1vcnBoVGFyZ2V0czt2b2lkIDAhPT1lJiZlLmxlbmd0aD4wJiZjb25zb2xlLmVycm9yKFwiVEhSRUUuUG9pbnRzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpIGRvZXMgbm90IHN1cHBvcnQgVEhSRUUuR2VvbWV0cnkuIFVzZSBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLlwiKX19fWZ1bmN0aW9uIHFhKHQsZSxuLGkscixzLGEpe2NvbnN0IG89VmEuZGlzdGFuY2VTcVRvUG9pbnQodCk7aWYobzxuKXtjb25zdCBuPW5ldyBCdDtWYS5jbG9zZXN0UG9pbnRUb1BvaW50KHQsbiksbi5hcHBseU1hdHJpeDQoaSk7Y29uc3QgbD1yLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhuKTtpZihsPHIubmVhcnx8bD5yLmZhcilyZXR1cm47cy5wdXNoKHtkaXN0YW5jZTpsLGRpc3RhbmNlVG9SYXk6TWF0aC5zcXJ0KG8pLHBvaW50Om4saW5kZXg6ZSxmYWNlOm51bGwsb2JqZWN0OmF9KX19amEucHJvdG90eXBlLmlzUG9pbnRzPSEwOyhjbGFzcyBleHRlbmRzIE50e2NvbnN0cnVjdG9yKHQsZSxuLGkscixzLGEsbyxsKXtzdXBlcih0LGUsbixpLHIscyxhLG8sbCksdGhpcy5mb3JtYXQ9dm9pZCAwIT09YT9hOjEwMjIsdGhpcy5taW5GaWx0ZXI9dm9pZCAwIT09cz9zOjEwMDYsdGhpcy5tYWdGaWx0ZXI9dm9pZCAwIT09cj9yOjEwMDYsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITE7Y29uc3QgYz10aGlzO1wicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFja1wiaW4gdCYmdC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChmdW5jdGlvbiBlKCl7Yy5uZWVkc1VwZGF0ZT0hMCx0LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soZSl9KSl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5pbWFnZSkuY29weSh0aGlzKX11cGRhdGUoKXtjb25zdCB0PXRoaXMuaW1hZ2U7ITE9PT1cInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tcImluIHQmJnQucmVhZHlTdGF0ZT49dC5IQVZFX0NVUlJFTlRfREFUQSYmKHRoaXMubmVlZHNVcGRhdGU9ITApfX0pLnByb3RvdHlwZS5pc1ZpZGVvVGV4dHVyZT0hMDtjbGFzcyBYYSBleHRlbmRzIE50e2NvbnN0cnVjdG9yKHQsZSxuLGkscixzLGEsbyxsLGMsaCx1KXtzdXBlcihudWxsLHMsYSxvLGwsYyxpLHIsaCx1KSx0aGlzLmltYWdlPXt3aWR0aDplLGhlaWdodDpufSx0aGlzLm1pcG1hcHM9dCx0aGlzLmZsaXBZPSExLHRoaXMuZ2VuZXJhdGVNaXBtYXBzPSExfX1YYS5wcm90b3R5cGUuaXNDb21wcmVzc2VkVGV4dHVyZT0hMDsoY2xhc3MgZXh0ZW5kcyBOdHtjb25zdHJ1Y3Rvcih0LGUsbixpLHIscyxhLG8sbCl7c3VwZXIodCxlLG4saSxyLHMsYSxvLGwpLHRoaXMubmVlZHNVcGRhdGU9ITB9fSkucHJvdG90eXBlLmlzQ2FudmFzVGV4dHVyZT0hMDsoY2xhc3MgZXh0ZW5kcyBOdHtjb25zdHJ1Y3Rvcih0LGUsbixpLHIscyxhLG8sbCxjKXtpZigxMDI2IT09KGM9dm9pZCAwIT09Yz9jOjEwMjYpJiYxMDI3IT09Yyl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdFwiKTt2b2lkIDA9PT1uJiYxMDI2PT09YyYmKG49MTAxMiksdm9pZCAwPT09biYmMTAyNz09PWMmJihuPTEwMjApLHN1cGVyKG51bGwsaSxyLHMsYSxvLGMsbixsKSx0aGlzLmltYWdlPXt3aWR0aDp0LGhlaWdodDplfSx0aGlzLm1hZ0ZpbHRlcj12b2lkIDAhPT1hP2E6MTAwMyx0aGlzLm1pbkZpbHRlcj12b2lkIDAhPT1vP286MTAwMyx0aGlzLmZsaXBZPSExLHRoaXMuZ2VuZXJhdGVNaXBtYXBzPSExfX0pLnByb3RvdHlwZS5pc0RlcHRoVGV4dHVyZT0hMCxuZXcgQnQsbmV3IEJ0LG5ldyBCdCxuZXcgUWU7Y2xhc3MgWWF7Y29uc3RydWN0b3IoKXt0aGlzLnR5cGU9XCJDdXJ2ZVwiLHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zPTIwMH1nZXRQb2ludCgpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLlwiKSxudWxsfWdldFBvaW50QXQodCxlKXtjb25zdCBuPXRoaXMuZ2V0VXRvVG1hcHBpbmcodCk7cmV0dXJuIHRoaXMuZ2V0UG9pbnQobixlKX1nZXRQb2ludHModD01KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248PXQ7bisrKWUucHVzaCh0aGlzLmdldFBvaW50KG4vdCkpO3JldHVybiBlfWdldFNwYWNlZFBvaW50cyh0PTUpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjw9dDtuKyspZS5wdXNoKHRoaXMuZ2V0UG9pbnRBdChuL3QpKTtyZXR1cm4gZX1nZXRMZW5ndGgoKXtjb25zdCB0PXRoaXMuZ2V0TGVuZ3RocygpO3JldHVybiB0W3QubGVuZ3RoLTFdfWdldExlbmd0aHModD10aGlzLmFyY0xlbmd0aERpdmlzaW9ucyl7aWYodGhpcy5jYWNoZUFyY0xlbmd0aHMmJnRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aD09PXQrMSYmIXRoaXMubmVlZHNVcGRhdGUpcmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO3RoaXMubmVlZHNVcGRhdGU9ITE7Y29uc3QgZT1bXTtsZXQgbixpPXRoaXMuZ2V0UG9pbnQoMCkscj0wO2UucHVzaCgwKTtmb3IobGV0IHM9MTtzPD10O3MrKyluPXRoaXMuZ2V0UG9pbnQocy90KSxyKz1uLmRpc3RhbmNlVG8oaSksZS5wdXNoKHIpLGk9bjtyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM9ZSxlfXVwZGF0ZUFyY0xlbmd0aHMoKXt0aGlzLm5lZWRzVXBkYXRlPSEwLHRoaXMuZ2V0TGVuZ3RocygpfWdldFV0b1RtYXBwaW5nKHQsZSl7Y29uc3Qgbj10aGlzLmdldExlbmd0aHMoKTtsZXQgaT0wO2NvbnN0IHI9bi5sZW5ndGg7bGV0IHM7cz1lfHx0Km5bci0xXTtsZXQgYSxvPTAsbD1yLTE7Zm9yKDtvPD1sOylpZihpPU1hdGguZmxvb3IobysobC1vKS8yKSxhPW5baV0tcyxhPDApbz1pKzE7ZWxzZXtpZighKGE+MCkpe2w9aTticmVha31sPWktMX1pZihpPWwsbltpXT09PXMpcmV0dXJuIGkvKHItMSk7Y29uc3QgYz1uW2ldO3JldHVybihpKyhzLWMpLyhuW2krMV0tYykpLyhyLTEpfWdldFRhbmdlbnQodCxlKXtjb25zdCBuPTFlLTQ7bGV0IGk9dC1uLHI9dCtuO2k8MCYmKGk9MCkscj4xJiYocj0xKTtjb25zdCBzPXRoaXMuZ2V0UG9pbnQoaSksYT10aGlzLmdldFBvaW50KHIpLG89ZXx8KHMuaXNWZWN0b3IyP25ldyBBdDpuZXcgQnQpO3JldHVybiBvLmNvcHkoYSkuc3ViKHMpLm5vcm1hbGl6ZSgpLG99Z2V0VGFuZ2VudEF0KHQsZSl7Y29uc3Qgbj10aGlzLmdldFV0b1RtYXBwaW5nKHQpO3JldHVybiB0aGlzLmdldFRhbmdlbnQobixlKX1jb21wdXRlRnJlbmV0RnJhbWVzKHQsZSl7Y29uc3Qgbj1uZXcgQnQsaT1bXSxyPVtdLHM9W10sYT1uZXcgQnQsbz1uZXcgdmU7Zm9yKGxldCBlPTA7ZTw9dDtlKyspe2NvbnN0IG49ZS90O2lbZV09dGhpcy5nZXRUYW5nZW50QXQobixuZXcgQnQpfXJbMF09bmV3IEJ0LHNbMF09bmV3IEJ0O2xldCBsPU51bWJlci5NQVhfVkFMVUU7Y29uc3QgYz1NYXRoLmFicyhpWzBdLngpLGg9TWF0aC5hYnMoaVswXS55KSx1PU1hdGguYWJzKGlbMF0ueik7Yzw9bCYmKGw9YyxuLnNldCgxLDAsMCkpLGg8PWwmJihsPWgsbi5zZXQoMCwxLDApKSx1PD1sJiZuLnNldCgwLDAsMSksYS5jcm9zc1ZlY3RvcnMoaVswXSxuKS5ub3JtYWxpemUoKSxyWzBdLmNyb3NzVmVjdG9ycyhpWzBdLGEpLHNbMF0uY3Jvc3NWZWN0b3JzKGlbMF0sclswXSk7Zm9yKGxldCBlPTE7ZTw9dDtlKyspe2lmKHJbZV09cltlLTFdLmNsb25lKCksc1tlXT1zW2UtMV0uY2xvbmUoKSxhLmNyb3NzVmVjdG9ycyhpW2UtMV0saVtlXSksYS5sZW5ndGgoKT5OdW1iZXIuRVBTSUxPTil7YS5ub3JtYWxpemUoKTtjb25zdCB0PU1hdGguYWNvcyhidChpW2UtMV0uZG90KGlbZV0pLC0xLDEpKTtyW2VdLmFwcGx5TWF0cml4NChvLm1ha2VSb3RhdGlvbkF4aXMoYSx0KSl9c1tlXS5jcm9zc1ZlY3RvcnMoaVtlXSxyW2VdKX1pZighMD09PWUpe2xldCBlPU1hdGguYWNvcyhidChyWzBdLmRvdChyW3RdKSwtMSwxKSk7ZS89dCxpWzBdLmRvdChhLmNyb3NzVmVjdG9ycyhyWzBdLHJbdF0pKT4wJiYoZT0tZSk7Zm9yKGxldCBuPTE7bjw9dDtuKyspcltuXS5hcHBseU1hdHJpeDQoby5tYWtlUm90YXRpb25BeGlzKGlbbl0sZSpuKSksc1tuXS5jcm9zc1ZlY3RvcnMoaVtuXSxyW25dKX1yZXR1cm57dGFuZ2VudHM6aSxub3JtYWxzOnIsYmlub3JtYWxzOnN9fWNsb25lKCl7cmV0dXJuKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpfWNvcHkodCl7cmV0dXJuIHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zPXQuYXJjTGVuZ3RoRGl2aXNpb25zLHRoaXN9dG9KU09OKCl7Y29uc3QgdD17bWV0YWRhdGE6e3ZlcnNpb246NC41LHR5cGU6XCJDdXJ2ZVwiLGdlbmVyYXRvcjpcIkN1cnZlLnRvSlNPTlwifX07cmV0dXJuIHQuYXJjTGVuZ3RoRGl2aXNpb25zPXRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zLHQudHlwZT10aGlzLnR5cGUsdH1mcm9tSlNPTih0KXtyZXR1cm4gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM9dC5hcmNMZW5ndGhEaXZpc2lvbnMsdGhpc319Y2xhc3MgWmEgZXh0ZW5kcyBZYXtjb25zdHJ1Y3Rvcih0PTAsZT0wLG49MSxpPTEscj0wLHM9MipNYXRoLlBJLGE9ITEsbz0wKXtzdXBlcigpLHRoaXMudHlwZT1cIkVsbGlwc2VDdXJ2ZVwiLHRoaXMuYVg9dCx0aGlzLmFZPWUsdGhpcy54UmFkaXVzPW4sdGhpcy55UmFkaXVzPWksdGhpcy5hU3RhcnRBbmdsZT1yLHRoaXMuYUVuZEFuZ2xlPXMsdGhpcy5hQ2xvY2t3aXNlPWEsdGhpcy5hUm90YXRpb249b31nZXRQb2ludCh0LGUpe2NvbnN0IG49ZXx8bmV3IEF0LGk9MipNYXRoLlBJO2xldCByPXRoaXMuYUVuZEFuZ2xlLXRoaXMuYVN0YXJ0QW5nbGU7Y29uc3Qgcz1NYXRoLmFicyhyKTxOdW1iZXIuRVBTSUxPTjtmb3IoO3I8MDspcis9aTtmb3IoO3I+aTspci09aTtyPE51bWJlci5FUFNJTE9OJiYocj1zPzA6aSksITAhPT10aGlzLmFDbG9ja3dpc2V8fHN8fChyPT09aT9yPS1pOnItPWkpO2NvbnN0IGE9dGhpcy5hU3RhcnRBbmdsZSt0KnI7bGV0IG89dGhpcy5hWCt0aGlzLnhSYWRpdXMqTWF0aC5jb3MoYSksbD10aGlzLmFZK3RoaXMueVJhZGl1cypNYXRoLnNpbihhKTtpZigwIT09dGhpcy5hUm90YXRpb24pe2NvbnN0IHQ9TWF0aC5jb3ModGhpcy5hUm90YXRpb24pLGU9TWF0aC5zaW4odGhpcy5hUm90YXRpb24pLG49by10aGlzLmFYLGk9bC10aGlzLmFZO289bip0LWkqZSt0aGlzLmFYLGw9biplK2kqdCt0aGlzLmFZfXJldHVybiBuLnNldChvLGwpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5hWD10LmFYLHRoaXMuYVk9dC5hWSx0aGlzLnhSYWRpdXM9dC54UmFkaXVzLHRoaXMueVJhZGl1cz10LnlSYWRpdXMsdGhpcy5hU3RhcnRBbmdsZT10LmFTdGFydEFuZ2xlLHRoaXMuYUVuZEFuZ2xlPXQuYUVuZEFuZ2xlLHRoaXMuYUNsb2Nrd2lzZT10LmFDbG9ja3dpc2UsdGhpcy5hUm90YXRpb249dC5hUm90YXRpb24sdGhpc310b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LmFYPXRoaXMuYVgsdC5hWT10aGlzLmFZLHQueFJhZGl1cz10aGlzLnhSYWRpdXMsdC55UmFkaXVzPXRoaXMueVJhZGl1cyx0LmFTdGFydEFuZ2xlPXRoaXMuYVN0YXJ0QW5nbGUsdC5hRW5kQW5nbGU9dGhpcy5hRW5kQW5nbGUsdC5hQ2xvY2t3aXNlPXRoaXMuYUNsb2Nrd2lzZSx0LmFSb3RhdGlvbj10aGlzLmFSb3RhdGlvbix0fWZyb21KU09OKHQpe3JldHVybiBzdXBlci5mcm9tSlNPTih0KSx0aGlzLmFYPXQuYVgsdGhpcy5hWT10LmFZLHRoaXMueFJhZGl1cz10LnhSYWRpdXMsdGhpcy55UmFkaXVzPXQueVJhZGl1cyx0aGlzLmFTdGFydEFuZ2xlPXQuYVN0YXJ0QW5nbGUsdGhpcy5hRW5kQW5nbGU9dC5hRW5kQW5nbGUsdGhpcy5hQ2xvY2t3aXNlPXQuYUNsb2Nrd2lzZSx0aGlzLmFSb3RhdGlvbj10LmFSb3RhdGlvbix0aGlzfX1aYS5wcm90b3R5cGUuaXNFbGxpcHNlQ3VydmU9ITA7Y2xhc3MgSmEgZXh0ZW5kcyBaYXtjb25zdHJ1Y3Rvcih0LGUsbixpLHIscyl7c3VwZXIodCxlLG4sbixpLHIscyksdGhpcy50eXBlPVwiQXJjQ3VydmVcIn19ZnVuY3Rpb24gJGEoKXtsZXQgdD0wLGU9MCxuPTAsaT0wO2Z1bmN0aW9uIHIocixzLGEsbyl7dD1yLGU9YSxuPS0zKnIrMypzLTIqYS1vLGk9MipyLTIqcythK299cmV0dXJue2luaXRDYXRtdWxsUm9tOmZ1bmN0aW9uKHQsZSxuLGkscyl7cihlLG4scyoobi10KSxzKihpLWUpKX0saW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOmZ1bmN0aW9uKHQsZSxuLGkscyxhLG8pe2xldCBsPShlLXQpL3MtKG4tdCkvKHMrYSkrKG4tZSkvYSxjPShuLWUpL2EtKGktZSkvKGErbykrKGktbikvbztsKj1hLGMqPWEscihlLG4sbCxjKX0sY2FsYzpmdW5jdGlvbihyKXtjb25zdCBzPXIqcjtyZXR1cm4gdCtlKnIrbipzK2kqKHMqcil9fX1KYS5wcm90b3R5cGUuaXNBcmNDdXJ2ZT0hMDtjb25zdCBLYT1uZXcgQnQsUWE9bmV3ICRhLHRvPW5ldyAkYSxlbz1uZXcgJGE7Y2xhc3Mgbm8gZXh0ZW5kcyBZYXtjb25zdHJ1Y3Rvcih0PVtdLGU9ITEsbj1cImNlbnRyaXBldGFsXCIsaT0uNSl7c3VwZXIoKSx0aGlzLnR5cGU9XCJDYXRtdWxsUm9tQ3VydmUzXCIsdGhpcy5wb2ludHM9dCx0aGlzLmNsb3NlZD1lLHRoaXMuY3VydmVUeXBlPW4sdGhpcy50ZW5zaW9uPWl9Z2V0UG9pbnQodCxlPW5ldyBCdCl7Y29uc3Qgbj1lLGk9dGhpcy5wb2ludHMscj1pLmxlbmd0aCxzPShyLSh0aGlzLmNsb3NlZD8wOjEpKSp0O2xldCBhLG8sbD1NYXRoLmZsb29yKHMpLGM9cy1sO3RoaXMuY2xvc2VkP2wrPWw+MD8wOihNYXRoLmZsb29yKE1hdGguYWJzKGwpL3IpKzEpKnI6MD09PWMmJmw9PT1yLTEmJihsPXItMixjPTEpLHRoaXMuY2xvc2VkfHxsPjA/YT1pWyhsLTEpJXJdOihLYS5zdWJWZWN0b3JzKGlbMF0saVsxXSkuYWRkKGlbMF0pLGE9S2EpO2NvbnN0IGg9aVtsJXJdLHU9aVsobCsxKSVyXTtpZih0aGlzLmNsb3NlZHx8bCsyPHI/bz1pWyhsKzIpJXJdOihLYS5zdWJWZWN0b3JzKGlbci0xXSxpW3ItMl0pLmFkZChpW3ItMV0pLG89S2EpLFwiY2VudHJpcGV0YWxcIj09PXRoaXMuY3VydmVUeXBlfHxcImNob3JkYWxcIj09PXRoaXMuY3VydmVUeXBlKXtjb25zdCB0PVwiY2hvcmRhbFwiPT09dGhpcy5jdXJ2ZVR5cGU/LjU6LjI1O2xldCBlPU1hdGgucG93KGEuZGlzdGFuY2VUb1NxdWFyZWQoaCksdCksbj1NYXRoLnBvdyhoLmRpc3RhbmNlVG9TcXVhcmVkKHUpLHQpLGk9TWF0aC5wb3codS5kaXN0YW5jZVRvU3F1YXJlZChvKSx0KTtuPDFlLTQmJihuPTEpLGU8MWUtNCYmKGU9biksaTwxZS00JiYoaT1uKSxRYS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oYS54LGgueCx1Lngsby54LGUsbixpKSx0by5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oYS55LGgueSx1Lnksby55LGUsbixpKSxlby5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oYS56LGgueix1Lnosby56LGUsbixpKX1lbHNlXCJjYXRtdWxscm9tXCI9PT10aGlzLmN1cnZlVHlwZSYmKFFhLmluaXRDYXRtdWxsUm9tKGEueCxoLngsdS54LG8ueCx0aGlzLnRlbnNpb24pLHRvLmluaXRDYXRtdWxsUm9tKGEueSxoLnksdS55LG8ueSx0aGlzLnRlbnNpb24pLGVvLmluaXRDYXRtdWxsUm9tKGEueixoLnosdS56LG8ueix0aGlzLnRlbnNpb24pKTtyZXR1cm4gbi5zZXQoUWEuY2FsYyhjKSx0by5jYWxjKGMpLGVvLmNhbGMoYykpLG59Y29weSh0KXtzdXBlci5jb3B5KHQpLHRoaXMucG9pbnRzPVtdO2ZvcihsZXQgZT0wLG49dC5wb2ludHMubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49dC5wb2ludHNbZV07dGhpcy5wb2ludHMucHVzaChuLmNsb25lKCkpfXJldHVybiB0aGlzLmNsb3NlZD10LmNsb3NlZCx0aGlzLmN1cnZlVHlwZT10LmN1cnZlVHlwZSx0aGlzLnRlbnNpb249dC50ZW5zaW9uLHRoaXN9dG9KU09OKCl7Y29uc3QgdD1zdXBlci50b0pTT04oKTt0LnBvaW50cz1bXTtmb3IobGV0IGU9MCxuPXRoaXMucG9pbnRzLmxlbmd0aDtlPG47ZSsrKXtjb25zdCBuPXRoaXMucG9pbnRzW2VdO3QucG9pbnRzLnB1c2gobi50b0FycmF5KCkpfXJldHVybiB0LmNsb3NlZD10aGlzLmNsb3NlZCx0LmN1cnZlVHlwZT10aGlzLmN1cnZlVHlwZSx0LnRlbnNpb249dGhpcy50ZW5zaW9uLHR9ZnJvbUpTT04odCl7c3VwZXIuZnJvbUpTT04odCksdGhpcy5wb2ludHM9W107Zm9yKGxldCBlPTAsbj10LnBvaW50cy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10LnBvaW50c1tlXTt0aGlzLnBvaW50cy5wdXNoKChuZXcgQnQpLmZyb21BcnJheShuKSl9cmV0dXJuIHRoaXMuY2xvc2VkPXQuY2xvc2VkLHRoaXMuY3VydmVUeXBlPXQuY3VydmVUeXBlLHRoaXMudGVuc2lvbj10LnRlbnNpb24sdGhpc319ZnVuY3Rpb24gaW8odCxlLG4saSxyKXtjb25zdCBzPS41KihpLWUpLGE9LjUqKHItbiksbz10KnQ7cmV0dXJuKDIqbi0yKmkrcythKSoodCpvKSsoLTMqbiszKmktMipzLWEpKm8rcyp0K259ZnVuY3Rpb24gcm8odCxlLG4saSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj0xLXQ7cmV0dXJuIG4qbiplfSh0LGUpK2Z1bmN0aW9uKHQsZSl7cmV0dXJuIDIqKDEtdCkqdCplfSh0LG4pK2Z1bmN0aW9uKHQsZSl7cmV0dXJuIHQqdCplfSh0LGkpfWZ1bmN0aW9uIHNvKHQsZSxuLGkscil7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj0xLXQ7cmV0dXJuIG4qbipuKmV9KHQsZSkrZnVuY3Rpb24odCxlKXtjb25zdCBuPTEtdDtyZXR1cm4gMypuKm4qdCplfSh0LG4pK2Z1bmN0aW9uKHQsZSl7cmV0dXJuIDMqKDEtdCkqdCp0KmV9KHQsaSkrZnVuY3Rpb24odCxlKXtyZXR1cm4gdCp0KnQqZX0odCxyKX1uby5wcm90b3R5cGUuaXNDYXRtdWxsUm9tQ3VydmUzPSEwO2NsYXNzIGFvIGV4dGVuZHMgWWF7Y29uc3RydWN0b3IodD1uZXcgQXQsZT1uZXcgQXQsbj1uZXcgQXQsaT1uZXcgQXQpe3N1cGVyKCksdGhpcy50eXBlPVwiQ3ViaWNCZXppZXJDdXJ2ZVwiLHRoaXMudjA9dCx0aGlzLnYxPWUsdGhpcy52Mj1uLHRoaXMudjM9aX1nZXRQb2ludCh0LGU9bmV3IEF0KXtjb25zdCBuPWUsaT10aGlzLnYwLHI9dGhpcy52MSxzPXRoaXMudjIsYT10aGlzLnYzO3JldHVybiBuLnNldChzbyh0LGkueCxyLngscy54LGEueCksc28odCxpLnksci55LHMueSxhLnkpKSxufWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy52MC5jb3B5KHQudjApLHRoaXMudjEuY29weSh0LnYxKSx0aGlzLnYyLmNvcHkodC52MiksdGhpcy52My5jb3B5KHQudjMpLHRoaXN9dG9KU09OKCl7Y29uc3QgdD1zdXBlci50b0pTT04oKTtyZXR1cm4gdC52MD10aGlzLnYwLnRvQXJyYXkoKSx0LnYxPXRoaXMudjEudG9BcnJheSgpLHQudjI9dGhpcy52Mi50b0FycmF5KCksdC52Mz10aGlzLnYzLnRvQXJyYXkoKSx0fWZyb21KU09OKHQpe3JldHVybiBzdXBlci5mcm9tSlNPTih0KSx0aGlzLnYwLmZyb21BcnJheSh0LnYwKSx0aGlzLnYxLmZyb21BcnJheSh0LnYxKSx0aGlzLnYyLmZyb21BcnJheSh0LnYyKSx0aGlzLnYzLmZyb21BcnJheSh0LnYzKSx0aGlzfX1hby5wcm90b3R5cGUuaXNDdWJpY0JlemllckN1cnZlPSEwO2NsYXNzIG9vIGV4dGVuZHMgWWF7Y29uc3RydWN0b3IodD1uZXcgQnQsZT1uZXcgQnQsbj1uZXcgQnQsaT1uZXcgQnQpe3N1cGVyKCksdGhpcy50eXBlPVwiQ3ViaWNCZXppZXJDdXJ2ZTNcIix0aGlzLnYwPXQsdGhpcy52MT1lLHRoaXMudjI9bix0aGlzLnYzPWl9Z2V0UG9pbnQodCxlPW5ldyBCdCl7Y29uc3Qgbj1lLGk9dGhpcy52MCxyPXRoaXMudjEscz10aGlzLnYyLGE9dGhpcy52MztyZXR1cm4gbi5zZXQoc28odCxpLngsci54LHMueCxhLngpLHNvKHQsaS55LHIueSxzLnksYS55KSxzbyh0LGkueixyLnoscy56LGEueikpLG59Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnYwLmNvcHkodC52MCksdGhpcy52MS5jb3B5KHQudjEpLHRoaXMudjIuY29weSh0LnYyKSx0aGlzLnYzLmNvcHkodC52MyksdGhpc310b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LnYwPXRoaXMudjAudG9BcnJheSgpLHQudjE9dGhpcy52MS50b0FycmF5KCksdC52Mj10aGlzLnYyLnRvQXJyYXkoKSx0LnYzPXRoaXMudjMudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMudjAuZnJvbUFycmF5KHQudjApLHRoaXMudjEuZnJvbUFycmF5KHQudjEpLHRoaXMudjIuZnJvbUFycmF5KHQudjIpLHRoaXMudjMuZnJvbUFycmF5KHQudjMpLHRoaXN9fW9vLnByb3RvdHlwZS5pc0N1YmljQmV6aWVyQ3VydmUzPSEwO2NsYXNzIGxvIGV4dGVuZHMgWWF7Y29uc3RydWN0b3IodD1uZXcgQXQsZT1uZXcgQXQpe3N1cGVyKCksdGhpcy50eXBlPVwiTGluZUN1cnZlXCIsdGhpcy52MT10LHRoaXMudjI9ZX1nZXRQb2ludCh0LGU9bmV3IEF0KXtjb25zdCBuPWU7cmV0dXJuIDE9PT10P24uY29weSh0aGlzLnYyKToobi5jb3B5KHRoaXMudjIpLnN1Yih0aGlzLnYxKSxuLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnYxKSksbn1nZXRQb2ludEF0KHQsZSl7cmV0dXJuIHRoaXMuZ2V0UG9pbnQodCxlKX1nZXRUYW5nZW50KHQsZSl7Y29uc3Qgbj1lfHxuZXcgQXQ7cmV0dXJuIG4uY29weSh0aGlzLnYyKS5zdWIodGhpcy52MSkubm9ybWFsaXplKCksbn1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMudjEuY29weSh0LnYxKSx0aGlzLnYyLmNvcHkodC52MiksdGhpc310b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LnYxPXRoaXMudjEudG9BcnJheSgpLHQudjI9dGhpcy52Mi50b0FycmF5KCksdH1mcm9tSlNPTih0KXtyZXR1cm4gc3VwZXIuZnJvbUpTT04odCksdGhpcy52MS5mcm9tQXJyYXkodC52MSksdGhpcy52Mi5mcm9tQXJyYXkodC52MiksdGhpc319bG8ucHJvdG90eXBlLmlzTGluZUN1cnZlPSEwO2NsYXNzIGNvIGV4dGVuZHMgWWF7Y29uc3RydWN0b3IodD1uZXcgQXQsZT1uZXcgQXQsbj1uZXcgQXQpe3N1cGVyKCksdGhpcy50eXBlPVwiUXVhZHJhdGljQmV6aWVyQ3VydmVcIix0aGlzLnYwPXQsdGhpcy52MT1lLHRoaXMudjI9bn1nZXRQb2ludCh0LGU9bmV3IEF0KXtjb25zdCBuPWUsaT10aGlzLnYwLHI9dGhpcy52MSxzPXRoaXMudjI7cmV0dXJuIG4uc2V0KHJvKHQsaS54LHIueCxzLngpLHJvKHQsaS55LHIueSxzLnkpKSxufWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy52MC5jb3B5KHQudjApLHRoaXMudjEuY29weSh0LnYxKSx0aGlzLnYyLmNvcHkodC52MiksdGhpc310b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LnYwPXRoaXMudjAudG9BcnJheSgpLHQudjE9dGhpcy52MS50b0FycmF5KCksdC52Mj10aGlzLnYyLnRvQXJyYXkoKSx0fWZyb21KU09OKHQpe3JldHVybiBzdXBlci5mcm9tSlNPTih0KSx0aGlzLnYwLmZyb21BcnJheSh0LnYwKSx0aGlzLnYxLmZyb21BcnJheSh0LnYxKSx0aGlzLnYyLmZyb21BcnJheSh0LnYyKSx0aGlzfX1jby5wcm90b3R5cGUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZT0hMDtjbGFzcyBobyBleHRlbmRzIFlhe2NvbnN0cnVjdG9yKHQ9bmV3IEJ0LGU9bmV3IEJ0LG49bmV3IEJ0KXtzdXBlcigpLHRoaXMudHlwZT1cIlF1YWRyYXRpY0JlemllckN1cnZlM1wiLHRoaXMudjA9dCx0aGlzLnYxPWUsdGhpcy52Mj1ufWdldFBvaW50KHQsZT1uZXcgQnQpe2NvbnN0IG49ZSxpPXRoaXMudjAscj10aGlzLnYxLHM9dGhpcy52MjtyZXR1cm4gbi5zZXQocm8odCxpLngsci54LHMueCkscm8odCxpLnksci55LHMueSkscm8odCxpLnosci56LHMueikpLG59Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnYwLmNvcHkodC52MCksdGhpcy52MS5jb3B5KHQudjEpLHRoaXMudjIuY29weSh0LnYyKSx0aGlzfXRvSlNPTigpe2NvbnN0IHQ9c3VwZXIudG9KU09OKCk7cmV0dXJuIHQudjA9dGhpcy52MC50b0FycmF5KCksdC52MT10aGlzLnYxLnRvQXJyYXkoKSx0LnYyPXRoaXMudjIudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMudjAuZnJvbUFycmF5KHQudjApLHRoaXMudjEuZnJvbUFycmF5KHQudjEpLHRoaXMudjIuZnJvbUFycmF5KHQudjIpLHRoaXN9fWhvLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlMz0hMDtjbGFzcyB1byBleHRlbmRzIFlhe2NvbnN0cnVjdG9yKHQ9W10pe3N1cGVyKCksdGhpcy50eXBlPVwiU3BsaW5lQ3VydmVcIix0aGlzLnBvaW50cz10fWdldFBvaW50KHQsZT1uZXcgQXQpe2NvbnN0IG49ZSxpPXRoaXMucG9pbnRzLHI9KGkubGVuZ3RoLTEpKnQscz1NYXRoLmZsb29yKHIpLGE9ci1zLG89aVswPT09cz9zOnMtMV0sbD1pW3NdLGM9aVtzPmkubGVuZ3RoLTI/aS5sZW5ndGgtMTpzKzFdLGg9aVtzPmkubGVuZ3RoLTM/aS5sZW5ndGgtMTpzKzJdO3JldHVybiBuLnNldChpbyhhLG8ueCxsLngsYy54LGgueCksaW8oYSxvLnksbC55LGMueSxoLnkpKSxufWNvcHkodCl7c3VwZXIuY29weSh0KSx0aGlzLnBvaW50cz1bXTtmb3IobGV0IGU9MCxuPXQucG9pbnRzLmxlbmd0aDtlPG47ZSsrKXtjb25zdCBuPXQucG9pbnRzW2VdO3RoaXMucG9pbnRzLnB1c2gobi5jbG9uZSgpKX1yZXR1cm4gdGhpc310b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3QucG9pbnRzPVtdO2ZvcihsZXQgZT0wLG49dGhpcy5wb2ludHMubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49dGhpcy5wb2ludHNbZV07dC5wb2ludHMucHVzaChuLnRvQXJyYXkoKSl9cmV0dXJuIHR9ZnJvbUpTT04odCl7c3VwZXIuZnJvbUpTT04odCksdGhpcy5wb2ludHM9W107Zm9yKGxldCBlPTAsbj10LnBvaW50cy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10LnBvaW50c1tlXTt0aGlzLnBvaW50cy5wdXNoKChuZXcgQXQpLmZyb21BcnJheShuKSl9cmV0dXJuIHRoaXN9fXVvLnByb3RvdHlwZS5pc1NwbGluZUN1cnZlPSEwO3ZhciBwbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBcmNDdXJ2ZTpKYSxDYXRtdWxsUm9tQ3VydmUzOm5vLEN1YmljQmV6aWVyQ3VydmU6YW8sQ3ViaWNCZXppZXJDdXJ2ZTM6b28sRWxsaXBzZUN1cnZlOlphLExpbmVDdXJ2ZTpsbyxMaW5lQ3VydmUzOmNsYXNzIGV4dGVuZHMgWWF7Y29uc3RydWN0b3IodD1uZXcgQnQsZT1uZXcgQnQpe3N1cGVyKCksdGhpcy50eXBlPVwiTGluZUN1cnZlM1wiLHRoaXMuaXNMaW5lQ3VydmUzPSEwLHRoaXMudjE9dCx0aGlzLnYyPWV9Z2V0UG9pbnQodCxlPW5ldyBCdCl7Y29uc3Qgbj1lO3JldHVybiAxPT09dD9uLmNvcHkodGhpcy52Mik6KG4uY29weSh0aGlzLnYyKS5zdWIodGhpcy52MSksbi5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy52MSkpLG59Z2V0UG9pbnRBdCh0LGUpe3JldHVybiB0aGlzLmdldFBvaW50KHQsZSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnYxLmNvcHkodC52MSksdGhpcy52Mi5jb3B5KHQudjIpLHRoaXN9dG9KU09OKCl7Y29uc3QgdD1zdXBlci50b0pTT04oKTtyZXR1cm4gdC52MT10aGlzLnYxLnRvQXJyYXkoKSx0LnYyPXRoaXMudjIudG9BcnJheSgpLHR9ZnJvbUpTT04odCl7cmV0dXJuIHN1cGVyLmZyb21KU09OKHQpLHRoaXMudjEuZnJvbUFycmF5KHQudjEpLHRoaXMudjIuZnJvbUFycmF5KHQudjIpLHRoaXN9fSxRdWFkcmF0aWNCZXppZXJDdXJ2ZTpjbyxRdWFkcmF0aWNCZXppZXJDdXJ2ZTM6aG8sU3BsaW5lQ3VydmU6dW99KTtjbGFzcyBtbyBleHRlbmRzIFlhe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJDdXJ2ZVBhdGhcIix0aGlzLmN1cnZlcz1bXSx0aGlzLmF1dG9DbG9zZT0hMX1hZGQodCl7dGhpcy5jdXJ2ZXMucHVzaCh0KX1jbG9zZVBhdGgoKXtjb25zdCB0PXRoaXMuY3VydmVzWzBdLmdldFBvaW50KDApLGU9dGhpcy5jdXJ2ZXNbdGhpcy5jdXJ2ZXMubGVuZ3RoLTFdLmdldFBvaW50KDEpO3QuZXF1YWxzKGUpfHx0aGlzLmN1cnZlcy5wdXNoKG5ldyBsbyhlLHQpKX1nZXRQb2ludCh0LGUpe2NvbnN0IG49dCp0aGlzLmdldExlbmd0aCgpLGk9dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtsZXQgcj0wO2Zvcig7cjxpLmxlbmd0aDspe2lmKGlbcl0+PW4pe2NvbnN0IHQ9aVtyXS1uLHM9dGhpcy5jdXJ2ZXNbcl0sYT1zLmdldExlbmd0aCgpLG89MD09PWE/MDoxLXQvYTtyZXR1cm4gcy5nZXRQb2ludEF0KG8sZSl9cisrfXJldHVybiBudWxsfWdldExlbmd0aCgpe2NvbnN0IHQ9dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtyZXR1cm4gdFt0Lmxlbmd0aC0xXX11cGRhdGVBcmNMZW5ndGhzKCl7dGhpcy5uZWVkc1VwZGF0ZT0hMCx0aGlzLmNhY2hlTGVuZ3Rocz1udWxsLHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCl9Z2V0Q3VydmVMZW5ndGhzKCl7aWYodGhpcy5jYWNoZUxlbmd0aHMmJnRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aD09PXRoaXMuY3VydmVzLmxlbmd0aClyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7Y29uc3QgdD1bXTtsZXQgZT0wO2ZvcihsZXQgbj0wLGk9dGhpcy5jdXJ2ZXMubGVuZ3RoO248aTtuKyspZSs9dGhpcy5jdXJ2ZXNbbl0uZ2V0TGVuZ3RoKCksdC5wdXNoKGUpO3JldHVybiB0aGlzLmNhY2hlTGVuZ3Rocz10LHR9Z2V0U3BhY2VkUG9pbnRzKHQ9NDApe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjw9dDtuKyspZS5wdXNoKHRoaXMuZ2V0UG9pbnQobi90KSk7cmV0dXJuIHRoaXMuYXV0b0Nsb3NlJiZlLnB1c2goZVswXSksZX1nZXRQb2ludHModD0xMil7Y29uc3QgZT1bXTtsZXQgbjtmb3IobGV0IGk9MCxyPXRoaXMuY3VydmVzO2k8ci5sZW5ndGg7aSsrKXtjb25zdCBzPXJbaV0sYT1zJiZzLmlzRWxsaXBzZUN1cnZlPzIqdDpzJiYocy5pc0xpbmVDdXJ2ZXx8cy5pc0xpbmVDdXJ2ZTMpPzE6cyYmcy5pc1NwbGluZUN1cnZlP3Qqcy5wb2ludHMubGVuZ3RoOnQsbz1zLmdldFBvaW50cyhhKTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKyl7Y29uc3QgaT1vW3RdO24mJm4uZXF1YWxzKGkpfHwoZS5wdXNoKGkpLG49aSl9fXJldHVybiB0aGlzLmF1dG9DbG9zZSYmZS5sZW5ndGg+MSYmIWVbZS5sZW5ndGgtMV0uZXF1YWxzKGVbMF0pJiZlLnB1c2goZVswXSksZX1jb3B5KHQpe3N1cGVyLmNvcHkodCksdGhpcy5jdXJ2ZXM9W107Zm9yKGxldCBlPTAsbj10LmN1cnZlcy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10LmN1cnZlc1tlXTt0aGlzLmN1cnZlcy5wdXNoKG4uY2xvbmUoKSl9cmV0dXJuIHRoaXMuYXV0b0Nsb3NlPXQuYXV0b0Nsb3NlLHRoaXN9dG9KU09OKCl7Y29uc3QgdD1zdXBlci50b0pTT04oKTt0LmF1dG9DbG9zZT10aGlzLmF1dG9DbG9zZSx0LmN1cnZlcz1bXTtmb3IobGV0IGU9MCxuPXRoaXMuY3VydmVzLmxlbmd0aDtlPG47ZSsrKXtjb25zdCBuPXRoaXMuY3VydmVzW2VdO3QuY3VydmVzLnB1c2gobi50b0pTT04oKSl9cmV0dXJuIHR9ZnJvbUpTT04odCl7c3VwZXIuZnJvbUpTT04odCksdGhpcy5hdXRvQ2xvc2U9dC5hdXRvQ2xvc2UsdGhpcy5jdXJ2ZXM9W107Zm9yKGxldCBlPTAsbj10LmN1cnZlcy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10LmN1cnZlc1tlXTt0aGlzLmN1cnZlcy5wdXNoKChuZXcgcG9bbi50eXBlXSkuZnJvbUpTT04obikpfXJldHVybiB0aGlzfX1jbGFzcyBmbyBleHRlbmRzIG1ve2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50eXBlPVwiUGF0aFwiLHRoaXMuY3VycmVudFBvaW50PW5ldyBBdCx0JiZ0aGlzLnNldEZyb21Qb2ludHModCl9c2V0RnJvbVBvaW50cyh0KXt0aGlzLm1vdmVUbyh0WzBdLngsdFswXS55KTtmb3IobGV0IGU9MSxuPXQubGVuZ3RoO2U8bjtlKyspdGhpcy5saW5lVG8odFtlXS54LHRbZV0ueSk7cmV0dXJuIHRoaXN9bW92ZVRvKHQsZSl7cmV0dXJuIHRoaXMuY3VycmVudFBvaW50LnNldCh0LGUpLHRoaXN9bGluZVRvKHQsZSl7Y29uc3Qgbj1uZXcgbG8odGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxuZXcgQXQodCxlKSk7cmV0dXJuIHRoaXMuY3VydmVzLnB1c2gobiksdGhpcy5jdXJyZW50UG9pbnQuc2V0KHQsZSksdGhpc31xdWFkcmF0aWNDdXJ2ZVRvKHQsZSxuLGkpe2NvbnN0IHI9bmV3IGNvKHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksbmV3IEF0KHQsZSksbmV3IEF0KG4saSkpO3JldHVybiB0aGlzLmN1cnZlcy5wdXNoKHIpLHRoaXMuY3VycmVudFBvaW50LnNldChuLGkpLHRoaXN9YmV6aWVyQ3VydmVUbyh0LGUsbixpLHIscyl7Y29uc3QgYT1uZXcgYW8odGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxuZXcgQXQodCxlKSxuZXcgQXQobixpKSxuZXcgQXQocixzKSk7cmV0dXJuIHRoaXMuY3VydmVzLnB1c2goYSksdGhpcy5jdXJyZW50UG9pbnQuc2V0KHIscyksdGhpc31zcGxpbmVUaHJ1KHQpe2NvbnN0IGU9W3RoaXMuY3VycmVudFBvaW50LmNsb25lKCldLmNvbmNhdCh0KSxuPW5ldyB1byhlKTtyZXR1cm4gdGhpcy5jdXJ2ZXMucHVzaChuKSx0aGlzLmN1cnJlbnRQb2ludC5jb3B5KHRbdC5sZW5ndGgtMV0pLHRoaXN9YXJjKHQsZSxuLGkscixzKXtjb25zdCBhPXRoaXMuY3VycmVudFBvaW50Lngsbz10aGlzLmN1cnJlbnRQb2ludC55O3JldHVybiB0aGlzLmFic2FyYyh0K2EsZStvLG4saSxyLHMpLHRoaXN9YWJzYXJjKHQsZSxuLGkscixzKXtyZXR1cm4gdGhpcy5hYnNlbGxpcHNlKHQsZSxuLG4saSxyLHMpLHRoaXN9ZWxsaXBzZSh0LGUsbixpLHIscyxhLG8pe2NvbnN0IGw9dGhpcy5jdXJyZW50UG9pbnQueCxjPXRoaXMuY3VycmVudFBvaW50Lnk7cmV0dXJuIHRoaXMuYWJzZWxsaXBzZSh0K2wsZStjLG4saSxyLHMsYSxvKSx0aGlzfWFic2VsbGlwc2UodCxlLG4saSxyLHMsYSxvKXtjb25zdCBsPW5ldyBaYSh0LGUsbixpLHIscyxhLG8pO2lmKHRoaXMuY3VydmVzLmxlbmd0aD4wKXtjb25zdCB0PWwuZ2V0UG9pbnQoMCk7dC5lcXVhbHModGhpcy5jdXJyZW50UG9pbnQpfHx0aGlzLmxpbmVUbyh0LngsdC55KX10aGlzLmN1cnZlcy5wdXNoKGwpO2NvbnN0IGM9bC5nZXRQb2ludCgxKTtyZXR1cm4gdGhpcy5jdXJyZW50UG9pbnQuY29weShjKSx0aGlzfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jdXJyZW50UG9pbnQuY29weSh0LmN1cnJlbnRQb2ludCksdGhpc310b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiB0LmN1cnJlbnRQb2ludD10aGlzLmN1cnJlbnRQb2ludC50b0FycmF5KCksdH1mcm9tSlNPTih0KXtyZXR1cm4gc3VwZXIuZnJvbUpTT04odCksdGhpcy5jdXJyZW50UG9pbnQuZnJvbUFycmF5KHQuY3VycmVudFBvaW50KSx0aGlzfX1jbGFzcyBnbyBleHRlbmRzIGZve2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMudXVpZD14dCgpLHRoaXMudHlwZT1cIlNoYXBlXCIsdGhpcy5ob2xlcz1bXX1nZXRQb2ludHNIb2xlcyh0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLGk9dGhpcy5ob2xlcy5sZW5ndGg7bjxpO24rKyllW25dPXRoaXMuaG9sZXNbbl0uZ2V0UG9pbnRzKHQpO3JldHVybiBlfWV4dHJhY3RQb2ludHModCl7cmV0dXJue3NoYXBlOnRoaXMuZ2V0UG9pbnRzKHQpLGhvbGVzOnRoaXMuZ2V0UG9pbnRzSG9sZXModCl9fWNvcHkodCl7c3VwZXIuY29weSh0KSx0aGlzLmhvbGVzPVtdO2ZvcihsZXQgZT0wLG49dC5ob2xlcy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10LmhvbGVzW2VdO3RoaXMuaG9sZXMucHVzaChuLmNsb25lKCkpfXJldHVybiB0aGlzfXRvSlNPTigpe2NvbnN0IHQ9c3VwZXIudG9KU09OKCk7dC51dWlkPXRoaXMudXVpZCx0LmhvbGVzPVtdO2ZvcihsZXQgZT0wLG49dGhpcy5ob2xlcy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10aGlzLmhvbGVzW2VdO3QuaG9sZXMucHVzaChuLnRvSlNPTigpKX1yZXR1cm4gdH1mcm9tSlNPTih0KXtzdXBlci5mcm9tSlNPTih0KSx0aGlzLnV1aWQ9dC51dWlkLHRoaXMuaG9sZXM9W107Zm9yKGxldCBlPTAsbj10LmhvbGVzLmxlbmd0aDtlPG47ZSsrKXtjb25zdCBuPXQuaG9sZXNbZV07dGhpcy5ob2xlcy5wdXNoKChuZXcgZm8pLmZyb21KU09OKG4pKX1yZXR1cm4gdGhpc319Y29uc3Qgdm89ZnVuY3Rpb24odCxlLG49Mil7Y29uc3QgaT1lJiZlLmxlbmd0aCxyPWk/ZVswXSpuOnQubGVuZ3RoO2xldCBzPXlvKHQsMCxyLG4sITApO2NvbnN0IGE9W107aWYoIXN8fHMubmV4dD09PXMucHJldilyZXR1cm4gYTtsZXQgbyxsLGMsaCx1LGQscDtpZihpJiYocz1mdW5jdGlvbih0LGUsbixpKXtjb25zdCByPVtdO2xldCBzLGEsbyxsLGM7Zm9yKHM9MCxhPWUubGVuZ3RoO3M8YTtzKyspbz1lW3NdKmksbD1zPGEtMT9lW3MrMV0qaTp0Lmxlbmd0aCxjPXlvKHQsbyxsLGksITEpLGM9PT1jLm5leHQmJihjLnN0ZWluZXI9ITApLHIucHVzaChSbyhjKSk7Zm9yKHIuc29ydChUbykscz0wO3M8ci5sZW5ndGg7cysrKUVvKHJbc10sbiksbj14byhuLG4ubmV4dCk7cmV0dXJuIG59KHQsZSxzLG4pKSx0Lmxlbmd0aD44MCpuKXtvPWM9dFswXSxsPWg9dFsxXTtmb3IobGV0IGU9bjtlPHI7ZSs9bil1PXRbZV0sZD10W2UrMV0sdTxvJiYobz11KSxkPGwmJihsPWQpLHU+YyYmKGM9dSksZD5oJiYoaD1kKTtwPU1hdGgubWF4KGMtbyxoLWwpLHA9MCE9PXA/MS9wOjB9cmV0dXJuIGJvKHMsYSxuLG8sbCxwKSxhfTtmdW5jdGlvbiB5byh0LGUsbixpLHIpe2xldCBzLGE7aWYocj09PWZ1bmN0aW9uKHQsZSxuLGkpe2xldCByPTA7Zm9yKGxldCBzPWUsYT1uLWk7czxuO3MrPWkpcis9KHRbYV0tdFtzXSkqKHRbcysxXSt0W2ErMV0pLGE9cztyZXR1cm4gcn0odCxlLG4saSk+MClmb3Iocz1lO3M8bjtzKz1pKWE9em8ocyx0W3NdLHRbcysxXSxhKTtlbHNlIGZvcihzPW4taTtzPj1lO3MtPWkpYT16byhzLHRbc10sdFtzKzFdLGEpO3JldHVybiBhJiZEbyhhLGEubmV4dCkmJihCbyhhKSxhPWEubmV4dCksYX1mdW5jdGlvbiB4byh0LGUpe2lmKCF0KXJldHVybiB0O2V8fChlPXQpO2xldCBuLGk9dDtkb3tpZihuPSExLGkuc3RlaW5lcnx8IURvKGksaS5uZXh0KSYmMCE9PUlvKGkucHJldixpLGkubmV4dCkpaT1pLm5leHQ7ZWxzZXtpZihCbyhpKSxpPWU9aS5wcmV2LGk9PT1pLm5leHQpYnJlYWs7bj0hMH19d2hpbGUobnx8aSE9PWUpO3JldHVybiBlfWZ1bmN0aW9uIGJvKHQsZSxuLGkscixzLGEpe2lmKCF0KXJldHVybjshYSYmcyYmZnVuY3Rpb24odCxlLG4saSl7bGV0IHI9dDtkb3tudWxsPT09ci56JiYoci56PUxvKHIueCxyLnksZSxuLGkpKSxyLnByZXZaPXIucHJldixyLm5leHRaPXIubmV4dCxyPXIubmV4dH13aGlsZShyIT09dCk7ci5wcmV2Wi5uZXh0Wj1udWxsLHIucHJldlo9bnVsbCxmdW5jdGlvbih0KXtsZXQgZSxuLGkscixzLGEsbyxsLGM9MTtkb3tmb3Iobj10LHQ9bnVsbCxzPW51bGwsYT0wO247KXtmb3IoYSsrLGk9bixvPTAsZT0wO2U8YyYmKG8rKyxpPWkubmV4dFosaSk7ZSsrKTtmb3IobD1jO28+MHx8bD4wJiZpOykwIT09byYmKDA9PT1sfHwhaXx8bi56PD1pLnopPyhyPW4sbj1uLm5leHRaLG8tLSk6KHI9aSxpPWkubmV4dFosbC0tKSxzP3MubmV4dFo9cjp0PXIsci5wcmV2Wj1zLHM9cjtuPWl9cy5uZXh0Wj1udWxsLGMqPTJ9d2hpbGUoYT4xKX0ocil9KHQsaSxyLHMpO2xldCBvLGwsYz10O2Zvcig7dC5wcmV2IT09dC5uZXh0OylpZihvPXQucHJldixsPXQubmV4dCxzP19vKHQsaSxyLHMpOndvKHQpKWUucHVzaChvLmkvbiksZS5wdXNoKHQuaS9uKSxlLnB1c2gobC5pL24pLEJvKHQpLHQ9bC5uZXh0LGM9bC5uZXh0O2Vsc2UgaWYoKHQ9bCk9PT1jKXthPzE9PT1hP2JvKHQ9TW8oeG8odCksZSxuKSxlLG4saSxyLHMsMik6Mj09PWEmJlNvKHQsZSxuLGkscixzKTpibyh4byh0KSxlLG4saSxyLHMsMSk7YnJlYWt9fWZ1bmN0aW9uIHdvKHQpe2NvbnN0IGU9dC5wcmV2LG49dCxpPXQubmV4dDtpZihJbyhlLG4saSk+PTApcmV0dXJuITE7bGV0IHI9dC5uZXh0Lm5leHQ7Zm9yKDtyIT09dC5wcmV2Oyl7aWYoQ28oZS54LGUueSxuLngsbi55LGkueCxpLnksci54LHIueSkmJklvKHIucHJldixyLHIubmV4dCk+PTApcmV0dXJuITE7cj1yLm5leHR9cmV0dXJuITB9ZnVuY3Rpb24gX28odCxlLG4saSl7Y29uc3Qgcj10LnByZXYscz10LGE9dC5uZXh0O2lmKElvKHIscyxhKT49MClyZXR1cm4hMTtjb25zdCBvPXIueDxzLng/ci54PGEueD9yLng6YS54OnMueDxhLng/cy54OmEueCxsPXIueTxzLnk/ci55PGEueT9yLnk6YS55OnMueTxhLnk/cy55OmEueSxjPXIueD5zLng/ci54PmEueD9yLng6YS54OnMueD5hLng/cy54OmEueCxoPXIueT5zLnk/ci55PmEueT9yLnk6YS55OnMueT5hLnk/cy55OmEueSx1PUxvKG8sbCxlLG4saSksZD1MbyhjLGgsZSxuLGkpO2xldCBwPXQucHJldlosbT10Lm5leHRaO2Zvcig7cCYmcC56Pj11JiZtJiZtLno8PWQ7KXtpZihwIT09dC5wcmV2JiZwIT09dC5uZXh0JiZDbyhyLngsci55LHMueCxzLnksYS54LGEueSxwLngscC55KSYmSW8ocC5wcmV2LHAscC5uZXh0KT49MClyZXR1cm4hMTtpZihwPXAucHJldlosbSE9PXQucHJldiYmbSE9PXQubmV4dCYmQ28oci54LHIueSxzLngscy55LGEueCxhLnksbS54LG0ueSkmJklvKG0ucHJldixtLG0ubmV4dCk+PTApcmV0dXJuITE7bT1tLm5leHRafWZvcig7cCYmcC56Pj11Oyl7aWYocCE9PXQucHJldiYmcCE9PXQubmV4dCYmQ28oci54LHIueSxzLngscy55LGEueCxhLnkscC54LHAueSkmJklvKHAucHJldixwLHAubmV4dCk+PTApcmV0dXJuITE7cD1wLnByZXZafWZvcig7bSYmbS56PD1kOyl7aWYobSE9PXQucHJldiYmbSE9PXQubmV4dCYmQ28oci54LHIueSxzLngscy55LGEueCxhLnksbS54LG0ueSkmJklvKG0ucHJldixtLG0ubmV4dCk+PTApcmV0dXJuITE7bT1tLm5leHRafXJldHVybiEwfWZ1bmN0aW9uIE1vKHQsZSxuKXtsZXQgaT10O2Rve2NvbnN0IHI9aS5wcmV2LHM9aS5uZXh0Lm5leHQ7IURvKHIscykmJk5vKHIsaSxpLm5leHQscykmJlVvKHIscykmJlVvKHMscikmJihlLnB1c2goci5pL24pLGUucHVzaChpLmkvbiksZS5wdXNoKHMuaS9uKSxCbyhpKSxCbyhpLm5leHQpLGk9dD1zKSxpPWkubmV4dH13aGlsZShpIT09dCk7cmV0dXJuIHhvKGkpfWZ1bmN0aW9uIFNvKHQsZSxuLGkscixzKXtsZXQgYT10O2Rve2xldCB0PWEubmV4dC5uZXh0O2Zvcig7dCE9PWEucHJldjspe2lmKGEuaSE9PXQuaSYmUG8oYSx0KSl7bGV0IG89a28oYSx0KTtyZXR1cm4gYT14byhhLGEubmV4dCksbz14byhvLG8ubmV4dCksYm8oYSxlLG4saSxyLHMpLHZvaWQgYm8obyxlLG4saSxyLHMpfXQ9dC5uZXh0fWE9YS5uZXh0fXdoaWxlKGEhPT10KX1mdW5jdGlvbiBUbyh0LGUpe3JldHVybiB0LngtZS54fWZ1bmN0aW9uIEVvKHQsZSl7aWYoZT1mdW5jdGlvbih0LGUpe2xldCBuPWU7Y29uc3QgaT10Lngscj10Lnk7bGV0IHMsYT0tMS8wO2Rve2lmKHI8PW4ueSYmcj49bi5uZXh0LnkmJm4ubmV4dC55IT09bi55KXtjb25zdCB0PW4ueCsoci1uLnkpKihuLm5leHQueC1uLngpLyhuLm5leHQueS1uLnkpO2lmKHQ8PWkmJnQ+YSl7aWYoYT10LHQ9PT1pKXtpZihyPT09bi55KXJldHVybiBuO2lmKHI9PT1uLm5leHQueSlyZXR1cm4gbi5uZXh0fXM9bi54PG4ubmV4dC54P246bi5uZXh0fX1uPW4ubmV4dH13aGlsZShuIT09ZSk7aWYoIXMpcmV0dXJuIG51bGw7aWYoaT09PWEpcmV0dXJuIHM7Y29uc3Qgbz1zLGw9cy54LGM9cy55O2xldCBoLHU9MS8wO249cztkb3tpPj1uLngmJm4ueD49bCYmaSE9PW4ueCYmQ28ocjxjP2k6YSxyLGwsYyxyPGM/YTppLHIsbi54LG4ueSkmJihoPU1hdGguYWJzKHItbi55KS8oaS1uLngpLFVvKG4sdCkmJihoPHV8fGg9PT11JiYobi54PnMueHx8bi54PT09cy54JiZBbyhzLG4pKSkmJihzPW4sdT1oKSksbj1uLm5leHR9d2hpbGUobiE9PW8pO3JldHVybiBzfSh0LGUpLGUpe2NvbnN0IG49a28oZSx0KTt4byhlLGUubmV4dCkseG8obixuLm5leHQpfX1mdW5jdGlvbiBBbyh0LGUpe3JldHVybiBJbyh0LnByZXYsdCxlLnByZXYpPDAmJklvKGUubmV4dCx0LHQubmV4dCk8MH1mdW5jdGlvbiBMbyh0LGUsbixpLHIpe3JldHVybih0PTE0MzE2NTU3NjUmKCh0PTg1ODk5MzQ1OSYoKHQ9MjUyNjQ1MTM1JigodD0xNjcxMTkzNSYoKHQ9MzI3NjcqKHQtbikqcil8dDw8OCkpfHQ8PDQpKXx0PDwyKSl8dDw8MSkpfChlPTE0MzE2NTU3NjUmKChlPTg1ODk5MzQ1OSYoKGU9MjUyNjQ1MTM1JigoZT0xNjcxMTkzNSYoKGU9MzI3NjcqKGUtaSkqcil8ZTw8OCkpfGU8PDQpKXxlPDwyKSl8ZTw8MSkpPDwxfWZ1bmN0aW9uIFJvKHQpe2xldCBlPXQsbj10O2RveyhlLng8bi54fHxlLng9PT1uLngmJmUueTxuLnkpJiYobj1lKSxlPWUubmV4dH13aGlsZShlIT09dCk7cmV0dXJuIG59ZnVuY3Rpb24gQ28odCxlLG4saSxyLHMsYSxvKXtyZXR1cm4oci1hKSooZS1vKS0odC1hKSoocy1vKT49MCYmKHQtYSkqKGktbyktKG4tYSkqKGUtbyk+PTAmJihuLWEpKihzLW8pLShyLWEpKihpLW8pPj0wfWZ1bmN0aW9uIFBvKHQsZSl7cmV0dXJuIHQubmV4dC5pIT09ZS5pJiZ0LnByZXYuaSE9PWUuaSYmIWZ1bmN0aW9uKHQsZSl7bGV0IG49dDtkb3tpZihuLmkhPT10LmkmJm4ubmV4dC5pIT09dC5pJiZuLmkhPT1lLmkmJm4ubmV4dC5pIT09ZS5pJiZObyhuLG4ubmV4dCx0LGUpKXJldHVybiEwO249bi5uZXh0fXdoaWxlKG4hPT10KTtyZXR1cm4hMX0odCxlKSYmKFVvKHQsZSkmJlVvKGUsdCkmJmZ1bmN0aW9uKHQsZSl7bGV0IG49dCxpPSExO2NvbnN0IHI9KHQueCtlLngpLzIscz0odC55K2UueSkvMjtkb3tuLnk+cyE9bi5uZXh0Lnk+cyYmbi5uZXh0LnkhPT1uLnkmJnI8KG4ubmV4dC54LW4ueCkqKHMtbi55KS8obi5uZXh0Lnktbi55KStuLngmJihpPSFpKSxuPW4ubmV4dH13aGlsZShuIT09dCk7cmV0dXJuIGl9KHQsZSkmJihJbyh0LnByZXYsdCxlLnByZXYpfHxJbyh0LGUucHJldixlKSl8fERvKHQsZSkmJklvKHQucHJldix0LHQubmV4dCk+MCYmSW8oZS5wcmV2LGUsZS5uZXh0KT4wKX1mdW5jdGlvbiBJbyh0LGUsbil7cmV0dXJuKGUueS10LnkpKihuLngtZS54KS0oZS54LXQueCkqKG4ueS1lLnkpfWZ1bmN0aW9uIERvKHQsZSl7cmV0dXJuIHQueD09PWUueCYmdC55PT09ZS55fWZ1bmN0aW9uIE5vKHQsZSxuLGkpe2NvbnN0IHI9T28oSW8odCxlLG4pKSxzPU9vKElvKHQsZSxpKSksYT1PbyhJbyhuLGksdCkpLG89T28oSW8obixpLGUpKTtyZXR1cm4gciE9PXMmJmEhPT1vfHwoISgwIT09cnx8IUZvKHQsbixlKSl8fCghKDAhPT1zfHwhRm8odCxpLGUpKXx8KCEoMCE9PWF8fCFGbyhuLHQsaSkpfHwhKDAhPT1vfHwhRm8obixlLGkpKSkpKX1mdW5jdGlvbiBGbyh0LGUsbil7cmV0dXJuIGUueDw9TWF0aC5tYXgodC54LG4ueCkmJmUueD49TWF0aC5taW4odC54LG4ueCkmJmUueTw9TWF0aC5tYXgodC55LG4ueSkmJmUueT49TWF0aC5taW4odC55LG4ueSl9ZnVuY3Rpb24gT28odCl7cmV0dXJuIHQ+MD8xOnQ8MD8tMTowfWZ1bmN0aW9uIFVvKHQsZSl7cmV0dXJuIElvKHQucHJldix0LHQubmV4dCk8MD9Jbyh0LGUsdC5uZXh0KT49MCYmSW8odCx0LnByZXYsZSk+PTA6SW8odCxlLHQucHJldik8MHx8SW8odCx0Lm5leHQsZSk8MH1mdW5jdGlvbiBrbyh0LGUpe2NvbnN0IG49bmV3IEhvKHQuaSx0LngsdC55KSxpPW5ldyBIbyhlLmksZS54LGUueSkscj10Lm5leHQscz1lLnByZXY7cmV0dXJuIHQubmV4dD1lLGUucHJldj10LG4ubmV4dD1yLHIucHJldj1uLGkubmV4dD1uLG4ucHJldj1pLHMubmV4dD1pLGkucHJldj1zLGl9ZnVuY3Rpb24gem8odCxlLG4saSl7Y29uc3Qgcj1uZXcgSG8odCxlLG4pO3JldHVybiBpPyhyLm5leHQ9aS5uZXh0LHIucHJldj1pLGkubmV4dC5wcmV2PXIsaS5uZXh0PXIpOihyLnByZXY9cixyLm5leHQ9cikscn1mdW5jdGlvbiBCbyh0KXt0Lm5leHQucHJldj10LnByZXYsdC5wcmV2Lm5leHQ9dC5uZXh0LHQucHJldlomJih0LnByZXZaLm5leHRaPXQubmV4dFopLHQubmV4dFomJih0Lm5leHRaLnByZXZaPXQucHJldlopfWZ1bmN0aW9uIEhvKHQsZSxuKXt0aGlzLmk9dCx0aGlzLng9ZSx0aGlzLnk9bix0aGlzLnByZXY9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLno9bnVsbCx0aGlzLnByZXZaPW51bGwsdGhpcy5uZXh0Wj1udWxsLHRoaXMuc3RlaW5lcj0hMX1jbGFzcyBWb3tzdGF0aWMgYXJlYSh0KXtjb25zdCBlPXQubGVuZ3RoO2xldCBuPTA7Zm9yKGxldCBpPWUtMSxyPTA7cjxlO2k9cisrKW4rPXRbaV0ueCp0W3JdLnktdFtyXS54KnRbaV0ueTtyZXR1cm4uNSpufXN0YXRpYyBpc0Nsb2NrV2lzZSh0KXtyZXR1cm4gVm8uYXJlYSh0KTwwfXN0YXRpYyB0cmlhbmd1bGF0ZVNoYXBlKHQsZSl7Y29uc3Qgbj1bXSxpPVtdLHI9W107R28odCksV28obix0KTtsZXQgcz10Lmxlbmd0aDtlLmZvckVhY2goR28pO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKWkucHVzaChzKSxzKz1lW3RdLmxlbmd0aCxXbyhuLGVbdF0pO2NvbnN0IGE9dm8obixpKTtmb3IobGV0IHQ9MDt0PGEubGVuZ3RoO3QrPTMpci5wdXNoKGEuc2xpY2UodCx0KzMpKTtyZXR1cm4gcn19ZnVuY3Rpb24gR28odCl7Y29uc3QgZT10Lmxlbmd0aDtlPjImJnRbZS0xXS5lcXVhbHModFswXSkmJnQucG9wKCl9ZnVuY3Rpb24gV28odCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl0LnB1c2goZVtuXS54KSx0LnB1c2goZVtuXS55KX1jbGFzcyBqbyBleHRlbmRzIFNue2NvbnN0cnVjdG9yKHQ9bmV3IGdvKFtuZXcgQXQoLjUsLjUpLG5ldyBBdCgtLjUsLjUpLG5ldyBBdCgtLjUsLS41KSxuZXcgQXQoLjUsLS41KV0pLGU9e30pe3N1cGVyKCksdGhpcy50eXBlPVwiRXh0cnVkZUdlb21ldHJ5XCIsdGhpcy5wYXJhbWV0ZXJzPXtzaGFwZXM6dCxvcHRpb25zOmV9LHQ9QXJyYXkuaXNBcnJheSh0KT90Olt0XTtjb25zdCBuPXRoaXMsaT1bXSxyPVtdO2ZvcihsZXQgZT0wLG49dC5sZW5ndGg7ZTxuO2UrKyl7cyh0W2VdKX1mdW5jdGlvbiBzKHQpe2NvbnN0IHM9W10sYT12b2lkIDAhPT1lLmN1cnZlU2VnbWVudHM/ZS5jdXJ2ZVNlZ21lbnRzOjEyLG89dm9pZCAwIT09ZS5zdGVwcz9lLnN0ZXBzOjE7bGV0IGw9dm9pZCAwIT09ZS5kZXB0aD9lLmRlcHRoOjEsYz12b2lkIDA9PT1lLmJldmVsRW5hYmxlZHx8ZS5iZXZlbEVuYWJsZWQsaD12b2lkIDAhPT1lLmJldmVsVGhpY2tuZXNzP2UuYmV2ZWxUaGlja25lc3M6LjIsdT12b2lkIDAhPT1lLmJldmVsU2l6ZT9lLmJldmVsU2l6ZTpoLS4xLGQ9dm9pZCAwIT09ZS5iZXZlbE9mZnNldD9lLmJldmVsT2Zmc2V0OjAscD12b2lkIDAhPT1lLmJldmVsU2VnbWVudHM/ZS5iZXZlbFNlZ21lbnRzOjM7Y29uc3QgbT1lLmV4dHJ1ZGVQYXRoLGY9dm9pZCAwIT09ZS5VVkdlbmVyYXRvcj9lLlVWR2VuZXJhdG9yOnFvO3ZvaWQgMCE9PWUuYW1vdW50JiYoY29uc29sZS53YXJuKFwiVEhSRUUuRXh0cnVkZUJ1ZmZlckdlb21ldHJ5OiBhbW91bnQgaGFzIGJlZW4gcmVuYW1lZCB0byBkZXB0aC5cIiksbD1lLmFtb3VudCk7bGV0IGcsdix5LHgsYix3PSExO20mJihnPW0uZ2V0U3BhY2VkUG9pbnRzKG8pLHc9ITAsYz0hMSx2PW0uY29tcHV0ZUZyZW5ldEZyYW1lcyhvLCExKSx5PW5ldyBCdCx4PW5ldyBCdCxiPW5ldyBCdCksY3x8KHA9MCxoPTAsdT0wLGQ9MCk7Y29uc3QgXz10LmV4dHJhY3RQb2ludHMoYSk7bGV0IE09Xy5zaGFwZTtjb25zdCBTPV8uaG9sZXM7aWYoIVZvLmlzQ2xvY2tXaXNlKE0pKXtNPU0ucmV2ZXJzZSgpO2ZvcihsZXQgdD0wLGU9Uy5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT1TW3RdO1ZvLmlzQ2xvY2tXaXNlKGUpJiYoU1t0XT1lLnJldmVyc2UoKSl9fWNvbnN0IFQ9Vm8udHJpYW5ndWxhdGVTaGFwZShNLFMpLEU9TTtmb3IobGV0IHQ9MCxlPVMubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9U1t0XTtNPU0uY29uY2F0KGUpfWZ1bmN0aW9uIEEodCxlLG4pe3JldHVybiBlfHxjb25zb2xlLmVycm9yKFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3RcIiksZS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKG4pLmFkZCh0KX1jb25zdCBMPU0ubGVuZ3RoLFI9VC5sZW5ndGg7ZnVuY3Rpb24gQyh0LGUsbil7bGV0IGkscixzO2NvbnN0IGE9dC54LWUueCxvPXQueS1lLnksbD1uLngtdC54LGM9bi55LXQueSxoPWEqYStvKm8sdT1hKmMtbypsO2lmKE1hdGguYWJzKHUpPk51bWJlci5FUFNJTE9OKXtjb25zdCB1PU1hdGguc3FydChoKSxkPU1hdGguc3FydChsKmwrYypjKSxwPWUueC1vL3UsbT1lLnkrYS91LGY9KChuLngtYy9kLXApKmMtKG4ueStsL2QtbSkqbCkvKGEqYy1vKmwpO2k9cCthKmYtdC54LHI9bStvKmYtdC55O2NvbnN0IGc9aSppK3IqcjtpZihnPD0yKXJldHVybiBuZXcgQXQoaSxyKTtzPU1hdGguc3FydChnLzIpfWVsc2V7bGV0IHQ9ITE7YT5OdW1iZXIuRVBTSUxPTj9sPk51bWJlci5FUFNJTE9OJiYodD0hMCk6YTwtTnVtYmVyLkVQU0lMT04/bDwtTnVtYmVyLkVQU0lMT04mJih0PSEwKTpNYXRoLnNpZ24obyk9PT1NYXRoLnNpZ24oYykmJih0PSEwKSx0PyhpPS1vLHI9YSxzPU1hdGguc3FydChoKSk6KGk9YSxyPW8scz1NYXRoLnNxcnQoaC8yKSl9cmV0dXJuIG5ldyBBdChpL3Msci9zKX1jb25zdCBQPVtdO2ZvcihsZXQgdD0wLGU9RS5sZW5ndGgsbj1lLTEsaT10KzE7dDxlO3QrKyxuKyssaSsrKW49PT1lJiYobj0wKSxpPT09ZSYmKGk9MCksUFt0XT1DKEVbdF0sRVtuXSxFW2ldKTtjb25zdCBJPVtdO2xldCBELE49UC5jb25jYXQoKTtmb3IobGV0IHQ9MCxlPVMubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9U1t0XTtEPVtdO2ZvcihsZXQgdD0wLG49ZS5sZW5ndGgsaT1uLTEscj10KzE7dDxuO3QrKyxpKysscisrKWk9PT1uJiYoaT0wKSxyPT09biYmKHI9MCksRFt0XT1DKGVbdF0sZVtpXSxlW3JdKTtJLnB1c2goRCksTj1OLmNvbmNhdChEKX1mb3IobGV0IHQ9MDt0PHA7dCsrKXtjb25zdCBlPXQvcCxuPWgqTWF0aC5jb3MoZSpNYXRoLlBJLzIpLGk9dSpNYXRoLnNpbihlKk1hdGguUEkvMikrZDtmb3IobGV0IHQ9MCxlPUUubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9QShFW3RdLFBbdF0saSk7VShlLngsZS55LC1uKX1mb3IobGV0IHQ9MCxlPVMubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9U1t0XTtEPUlbdF07Zm9yKGxldCB0PTAscj1lLmxlbmd0aDt0PHI7dCsrKXtjb25zdCByPUEoZVt0XSxEW3RdLGkpO1Uoci54LHIueSwtbil9fX1jb25zdCBGPXUrZDtmb3IobGV0IHQ9MDt0PEw7dCsrKXtjb25zdCBlPWM/QShNW3RdLE5bdF0sRik6TVt0XTt3Pyh4LmNvcHkodi5ub3JtYWxzWzBdKS5tdWx0aXBseVNjYWxhcihlLngpLHkuY29weSh2LmJpbm9ybWFsc1swXSkubXVsdGlwbHlTY2FsYXIoZS55KSxiLmNvcHkoZ1swXSkuYWRkKHgpLmFkZCh5KSxVKGIueCxiLnksYi56KSk6VShlLngsZS55LDApfWZvcihsZXQgdD0xO3Q8PW87dCsrKWZvcihsZXQgZT0wO2U8TDtlKyspe2NvbnN0IG49Yz9BKE1bZV0sTltlXSxGKTpNW2VdO3c/KHguY29weSh2Lm5vcm1hbHNbdF0pLm11bHRpcGx5U2NhbGFyKG4ueCkseS5jb3B5KHYuYmlub3JtYWxzW3RdKS5tdWx0aXBseVNjYWxhcihuLnkpLGIuY29weShnW3RdKS5hZGQoeCkuYWRkKHkpLFUoYi54LGIueSxiLnopKTpVKG4ueCxuLnksbC9vKnQpfWZvcihsZXQgdD1wLTE7dD49MDt0LS0pe2NvbnN0IGU9dC9wLG49aCpNYXRoLmNvcyhlKk1hdGguUEkvMiksaT11Kk1hdGguc2luKGUqTWF0aC5QSS8yKStkO2ZvcihsZXQgdD0wLGU9RS5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT1BKEVbdF0sUFt0XSxpKTtVKGUueCxlLnksbCtuKX1mb3IobGV0IHQ9MCxlPVMubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9U1t0XTtEPUlbdF07Zm9yKGxldCB0PTAscj1lLmxlbmd0aDt0PHI7dCsrKXtjb25zdCByPUEoZVt0XSxEW3RdLGkpO3c/VShyLngsci55K2dbby0xXS55LGdbby0xXS54K24pOlUoci54LHIueSxsK24pfX19ZnVuY3Rpb24gTyh0LGUpe2xldCBuPXQubGVuZ3RoO2Zvcig7LS1uPj0wOyl7Y29uc3QgaT1uO2xldCByPW4tMTtyPDAmJihyPXQubGVuZ3RoLTEpO2ZvcihsZXQgdD0wLG49bysyKnA7dDxuO3QrKyl7Y29uc3Qgbj1MKnQscz1MKih0KzEpO3ooZStpK24sZStyK24sZStyK3MsZStpK3MpfX19ZnVuY3Rpb24gVSh0LGUsbil7cy5wdXNoKHQpLHMucHVzaChlKSxzLnB1c2gobil9ZnVuY3Rpb24gayh0LGUscil7Qih0KSxCKGUpLEIocik7Y29uc3Qgcz1pLmxlbmd0aC8zLGE9Zi5nZW5lcmF0ZVRvcFVWKG4saSxzLTMscy0yLHMtMSk7SChhWzBdKSxIKGFbMV0pLEgoYVsyXSl9ZnVuY3Rpb24geih0LGUscixzKXtCKHQpLEIoZSksQihzKSxCKGUpLEIociksQihzKTtjb25zdCBhPWkubGVuZ3RoLzMsbz1mLmdlbmVyYXRlU2lkZVdhbGxVVihuLGksYS02LGEtMyxhLTIsYS0xKTtIKG9bMF0pLEgob1sxXSksSChvWzNdKSxIKG9bMV0pLEgob1syXSksSChvWzNdKX1mdW5jdGlvbiBCKHQpe2kucHVzaChzWzMqdCswXSksaS5wdXNoKHNbMyp0KzFdKSxpLnB1c2goc1szKnQrMl0pfWZ1bmN0aW9uIEgodCl7ci5wdXNoKHQueCksci5wdXNoKHQueSl9IWZ1bmN0aW9uKCl7Y29uc3QgdD1pLmxlbmd0aC8zO2lmKGMpe2xldCB0PTAsZT1MKnQ7Zm9yKGxldCB0PTA7dDxSO3QrKyl7Y29uc3Qgbj1UW3RdO2soblsyXStlLG5bMV0rZSxuWzBdK2UpfXQ9bysyKnAsZT1MKnQ7Zm9yKGxldCB0PTA7dDxSO3QrKyl7Y29uc3Qgbj1UW3RdO2soblswXStlLG5bMV0rZSxuWzJdK2UpfX1lbHNle2ZvcihsZXQgdD0wO3Q8Ujt0Kyspe2NvbnN0IGU9VFt0XTtrKGVbMl0sZVsxXSxlWzBdKX1mb3IobGV0IHQ9MDt0PFI7dCsrKXtjb25zdCBlPVRbdF07ayhlWzBdK0wqbyxlWzFdK0wqbyxlWzJdK0wqbyl9fW4uYWRkR3JvdXAodCxpLmxlbmd0aC8zLXQsMCl9KCksZnVuY3Rpb24oKXtjb25zdCB0PWkubGVuZ3RoLzM7bGV0IGU9MDtPKEUsZSksZSs9RS5sZW5ndGg7Zm9yKGxldCB0PTAsbj1TLmxlbmd0aDt0PG47dCsrKXtjb25zdCBuPVNbdF07TyhuLGUpLGUrPW4ubGVuZ3RofW4uYWRkR3JvdXAodCxpLmxlbmd0aC8zLXQsMSl9KCl9dGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBnbihpLDMpKSx0aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsbmV3IGduKHIsMikpLHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKX10b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiBmdW5jdGlvbih0LGUsbil7aWYobi5zaGFwZXM9W10sQXJyYXkuaXNBcnJheSh0KSlmb3IobGV0IGU9MCxpPXQubGVuZ3RoO2U8aTtlKyspe2NvbnN0IGk9dFtlXTtuLnNoYXBlcy5wdXNoKGkudXVpZCl9ZWxzZSBuLnNoYXBlcy5wdXNoKHQudXVpZCk7dm9pZCAwIT09ZS5leHRydWRlUGF0aCYmKG4ub3B0aW9ucy5leHRydWRlUGF0aD1lLmV4dHJ1ZGVQYXRoLnRvSlNPTigpKTtyZXR1cm4gbn0odGhpcy5wYXJhbWV0ZXJzLnNoYXBlcyx0aGlzLnBhcmFtZXRlcnMub3B0aW9ucyx0KX1zdGF0aWMgZnJvbUpTT04odCxlKXtjb25zdCBuPVtdO2ZvcihsZXQgaT0wLHI9dC5zaGFwZXMubGVuZ3RoO2k8cjtpKyspe2NvbnN0IHI9ZVt0LnNoYXBlc1tpXV07bi5wdXNoKHIpfWNvbnN0IGk9dC5vcHRpb25zLmV4dHJ1ZGVQYXRoO3JldHVybiB2b2lkIDAhPT1pJiYodC5vcHRpb25zLmV4dHJ1ZGVQYXRoPShuZXcgcG9baS50eXBlXSkuZnJvbUpTT04oaSkpLG5ldyBqbyhuLHQub3B0aW9ucyl9fWNvbnN0IHFvPXtnZW5lcmF0ZVRvcFVWOmZ1bmN0aW9uKHQsZSxuLGkscil7Y29uc3Qgcz1lWzMqbl0sYT1lWzMqbisxXSxvPWVbMyppXSxsPWVbMyppKzFdLGM9ZVszKnJdLGg9ZVszKnIrMV07cmV0dXJuW25ldyBBdChzLGEpLG5ldyBBdChvLGwpLG5ldyBBdChjLGgpXX0sZ2VuZXJhdGVTaWRlV2FsbFVWOmZ1bmN0aW9uKHQsZSxuLGkscixzKXtjb25zdCBhPWVbMypuXSxvPWVbMypuKzFdLGw9ZVszKm4rMl0sYz1lWzMqaV0saD1lWzMqaSsxXSx1PWVbMyppKzJdLGQ9ZVszKnJdLHA9ZVszKnIrMV0sbT1lWzMqcisyXSxmPWVbMypzXSxnPWVbMypzKzFdLHY9ZVszKnMrMl07cmV0dXJuIE1hdGguYWJzKG8taCk8TWF0aC5hYnMoYS1jKT9bbmV3IEF0KGEsMS1sKSxuZXcgQXQoYywxLXUpLG5ldyBBdChkLDEtbSksbmV3IEF0KGYsMS12KV06W25ldyBBdChvLDEtbCksbmV3IEF0KGgsMS11KSxuZXcgQXQocCwxLW0pLG5ldyBBdChnLDEtdildfX07Y2xhc3MgWG8gZXh0ZW5kcyBTbntjb25zdHJ1Y3Rvcih0PW5ldyBnbyhbbmV3IEF0KDAsLjUpLG5ldyBBdCgtLjUsLS41KSxuZXcgQXQoLjUsLS41KV0pLGU9MTIpe3N1cGVyKCksdGhpcy50eXBlPVwiU2hhcGVHZW9tZXRyeVwiLHRoaXMucGFyYW1ldGVycz17c2hhcGVzOnQsY3VydmVTZWdtZW50czplfTtjb25zdCBuPVtdLGk9W10scj1bXSxzPVtdO2xldCBhPTAsbz0wO2lmKCExPT09QXJyYXkuaXNBcnJheSh0KSlsKHQpO2Vsc2UgZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspbCh0W2VdKSx0aGlzLmFkZEdyb3VwKGEsbyxlKSxhKz1vLG89MDtmdW5jdGlvbiBsKHQpe2NvbnN0IGE9aS5sZW5ndGgvMyxsPXQuZXh0cmFjdFBvaW50cyhlKTtsZXQgYz1sLnNoYXBlO2NvbnN0IGg9bC5ob2xlczshMT09PVZvLmlzQ2xvY2tXaXNlKGMpJiYoYz1jLnJldmVyc2UoKSk7Zm9yKGxldCB0PTAsZT1oLmxlbmd0aDt0PGU7dCsrKXtjb25zdCBlPWhbdF07ITA9PT1Wby5pc0Nsb2NrV2lzZShlKSYmKGhbdF09ZS5yZXZlcnNlKCkpfWNvbnN0IHU9Vm8udHJpYW5ndWxhdGVTaGFwZShjLGgpO2ZvcihsZXQgdD0wLGU9aC5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT1oW3RdO2M9Yy5jb25jYXQoZSl9Zm9yKGxldCB0PTAsZT1jLmxlbmd0aDt0PGU7dCsrKXtjb25zdCBlPWNbdF07aS5wdXNoKGUueCxlLnksMCksci5wdXNoKDAsMCwxKSxzLnB1c2goZS54LGUueSl9Zm9yKGxldCB0PTAsZT11Lmxlbmd0aDt0PGU7dCsrKXtjb25zdCBlPXVbdF0saT1lWzBdK2Escj1lWzFdK2Escz1lWzJdK2E7bi5wdXNoKGkscixzKSxvKz0zfX10aGlzLnNldEluZGV4KG4pLHRoaXMuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgZ24oaSwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIixuZXcgZ24ociwzKSksdGhpcy5zZXRBdHRyaWJ1dGUoXCJ1dlwiLG5ldyBnbihzLDIpKX10b0pTT04oKXtjb25zdCB0PXN1cGVyLnRvSlNPTigpO3JldHVybiBmdW5jdGlvbih0LGUpe2lmKGUuc2hhcGVzPVtdLEFycmF5LmlzQXJyYXkodCkpZm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKXtjb25zdCBpPXRbbl07ZS5zaGFwZXMucHVzaChpLnV1aWQpfWVsc2UgZS5zaGFwZXMucHVzaCh0LnV1aWQpO3JldHVybiBlfSh0aGlzLnBhcmFtZXRlcnMuc2hhcGVzLHQpfXN0YXRpYyBmcm9tSlNPTih0LGUpe2NvbnN0IG49W107Zm9yKGxldCBpPTAscj10LnNoYXBlcy5sZW5ndGg7aTxyO2krKyl7Y29uc3Qgcj1lW3Quc2hhcGVzW2ldXTtuLnB1c2gocil9cmV0dXJuIG5ldyBYbyhuLHQuY3VydmVTZWdtZW50cyl9fWNsYXNzIFlvIGV4dGVuZHMgZW57Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJTaGFkb3dNYXRlcmlhbFwiLHRoaXMuY29sb3I9bmV3IGNuKDApLHRoaXMudHJhbnNwYXJlbnQ9ITAsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpc319WW8ucHJvdG90eXBlLmlzU2hhZG93TWF0ZXJpYWw9ITA7Y2xhc3MgWm8gZXh0ZW5kcyBlbntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuZGVmaW5lcz17U1RBTkRBUkQ6XCJcIn0sdGhpcy50eXBlPVwiTWVzaFN0YW5kYXJkTWF0ZXJpYWxcIix0aGlzLmNvbG9yPW5ldyBjbigxNjc3NzIxNSksdGhpcy5yb3VnaG5lc3M9MSx0aGlzLm1ldGFsbmVzcz0wLHRoaXMubWFwPW51bGwsdGhpcy5saWdodE1hcD1udWxsLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9MSx0aGlzLmFvTWFwPW51bGwsdGhpcy5hb01hcEludGVuc2l0eT0xLHRoaXMuZW1pc3NpdmU9bmV3IGNuKDApLHRoaXMuZW1pc3NpdmVJbnRlbnNpdHk9MSx0aGlzLmVtaXNzaXZlTWFwPW51bGwsdGhpcy5idW1wTWFwPW51bGwsdGhpcy5idW1wU2NhbGU9MSx0aGlzLm5vcm1hbE1hcD1udWxsLHRoaXMubm9ybWFsTWFwVHlwZT0wLHRoaXMubm9ybWFsU2NhbGU9bmV3IEF0KDEsMSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy5yb3VnaG5lc3NNYXA9bnVsbCx0aGlzLm1ldGFsbmVzc01hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLmVudk1hcD1udWxsLHRoaXMuZW52TWFwSW50ZW5zaXR5PTEsdGhpcy5yZWZyYWN0aW9uUmF0aW89Ljk4LHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPVwicm91bmRcIix0aGlzLndpcmVmcmFtZUxpbmVqb2luPVwicm91bmRcIix0aGlzLmZsYXRTaGFkaW5nPSExLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5kZWZpbmVzPXtTVEFOREFSRDpcIlwifSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5yb3VnaG5lc3M9dC5yb3VnaG5lc3MsdGhpcy5tZXRhbG5lc3M9dC5tZXRhbG5lc3MsdGhpcy5tYXA9dC5tYXAsdGhpcy5saWdodE1hcD10LmxpZ2h0TWFwLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9dC5saWdodE1hcEludGVuc2l0eSx0aGlzLmFvTWFwPXQuYW9NYXAsdGhpcy5hb01hcEludGVuc2l0eT10LmFvTWFwSW50ZW5zaXR5LHRoaXMuZW1pc3NpdmUuY29weSh0LmVtaXNzaXZlKSx0aGlzLmVtaXNzaXZlTWFwPXQuZW1pc3NpdmVNYXAsdGhpcy5lbWlzc2l2ZUludGVuc2l0eT10LmVtaXNzaXZlSW50ZW5zaXR5LHRoaXMuYnVtcE1hcD10LmJ1bXBNYXAsdGhpcy5idW1wU2NhbGU9dC5idW1wU2NhbGUsdGhpcy5ub3JtYWxNYXA9dC5ub3JtYWxNYXAsdGhpcy5ub3JtYWxNYXBUeXBlPXQubm9ybWFsTWFwVHlwZSx0aGlzLm5vcm1hbFNjYWxlLmNvcHkodC5ub3JtYWxTY2FsZSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9dC5kaXNwbGFjZW1lbnRNYXAsdGhpcy5kaXNwbGFjZW1lbnRTY2FsZT10LmRpc3BsYWNlbWVudFNjYWxlLHRoaXMuZGlzcGxhY2VtZW50Qmlhcz10LmRpc3BsYWNlbWVudEJpYXMsdGhpcy5yb3VnaG5lc3NNYXA9dC5yb3VnaG5lc3NNYXAsdGhpcy5tZXRhbG5lc3NNYXA9dC5tZXRhbG5lc3NNYXAsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMuZW52TWFwPXQuZW52TWFwLHRoaXMuZW52TWFwSW50ZW5zaXR5PXQuZW52TWFwSW50ZW5zaXR5LHRoaXMucmVmcmFjdGlvblJhdGlvPXQucmVmcmFjdGlvblJhdGlvLHRoaXMud2lyZWZyYW1lPXQud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPXQud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMud2lyZWZyYW1lTGluZWNhcD10LndpcmVmcmFtZUxpbmVjYXAsdGhpcy53aXJlZnJhbWVMaW5lam9pbj10LndpcmVmcmFtZUxpbmVqb2luLHRoaXMuZmxhdFNoYWRpbmc9dC5mbGF0U2hhZGluZyx0aGlzfX1aby5wcm90b3R5cGUuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbD0hMDtjbGFzcyBKbyBleHRlbmRzIFpve2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5kZWZpbmVzPXtTVEFOREFSRDpcIlwiLFBIWVNJQ0FMOlwiXCJ9LHRoaXMudHlwZT1cIk1lc2hQaHlzaWNhbE1hdGVyaWFsXCIsdGhpcy5jbGVhcmNvYXRNYXA9bnVsbCx0aGlzLmNsZWFyY29hdFJvdWdobmVzcz0wLHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwPW51bGwsdGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZT1uZXcgQXQoMSwxKSx0aGlzLmNsZWFyY29hdE5vcm1hbE1hcD1udWxsLHRoaXMuaW9yPTEuNSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInJlZmxlY3Rpdml0eVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYnQoMi41Kih0aGlzLmlvci0xKS8odGhpcy5pb3IrMSksMCwxKX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuaW9yPSgxKy40KnQpLygxLS40KnQpfX0pLHRoaXMuc2hlZW5UaW50PW5ldyBjbigwKSx0aGlzLnNoZWVuUm91Z2huZXNzPTEsdGhpcy50cmFuc21pc3Npb25NYXA9bnVsbCx0aGlzLnRoaWNrbmVzcz0uMDEsdGhpcy50aGlja25lc3NNYXA9bnVsbCx0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2U9MCx0aGlzLmF0dGVudWF0aW9uVGludD1uZXcgY24oMSwxLDEpLHRoaXMuc3BlY3VsYXJJbnRlbnNpdHk9MSx0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwPW51bGwsdGhpcy5zcGVjdWxhclRpbnQ9bmV3IGNuKDEsMSwxKSx0aGlzLnNwZWN1bGFyVGludE1hcD1udWxsLHRoaXMuX3NoZWVuPTAsdGhpcy5fY2xlYXJjb2F0PTAsdGhpcy5fdHJhbnNtaXNzaW9uPTAsdGhpcy5zZXRWYWx1ZXModCl9Z2V0IHNoZWVuKCl7cmV0dXJuIHRoaXMuX3NoZWVufXNldCBzaGVlbih0KXt0aGlzLl9zaGVlbj4wIT10PjAmJnRoaXMudmVyc2lvbisrLHRoaXMuX3NoZWVuPXR9Z2V0IGNsZWFyY29hdCgpe3JldHVybiB0aGlzLl9jbGVhcmNvYXR9c2V0IGNsZWFyY29hdCh0KXt0aGlzLl9jbGVhcmNvYXQ+MCE9dD4wJiZ0aGlzLnZlcnNpb24rKyx0aGlzLl9jbGVhcmNvYXQ9dH1nZXQgdHJhbnNtaXNzaW9uKCl7cmV0dXJuIHRoaXMuX3RyYW5zbWlzc2lvbn1zZXQgdHJhbnNtaXNzaW9uKHQpe3RoaXMuX3RyYW5zbWlzc2lvbj4wIT10PjAmJnRoaXMudmVyc2lvbisrLHRoaXMuX3RyYW5zbWlzc2lvbj10fWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5kZWZpbmVzPXtTVEFOREFSRDpcIlwiLFBIWVNJQ0FMOlwiXCJ9LHRoaXMuY2xlYXJjb2F0PXQuY2xlYXJjb2F0LHRoaXMuY2xlYXJjb2F0TWFwPXQuY2xlYXJjb2F0TWFwLHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzPXQuY2xlYXJjb2F0Um91Z2huZXNzLHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwPXQuY2xlYXJjb2F0Um91Z2huZXNzTWFwLHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwPXQuY2xlYXJjb2F0Tm9ybWFsTWFwLHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUuY29weSh0LmNsZWFyY29hdE5vcm1hbFNjYWxlKSx0aGlzLmlvcj10Lmlvcix0aGlzLnNoZWVuPXQuc2hlZW4sdGhpcy5zaGVlblRpbnQuY29weSh0LnNoZWVuVGludCksdGhpcy5zaGVlblJvdWdobmVzcz10LnNoZWVuUm91Z2huZXNzLHRoaXMudHJhbnNtaXNzaW9uPXQudHJhbnNtaXNzaW9uLHRoaXMudHJhbnNtaXNzaW9uTWFwPXQudHJhbnNtaXNzaW9uTWFwLHRoaXMudGhpY2tuZXNzPXQudGhpY2tuZXNzLHRoaXMudGhpY2tuZXNzTWFwPXQudGhpY2tuZXNzTWFwLHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZT10LmF0dGVudWF0aW9uRGlzdGFuY2UsdGhpcy5hdHRlbnVhdGlvblRpbnQuY29weSh0LmF0dGVudWF0aW9uVGludCksdGhpcy5zcGVjdWxhckludGVuc2l0eT10LnNwZWN1bGFySW50ZW5zaXR5LHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXA9dC5zcGVjdWxhckludGVuc2l0eU1hcCx0aGlzLnNwZWN1bGFyVGludC5jb3B5KHQuc3BlY3VsYXJUaW50KSx0aGlzLnNwZWN1bGFyVGludE1hcD10LnNwZWN1bGFyVGludE1hcCx0aGlzfX1Kby5wcm90b3R5cGUuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbD0hMDsoY2xhc3MgZXh0ZW5kcyBlbntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMudHlwZT1cIk1lc2hQaG9uZ01hdGVyaWFsXCIsdGhpcy5jb2xvcj1uZXcgY24oMTY3NzcyMTUpLHRoaXMuc3BlY3VsYXI9bmV3IGNuKDExMTg0ODEpLHRoaXMuc2hpbmluZXNzPTMwLHRoaXMubWFwPW51bGwsdGhpcy5saWdodE1hcD1udWxsLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9MSx0aGlzLmFvTWFwPW51bGwsdGhpcy5hb01hcEludGVuc2l0eT0xLHRoaXMuZW1pc3NpdmU9bmV3IGNuKDApLHRoaXMuZW1pc3NpdmVJbnRlbnNpdHk9MSx0aGlzLmVtaXNzaXZlTWFwPW51bGwsdGhpcy5idW1wTWFwPW51bGwsdGhpcy5idW1wU2NhbGU9MSx0aGlzLm5vcm1hbE1hcD1udWxsLHRoaXMubm9ybWFsTWFwVHlwZT0wLHRoaXMubm9ybWFsU2NhbGU9bmV3IEF0KDEsMSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy5zcGVjdWxhck1hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLmVudk1hcD1udWxsLHRoaXMuY29tYmluZT0wLHRoaXMucmVmbGVjdGl2aXR5PTEsdGhpcy5yZWZyYWN0aW9uUmF0aW89Ljk4LHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPVwicm91bmRcIix0aGlzLndpcmVmcmFtZUxpbmVqb2luPVwicm91bmRcIix0aGlzLmZsYXRTaGFkaW5nPSExLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jb2xvci5jb3B5KHQuY29sb3IpLHRoaXMuc3BlY3VsYXIuY29weSh0LnNwZWN1bGFyKSx0aGlzLnNoaW5pbmVzcz10LnNoaW5pbmVzcyx0aGlzLm1hcD10Lm1hcCx0aGlzLmxpZ2h0TWFwPXQubGlnaHRNYXAsdGhpcy5saWdodE1hcEludGVuc2l0eT10LmxpZ2h0TWFwSW50ZW5zaXR5LHRoaXMuYW9NYXA9dC5hb01hcCx0aGlzLmFvTWFwSW50ZW5zaXR5PXQuYW9NYXBJbnRlbnNpdHksdGhpcy5lbWlzc2l2ZS5jb3B5KHQuZW1pc3NpdmUpLHRoaXMuZW1pc3NpdmVNYXA9dC5lbWlzc2l2ZU1hcCx0aGlzLmVtaXNzaXZlSW50ZW5zaXR5PXQuZW1pc3NpdmVJbnRlbnNpdHksdGhpcy5idW1wTWFwPXQuYnVtcE1hcCx0aGlzLmJ1bXBTY2FsZT10LmJ1bXBTY2FsZSx0aGlzLm5vcm1hbE1hcD10Lm5vcm1hbE1hcCx0aGlzLm5vcm1hbE1hcFR5cGU9dC5ub3JtYWxNYXBUeXBlLHRoaXMubm9ybWFsU2NhbGUuY29weSh0Lm5vcm1hbFNjYWxlKSx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLnNwZWN1bGFyTWFwPXQuc3BlY3VsYXJNYXAsdGhpcy5hbHBoYU1hcD10LmFscGhhTWFwLHRoaXMuZW52TWFwPXQuZW52TWFwLHRoaXMuY29tYmluZT10LmNvbWJpbmUsdGhpcy5yZWZsZWN0aXZpdHk9dC5yZWZsZWN0aXZpdHksdGhpcy5yZWZyYWN0aW9uUmF0aW89dC5yZWZyYWN0aW9uUmF0aW8sdGhpcy53aXJlZnJhbWU9dC53aXJlZnJhbWUsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9dC53aXJlZnJhbWVMaW5ld2lkdGgsdGhpcy53aXJlZnJhbWVMaW5lY2FwPXQud2lyZWZyYW1lTGluZWNhcCx0aGlzLndpcmVmcmFtZUxpbmVqb2luPXQud2lyZWZyYW1lTGluZWpvaW4sdGhpcy5mbGF0U2hhZGluZz10LmZsYXRTaGFkaW5nLHRoaXN9fSkucHJvdG90eXBlLmlzTWVzaFBob25nTWF0ZXJpYWw9ITA7KGNsYXNzIGV4dGVuZHMgZW57Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmRlZmluZXM9e1RPT046XCJcIn0sdGhpcy50eXBlPVwiTWVzaFRvb25NYXRlcmlhbFwiLHRoaXMuY29sb3I9bmV3IGNuKDE2Nzc3MjE1KSx0aGlzLm1hcD1udWxsLHRoaXMuZ3JhZGllbnRNYXA9bnVsbCx0aGlzLmxpZ2h0TWFwPW51bGwsdGhpcy5saWdodE1hcEludGVuc2l0eT0xLHRoaXMuYW9NYXA9bnVsbCx0aGlzLmFvTWFwSW50ZW5zaXR5PTEsdGhpcy5lbWlzc2l2ZT1uZXcgY24oMCksdGhpcy5lbWlzc2l2ZUludGVuc2l0eT0xLHRoaXMuZW1pc3NpdmVNYXA9bnVsbCx0aGlzLmJ1bXBNYXA9bnVsbCx0aGlzLmJ1bXBTY2FsZT0xLHRoaXMubm9ybWFsTWFwPW51bGwsdGhpcy5ub3JtYWxNYXBUeXBlPTAsdGhpcy5ub3JtYWxTY2FsZT1uZXcgQXQoMSwxKSx0aGlzLmRpc3BsYWNlbWVudE1hcD1udWxsLHRoaXMuZGlzcGxhY2VtZW50U2NhbGU9MSx0aGlzLmRpc3BsYWNlbWVudEJpYXM9MCx0aGlzLmFscGhhTWFwPW51bGwsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLndpcmVmcmFtZUxpbmVjYXA9XCJyb3VuZFwiLHRoaXMud2lyZWZyYW1lTGluZWpvaW49XCJyb3VuZFwiLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jb2xvci5jb3B5KHQuY29sb3IpLHRoaXMubWFwPXQubWFwLHRoaXMuZ3JhZGllbnRNYXA9dC5ncmFkaWVudE1hcCx0aGlzLmxpZ2h0TWFwPXQubGlnaHRNYXAsdGhpcy5saWdodE1hcEludGVuc2l0eT10LmxpZ2h0TWFwSW50ZW5zaXR5LHRoaXMuYW9NYXA9dC5hb01hcCx0aGlzLmFvTWFwSW50ZW5zaXR5PXQuYW9NYXBJbnRlbnNpdHksdGhpcy5lbWlzc2l2ZS5jb3B5KHQuZW1pc3NpdmUpLHRoaXMuZW1pc3NpdmVNYXA9dC5lbWlzc2l2ZU1hcCx0aGlzLmVtaXNzaXZlSW50ZW5zaXR5PXQuZW1pc3NpdmVJbnRlbnNpdHksdGhpcy5idW1wTWFwPXQuYnVtcE1hcCx0aGlzLmJ1bXBTY2FsZT10LmJ1bXBTY2FsZSx0aGlzLm5vcm1hbE1hcD10Lm5vcm1hbE1hcCx0aGlzLm5vcm1hbE1hcFR5cGU9dC5ub3JtYWxNYXBUeXBlLHRoaXMubm9ybWFsU2NhbGUuY29weSh0Lm5vcm1hbFNjYWxlKSx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLmFscGhhTWFwPXQuYWxwaGFNYXAsdGhpcy53aXJlZnJhbWU9dC53aXJlZnJhbWUsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9dC53aXJlZnJhbWVMaW5ld2lkdGgsdGhpcy53aXJlZnJhbWVMaW5lY2FwPXQud2lyZWZyYW1lTGluZWNhcCx0aGlzLndpcmVmcmFtZUxpbmVqb2luPXQud2lyZWZyYW1lTGluZWpvaW4sdGhpc319KS5wcm90b3R5cGUuaXNNZXNoVG9vbk1hdGVyaWFsPSEwOyhjbGFzcyBleHRlbmRzIGVue2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50eXBlPVwiTWVzaE5vcm1hbE1hdGVyaWFsXCIsdGhpcy5idW1wTWFwPW51bGwsdGhpcy5idW1wU2NhbGU9MSx0aGlzLm5vcm1hbE1hcD1udWxsLHRoaXMubm9ybWFsTWFwVHlwZT0wLHRoaXMubm9ybWFsU2NhbGU9bmV3IEF0KDEsMSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy53aXJlZnJhbWU9ITEsdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MSx0aGlzLmZvZz0hMSx0aGlzLmZsYXRTaGFkaW5nPSExLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5idW1wTWFwPXQuYnVtcE1hcCx0aGlzLmJ1bXBTY2FsZT10LmJ1bXBTY2FsZSx0aGlzLm5vcm1hbE1hcD10Lm5vcm1hbE1hcCx0aGlzLm5vcm1hbE1hcFR5cGU9dC5ub3JtYWxNYXBUeXBlLHRoaXMubm9ybWFsU2NhbGUuY29weSh0Lm5vcm1hbFNjYWxlKSx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLndpcmVmcmFtZT10LndpcmVmcmFtZSx0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD10LndpcmVmcmFtZUxpbmV3aWR0aCx0aGlzLmZsYXRTaGFkaW5nPXQuZmxhdFNoYWRpbmcsdGhpc319KS5wcm90b3R5cGUuaXNNZXNoTm9ybWFsTWF0ZXJpYWw9ITA7KGNsYXNzIGV4dGVuZHMgZW57Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJNZXNoTGFtYmVydE1hdGVyaWFsXCIsdGhpcy5jb2xvcj1uZXcgY24oMTY3NzcyMTUpLHRoaXMubWFwPW51bGwsdGhpcy5saWdodE1hcD1udWxsLHRoaXMubGlnaHRNYXBJbnRlbnNpdHk9MSx0aGlzLmFvTWFwPW51bGwsdGhpcy5hb01hcEludGVuc2l0eT0xLHRoaXMuZW1pc3NpdmU9bmV3IGNuKDApLHRoaXMuZW1pc3NpdmVJbnRlbnNpdHk9MSx0aGlzLmVtaXNzaXZlTWFwPW51bGwsdGhpcy5zcGVjdWxhck1hcD1udWxsLHRoaXMuYWxwaGFNYXA9bnVsbCx0aGlzLmVudk1hcD1udWxsLHRoaXMuY29tYmluZT0wLHRoaXMucmVmbGVjdGl2aXR5PTEsdGhpcy5yZWZyYWN0aW9uUmF0aW89Ljk4LHRoaXMud2lyZWZyYW1lPSExLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPTEsdGhpcy53aXJlZnJhbWVMaW5lY2FwPVwicm91bmRcIix0aGlzLndpcmVmcmFtZUxpbmVqb2luPVwicm91bmRcIix0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuY29sb3IuY29weSh0LmNvbG9yKSx0aGlzLm1hcD10Lm1hcCx0aGlzLmxpZ2h0TWFwPXQubGlnaHRNYXAsdGhpcy5saWdodE1hcEludGVuc2l0eT10LmxpZ2h0TWFwSW50ZW5zaXR5LHRoaXMuYW9NYXA9dC5hb01hcCx0aGlzLmFvTWFwSW50ZW5zaXR5PXQuYW9NYXBJbnRlbnNpdHksdGhpcy5lbWlzc2l2ZS5jb3B5KHQuZW1pc3NpdmUpLHRoaXMuZW1pc3NpdmVNYXA9dC5lbWlzc2l2ZU1hcCx0aGlzLmVtaXNzaXZlSW50ZW5zaXR5PXQuZW1pc3NpdmVJbnRlbnNpdHksdGhpcy5zcGVjdWxhck1hcD10LnNwZWN1bGFyTWFwLHRoaXMuYWxwaGFNYXA9dC5hbHBoYU1hcCx0aGlzLmVudk1hcD10LmVudk1hcCx0aGlzLmNvbWJpbmU9dC5jb21iaW5lLHRoaXMucmVmbGVjdGl2aXR5PXQucmVmbGVjdGl2aXR5LHRoaXMucmVmcmFjdGlvblJhdGlvPXQucmVmcmFjdGlvblJhdGlvLHRoaXMud2lyZWZyYW1lPXQud2lyZWZyYW1lLHRoaXMud2lyZWZyYW1lTGluZXdpZHRoPXQud2lyZWZyYW1lTGluZXdpZHRoLHRoaXMud2lyZWZyYW1lTGluZWNhcD10LndpcmVmcmFtZUxpbmVjYXAsdGhpcy53aXJlZnJhbWVMaW5lam9pbj10LndpcmVmcmFtZUxpbmVqb2luLHRoaXN9fSkucHJvdG90eXBlLmlzTWVzaExhbWJlcnRNYXRlcmlhbD0hMDsoY2xhc3MgZXh0ZW5kcyBlbntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuZGVmaW5lcz17TUFUQ0FQOlwiXCJ9LHRoaXMudHlwZT1cIk1lc2hNYXRjYXBNYXRlcmlhbFwiLHRoaXMuY29sb3I9bmV3IGNuKDE2Nzc3MjE1KSx0aGlzLm1hdGNhcD1udWxsLHRoaXMubWFwPW51bGwsdGhpcy5idW1wTWFwPW51bGwsdGhpcy5idW1wU2NhbGU9MSx0aGlzLm5vcm1hbE1hcD1udWxsLHRoaXMubm9ybWFsTWFwVHlwZT0wLHRoaXMubm9ybWFsU2NhbGU9bmV3IEF0KDEsMSksdGhpcy5kaXNwbGFjZW1lbnRNYXA9bnVsbCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPTEsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPTAsdGhpcy5hbHBoYU1hcD1udWxsLHRoaXMuZmxhdFNoYWRpbmc9ITEsdGhpcy5zZXRWYWx1ZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmRlZmluZXM9e01BVENBUDpcIlwifSx0aGlzLmNvbG9yLmNvcHkodC5jb2xvciksdGhpcy5tYXRjYXA9dC5tYXRjYXAsdGhpcy5tYXA9dC5tYXAsdGhpcy5idW1wTWFwPXQuYnVtcE1hcCx0aGlzLmJ1bXBTY2FsZT10LmJ1bXBTY2FsZSx0aGlzLm5vcm1hbE1hcD10Lm5vcm1hbE1hcCx0aGlzLm5vcm1hbE1hcFR5cGU9dC5ub3JtYWxNYXBUeXBlLHRoaXMubm9ybWFsU2NhbGUuY29weSh0Lm5vcm1hbFNjYWxlKSx0aGlzLmRpc3BsYWNlbWVudE1hcD10LmRpc3BsYWNlbWVudE1hcCx0aGlzLmRpc3BsYWNlbWVudFNjYWxlPXQuZGlzcGxhY2VtZW50U2NhbGUsdGhpcy5kaXNwbGFjZW1lbnRCaWFzPXQuZGlzcGxhY2VtZW50Qmlhcyx0aGlzLmFscGhhTWFwPXQuYWxwaGFNYXAsdGhpcy5mbGF0U2hhZGluZz10LmZsYXRTaGFkaW5nLHRoaXN9fSkucHJvdG90eXBlLmlzTWVzaE1hdGNhcE1hdGVyaWFsPSEwOyhjbGFzcyBleHRlbmRzIFJhe2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50eXBlPVwiTGluZURhc2hlZE1hdGVyaWFsXCIsdGhpcy5zY2FsZT0xLHRoaXMuZGFzaFNpemU9Myx0aGlzLmdhcFNpemU9MSx0aGlzLnNldFZhbHVlcyh0KX1jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuc2NhbGU9dC5zY2FsZSx0aGlzLmRhc2hTaXplPXQuZGFzaFNpemUsdGhpcy5nYXBTaXplPXQuZ2FwU2l6ZSx0aGlzfX0pLnByb3RvdHlwZS5pc0xpbmVEYXNoZWRNYXRlcmlhbD0hMDtjb25zdCAkbz17YXJyYXlTbGljZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuICRvLmlzVHlwZWRBcnJheSh0KT9uZXcgdC5jb25zdHJ1Y3Rvcih0LnN1YmFycmF5KGUsdm9pZCAwIT09bj9uOnQubGVuZ3RoKSk6dC5zbGljZShlLG4pfSxjb252ZXJ0QXJyYXk6ZnVuY3Rpb24odCxlLG4pe3JldHVybiF0fHwhbiYmdC5jb25zdHJ1Y3Rvcj09PWU/dDpcIm51bWJlclwiPT10eXBlb2YgZS5CWVRFU19QRVJfRUxFTUVOVD9uZXcgZSh0KTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KX0saXNUeXBlZEFycmF5OmZ1bmN0aW9uKHQpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodCkmJiEodCBpbnN0YW5jZW9mIERhdGFWaWV3KX0sZ2V0S2V5ZnJhbWVPcmRlcjpmdW5jdGlvbih0KXtjb25zdCBlPXQubGVuZ3RoLG49bmV3IEFycmF5KGUpO2ZvcihsZXQgdD0wO3QhPT1lOysrdCluW3RdPXQ7cmV0dXJuIG4uc29ydCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdFtlXS10W25dfSkpLG59LHNvcnRlZEFycmF5OmZ1bmN0aW9uKHQsZSxuKXtjb25zdCBpPXQubGVuZ3RoLHI9bmV3IHQuY29uc3RydWN0b3IoaSk7Zm9yKGxldCBzPTAsYT0wO2EhPT1pOysrcyl7Y29uc3QgaT1uW3NdKmU7Zm9yKGxldCBuPTA7biE9PWU7KytuKXJbYSsrXT10W2krbl19cmV0dXJuIHJ9LGZsYXR0ZW5KU09OOmZ1bmN0aW9uKHQsZSxuLGkpe2xldCByPTEscz10WzBdO2Zvcig7dm9pZCAwIT09cyYmdm9pZCAwPT09c1tpXTspcz10W3IrK107aWYodm9pZCAwPT09cylyZXR1cm47bGV0IGE9c1tpXTtpZih2b2lkIDAhPT1hKWlmKEFycmF5LmlzQXJyYXkoYSkpZG97YT1zW2ldLHZvaWQgMCE9PWEmJihlLnB1c2gocy50aW1lKSxuLnB1c2guYXBwbHkobixhKSkscz10W3IrK119d2hpbGUodm9pZCAwIT09cyk7ZWxzZSBpZih2b2lkIDAhPT1hLnRvQXJyYXkpZG97YT1zW2ldLHZvaWQgMCE9PWEmJihlLnB1c2gocy50aW1lKSxhLnRvQXJyYXkobixuLmxlbmd0aCkpLHM9dFtyKytdfXdoaWxlKHZvaWQgMCE9PXMpO2Vsc2UgZG97YT1zW2ldLHZvaWQgMCE9PWEmJihlLnB1c2gocy50aW1lKSxuLnB1c2goYSkpLHM9dFtyKytdfXdoaWxlKHZvaWQgMCE9PXMpfSxzdWJjbGlwOmZ1bmN0aW9uKHQsZSxuLGkscj0zMCl7Y29uc3Qgcz10LmNsb25lKCk7cy5uYW1lPWU7Y29uc3QgYT1bXTtmb3IobGV0IHQ9MDt0PHMudHJhY2tzLmxlbmd0aDsrK3Qpe2NvbnN0IGU9cy50cmFja3NbdF0sbz1lLmdldFZhbHVlU2l6ZSgpLGw9W10sYz1bXTtmb3IobGV0IHQ9MDt0PGUudGltZXMubGVuZ3RoOysrdCl7Y29uc3Qgcz1lLnRpbWVzW3RdKnI7aWYoIShzPG58fHM+PWkpKXtsLnB1c2goZS50aW1lc1t0XSk7Zm9yKGxldCBuPTA7bjxvOysrbiljLnB1c2goZS52YWx1ZXNbdCpvK25dKX19MCE9PWwubGVuZ3RoJiYoZS50aW1lcz0kby5jb252ZXJ0QXJyYXkobCxlLnRpbWVzLmNvbnN0cnVjdG9yKSxlLnZhbHVlcz0kby5jb252ZXJ0QXJyYXkoYyxlLnZhbHVlcy5jb25zdHJ1Y3RvciksYS5wdXNoKGUpKX1zLnRyYWNrcz1hO2xldCBvPTEvMDtmb3IobGV0IHQ9MDt0PHMudHJhY2tzLmxlbmd0aDsrK3Qpbz5zLnRyYWNrc1t0XS50aW1lc1swXSYmKG89cy50cmFja3NbdF0udGltZXNbMF0pO2ZvcihsZXQgdD0wO3Q8cy50cmFja3MubGVuZ3RoOysrdClzLnRyYWNrc1t0XS5zaGlmdCgtMSpvKTtyZXR1cm4gcy5yZXNldER1cmF0aW9uKCksc30sbWFrZUNsaXBBZGRpdGl2ZTpmdW5jdGlvbih0LGU9MCxuPXQsaT0zMCl7aTw9MCYmKGk9MzApO2NvbnN0IHI9bi50cmFja3MubGVuZ3RoLHM9ZS9pO2ZvcihsZXQgZT0wO2U8cjsrK2Upe2NvbnN0IGk9bi50cmFja3NbZV0scj1pLlZhbHVlVHlwZU5hbWU7aWYoXCJib29sXCI9PT1yfHxcInN0cmluZ1wiPT09ciljb250aW51ZTtjb25zdCBhPXQudHJhY2tzLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWU9PT1pLm5hbWUmJnQuVmFsdWVUeXBlTmFtZT09PXJ9KSk7aWYodm9pZCAwPT09YSljb250aW51ZTtsZXQgbz0wO2NvbnN0IGw9aS5nZXRWYWx1ZVNpemUoKTtpLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lJiYobz1sLzMpO2xldCBjPTA7Y29uc3QgaD1hLmdldFZhbHVlU2l6ZSgpO2EuY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUmJihjPWgvMyk7Y29uc3QgdT1pLnRpbWVzLmxlbmd0aC0xO2xldCBkO2lmKHM8PWkudGltZXNbMF0pe2NvbnN0IHQ9byxlPWwtbztkPSRvLmFycmF5U2xpY2UoaS52YWx1ZXMsdCxlKX1lbHNlIGlmKHM+PWkudGltZXNbdV0pe2NvbnN0IHQ9dSpsK28sZT10K2wtbztkPSRvLmFycmF5U2xpY2UoaS52YWx1ZXMsdCxlKX1lbHNle2NvbnN0IHQ9aS5jcmVhdGVJbnRlcnBvbGFudCgpLGU9byxuPWwtbzt0LmV2YWx1YXRlKHMpLGQ9JG8uYXJyYXlTbGljZSh0LnJlc3VsdEJ1ZmZlcixlLG4pfWlmKFwicXVhdGVybmlvblwiPT09cil7KG5ldyB6dCkuZnJvbUFycmF5KGQpLm5vcm1hbGl6ZSgpLmNvbmp1Z2F0ZSgpLnRvQXJyYXkoZCl9Y29uc3QgcD1hLnRpbWVzLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHA7Kyt0KXtjb25zdCBlPXQqaCtjO2lmKFwicXVhdGVybmlvblwiPT09cil6dC5tdWx0aXBseVF1YXRlcm5pb25zRmxhdChhLnZhbHVlcyxlLGQsMCxhLnZhbHVlcyxlKTtlbHNle2NvbnN0IHQ9aC0yKmM7Zm9yKGxldCBuPTA7bjx0OysrbilhLnZhbHVlc1tlK25dLT1kW25dfX19cmV0dXJuIHQuYmxlbmRNb2RlPTI1MDEsdH19O2NsYXNzIEtve2NvbnN0cnVjdG9yKHQsZSxuLGkpe3RoaXMucGFyYW1ldGVyUG9zaXRpb25zPXQsdGhpcy5fY2FjaGVkSW5kZXg9MCx0aGlzLnJlc3VsdEJ1ZmZlcj12b2lkIDAhPT1pP2k6bmV3IGUuY29uc3RydWN0b3IobiksdGhpcy5zYW1wbGVWYWx1ZXM9ZSx0aGlzLnZhbHVlU2l6ZT1uLHRoaXMuc2V0dGluZ3M9bnVsbCx0aGlzLkRlZmF1bHRTZXR0aW5nc189e319ZXZhbHVhdGUodCl7Y29uc3QgZT10aGlzLnBhcmFtZXRlclBvc2l0aW9ucztsZXQgbj10aGlzLl9jYWNoZWRJbmRleCxpPWVbbl0scj1lW24tMV07dDp7ZTp7bGV0IHM7bjp7aTppZighKHQ8aSkpe2ZvcihsZXQgcz1uKzI7Oyl7aWYodm9pZCAwPT09aSl7aWYodDxyKWJyZWFrIGk7cmV0dXJuIG49ZS5sZW5ndGgsdGhpcy5fY2FjaGVkSW5kZXg9bix0aGlzLmFmdGVyRW5kXyhuLTEsdCxyKX1pZihuPT09cylicmVhaztpZihyPWksaT1lWysrbl0sdDxpKWJyZWFrIGV9cz1lLmxlbmd0aDticmVhayBufWlmKHQ+PXIpYnJlYWsgdDt7Y29uc3QgYT1lWzFdO3Q8YSYmKG49MixyPWEpO2ZvcihsZXQgcz1uLTI7Oyl7aWYodm9pZCAwPT09cilyZXR1cm4gdGhpcy5fY2FjaGVkSW5kZXg9MCx0aGlzLmJlZm9yZVN0YXJ0XygwLHQsaSk7aWYobj09PXMpYnJlYWs7aWYoaT1yLHI9ZVstLW4tMV0sdD49cilicmVhayBlfXM9bixuPTB9fWZvcig7bjxzOyl7Y29uc3QgaT1uK3M+Pj4xO3Q8ZVtpXT9zPWk6bj1pKzF9aWYoaT1lW25dLHI9ZVtuLTFdLHZvaWQgMD09PXIpcmV0dXJuIHRoaXMuX2NhY2hlZEluZGV4PTAsdGhpcy5iZWZvcmVTdGFydF8oMCx0LGkpO2lmKHZvaWQgMD09PWkpcmV0dXJuIG49ZS5sZW5ndGgsdGhpcy5fY2FjaGVkSW5kZXg9bix0aGlzLmFmdGVyRW5kXyhuLTEscix0KX10aGlzLl9jYWNoZWRJbmRleD1uLHRoaXMuaW50ZXJ2YWxDaGFuZ2VkXyhuLHIsaSl9cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKG4scix0LGkpfWdldFNldHRpbmdzXygpe3JldHVybiB0aGlzLnNldHRpbmdzfHx0aGlzLkRlZmF1bHRTZXR0aW5nc199Y29weVNhbXBsZVZhbHVlXyh0KXtjb25zdCBlPXRoaXMucmVzdWx0QnVmZmVyLG49dGhpcy5zYW1wbGVWYWx1ZXMsaT10aGlzLnZhbHVlU2l6ZSxyPXQqaTtmb3IobGV0IHQ9MDt0IT09aTsrK3QpZVt0XT1uW3IrdF07cmV0dXJuIGV9aW50ZXJwb2xhdGVfKCl7dGhyb3cgbmV3IEVycm9yKFwiY2FsbCB0byBhYnN0cmFjdCBtZXRob2RcIil9aW50ZXJ2YWxDaGFuZ2VkXygpe319S28ucHJvdG90eXBlLmJlZm9yZVN0YXJ0Xz1Lby5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxLby5wcm90b3R5cGUuYWZ0ZXJFbmRfPUtvLnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfO2NsYXNzIFFvIGV4dGVuZHMgS297Y29uc3RydWN0b3IodCxlLG4saSl7c3VwZXIodCxlLG4saSksdGhpcy5fd2VpZ2h0UHJldj0tMCx0aGlzLl9vZmZzZXRQcmV2PS0wLHRoaXMuX3dlaWdodE5leHQ9LTAsdGhpcy5fb2Zmc2V0TmV4dD0tMCx0aGlzLkRlZmF1bHRTZXR0aW5nc189e2VuZGluZ1N0YXJ0OjI0MDAsZW5kaW5nRW5kOjI0MDB9fWludGVydmFsQ2hhbmdlZF8odCxlLG4pe2NvbnN0IGk9dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnM7bGV0IHI9dC0yLHM9dCsxLGE9aVtyXSxvPWlbc107aWYodm9pZCAwPT09YSlzd2l0Y2godGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCl7Y2FzZSAyNDAxOnI9dCxhPTIqZS1uO2JyZWFrO2Nhc2UgMjQwMjpyPWkubGVuZ3RoLTIsYT1lK2lbcl0taVtyKzFdO2JyZWFrO2RlZmF1bHQ6cj10LGE9bn1pZih2b2lkIDA9PT1vKXN3aXRjaCh0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ0VuZCl7Y2FzZSAyNDAxOnM9dCxvPTIqbi1lO2JyZWFrO2Nhc2UgMjQwMjpzPTEsbz1uK2lbMV0taVswXTticmVhaztkZWZhdWx0OnM9dC0xLG89ZX1jb25zdCBsPS41KihuLWUpLGM9dGhpcy52YWx1ZVNpemU7dGhpcy5fd2VpZ2h0UHJldj1sLyhlLWEpLHRoaXMuX3dlaWdodE5leHQ9bC8oby1uKSx0aGlzLl9vZmZzZXRQcmV2PXIqYyx0aGlzLl9vZmZzZXROZXh0PXMqY31pbnRlcnBvbGF0ZV8odCxlLG4saSl7Y29uc3Qgcj10aGlzLnJlc3VsdEJ1ZmZlcixzPXRoaXMuc2FtcGxlVmFsdWVzLGE9dGhpcy52YWx1ZVNpemUsbz10KmEsbD1vLWEsYz10aGlzLl9vZmZzZXRQcmV2LGg9dGhpcy5fb2Zmc2V0TmV4dCx1PXRoaXMuX3dlaWdodFByZXYsZD10aGlzLl93ZWlnaHROZXh0LHA9KG4tZSkvKGktZSksbT1wKnAsZj1tKnAsZz0tdSpmKzIqdSptLXUqcCx2PSgxK3UpKmYrKC0xLjUtMip1KSptKygtLjUrdSkqcCsxLHk9KC0xLWQpKmYrKDEuNStkKSptKy41KnAseD1kKmYtZCptO2ZvcihsZXQgdD0wO3QhPT1hOysrdClyW3RdPWcqc1tjK3RdK3Yqc1tsK3RdK3kqc1tvK3RdK3gqc1toK3RdO3JldHVybiByfX1jbGFzcyB0bCBleHRlbmRzIEtve2NvbnN0cnVjdG9yKHQsZSxuLGkpe3N1cGVyKHQsZSxuLGkpfWludGVycG9sYXRlXyh0LGUsbixpKXtjb25zdCByPXRoaXMucmVzdWx0QnVmZmVyLHM9dGhpcy5zYW1wbGVWYWx1ZXMsYT10aGlzLnZhbHVlU2l6ZSxvPXQqYSxsPW8tYSxjPShuLWUpLyhpLWUpLGg9MS1jO2ZvcihsZXQgdD0wO3QhPT1hOysrdClyW3RdPXNbbCt0XSpoK3Nbbyt0XSpjO3JldHVybiByfX1jbGFzcyBlbCBleHRlbmRzIEtve2NvbnN0cnVjdG9yKHQsZSxuLGkpe3N1cGVyKHQsZSxuLGkpfWludGVycG9sYXRlXyh0KXtyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKHQtMSl9fWNsYXNzIG5se2NvbnN0cnVjdG9yKHQsZSxuLGkpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgbmFtZSBpcyB1bmRlZmluZWRcIik7aWYodm9pZCAwPT09ZXx8MD09PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRIUkVFLktleWZyYW1lVHJhY2s6IG5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCBcIit0KTt0aGlzLm5hbWU9dCx0aGlzLnRpbWVzPSRvLmNvbnZlcnRBcnJheShlLHRoaXMuVGltZUJ1ZmZlclR5cGUpLHRoaXMudmFsdWVzPSRvLmNvbnZlcnRBcnJheShuLHRoaXMuVmFsdWVCdWZmZXJUeXBlKSx0aGlzLnNldEludGVycG9sYXRpb24oaXx8dGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbil9c3RhdGljIHRvSlNPTih0KXtjb25zdCBlPXQuY29uc3RydWN0b3I7bGV0IG47aWYoZS50b0pTT04hPT10aGlzLnRvSlNPTiluPWUudG9KU09OKHQpO2Vsc2V7bj17bmFtZTp0Lm5hbWUsdGltZXM6JG8uY29udmVydEFycmF5KHQudGltZXMsQXJyYXkpLHZhbHVlczokby5jb252ZXJ0QXJyYXkodC52YWx1ZXMsQXJyYXkpfTtjb25zdCBlPXQuZ2V0SW50ZXJwb2xhdGlvbigpO2UhPT10LkRlZmF1bHRJbnRlcnBvbGF0aW9uJiYobi5pbnRlcnBvbGF0aW9uPWUpfXJldHVybiBuLnR5cGU9dC5WYWx1ZVR5cGVOYW1lLG59SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGUodCl7cmV0dXJuIG5ldyBlbCh0aGlzLnRpbWVzLHRoaXMudmFsdWVzLHRoaXMuZ2V0VmFsdWVTaXplKCksdCl9SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyKHQpe3JldHVybiBuZXcgdGwodGhpcy50aW1lcyx0aGlzLnZhbHVlcyx0aGlzLmdldFZhbHVlU2l6ZSgpLHQpfUludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCh0KXtyZXR1cm4gbmV3IFFvKHRoaXMudGltZXMsdGhpcy52YWx1ZXMsdGhpcy5nZXRWYWx1ZVNpemUoKSx0KX1zZXRJbnRlcnBvbGF0aW9uKHQpe2xldCBlO3N3aXRjaCh0KXtjYXNlIDIzMDA6ZT10aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO2JyZWFrO2Nhc2UgMjMwMTplPXRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyO2JyZWFrO2Nhc2UgMjMwMjplPXRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RofWlmKHZvaWQgMD09PWUpe2NvbnN0IGU9XCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcIit0aGlzLlZhbHVlVHlwZU5hbWUrXCIga2V5ZnJhbWUgdHJhY2sgbmFtZWQgXCIrdGhpcy5uYW1lO2lmKHZvaWQgMD09PXRoaXMuY3JlYXRlSW50ZXJwb2xhbnQpe2lmKHQ9PT10aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uKXRocm93IG5ldyBFcnJvcihlKTt0aGlzLnNldEludGVycG9sYXRpb24odGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbil9cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLktleWZyYW1lVHJhY2s6XCIsZSksdGhpc31yZXR1cm4gdGhpcy5jcmVhdGVJbnRlcnBvbGFudD1lLHRoaXN9Z2V0SW50ZXJwb2xhdGlvbigpe3N3aXRjaCh0aGlzLmNyZWF0ZUludGVycG9sYW50KXtjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6cmV0dXJuIDIzMDA7Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpyZXR1cm4gMjMwMTtjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOnJldHVybiAyMzAyfX1nZXRWYWx1ZVNpemUoKXtyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoL3RoaXMudGltZXMubGVuZ3RofXNoaWZ0KHQpe2lmKDAhPT10KXtjb25zdCBlPXRoaXMudGltZXM7Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuIT09aTsrK24pZVtuXSs9dH1yZXR1cm4gdGhpc31zY2FsZSh0KXtpZigxIT09dCl7Y29uc3QgZT10aGlzLnRpbWVzO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7biE9PWk7KytuKWVbbl0qPXR9cmV0dXJuIHRoaXN9dHJpbSh0LGUpe2NvbnN0IG49dGhpcy50aW1lcyxpPW4ubGVuZ3RoO2xldCByPTAscz1pLTE7Zm9yKDtyIT09aSYmbltyXTx0OykrK3I7Zm9yKDstMSE9PXMmJm5bc10+ZTspLS1zO2lmKCsrcywwIT09cnx8cyE9PWkpe3I+PXMmJihzPU1hdGgubWF4KHMsMSkscj1zLTEpO2NvbnN0IHQ9dGhpcy5nZXRWYWx1ZVNpemUoKTt0aGlzLnRpbWVzPSRvLmFycmF5U2xpY2UobixyLHMpLHRoaXMudmFsdWVzPSRvLmFycmF5U2xpY2UodGhpcy52YWx1ZXMscip0LHMqdCl9cmV0dXJuIHRoaXN9dmFsaWRhdGUoKXtsZXQgdD0hMDtjb25zdCBlPXRoaXMuZ2V0VmFsdWVTaXplKCk7ZS1NYXRoLmZsb29yKGUpIT0wJiYoY29uc29sZS5lcnJvcihcIlRIUkVFLktleWZyYW1lVHJhY2s6IEludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFjay5cIix0aGlzKSx0PSExKTtjb25zdCBuPXRoaXMudGltZXMsaT10aGlzLnZhbHVlcyxyPW4ubGVuZ3RoOzA9PT1yJiYoY29uc29sZS5lcnJvcihcIlRIUkVFLktleWZyYW1lVHJhY2s6IFRyYWNrIGlzIGVtcHR5LlwiLHRoaXMpLHQ9ITEpO2xldCBzPW51bGw7Zm9yKGxldCBlPTA7ZSE9PXI7ZSsrKXtjb25zdCBpPW5bZV07aWYoXCJudW1iZXJcIj09dHlwZW9mIGkmJmlzTmFOKGkpKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuS2V5ZnJhbWVUcmFjazogVGltZSBpcyBub3QgYSB2YWxpZCBudW1iZXIuXCIsdGhpcyxlLGkpLHQ9ITE7YnJlYWt9aWYobnVsbCE9PXMmJnM+aSl7Y29uc29sZS5lcnJvcihcIlRIUkVFLktleWZyYW1lVHJhY2s6IE91dCBvZiBvcmRlciBrZXlzLlwiLHRoaXMsZSxpLHMpLHQ9ITE7YnJlYWt9cz1pfWlmKHZvaWQgMCE9PWkmJiRvLmlzVHlwZWRBcnJheShpKSlmb3IobGV0IGU9MCxuPWkubGVuZ3RoO2UhPT1uOysrZSl7Y29uc3Qgbj1pW2VdO2lmKGlzTmFOKG4pKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuS2V5ZnJhbWVUcmFjazogVmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLlwiLHRoaXMsZSxuKSx0PSExO2JyZWFrfX1yZXR1cm4gdH1vcHRpbWl6ZSgpe2NvbnN0IHQ9JG8uYXJyYXlTbGljZSh0aGlzLnRpbWVzKSxlPSRvLmFycmF5U2xpY2UodGhpcy52YWx1ZXMpLG49dGhpcy5nZXRWYWx1ZVNpemUoKSxpPTIzMDI9PT10aGlzLmdldEludGVycG9sYXRpb24oKSxyPXQubGVuZ3RoLTE7bGV0IHM9MTtmb3IobGV0IGE9MTthPHI7KythKXtsZXQgcj0hMTtjb25zdCBvPXRbYV07aWYobyE9PXRbYSsxXSYmKDEhPT1hfHxvIT09dFswXSkpaWYoaSlyPSEwO2Vsc2V7Y29uc3QgdD1hKm4saT10LW4scz10K247Zm9yKGxldCBhPTA7YSE9PW47KythKXtjb25zdCBuPWVbdCthXTtpZihuIT09ZVtpK2FdfHxuIT09ZVtzK2FdKXtyPSEwO2JyZWFrfX19aWYocil7aWYoYSE9PXMpe3Rbc109dFthXTtjb25zdCBpPWEqbixyPXMqbjtmb3IobGV0IHQ9MDt0IT09bjsrK3QpZVtyK3RdPWVbaSt0XX0rK3N9fWlmKHI+MCl7dFtzXT10W3JdO2ZvcihsZXQgdD1yKm4saT1zKm4sYT0wO2EhPT1uOysrYSllW2krYV09ZVt0K2FdOysrc31yZXR1cm4gcyE9PXQubGVuZ3RoPyh0aGlzLnRpbWVzPSRvLmFycmF5U2xpY2UodCwwLHMpLHRoaXMudmFsdWVzPSRvLmFycmF5U2xpY2UoZSwwLHMqbikpOih0aGlzLnRpbWVzPXQsdGhpcy52YWx1ZXM9ZSksdGhpc31jbG9uZSgpe2NvbnN0IHQ9JG8uYXJyYXlTbGljZSh0aGlzLnRpbWVzLDApLGU9JG8uYXJyYXlTbGljZSh0aGlzLnZhbHVlcywwKSxuPW5ldygwLHRoaXMuY29uc3RydWN0b3IpKHRoaXMubmFtZSx0LGUpO3JldHVybiBuLmNyZWF0ZUludGVycG9sYW50PXRoaXMuY3JlYXRlSW50ZXJwb2xhbnQsbn19bmwucHJvdG90eXBlLlRpbWVCdWZmZXJUeXBlPUZsb2F0MzJBcnJheSxubC5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlPUZsb2F0MzJBcnJheSxubC5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb249MjMwMTtjbGFzcyBpbCBleHRlbmRzIG5se31pbC5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZT1cImJvb2xcIixpbC5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlPUFycmF5LGlsLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbj0yMzAwLGlsLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI9dm9pZCAwLGlsLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg9dm9pZCAwO2NsYXNzIHJsIGV4dGVuZHMgbmx7fXJsLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lPVwiY29sb3JcIjtjbGFzcyBzbCBleHRlbmRzIG5se31zbC5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZT1cIm51bWJlclwiO2NsYXNzIGFsIGV4dGVuZHMgS297Y29uc3RydWN0b3IodCxlLG4saSl7c3VwZXIodCxlLG4saSl9aW50ZXJwb2xhdGVfKHQsZSxuLGkpe2NvbnN0IHI9dGhpcy5yZXN1bHRCdWZmZXIscz10aGlzLnNhbXBsZVZhbHVlcyxhPXRoaXMudmFsdWVTaXplLG89KG4tZSkvKGktZSk7bGV0IGw9dCphO2ZvcihsZXQgdD1sK2E7bCE9PXQ7bCs9NCl6dC5zbGVycEZsYXQociwwLHMsbC1hLHMsbCxvKTtyZXR1cm4gcn19Y2xhc3Mgb2wgZXh0ZW5kcyBubHtJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIodCl7cmV0dXJuIG5ldyBhbCh0aGlzLnRpbWVzLHRoaXMudmFsdWVzLHRoaXMuZ2V0VmFsdWVTaXplKCksdCl9fW9sLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lPVwicXVhdGVybmlvblwiLG9sLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbj0yMzAxLG9sLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg9dm9pZCAwO2NsYXNzIGxsIGV4dGVuZHMgbmx7fWxsLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lPVwic3RyaW5nXCIsbGwucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZT1BcnJheSxsbC5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb249MjMwMCxsbC5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyPXZvaWQgMCxsbC5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoPXZvaWQgMDtjbGFzcyBjbCBleHRlbmRzIG5se31jbC5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZT1cInZlY3RvclwiO2NsYXNzIGhse2NvbnN0cnVjdG9yKHQsZT0tMSxuLGk9MjUwMCl7dGhpcy5uYW1lPXQsdGhpcy50cmFja3M9bix0aGlzLmR1cmF0aW9uPWUsdGhpcy5ibGVuZE1vZGU9aSx0aGlzLnV1aWQ9eHQoKSx0aGlzLmR1cmF0aW9uPDAmJnRoaXMucmVzZXREdXJhdGlvbigpfXN0YXRpYyBwYXJzZSh0KXtjb25zdCBlPVtdLG49dC50cmFja3MsaT0xLyh0LmZwc3x8MSk7Zm9yKGxldCB0PTAscj1uLmxlbmd0aDt0IT09cjsrK3QpZS5wdXNoKHVsKG5bdF0pLnNjYWxlKGkpKTtjb25zdCByPW5ldyB0aGlzKHQubmFtZSx0LmR1cmF0aW9uLGUsdC5ibGVuZE1vZGUpO3JldHVybiByLnV1aWQ9dC51dWlkLHJ9c3RhdGljIHRvSlNPTih0KXtjb25zdCBlPVtdLG49dC50cmFja3MsaT17bmFtZTp0Lm5hbWUsZHVyYXRpb246dC5kdXJhdGlvbix0cmFja3M6ZSx1dWlkOnQudXVpZCxibGVuZE1vZGU6dC5ibGVuZE1vZGV9O2ZvcihsZXQgdD0wLGk9bi5sZW5ndGg7dCE9PWk7Kyt0KWUucHVzaChubC50b0pTT04oblt0XSkpO3JldHVybiBpfXN0YXRpYyBDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSh0LGUsbixpKXtjb25zdCByPWUubGVuZ3RoLHM9W107Zm9yKGxldCB0PTA7dDxyO3QrKyl7bGV0IGE9W10sbz1bXTthLnB1c2goKHQrci0xKSVyLHQsKHQrMSklciksby5wdXNoKDAsMSwwKTtjb25zdCBsPSRvLmdldEtleWZyYW1lT3JkZXIoYSk7YT0kby5zb3J0ZWRBcnJheShhLDEsbCksbz0kby5zb3J0ZWRBcnJheShvLDEsbCksaXx8MCE9PWFbMF18fChhLnB1c2gociksby5wdXNoKG9bMF0pKSxzLnB1c2gobmV3IHNsKFwiLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tcIitlW3RdLm5hbWUrXCJdXCIsYSxvKS5zY2FsZSgxL24pKX1yZXR1cm4gbmV3IHRoaXModCwtMSxzKX1zdGF0aWMgZmluZEJ5TmFtZSh0LGUpe2xldCBuPXQ7aWYoIUFycmF5LmlzQXJyYXkodCkpe2NvbnN0IGU9dDtuPWUuZ2VvbWV0cnkmJmUuZ2VvbWV0cnkuYW5pbWF0aW9uc3x8ZS5hbmltYXRpb25zfWZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWlmKG5bdF0ubmFtZT09PWUpcmV0dXJuIG5bdF07cmV0dXJuIG51bGx9c3RhdGljIENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKHQsZSxuKXtjb25zdCBpPXt9LHI9L14oW1xcdy1dKj8pKFtcXGRdKykkLztmb3IobGV0IGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49dFtlXSxzPW4ubmFtZS5tYXRjaChyKTtpZihzJiZzLmxlbmd0aD4xKXtjb25zdCB0PXNbMV07bGV0IGU9aVt0XTtlfHwoaVt0XT1lPVtdKSxlLnB1c2gobil9fWNvbnN0IHM9W107Zm9yKGNvbnN0IHQgaW4gaSlzLnB1c2godGhpcy5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSh0LGlbdF0sZSxuKSk7cmV0dXJuIHN9c3RhdGljIHBhcnNlQW5pbWF0aW9uKHQsZSl7aWYoIXQpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5BbmltYXRpb25DbGlwOiBObyBhbmltYXRpb24gaW4gSlNPTkxvYWRlciBkYXRhLlwiKSxudWxsO2NvbnN0IG49ZnVuY3Rpb24odCxlLG4saSxyKXtpZigwIT09bi5sZW5ndGgpe2NvbnN0IHM9W10sYT1bXTskby5mbGF0dGVuSlNPTihuLHMsYSxpKSwwIT09cy5sZW5ndGgmJnIucHVzaChuZXcgdChlLHMsYSkpfX0saT1bXSxyPXQubmFtZXx8XCJkZWZhdWx0XCIscz10LmZwc3x8MzAsYT10LmJsZW5kTW9kZTtsZXQgbz10Lmxlbmd0aHx8LTE7Y29uc3QgbD10LmhpZXJhcmNoeXx8W107Zm9yKGxldCB0PTA7dDxsLmxlbmd0aDt0Kyspe2NvbnN0IHI9bFt0XS5rZXlzO2lmKHImJjAhPT1yLmxlbmd0aClpZihyWzBdLm1vcnBoVGFyZ2V0cyl7Y29uc3QgdD17fTtsZXQgZTtmb3IoZT0wO2U8ci5sZW5ndGg7ZSsrKWlmKHJbZV0ubW9ycGhUYXJnZXRzKWZvcihsZXQgbj0wO248cltlXS5tb3JwaFRhcmdldHMubGVuZ3RoO24rKyl0W3JbZV0ubW9ycGhUYXJnZXRzW25dXT0tMTtmb3IoY29uc3QgbiBpbiB0KXtjb25zdCB0PVtdLHM9W107Zm9yKGxldCBpPTA7aSE9PXJbZV0ubW9ycGhUYXJnZXRzLmxlbmd0aDsrK2kpe2NvbnN0IGk9cltlXTt0LnB1c2goaS50aW1lKSxzLnB1c2goaS5tb3JwaFRhcmdldD09PW4/MTowKX1pLnB1c2gobmV3IHNsKFwiLm1vcnBoVGFyZ2V0SW5mbHVlbmNlW1wiK24rXCJdXCIsdCxzKSl9bz10Lmxlbmd0aCooc3x8MSl9ZWxzZXtjb25zdCBzPVwiLmJvbmVzW1wiK2VbdF0ubmFtZStcIl1cIjtuKGNsLHMrXCIucG9zaXRpb25cIixyLFwicG9zXCIsaSksbihvbCxzK1wiLnF1YXRlcm5pb25cIixyLFwicm90XCIsaSksbihjbCxzK1wiLnNjYWxlXCIscixcInNjbFwiLGkpfX1pZigwPT09aS5sZW5ndGgpcmV0dXJuIG51bGw7cmV0dXJuIG5ldyB0aGlzKHIsbyxpLGEpfXJlc2V0RHVyYXRpb24oKXtsZXQgdD0wO2ZvcihsZXQgZT0wLG49dGhpcy50cmFja3MubGVuZ3RoO2UhPT1uOysrZSl7Y29uc3Qgbj10aGlzLnRyYWNrc1tlXTt0PU1hdGgubWF4KHQsbi50aW1lc1tuLnRpbWVzLmxlbmd0aC0xXSl9cmV0dXJuIHRoaXMuZHVyYXRpb249dCx0aGlzfXRyaW0oKXtmb3IobGV0IHQ9MDt0PHRoaXMudHJhY2tzLmxlbmd0aDt0KyspdGhpcy50cmFja3NbdF0udHJpbSgwLHRoaXMuZHVyYXRpb24pO3JldHVybiB0aGlzfXZhbGlkYXRlKCl7bGV0IHQ9ITA7Zm9yKGxldCBlPTA7ZTx0aGlzLnRyYWNrcy5sZW5ndGg7ZSsrKXQ9dCYmdGhpcy50cmFja3NbZV0udmFsaWRhdGUoKTtyZXR1cm4gdH1vcHRpbWl6ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy50cmFja3MubGVuZ3RoO3QrKyl0aGlzLnRyYWNrc1t0XS5vcHRpbWl6ZSgpO3JldHVybiB0aGlzfWNsb25lKCl7Y29uc3QgdD1bXTtmb3IobGV0IGU9MDtlPHRoaXMudHJhY2tzLmxlbmd0aDtlKyspdC5wdXNoKHRoaXMudHJhY2tzW2VdLmNsb25lKCkpO3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm5hbWUsdGhpcy5kdXJhdGlvbix0LHRoaXMuYmxlbmRNb2RlKX10b0pTT04oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b0pTT04odGhpcyl9fWZ1bmN0aW9uIHVsKHQpe2lmKHZvaWQgMD09PXQudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayB0eXBlIHVuZGVmaW5lZCwgY2FuIG5vdCBwYXJzZVwiKTtjb25zdCBlPWZ1bmN0aW9uKHQpe3N3aXRjaCh0LnRvTG93ZXJDYXNlKCkpe2Nhc2VcInNjYWxhclwiOmNhc2VcImRvdWJsZVwiOmNhc2VcImZsb2F0XCI6Y2FzZVwibnVtYmVyXCI6Y2FzZVwiaW50ZWdlclwiOnJldHVybiBzbDtjYXNlXCJ2ZWN0b3JcIjpjYXNlXCJ2ZWN0b3IyXCI6Y2FzZVwidmVjdG9yM1wiOmNhc2VcInZlY3RvcjRcIjpyZXR1cm4gY2w7Y2FzZVwiY29sb3JcIjpyZXR1cm4gcmw7Y2FzZVwicXVhdGVybmlvblwiOnJldHVybiBvbDtjYXNlXCJib29sXCI6Y2FzZVwiYm9vbGVhblwiOnJldHVybiBpbDtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gbGx9dGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuS2V5ZnJhbWVUcmFjazogVW5zdXBwb3J0ZWQgdHlwZU5hbWU6IFwiK3QpfSh0LnR5cGUpO2lmKHZvaWQgMD09PXQudGltZXMpe2NvbnN0IGU9W10sbj1bXTskby5mbGF0dGVuSlNPTih0LmtleXMsZSxuLFwidmFsdWVcIiksdC50aW1lcz1lLHQudmFsdWVzPW59cmV0dXJuIHZvaWQgMCE9PWUucGFyc2U/ZS5wYXJzZSh0KTpuZXcgZSh0Lm5hbWUsdC50aW1lcyx0LnZhbHVlcyx0LmludGVycG9sYXRpb24pfWNvbnN0IGRsPXtlbmFibGVkOiExLGZpbGVzOnt9LGFkZDpmdW5jdGlvbih0LGUpeyExIT09dGhpcy5lbmFibGVkJiYodGhpcy5maWxlc1t0XT1lKX0sZ2V0OmZ1bmN0aW9uKHQpe2lmKCExIT09dGhpcy5lbmFibGVkKXJldHVybiB0aGlzLmZpbGVzW3RdfSxyZW1vdmU6ZnVuY3Rpb24odCl7ZGVsZXRlIHRoaXMuZmlsZXNbdF19LGNsZWFyOmZ1bmN0aW9uKCl7dGhpcy5maWxlcz17fX19O2NvbnN0IHBsPW5ldyBjbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7Y29uc3QgaT10aGlzO2xldCByLHM9ITEsYT0wLG89MDtjb25zdCBsPVtdO3RoaXMub25TdGFydD12b2lkIDAsdGhpcy5vbkxvYWQ9dCx0aGlzLm9uUHJvZ3Jlc3M9ZSx0aGlzLm9uRXJyb3I9bix0aGlzLml0ZW1TdGFydD1mdW5jdGlvbih0KXtvKyssITE9PT1zJiZ2b2lkIDAhPT1pLm9uU3RhcnQmJmkub25TdGFydCh0LGEsbykscz0hMH0sdGhpcy5pdGVtRW5kPWZ1bmN0aW9uKHQpe2ErKyx2b2lkIDAhPT1pLm9uUHJvZ3Jlc3MmJmkub25Qcm9ncmVzcyh0LGEsbyksYT09PW8mJihzPSExLHZvaWQgMCE9PWkub25Mb2FkJiZpLm9uTG9hZCgpKX0sdGhpcy5pdGVtRXJyb3I9ZnVuY3Rpb24odCl7dm9pZCAwIT09aS5vbkVycm9yJiZpLm9uRXJyb3IodCl9LHRoaXMucmVzb2x2ZVVSTD1mdW5jdGlvbih0KXtyZXR1cm4gcj9yKHQpOnR9LHRoaXMuc2V0VVJMTW9kaWZpZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHI9dCx0aGlzfSx0aGlzLmFkZEhhbmRsZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbC5wdXNoKHQsZSksdGhpc30sdGhpcy5yZW1vdmVIYW5kbGVyPWZ1bmN0aW9uKHQpe2NvbnN0IGU9bC5pbmRleE9mKHQpO3JldHVybi0xIT09ZSYmbC5zcGxpY2UoZSwyKSx0aGlzfSx0aGlzLmdldEhhbmRsZXI9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPTAsbj1sLmxlbmd0aDtlPG47ZSs9Mil7Y29uc3Qgbj1sW2VdLGk9bFtlKzFdO2lmKG4uZ2xvYmFsJiYobi5sYXN0SW5kZXg9MCksbi50ZXN0KHQpKXJldHVybiBpfXJldHVybiBudWxsfX19O2NsYXNzIG1se2NvbnN0cnVjdG9yKHQpe3RoaXMubWFuYWdlcj12b2lkIDAhPT10P3Q6cGwsdGhpcy5jcm9zc09yaWdpbj1cImFub255bW91c1wiLHRoaXMud2l0aENyZWRlbnRpYWxzPSExLHRoaXMucGF0aD1cIlwiLHRoaXMucmVzb3VyY2VQYXRoPVwiXCIsdGhpcy5yZXF1ZXN0SGVhZGVyPXt9fWxvYWQoKXt9bG9hZEFzeW5jKHQsZSl7Y29uc3Qgbj10aGlzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxyKXtuLmxvYWQodCxpLGUscil9KSl9cGFyc2UoKXt9c2V0Q3Jvc3NPcmlnaW4odCl7cmV0dXJuIHRoaXMuY3Jvc3NPcmlnaW49dCx0aGlzfXNldFdpdGhDcmVkZW50aWFscyh0KXtyZXR1cm4gdGhpcy53aXRoQ3JlZGVudGlhbHM9dCx0aGlzfXNldFBhdGgodCl7cmV0dXJuIHRoaXMucGF0aD10LHRoaXN9c2V0UmVzb3VyY2VQYXRoKHQpe3JldHVybiB0aGlzLnJlc291cmNlUGF0aD10LHRoaXN9c2V0UmVxdWVzdEhlYWRlcih0KXtyZXR1cm4gdGhpcy5yZXF1ZXN0SGVhZGVyPXQsdGhpc319Y29uc3QgZmw9e307Y2xhc3MgZ2wgZXh0ZW5kcyBtbHtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1sb2FkKHQsZSxuLGkpe3ZvaWQgMD09PXQmJih0PVwiXCIpLHZvaWQgMCE9PXRoaXMucGF0aCYmKHQ9dGhpcy5wYXRoK3QpLHQ9dGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwodCk7Y29uc3Qgcj10aGlzLHM9ZGwuZ2V0KHQpO2lmKHZvaWQgMCE9PXMpcmV0dXJuIHIubWFuYWdlci5pdGVtU3RhcnQodCksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtlJiZlKHMpLHIubWFuYWdlci5pdGVtRW5kKHQpfSksMCkscztpZih2b2lkIDAhPT1mbFt0XSlyZXR1cm4gdm9pZCBmbFt0XS5wdXNoKHtvbkxvYWQ6ZSxvblByb2dyZXNzOm4sb25FcnJvcjppfSk7Y29uc3QgYT10Lm1hdGNoKC9eZGF0YTooLio/KSg7YmFzZTY0KT8sKC4qKSQvKTtsZXQgbztpZihhKXtjb25zdCBuPWFbMV0scz0hIWFbMl07bGV0IG89YVszXTtvPWRlY29kZVVSSUNvbXBvbmVudChvKSxzJiYobz1hdG9iKG8pKTt0cnl7bGV0IGk7Y29uc3Qgcz0odGhpcy5yZXNwb25zZVR5cGV8fFwiXCIpLnRvTG93ZXJDYXNlKCk7c3dpdGNoKHMpe2Nhc2VcImFycmF5YnVmZmVyXCI6Y2FzZVwiYmxvYlwiOmNvbnN0IHQ9bmV3IFVpbnQ4QXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgZT0wO2U8by5sZW5ndGg7ZSsrKXRbZV09by5jaGFyQ29kZUF0KGUpO2k9XCJibG9iXCI9PT1zP25ldyBCbG9iKFt0LmJ1ZmZlcl0se3R5cGU6bn0pOnQuYnVmZmVyO2JyZWFrO2Nhc2VcImRvY3VtZW50XCI6Y29uc3QgZT1uZXcgRE9NUGFyc2VyO2k9ZS5wYXJzZUZyb21TdHJpbmcobyxuKTticmVhaztjYXNlXCJqc29uXCI6aT1KU09OLnBhcnNlKG8pO2JyZWFrO2RlZmF1bHQ6aT1vfXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZSYmZShpKSxyLm1hbmFnZXIuaXRlbUVuZCh0KX0pLDApfWNhdGNoKGUpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aSYmaShlKSxyLm1hbmFnZXIuaXRlbUVycm9yKHQpLHIubWFuYWdlci5pdGVtRW5kKHQpfSksMCl9fWVsc2V7ZmxbdF09W10sZmxbdF0ucHVzaCh7b25Mb2FkOmUsb25Qcm9ncmVzczpuLG9uRXJyb3I6aX0pLG89bmV3IFhNTEh0dHBSZXF1ZXN0LG8ub3BlbihcIkdFVFwiLHQsITApLG8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oZSl7Y29uc3Qgbj10aGlzLnJlc3BvbnNlLGk9ZmxbdF07aWYoZGVsZXRlIGZsW3RdLDIwMD09PXRoaXMuc3RhdHVzfHwwPT09dGhpcy5zdGF0dXMpezA9PT10aGlzLnN0YXR1cyYmY29uc29sZS53YXJuKFwiVEhSRUUuRmlsZUxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC5cIiksZGwuYWRkKHQsbik7Zm9yKGxldCB0PTAsZT1pLmxlbmd0aDt0PGU7dCsrKXtjb25zdCBlPWlbdF07ZS5vbkxvYWQmJmUub25Mb2FkKG4pfXIubWFuYWdlci5pdGVtRW5kKHQpfWVsc2V7Zm9yKGxldCB0PTAsbj1pLmxlbmd0aDt0PG47dCsrKXtjb25zdCBuPWlbdF07bi5vbkVycm9yJiZuLm9uRXJyb3IoZSl9ci5tYW5hZ2VyLml0ZW1FcnJvcih0KSxyLm1hbmFnZXIuaXRlbUVuZCh0KX19KSwhMSksby5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwoZnVuY3Rpb24oZSl7Y29uc3Qgbj1mbFt0XTtmb3IobGV0IHQ9MCxpPW4ubGVuZ3RoO3Q8aTt0Kyspe2NvbnN0IGk9blt0XTtpLm9uUHJvZ3Jlc3MmJmkub25Qcm9ncmVzcyhlKX19KSwhMSksby5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwoZnVuY3Rpb24oZSl7Y29uc3Qgbj1mbFt0XTtkZWxldGUgZmxbdF07Zm9yKGxldCB0PTAsaT1uLmxlbmd0aDt0PGk7dCsrKXtjb25zdCBpPW5bdF07aS5vbkVycm9yJiZpLm9uRXJyb3IoZSl9ci5tYW5hZ2VyLml0ZW1FcnJvcih0KSxyLm1hbmFnZXIuaXRlbUVuZCh0KX0pLCExKSxvLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLChmdW5jdGlvbihlKXtjb25zdCBuPWZsW3RdO2RlbGV0ZSBmbFt0XTtmb3IobGV0IHQ9MCxpPW4ubGVuZ3RoO3Q8aTt0Kyspe2NvbnN0IGk9blt0XTtpLm9uRXJyb3ImJmkub25FcnJvcihlKX1yLm1hbmFnZXIuaXRlbUVycm9yKHQpLHIubWFuYWdlci5pdGVtRW5kKHQpfSksITEpLHZvaWQgMCE9PXRoaXMucmVzcG9uc2VUeXBlJiYoby5yZXNwb25zZVR5cGU9dGhpcy5yZXNwb25zZVR5cGUpLHZvaWQgMCE9PXRoaXMud2l0aENyZWRlbnRpYWxzJiYoby53aXRoQ3JlZGVudGlhbHM9dGhpcy53aXRoQ3JlZGVudGlhbHMpLG8ub3ZlcnJpZGVNaW1lVHlwZSYmby5vdmVycmlkZU1pbWVUeXBlKHZvaWQgMCE9PXRoaXMubWltZVR5cGU/dGhpcy5taW1lVHlwZTpcInRleHQvcGxhaW5cIik7Zm9yKGNvbnN0IHQgaW4gdGhpcy5yZXF1ZXN0SGVhZGVyKW8uc2V0UmVxdWVzdEhlYWRlcih0LHRoaXMucmVxdWVzdEhlYWRlclt0XSk7by5zZW5kKG51bGwpfXJldHVybiByLm1hbmFnZXIuaXRlbVN0YXJ0KHQpLG99c2V0UmVzcG9uc2VUeXBlKHQpe3JldHVybiB0aGlzLnJlc3BvbnNlVHlwZT10LHRoaXN9c2V0TWltZVR5cGUodCl7cmV0dXJuIHRoaXMubWltZVR5cGU9dCx0aGlzfX1jbGFzcyB2bCBleHRlbmRzIG1se2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLG4saSl7dm9pZCAwIT09dGhpcy5wYXRoJiYodD10aGlzLnBhdGgrdCksdD10aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCh0KTtjb25zdCByPXRoaXMscz1kbC5nZXQodCk7aWYodm9pZCAwIT09cylyZXR1cm4gci5tYW5hZ2VyLml0ZW1TdGFydCh0KSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe2UmJmUocyksci5tYW5hZ2VyLml0ZW1FbmQodCl9KSwwKSxzO2NvbnN0IGE9Q3QoXCJpbWdcIik7ZnVuY3Rpb24gbygpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixvLCExKSxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGwsITEpLGRsLmFkZCh0LHRoaXMpLGUmJmUodGhpcyksci5tYW5hZ2VyLml0ZW1FbmQodCl9ZnVuY3Rpb24gbChlKXthLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsbywhMSksYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixsLCExKSxpJiZpKGUpLHIubWFuYWdlci5pdGVtRXJyb3IodCksci5tYW5hZ2VyLml0ZW1FbmQodCl9cmV0dXJuIGEuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixvLCExKSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGwsITEpLFwiZGF0YTpcIiE9PXQuc3Vic3RyKDAsNSkmJnZvaWQgMCE9PXRoaXMuY3Jvc3NPcmlnaW4mJihhLmNyb3NzT3JpZ2luPXRoaXMuY3Jvc3NPcmlnaW4pLHIubWFuYWdlci5pdGVtU3RhcnQodCksYS5zcmM9dCxhfX1jbGFzcyB5bCBleHRlbmRzIG1se2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLG4saSl7Y29uc3Qgcj1uZXcgS24scz1uZXcgdmwodGhpcy5tYW5hZ2VyKTtzLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pLHMuc2V0UGF0aCh0aGlzLnBhdGgpO2xldCBhPTA7ZnVuY3Rpb24gbyhuKXtzLmxvYWQodFtuXSwoZnVuY3Rpb24odCl7ci5pbWFnZXNbbl09dCxhKyssNj09PWEmJihyLm5lZWRzVXBkYXRlPSEwLGUmJmUocikpfSksdm9pZCAwLGkpfWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKW8oZSk7cmV0dXJuIHJ9fWNsYXNzIHhsIGV4dGVuZHMgbWx7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9bG9hZCh0LGUsbixpKXtjb25zdCByPXRoaXMscz1uZXcgYmEsYT1uZXcgZ2wodGhpcy5tYW5hZ2VyKTtyZXR1cm4gYS5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKSxhLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKSxhLnNldFBhdGgodGhpcy5wYXRoKSxhLnNldFdpdGhDcmVkZW50aWFscyhyLndpdGhDcmVkZW50aWFscyksYS5sb2FkKHQsKGZ1bmN0aW9uKHQpe2NvbnN0IG49ci5wYXJzZSh0KTtuJiYodm9pZCAwIT09bi5pbWFnZT9zLmltYWdlPW4uaW1hZ2U6dm9pZCAwIT09bi5kYXRhJiYocy5pbWFnZS53aWR0aD1uLndpZHRoLHMuaW1hZ2UuaGVpZ2h0PW4uaGVpZ2h0LHMuaW1hZ2UuZGF0YT1uLmRhdGEpLHMud3JhcFM9dm9pZCAwIT09bi53cmFwUz9uLndyYXBTOjEwMDEscy53cmFwVD12b2lkIDAhPT1uLndyYXBUP24ud3JhcFQ6MTAwMSxzLm1hZ0ZpbHRlcj12b2lkIDAhPT1uLm1hZ0ZpbHRlcj9uLm1hZ0ZpbHRlcjoxMDA2LHMubWluRmlsdGVyPXZvaWQgMCE9PW4ubWluRmlsdGVyP24ubWluRmlsdGVyOjEwMDYscy5hbmlzb3Ryb3B5PXZvaWQgMCE9PW4uYW5pc290cm9weT9uLmFuaXNvdHJvcHk6MSx2b2lkIDAhPT1uLmVuY29kaW5nJiYocy5lbmNvZGluZz1uLmVuY29kaW5nKSx2b2lkIDAhPT1uLmZsaXBZJiYocy5mbGlwWT1uLmZsaXBZKSx2b2lkIDAhPT1uLmZvcm1hdCYmKHMuZm9ybWF0PW4uZm9ybWF0KSx2b2lkIDAhPT1uLnR5cGUmJihzLnR5cGU9bi50eXBlKSx2b2lkIDAhPT1uLm1pcG1hcHMmJihzLm1pcG1hcHM9bi5taXBtYXBzLHMubWluRmlsdGVyPTEwMDgpLDE9PT1uLm1pcG1hcENvdW50JiYocy5taW5GaWx0ZXI9MTAwNiksdm9pZCAwIT09bi5nZW5lcmF0ZU1pcG1hcHMmJihzLmdlbmVyYXRlTWlwbWFwcz1uLmdlbmVyYXRlTWlwbWFwcykscy5uZWVkc1VwZGF0ZT0hMCxlJiZlKHMsbikpfSksbixpKSxzfX1jbGFzcyBibCBleHRlbmRzIG1se2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLG4saSl7Y29uc3Qgcj1uZXcgTnQscz1uZXcgdmwodGhpcy5tYW5hZ2VyKTtyZXR1cm4gcy5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKSxzLnNldFBhdGgodGhpcy5wYXRoKSxzLmxvYWQodCwoZnVuY3Rpb24odCl7ci5pbWFnZT10LHIubmVlZHNVcGRhdGU9ITAsdm9pZCAwIT09ZSYmZShyKX0pLG4saSkscn19Y2xhc3Mgd2wgZXh0ZW5kcyBWZXtjb25zdHJ1Y3Rvcih0LGU9MSl7c3VwZXIoKSx0aGlzLnR5cGU9XCJMaWdodFwiLHRoaXMuY29sb3I9bmV3IGNuKHQpLHRoaXMuaW50ZW5zaXR5PWV9ZGlzcG9zZSgpe31jb3B5KHQpe3JldHVybiBzdXBlci5jb3B5KHQpLHRoaXMuY29sb3IuY29weSh0LmNvbG9yKSx0aGlzLmludGVuc2l0eT10LmludGVuc2l0eSx0aGlzfXRvSlNPTih0KXtjb25zdCBlPXN1cGVyLnRvSlNPTih0KTtyZXR1cm4gZS5vYmplY3QuY29sb3I9dGhpcy5jb2xvci5nZXRIZXgoKSxlLm9iamVjdC5pbnRlbnNpdHk9dGhpcy5pbnRlbnNpdHksdm9pZCAwIT09dGhpcy5ncm91bmRDb2xvciYmKGUub2JqZWN0Lmdyb3VuZENvbG9yPXRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCkpLHZvaWQgMCE9PXRoaXMuZGlzdGFuY2UmJihlLm9iamVjdC5kaXN0YW5jZT10aGlzLmRpc3RhbmNlKSx2b2lkIDAhPT10aGlzLmFuZ2xlJiYoZS5vYmplY3QuYW5nbGU9dGhpcy5hbmdsZSksdm9pZCAwIT09dGhpcy5kZWNheSYmKGUub2JqZWN0LmRlY2F5PXRoaXMuZGVjYXkpLHZvaWQgMCE9PXRoaXMucGVudW1icmEmJihlLm9iamVjdC5wZW51bWJyYT10aGlzLnBlbnVtYnJhKSx2b2lkIDAhPT10aGlzLnNoYWRvdyYmKGUub2JqZWN0LnNoYWRvdz10aGlzLnNoYWRvdy50b0pTT04oKSksZX19d2wucHJvdG90eXBlLmlzTGlnaHQ9ITA7KGNsYXNzIGV4dGVuZHMgd2x7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKHQsbiksdGhpcy50eXBlPVwiSGVtaXNwaGVyZUxpZ2h0XCIsdGhpcy5wb3NpdGlvbi5jb3B5KFZlLkRlZmF1bHRVcCksdGhpcy51cGRhdGVNYXRyaXgoKSx0aGlzLmdyb3VuZENvbG9yPW5ldyBjbihlKX1jb3B5KHQpe3JldHVybiB3bC5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsdCksdGhpcy5ncm91bmRDb2xvci5jb3B5KHQuZ3JvdW5kQ29sb3IpLHRoaXN9fSkucHJvdG90eXBlLmlzSGVtaXNwaGVyZUxpZ2h0PSEwO2NvbnN0IF9sPW5ldyB2ZSxNbD1uZXcgQnQsU2w9bmV3IEJ0O2NsYXNzIFRse2NvbnN0cnVjdG9yKHQpe3RoaXMuY2FtZXJhPXQsdGhpcy5iaWFzPTAsdGhpcy5ub3JtYWxCaWFzPTAsdGhpcy5yYWRpdXM9MSx0aGlzLmJsdXJTYW1wbGVzPTgsdGhpcy5tYXBTaXplPW5ldyBBdCg1MTIsNTEyKSx0aGlzLm1hcD1udWxsLHRoaXMubWFwUGFzcz1udWxsLHRoaXMubWF0cml4PW5ldyB2ZSx0aGlzLmF1dG9VcGRhdGU9ITAsdGhpcy5uZWVkc1VwZGF0ZT0hMSx0aGlzLl9mcnVzdHVtPW5ldyBhaSx0aGlzLl9mcmFtZUV4dGVudHM9bmV3IEF0KDEsMSksdGhpcy5fdmlld3BvcnRDb3VudD0xLHRoaXMuX3ZpZXdwb3J0cz1bbmV3IE90KDAsMCwxLDEpXX1nZXRWaWV3cG9ydENvdW50KCl7cmV0dXJuIHRoaXMuX3ZpZXdwb3J0Q291bnR9Z2V0RnJ1c3R1bSgpe3JldHVybiB0aGlzLl9mcnVzdHVtfXVwZGF0ZU1hdHJpY2VzKHQpe2NvbnN0IGU9dGhpcy5jYW1lcmEsbj10aGlzLm1hdHJpeDtNbC5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCksZS5wb3NpdGlvbi5jb3B5KE1sKSxTbC5zZXRGcm9tTWF0cml4UG9zaXRpb24odC50YXJnZXQubWF0cml4V29ybGQpLGUubG9va0F0KFNsKSxlLnVwZGF0ZU1hdHJpeFdvcmxkKCksX2wubXVsdGlwbHlNYXRyaWNlcyhlLnByb2plY3Rpb25NYXRyaXgsZS5tYXRyaXhXb3JsZEludmVyc2UpLHRoaXMuX2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoX2wpLG4uc2V0KC41LDAsMCwuNSwwLC41LDAsLjUsMCwwLC41LC41LDAsMCwwLDEpLG4ubXVsdGlwbHkoZS5wcm9qZWN0aW9uTWF0cml4KSxuLm11bHRpcGx5KGUubWF0cml4V29ybGRJbnZlcnNlKX1nZXRWaWV3cG9ydCh0KXtyZXR1cm4gdGhpcy5fdmlld3BvcnRzW3RdfWdldEZyYW1lRXh0ZW50cygpe3JldHVybiB0aGlzLl9mcmFtZUV4dGVudHN9ZGlzcG9zZSgpe3RoaXMubWFwJiZ0aGlzLm1hcC5kaXNwb3NlKCksdGhpcy5tYXBQYXNzJiZ0aGlzLm1hcFBhc3MuZGlzcG9zZSgpfWNvcHkodCl7cmV0dXJuIHRoaXMuY2FtZXJhPXQuY2FtZXJhLmNsb25lKCksdGhpcy5iaWFzPXQuYmlhcyx0aGlzLnJhZGl1cz10LnJhZGl1cyx0aGlzLm1hcFNpemUuY29weSh0Lm1hcFNpemUpLHRoaXN9Y2xvbmUoKXtyZXR1cm4obmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcyl9dG9KU09OKCl7Y29uc3QgdD17fTtyZXR1cm4gMCE9PXRoaXMuYmlhcyYmKHQuYmlhcz10aGlzLmJpYXMpLDAhPT10aGlzLm5vcm1hbEJpYXMmJih0Lm5vcm1hbEJpYXM9dGhpcy5ub3JtYWxCaWFzKSwxIT09dGhpcy5yYWRpdXMmJih0LnJhZGl1cz10aGlzLnJhZGl1cyksNTEyPT09dGhpcy5tYXBTaXplLngmJjUxMj09PXRoaXMubWFwU2l6ZS55fHwodC5tYXBTaXplPXRoaXMubWFwU2l6ZS50b0FycmF5KCkpLHQuY2FtZXJhPXRoaXMuY2FtZXJhLnRvSlNPTighMSkub2JqZWN0LGRlbGV0ZSB0LmNhbWVyYS5tYXRyaXgsdH19Y2xhc3MgRWwgZXh0ZW5kcyBUbHtjb25zdHJ1Y3Rvcigpe3N1cGVyKG5ldyBKbig1MCwxLC41LDUwMCkpLHRoaXMuZm9jdXM9MX11cGRhdGVNYXRyaWNlcyh0KXtjb25zdCBlPXRoaXMuY2FtZXJhLG49MipndCp0LmFuZ2xlKnRoaXMuZm9jdXMsaT10aGlzLm1hcFNpemUud2lkdGgvdGhpcy5tYXBTaXplLmhlaWdodCxyPXQuZGlzdGFuY2V8fGUuZmFyO249PT1lLmZvdiYmaT09PWUuYXNwZWN0JiZyPT09ZS5mYXJ8fChlLmZvdj1uLGUuYXNwZWN0PWksZS5mYXI9cixlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSksc3VwZXIudXBkYXRlTWF0cmljZXModCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmZvY3VzPXQuZm9jdXMsdGhpc319RWwucHJvdG90eXBlLmlzU3BvdExpZ2h0U2hhZG93PSEwO2NsYXNzIEFsIGV4dGVuZHMgd2x7Y29uc3RydWN0b3IodCxlLG49MCxpPU1hdGguUEkvMyxyPTAscz0xKXtzdXBlcih0LGUpLHRoaXMudHlwZT1cIlNwb3RMaWdodFwiLHRoaXMucG9zaXRpb24uY29weShWZS5EZWZhdWx0VXApLHRoaXMudXBkYXRlTWF0cml4KCksdGhpcy50YXJnZXQ9bmV3IFZlLHRoaXMuZGlzdGFuY2U9bix0aGlzLmFuZ2xlPWksdGhpcy5wZW51bWJyYT1yLHRoaXMuZGVjYXk9cyx0aGlzLnNoYWRvdz1uZXcgRWx9Z2V0IHBvd2VyKCl7cmV0dXJuIHRoaXMuaW50ZW5zaXR5Kk1hdGguUEl9c2V0IHBvd2VyKHQpe3RoaXMuaW50ZW5zaXR5PXQvTWF0aC5QSX1kaXNwb3NlKCl7dGhpcy5zaGFkb3cuZGlzcG9zZSgpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5kaXN0YW5jZT10LmRpc3RhbmNlLHRoaXMuYW5nbGU9dC5hbmdsZSx0aGlzLnBlbnVtYnJhPXQucGVudW1icmEsdGhpcy5kZWNheT10LmRlY2F5LHRoaXMudGFyZ2V0PXQudGFyZ2V0LmNsb25lKCksdGhpcy5zaGFkb3c9dC5zaGFkb3cuY2xvbmUoKSx0aGlzfX1BbC5wcm90b3R5cGUuaXNTcG90TGlnaHQ9ITA7Y29uc3QgTGw9bmV3IHZlLFJsPW5ldyBCdCxDbD1uZXcgQnQ7Y2xhc3MgUGwgZXh0ZW5kcyBUbHtjb25zdHJ1Y3Rvcigpe3N1cGVyKG5ldyBKbig5MCwxLC41LDUwMCkpLHRoaXMuX2ZyYW1lRXh0ZW50cz1uZXcgQXQoNCwyKSx0aGlzLl92aWV3cG9ydENvdW50PTYsdGhpcy5fdmlld3BvcnRzPVtuZXcgT3QoMiwxLDEsMSksbmV3IE90KDAsMSwxLDEpLG5ldyBPdCgzLDEsMSwxKSxuZXcgT3QoMSwxLDEsMSksbmV3IE90KDMsMCwxLDEpLG5ldyBPdCgxLDAsMSwxKV0sdGhpcy5fY3ViZURpcmVjdGlvbnM9W25ldyBCdCgxLDAsMCksbmV3IEJ0KC0xLDAsMCksbmV3IEJ0KDAsMCwxKSxuZXcgQnQoMCwwLC0xKSxuZXcgQnQoMCwxLDApLG5ldyBCdCgwLC0xLDApXSx0aGlzLl9jdWJlVXBzPVtuZXcgQnQoMCwxLDApLG5ldyBCdCgwLDEsMCksbmV3IEJ0KDAsMSwwKSxuZXcgQnQoMCwxLDApLG5ldyBCdCgwLDAsMSksbmV3IEJ0KDAsMCwtMSldfXVwZGF0ZU1hdHJpY2VzKHQsZT0wKXtjb25zdCBuPXRoaXMuY2FtZXJhLGk9dGhpcy5tYXRyaXgscj10LmRpc3RhbmNlfHxuLmZhcjtyIT09bi5mYXImJihuLmZhcj1yLG4udXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpKSxSbC5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCksbi5wb3NpdGlvbi5jb3B5KFJsKSxDbC5jb3B5KG4ucG9zaXRpb24pLENsLmFkZCh0aGlzLl9jdWJlRGlyZWN0aW9uc1tlXSksbi51cC5jb3B5KHRoaXMuX2N1YmVVcHNbZV0pLG4ubG9va0F0KENsKSxuLnVwZGF0ZU1hdHJpeFdvcmxkKCksaS5tYWtlVHJhbnNsYXRpb24oLVJsLngsLVJsLnksLVJsLnopLExsLm11bHRpcGx5TWF0cmljZXMobi5wcm9qZWN0aW9uTWF0cml4LG4ubWF0cml4V29ybGRJbnZlcnNlKSx0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KExsKX19UGwucHJvdG90eXBlLmlzUG9pbnRMaWdodFNoYWRvdz0hMDtjbGFzcyBJbCBleHRlbmRzIHdse2NvbnN0cnVjdG9yKHQsZSxuPTAsaT0xKXtzdXBlcih0LGUpLHRoaXMudHlwZT1cIlBvaW50TGlnaHRcIix0aGlzLmRpc3RhbmNlPW4sdGhpcy5kZWNheT1pLHRoaXMuc2hhZG93PW5ldyBQbH1nZXQgcG93ZXIoKXtyZXR1cm4gNCp0aGlzLmludGVuc2l0eSpNYXRoLlBJfXNldCBwb3dlcih0KXt0aGlzLmludGVuc2l0eT10Lyg0Kk1hdGguUEkpfWRpc3Bvc2UoKXt0aGlzLnNoYWRvdy5kaXNwb3NlKCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLmRpc3RhbmNlPXQuZGlzdGFuY2UsdGhpcy5kZWNheT10LmRlY2F5LHRoaXMuc2hhZG93PXQuc2hhZG93LmNsb25lKCksdGhpc319SWwucHJvdG90eXBlLmlzUG9pbnRMaWdodD0hMDtjbGFzcyBEbCBleHRlbmRzIFRse2NvbnN0cnVjdG9yKCl7c3VwZXIobmV3IHhpKC01LDUsNSwtNSwuNSw1MDApKX19RGwucHJvdG90eXBlLmlzRGlyZWN0aW9uYWxMaWdodFNoYWRvdz0hMDtjbGFzcyBObCBleHRlbmRzIHdse2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIodCxlKSx0aGlzLnR5cGU9XCJEaXJlY3Rpb25hbExpZ2h0XCIsdGhpcy5wb3NpdGlvbi5jb3B5KFZlLkRlZmF1bHRVcCksdGhpcy51cGRhdGVNYXRyaXgoKSx0aGlzLnRhcmdldD1uZXcgVmUsdGhpcy5zaGFkb3c9bmV3IERsfWRpc3Bvc2UoKXt0aGlzLnNoYWRvdy5kaXNwb3NlKCl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnRhcmdldD10LnRhcmdldC5jbG9uZSgpLHRoaXMuc2hhZG93PXQuc2hhZG93LmNsb25lKCksdGhpc319TmwucHJvdG90eXBlLmlzRGlyZWN0aW9uYWxMaWdodD0hMDsoY2xhc3MgZXh0ZW5kcyB3bHtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQsZSksdGhpcy50eXBlPVwiQW1iaWVudExpZ2h0XCJ9fSkucHJvdG90eXBlLmlzQW1iaWVudExpZ2h0PSEwOyhjbGFzcyBleHRlbmRzIHdse2NvbnN0cnVjdG9yKHQsZSxuPTEwLGk9MTApe3N1cGVyKHQsZSksdGhpcy50eXBlPVwiUmVjdEFyZWFMaWdodFwiLHRoaXMud2lkdGg9bix0aGlzLmhlaWdodD1pfWdldCBwb3dlcigpe3JldHVybiB0aGlzLmludGVuc2l0eSp0aGlzLndpZHRoKnRoaXMuaGVpZ2h0Kk1hdGguUEl9c2V0IHBvd2VyKHQpe3RoaXMuaW50ZW5zaXR5PXQvKHRoaXMud2lkdGgqdGhpcy5oZWlnaHQqTWF0aC5QSSl9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLndpZHRoPXQud2lkdGgsdGhpcy5oZWlnaHQ9dC5oZWlnaHQsdGhpc310b0pTT04odCl7Y29uc3QgZT1zdXBlci50b0pTT04odCk7cmV0dXJuIGUub2JqZWN0LndpZHRoPXRoaXMud2lkdGgsZS5vYmplY3QuaGVpZ2h0PXRoaXMuaGVpZ2h0LGV9fSkucHJvdG90eXBlLmlzUmVjdEFyZWFMaWdodD0hMDtjbGFzcyBGbHtjb25zdHJ1Y3Rvcigpe3RoaXMuY29lZmZpY2llbnRzPVtdO2ZvcihsZXQgdD0wO3Q8OTt0KyspdGhpcy5jb2VmZmljaWVudHMucHVzaChuZXcgQnQpfXNldCh0KXtmb3IobGV0IGU9MDtlPDk7ZSsrKXRoaXMuY29lZmZpY2llbnRzW2VdLmNvcHkodFtlXSk7cmV0dXJuIHRoaXN9emVybygpe2ZvcihsZXQgdD0wO3Q8OTt0KyspdGhpcy5jb2VmZmljaWVudHNbdF0uc2V0KDAsMCwwKTtyZXR1cm4gdGhpc31nZXRBdCh0LGUpe2NvbnN0IG49dC54LGk9dC55LHI9dC56LHM9dGhpcy5jb2VmZmljaWVudHM7cmV0dXJuIGUuY29weShzWzBdKS5tdWx0aXBseVNjYWxhciguMjgyMDk1KSxlLmFkZFNjYWxlZFZlY3RvcihzWzFdLC40ODg2MDMqaSksZS5hZGRTY2FsZWRWZWN0b3Ioc1syXSwuNDg4NjAzKnIpLGUuYWRkU2NhbGVkVmVjdG9yKHNbM10sLjQ4ODYwMypuKSxlLmFkZFNjYWxlZFZlY3RvcihzWzRdLG4qaSoxLjA5MjU0OCksZS5hZGRTY2FsZWRWZWN0b3Ioc1s1XSxpKnIqMS4wOTI1NDgpLGUuYWRkU2NhbGVkVmVjdG9yKHNbNl0sLjMxNTM5MiooMypyKnItMSkpLGUuYWRkU2NhbGVkVmVjdG9yKHNbN10sbipyKjEuMDkyNTQ4KSxlLmFkZFNjYWxlZFZlY3RvcihzWzhdLC41NDYyNzQqKG4qbi1pKmkpKSxlfWdldElycmFkaWFuY2VBdCh0LGUpe2NvbnN0IG49dC54LGk9dC55LHI9dC56LHM9dGhpcy5jb2VmZmljaWVudHM7cmV0dXJuIGUuY29weShzWzBdKS5tdWx0aXBseVNjYWxhciguODg2MjI3KSxlLmFkZFNjYWxlZFZlY3RvcihzWzFdLDEuMDIzMzI4KmkpLGUuYWRkU2NhbGVkVmVjdG9yKHNbMl0sMS4wMjMzMjgqciksZS5hZGRTY2FsZWRWZWN0b3Ioc1szXSwxLjAyMzMyOCpuKSxlLmFkZFNjYWxlZFZlY3RvcihzWzRdLC44NTgwODYqbippKSxlLmFkZFNjYWxlZFZlY3RvcihzWzVdLC44NTgwODYqaSpyKSxlLmFkZFNjYWxlZFZlY3RvcihzWzZdLC43NDMxMjUqcipyLS4yNDc3MDgpLGUuYWRkU2NhbGVkVmVjdG9yKHNbN10sLjg1ODA4NipuKnIpLGUuYWRkU2NhbGVkVmVjdG9yKHNbOF0sLjQyOTA0MyoobipuLWkqaSkpLGV9YWRkKHQpe2ZvcihsZXQgZT0wO2U8OTtlKyspdGhpcy5jb2VmZmljaWVudHNbZV0uYWRkKHQuY29lZmZpY2llbnRzW2VdKTtyZXR1cm4gdGhpc31hZGRTY2FsZWRTSCh0LGUpe2ZvcihsZXQgbj0wO248OTtuKyspdGhpcy5jb2VmZmljaWVudHNbbl0uYWRkU2NhbGVkVmVjdG9yKHQuY29lZmZpY2llbnRzW25dLGUpO3JldHVybiB0aGlzfXNjYWxlKHQpe2ZvcihsZXQgZT0wO2U8OTtlKyspdGhpcy5jb2VmZmljaWVudHNbZV0ubXVsdGlwbHlTY2FsYXIodCk7cmV0dXJuIHRoaXN9bGVycCh0LGUpe2ZvcihsZXQgbj0wO248OTtuKyspdGhpcy5jb2VmZmljaWVudHNbbl0ubGVycCh0LmNvZWZmaWNpZW50c1tuXSxlKTtyZXR1cm4gdGhpc31lcXVhbHModCl7Zm9yKGxldCBlPTA7ZTw5O2UrKylpZighdGhpcy5jb2VmZmljaWVudHNbZV0uZXF1YWxzKHQuY29lZmZpY2llbnRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH1jb3B5KHQpe3JldHVybiB0aGlzLnNldCh0LmNvZWZmaWNpZW50cyl9Y2xvbmUoKXtyZXR1cm4obmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcyl9ZnJvbUFycmF5KHQsZT0wKXtjb25zdCBuPXRoaXMuY29lZmZpY2llbnRzO2ZvcihsZXQgaT0wO2k8OTtpKyspbltpXS5mcm9tQXJyYXkodCxlKzMqaSk7cmV0dXJuIHRoaXN9dG9BcnJheSh0PVtdLGU9MCl7Y29uc3Qgbj10aGlzLmNvZWZmaWNpZW50cztmb3IobGV0IGk9MDtpPDk7aSsrKW5baV0udG9BcnJheSh0LGUrMyppKTtyZXR1cm4gdH1zdGF0aWMgZ2V0QmFzaXNBdCh0LGUpe2NvbnN0IG49dC54LGk9dC55LHI9dC56O2VbMF09LjI4MjA5NSxlWzFdPS40ODg2MDMqaSxlWzJdPS40ODg2MDMqcixlWzNdPS40ODg2MDMqbixlWzRdPTEuMDkyNTQ4Km4qaSxlWzVdPTEuMDkyNTQ4KmkqcixlWzZdPS4zMTUzOTIqKDMqcipyLTEpLGVbN109MS4wOTI1NDgqbipyLGVbOF09LjU0NjI3NCoobipuLWkqaSl9fUZsLnByb3RvdHlwZS5pc1NwaGVyaWNhbEhhcm1vbmljczM9ITA7Y2xhc3MgT2wgZXh0ZW5kcyB3bHtjb25zdHJ1Y3Rvcih0PW5ldyBGbCxlPTEpe3N1cGVyKHZvaWQgMCxlKSx0aGlzLnNoPXR9Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLnNoLmNvcHkodC5zaCksdGhpc31mcm9tSlNPTih0KXtyZXR1cm4gdGhpcy5pbnRlbnNpdHk9dC5pbnRlbnNpdHksdGhpcy5zaC5mcm9tQXJyYXkodC5zaCksdGhpc310b0pTT04odCl7Y29uc3QgZT1zdXBlci50b0pTT04odCk7cmV0dXJuIGUub2JqZWN0LnNoPXRoaXMuc2gudG9BcnJheSgpLGV9fU9sLnByb3RvdHlwZS5pc0xpZ2h0UHJvYmU9ITA7Y2xhc3MgVWx7c3RhdGljIGRlY29kZVRleHQodCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyKXJldHVybihuZXcgVGV4dERlY29kZXIpLmRlY29kZSh0KTtsZXQgZT1cIlwiO2ZvcihsZXQgbj0wLGk9dC5sZW5ndGg7bjxpO24rKyllKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbbl0pO3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlKSl9Y2F0Y2godCl7cmV0dXJuIGV9fXN0YXRpYyBleHRyYWN0VXJsQmFzZSh0KXtjb25zdCBlPXQubGFzdEluZGV4T2YoXCIvXCIpO3JldHVybi0xPT09ZT9cIi4vXCI6dC5zdWJzdHIoMCxlKzEpfX0oY2xhc3MgZXh0ZW5kcyBTbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy50eXBlPVwiSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnlcIix0aGlzLmluc3RhbmNlQ291bnQ9MS8wfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5pbnN0YW5jZUNvdW50PXQuaW5zdGFuY2VDb3VudCx0aGlzfWNsb25lKCl7cmV0dXJuKG5ldyB0aGlzLmNvbnN0cnVjdG9yKS5jb3B5KHRoaXMpfXRvSlNPTigpe2NvbnN0IHQ9c3VwZXIudG9KU09OKHRoaXMpO3JldHVybiB0Lmluc3RhbmNlQ291bnQ9dGhpcy5pbnN0YW5jZUNvdW50LHQuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeT0hMCx0fX0pLnByb3RvdHlwZS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5PSEwO2NsYXNzIGtsIGV4dGVuZHMgbWx7Y29uc3RydWN0b3IodCl7c3VwZXIodCksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwJiZjb25zb2xlLndhcm4oXCJUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogY3JlYXRlSW1hZ2VCaXRtYXAoKSBub3Qgc3VwcG9ydGVkLlwiKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgZmV0Y2gmJmNvbnNvbGUud2FybihcIlRIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBmZXRjaCgpIG5vdCBzdXBwb3J0ZWQuXCIpLHRoaXMub3B0aW9ucz17cHJlbXVsdGlwbHlBbHBoYTpcIm5vbmVcIn19c2V0T3B0aW9ucyh0KXtyZXR1cm4gdGhpcy5vcHRpb25zPXQsdGhpc31sb2FkKHQsZSxuLGkpe3ZvaWQgMD09PXQmJih0PVwiXCIpLHZvaWQgMCE9PXRoaXMucGF0aCYmKHQ9dGhpcy5wYXRoK3QpLHQ9dGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwodCk7Y29uc3Qgcj10aGlzLHM9ZGwuZ2V0KHQpO2lmKHZvaWQgMCE9PXMpcmV0dXJuIHIubWFuYWdlci5pdGVtU3RhcnQodCksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtlJiZlKHMpLHIubWFuYWdlci5pdGVtRW5kKHQpfSksMCkscztjb25zdCBhPXt9O2EuY3JlZGVudGlhbHM9XCJhbm9ueW1vdXNcIj09PXRoaXMuY3Jvc3NPcmlnaW4/XCJzYW1lLW9yaWdpblwiOlwiaW5jbHVkZVwiLGEuaGVhZGVycz10aGlzLnJlcXVlc3RIZWFkZXIsZmV0Y2godCxhKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdC5ibG9iKCl9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHQsT2JqZWN0LmFzc2lnbihyLm9wdGlvbnMse2NvbG9yU3BhY2VDb252ZXJzaW9uOlwibm9uZVwifSkpfSkpLnRoZW4oKGZ1bmN0aW9uKG4pe2RsLmFkZCh0LG4pLGUmJmUobiksci5tYW5hZ2VyLml0ZW1FbmQodCl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2kmJmkoZSksci5tYW5hZ2VyLml0ZW1FcnJvcih0KSxyLm1hbmFnZXIuaXRlbUVuZCh0KX0pKSxyLm1hbmFnZXIuaXRlbVN0YXJ0KHQpfX1sZXQgemw7a2wucHJvdG90eXBlLmlzSW1hZ2VCaXRtYXBMb2FkZXI9ITA7Y29uc3QgQmw9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09emwmJih6bD1uZXcod2luZG93LkF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkpLHpsfTtjbGFzcyBIbCBleHRlbmRzIG1se2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLG4saSl7Y29uc3Qgcj10aGlzLHM9bmV3IGdsKHRoaXMubWFuYWdlcik7cy5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKSxzLnNldFBhdGgodGhpcy5wYXRoKSxzLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKSxzLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscykscy5sb2FkKHQsKGZ1bmN0aW9uKG4pe3RyeXtjb25zdCB0PW4uc2xpY2UoMCk7QmwoKS5kZWNvZGVBdWRpb0RhdGEodCwoZnVuY3Rpb24odCl7ZSh0KX0pKX1jYXRjaChlKXtpP2koZSk6Y29uc29sZS5lcnJvcihlKSxyLm1hbmFnZXIuaXRlbUVycm9yKHQpfX0pLG4saSl9fShjbGFzcyBleHRlbmRzIE9se2NvbnN0cnVjdG9yKHQsZSxuPTEpe3N1cGVyKHZvaWQgMCxuKTtjb25zdCBpPShuZXcgY24pLnNldCh0KSxyPShuZXcgY24pLnNldChlKSxzPW5ldyBCdChpLnIsaS5nLGkuYiksYT1uZXcgQnQoci5yLHIuZyxyLmIpLG89TWF0aC5zcXJ0KE1hdGguUEkpLGw9bypNYXRoLnNxcnQoLjc1KTt0aGlzLnNoLmNvZWZmaWNpZW50c1swXS5jb3B5KHMpLmFkZChhKS5tdWx0aXBseVNjYWxhcihvKSx0aGlzLnNoLmNvZWZmaWNpZW50c1sxXS5jb3B5KHMpLnN1YihhKS5tdWx0aXBseVNjYWxhcihsKX19KS5wcm90b3R5cGUuaXNIZW1pc3BoZXJlTGlnaHRQcm9iZT0hMDsoY2xhc3MgZXh0ZW5kcyBPbHtjb25zdHJ1Y3Rvcih0LGU9MSl7c3VwZXIodm9pZCAwLGUpO2NvbnN0IG49KG5ldyBjbikuc2V0KHQpO3RoaXMuc2guY29lZmZpY2llbnRzWzBdLnNldChuLnIsbi5nLG4uYikubXVsdGlwbHlTY2FsYXIoMipNYXRoLnNxcnQoTWF0aC5QSSkpfX0pLnByb3RvdHlwZS5pc0FtYmllbnRMaWdodFByb2JlPSEwO2NsYXNzIFZse2NvbnN0cnVjdG9yKHQsZSxuKXtsZXQgaSxyLHM7c3dpdGNoKHRoaXMuYmluZGluZz10LHRoaXMudmFsdWVTaXplPW4sZSl7Y2FzZVwicXVhdGVybmlvblwiOmk9dGhpcy5fc2xlcnAscj10aGlzLl9zbGVycEFkZGl0aXZlLHM9dGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb24sdGhpcy5idWZmZXI9bmV3IEZsb2F0NjRBcnJheSg2Km4pLHRoaXMuX3dvcmtJbmRleD01O2JyZWFrO2Nhc2VcInN0cmluZ1wiOmNhc2VcImJvb2xcIjppPXRoaXMuX3NlbGVjdCxyPXRoaXMuX3NlbGVjdCxzPXRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcix0aGlzLmJ1ZmZlcj1uZXcgQXJyYXkoNSpuKTticmVhaztkZWZhdWx0Omk9dGhpcy5fbGVycCxyPXRoaXMuX2xlcnBBZGRpdGl2ZSxzPXRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljLHRoaXMuYnVmZmVyPW5ldyBGbG9hdDY0QXJyYXkoNSpuKX10aGlzLl9taXhCdWZmZXJSZWdpb249aSx0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZT1yLHRoaXMuX3NldElkZW50aXR5PXMsdGhpcy5fb3JpZ0luZGV4PTMsdGhpcy5fYWRkSW5kZXg9NCx0aGlzLmN1bXVsYXRpdmVXZWlnaHQ9MCx0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZT0wLHRoaXMudXNlQ291bnQ9MCx0aGlzLnJlZmVyZW5jZUNvdW50PTB9YWNjdW11bGF0ZSh0LGUpe2NvbnN0IG49dGhpcy5idWZmZXIsaT10aGlzLnZhbHVlU2l6ZSxyPXQqaStpO2xldCBzPXRoaXMuY3VtdWxhdGl2ZVdlaWdodDtpZigwPT09cyl7Zm9yKGxldCB0PTA7dCE9PWk7Kyt0KW5bcit0XT1uW3RdO3M9ZX1lbHNle3MrPWU7Y29uc3QgdD1lL3M7dGhpcy5fbWl4QnVmZmVyUmVnaW9uKG4sciwwLHQsaSl9dGhpcy5jdW11bGF0aXZlV2VpZ2h0PXN9YWNjdW11bGF0ZUFkZGl0aXZlKHQpe2NvbnN0IGU9dGhpcy5idWZmZXIsbj10aGlzLnZhbHVlU2l6ZSxpPW4qdGhpcy5fYWRkSW5kZXg7MD09PXRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlJiZ0aGlzLl9zZXRJZGVudGl0eSgpLHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlKGUsaSwwLHQsbiksdGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUrPXR9YXBwbHkodCl7Y29uc3QgZT10aGlzLnZhbHVlU2l6ZSxuPXRoaXMuYnVmZmVyLGk9dCplK2Uscj10aGlzLmN1bXVsYXRpdmVXZWlnaHQscz10aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSxhPXRoaXMuYmluZGluZztpZih0aGlzLmN1bXVsYXRpdmVXZWlnaHQ9MCx0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZT0wLHI8MSl7Y29uc3QgdD1lKnRoaXMuX29yaWdJbmRleDt0aGlzLl9taXhCdWZmZXJSZWdpb24obixpLHQsMS1yLGUpfXM+MCYmdGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUobixpLHRoaXMuX2FkZEluZGV4KmUsMSxlKTtmb3IobGV0IHQ9ZSxyPWUrZTt0IT09cjsrK3QpaWYoblt0XSE9PW5bdCtlXSl7YS5zZXRWYWx1ZShuLGkpO2JyZWFrfX1zYXZlT3JpZ2luYWxTdGF0ZSgpe2NvbnN0IHQ9dGhpcy5iaW5kaW5nLGU9dGhpcy5idWZmZXIsbj10aGlzLnZhbHVlU2l6ZSxpPW4qdGhpcy5fb3JpZ0luZGV4O3QuZ2V0VmFsdWUoZSxpKTtmb3IobGV0IHQ9bixyPWk7dCE9PXI7Kyt0KWVbdF09ZVtpK3Qlbl07dGhpcy5fc2V0SWRlbnRpdHkoKSx0aGlzLmN1bXVsYXRpdmVXZWlnaHQ9MCx0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZT0wfXJlc3RvcmVPcmlnaW5hbFN0YXRlKCl7Y29uc3QgdD0zKnRoaXMudmFsdWVTaXplO3RoaXMuYmluZGluZy5zZXRWYWx1ZSh0aGlzLmJ1ZmZlcix0KX1fc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWMoKXtjb25zdCB0PXRoaXMuX2FkZEluZGV4KnRoaXMudmFsdWVTaXplLGU9dCt0aGlzLnZhbHVlU2l6ZTtmb3IobGV0IG49dDtuPGU7bisrKXRoaXMuYnVmZmVyW25dPTB9X3NldEFkZGl0aXZlSWRlbnRpdHlRdWF0ZXJuaW9uKCl7dGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWMoKSx0aGlzLmJ1ZmZlclt0aGlzLl9hZGRJbmRleCp0aGlzLnZhbHVlU2l6ZSszXT0xfV9zZXRBZGRpdGl2ZUlkZW50aXR5T3RoZXIoKXtjb25zdCB0PXRoaXMuX29yaWdJbmRleCp0aGlzLnZhbHVlU2l6ZSxlPXRoaXMuX2FkZEluZGV4KnRoaXMudmFsdWVTaXplO2ZvcihsZXQgbj0wO248dGhpcy52YWx1ZVNpemU7bisrKXRoaXMuYnVmZmVyW2Urbl09dGhpcy5idWZmZXJbdCtuXX1fc2VsZWN0KHQsZSxuLGkscil7aWYoaT49LjUpZm9yKGxldCBpPTA7aSE9PXI7KytpKXRbZStpXT10W24raV19X3NsZXJwKHQsZSxuLGkpe3p0LnNsZXJwRmxhdCh0LGUsdCxlLHQsbixpKX1fc2xlcnBBZGRpdGl2ZSh0LGUsbixpLHIpe2NvbnN0IHM9dGhpcy5fd29ya0luZGV4KnI7enQubXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQodCxzLHQsZSx0LG4pLHp0LnNsZXJwRmxhdCh0LGUsdCxlLHQscyxpKX1fbGVycCh0LGUsbixpLHIpe2NvbnN0IHM9MS1pO2ZvcihsZXQgYT0wO2EhPT1yOysrYSl7Y29uc3Qgcj1lK2E7dFtyXT10W3JdKnMrdFtuK2FdKml9fV9sZXJwQWRkaXRpdmUodCxlLG4saSxyKXtmb3IobGV0IHM9MDtzIT09cjsrK3Mpe2NvbnN0IHI9ZStzO3Rbcl09dFtyXSt0W24rc10qaX19fWNvbnN0IEdsPW5ldyBSZWdFeHAoXCJbXFxcXFtcXFxcXVxcXFwuOlxcXFwvXVwiLFwiZ1wiKSxXbD1cIlteXCIrXCJcXFxcW1xcXFxdXFxcXC46XFxcXC9cIi5yZXBsYWNlKFwiXFxcXC5cIixcIlwiKStcIl1cIixqbD0vKCg/OldDK1tcXC86XSkqKS8uc291cmNlLnJlcGxhY2UoXCJXQ1wiLFwiW15cXFxcW1xcXFxdXFxcXC46XFxcXC9dXCIpLHFsPS8oV0NPRCspPy8uc291cmNlLnJlcGxhY2UoXCJXQ09EXCIsV2wpLFhsPS8oPzpcXC4oV0MrKSg/OlxcWyguKylcXF0pPyk/Ly5zb3VyY2UucmVwbGFjZShcIldDXCIsXCJbXlxcXFxbXFxcXF1cXFxcLjpcXFxcL11cIiksWWw9L1xcLihXQyspKD86XFxbKC4rKVxcXSk/Ly5zb3VyY2UucmVwbGFjZShcIldDXCIsXCJbXlxcXFxbXFxcXF1cXFxcLjpcXFxcL11cIiksWmw9bmV3IFJlZ0V4cChcIl5cIitqbCtxbCtYbCtZbCtcIiRcIiksSmw9W1wibWF0ZXJpYWxcIixcIm1hdGVyaWFsc1wiLFwiYm9uZXNcIl07Y2xhc3MgJGx7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMucGF0aD1lLHRoaXMucGFyc2VkUGF0aD1ufHwkbC5wYXJzZVRyYWNrTmFtZShlKSx0aGlzLm5vZGU9JGwuZmluZE5vZGUodCx0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUpfHx0LHRoaXMucm9vdE5vZGU9dCx0aGlzLmdldFZhbHVlPXRoaXMuX2dldFZhbHVlX3VuYm91bmQsdGhpcy5zZXRWYWx1ZT10aGlzLl9zZXRWYWx1ZV91bmJvdW5kfXN0YXRpYyBjcmVhdGUodCxlLG4pe3JldHVybiB0JiZ0LmlzQW5pbWF0aW9uT2JqZWN0R3JvdXA/bmV3ICRsLkNvbXBvc2l0ZSh0LGUsbik6bmV3ICRsKHQsZSxuKX1zdGF0aWMgc2FuaXRpemVOb2RlTmFtZSh0KXtyZXR1cm4gdC5yZXBsYWNlKC9cXHMvZyxcIl9cIikucmVwbGFjZShHbCxcIlwiKX1zdGF0aWMgcGFyc2VUcmFja05hbWUodCl7Y29uc3QgZT1abC5leGVjKHQpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcIlByb3BlcnR5QmluZGluZzogQ2Fubm90IHBhcnNlIHRyYWNrTmFtZTogXCIrdCk7Y29uc3Qgbj17bm9kZU5hbWU6ZVsyXSxvYmplY3ROYW1lOmVbM10sb2JqZWN0SW5kZXg6ZVs0XSxwcm9wZXJ0eU5hbWU6ZVs1XSxwcm9wZXJ0eUluZGV4OmVbNl19LGk9bi5ub2RlTmFtZSYmbi5ub2RlTmFtZS5sYXN0SW5kZXhPZihcIi5cIik7aWYodm9pZCAwIT09aSYmLTEhPT1pKXtjb25zdCB0PW4ubm9kZU5hbWUuc3Vic3RyaW5nKGkrMSk7LTEhPT1KbC5pbmRleE9mKHQpJiYobi5ub2RlTmFtZT1uLm5vZGVOYW1lLnN1YnN0cmluZygwLGkpLG4ub2JqZWN0TmFtZT10KX1pZihudWxsPT09bi5wcm9wZXJ0eU5hbWV8fDA9PT1uLnByb3BlcnR5TmFtZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogXCIrdCk7cmV0dXJuIG59c3RhdGljIGZpbmROb2RlKHQsZSl7aWYoIWV8fFwiXCI9PT1lfHxcIi5cIj09PWV8fC0xPT09ZXx8ZT09PXQubmFtZXx8ZT09PXQudXVpZClyZXR1cm4gdDtpZih0LnNrZWxldG9uKXtjb25zdCBuPXQuc2tlbGV0b24uZ2V0Qm9uZUJ5TmFtZShlKTtpZih2b2lkIDAhPT1uKXJldHVybiBufWlmKHQuY2hpbGRyZW4pe2NvbnN0IG49ZnVuY3Rpb24odCl7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IHI9dFtpXTtpZihyLm5hbWU9PT1lfHxyLnV1aWQ9PT1lKXJldHVybiByO2NvbnN0IHM9bihyLmNoaWxkcmVuKTtpZihzKXJldHVybiBzfXJldHVybiBudWxsfSxpPW4odC5jaGlsZHJlbik7aWYoaSlyZXR1cm4gaX1yZXR1cm4gbnVsbH1fZ2V0VmFsdWVfdW5hdmFpbGFibGUoKXt9X3NldFZhbHVlX3VuYXZhaWxhYmxlKCl7fV9nZXRWYWx1ZV9kaXJlY3QodCxlKXt0W2VdPXRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXX1fZ2V0VmFsdWVfYXJyYXkodCxlKXtjb25zdCBuPXRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtmb3IobGV0IGk9MCxyPW4ubGVuZ3RoO2khPT1yOysraSl0W2UrK109bltpXX1fZ2V0VmFsdWVfYXJyYXlFbGVtZW50KHQsZSl7dFtlXT10aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XX1fZ2V0VmFsdWVfdG9BcnJheSh0LGUpe3RoaXMucmVzb2x2ZWRQcm9wZXJ0eS50b0FycmF5KHQsZSl9X3NldFZhbHVlX2RpcmVjdCh0LGUpe3RoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXT10W2VdfV9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUodCxlKXt0aGlzLnRhcmdldE9iamVjdFt0aGlzLnByb3BlcnR5TmFtZV09dFtlXSx0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZT0hMH1fc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUodCxlKXt0aGlzLnRhcmdldE9iamVjdFt0aGlzLnByb3BlcnR5TmFtZV09dFtlXSx0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwfV9zZXRWYWx1ZV9hcnJheSh0LGUpe2NvbnN0IG49dGhpcy5yZXNvbHZlZFByb3BlcnR5O2ZvcihsZXQgaT0wLHI9bi5sZW5ndGg7aSE9PXI7KytpKW5baV09dFtlKytdfV9zZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZSh0LGUpe2NvbnN0IG49dGhpcy5yZXNvbHZlZFByb3BlcnR5O2ZvcihsZXQgaT0wLHI9bi5sZW5ndGg7aSE9PXI7KytpKW5baV09dFtlKytdO3RoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlPSEwfV9zZXRWYWx1ZV9hcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKHQsZSl7Y29uc3Qgbj10aGlzLnJlc29sdmVkUHJvcGVydHk7Zm9yKGxldCBpPTAscj1uLmxlbmd0aDtpIT09cjsrK2kpbltpXT10W2UrK107dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH1fc2V0VmFsdWVfYXJyYXlFbGVtZW50KHQsZSl7dGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF09dFtlXX1fc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlKHQsZSl7dGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF09dFtlXSx0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZT0hMH1fc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUodCxlKXt0aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XT10W2VdLHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITB9X3NldFZhbHVlX2Zyb21BcnJheSh0LGUpe3RoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkodCxlKX1fc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlKHQsZSl7dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSh0LGUpLHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlPSEwfV9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSh0LGUpe3RoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkodCxlKSx0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwfV9nZXRWYWx1ZV91bmJvdW5kKHQsZSl7dGhpcy5iaW5kKCksdGhpcy5nZXRWYWx1ZSh0LGUpfV9zZXRWYWx1ZV91bmJvdW5kKHQsZSl7dGhpcy5iaW5kKCksdGhpcy5zZXRWYWx1ZSh0LGUpfWJpbmQoKXtsZXQgdD10aGlzLm5vZGU7Y29uc3QgZT10aGlzLnBhcnNlZFBhdGgsbj1lLm9iamVjdE5hbWUsaT1lLnByb3BlcnR5TmFtZTtsZXQgcj1lLnByb3BlcnR5SW5kZXg7aWYodHx8KHQ9JGwuZmluZE5vZGUodGhpcy5yb290Tm9kZSxlLm5vZGVOYW1lKXx8dGhpcy5yb290Tm9kZSx0aGlzLm5vZGU9dCksdGhpcy5nZXRWYWx1ZT10aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZSx0aGlzLnNldFZhbHVlPXRoaXMuX3NldFZhbHVlX3VuYXZhaWxhYmxlLCF0KXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgbm9kZSBmb3IgdHJhY2s6IFwiK3RoaXMucGF0aCtcIiBidXQgaXQgd2Fzbid0IGZvdW5kLlwiKTtpZihuKXtsZXQgaT1lLm9iamVjdEluZGV4O3N3aXRjaChuKXtjYXNlXCJtYXRlcmlhbHNcIjppZighdC5tYXRlcmlhbClyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwuXCIsdGhpcyk7aWYoIXQubWF0ZXJpYWwubWF0ZXJpYWxzKXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5LlwiLHRoaXMpO3Q9dC5tYXRlcmlhbC5tYXRlcmlhbHM7YnJlYWs7Y2FzZVwiYm9uZXNcIjppZighdC5za2VsZXRvbilyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24uXCIsdGhpcyk7dD10LnNrZWxldG9uLmJvbmVzO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZV0ubmFtZT09PWkpe2k9ZTticmVha31icmVhaztkZWZhdWx0OmlmKHZvaWQgMD09PXRbbl0pcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIlRIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG9iamVjdE5hbWUgb2Ygbm9kZSB1bmRlZmluZWQuXCIsdGhpcyk7dD10W25dfWlmKHZvaWQgMCE9PWkpe2lmKHZvaWQgMD09PXRbaV0pcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIlRIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZC5cIix0aGlzLHQpO3Q9dFtpXX19Y29uc3Qgcz10W2ldO2lmKHZvaWQgMD09PXMpe2NvbnN0IG49ZS5ub2RlTmFtZTtyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogXCIrbitcIi5cIitpK1wiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIsdCl9bGV0IGE9dGhpcy5WZXJzaW9uaW5nLk5vbmU7dGhpcy50YXJnZXRPYmplY3Q9dCx2b2lkIDAhPT10Lm5lZWRzVXBkYXRlP2E9dGhpcy5WZXJzaW9uaW5nLk5lZWRzVXBkYXRlOnZvaWQgMCE9PXQubWF0cml4V29ybGROZWVkc1VwZGF0ZSYmKGE9dGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGUpO2xldCBvPXRoaXMuQmluZGluZ1R5cGUuRGlyZWN0O2lmKHZvaWQgMCE9PXIpe2lmKFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCI9PT1pKXtpZighdC5nZW9tZXRyeSlyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkuXCIsdGhpcyk7aWYoIXQuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSlyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIG9uIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC5cIix0aGlzKTtpZighdC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIlRIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5cIix0aGlzKTt2b2lkIDAhPT10Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtyXSYmKHI9dC5tb3JwaFRhcmdldERpY3Rpb25hcnlbcl0pfW89dGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQsdGhpcy5yZXNvbHZlZFByb3BlcnR5PXMsdGhpcy5wcm9wZXJ0eUluZGV4PXJ9ZWxzZSB2b2lkIDAhPT1zLmZyb21BcnJheSYmdm9pZCAwIT09cy50b0FycmF5PyhvPXRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXksdGhpcy5yZXNvbHZlZFByb3BlcnR5PXMpOkFycmF5LmlzQXJyYXkocyk/KG89dGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheSx0aGlzLnJlc29sdmVkUHJvcGVydHk9cyk6dGhpcy5wcm9wZXJ0eU5hbWU9aTt0aGlzLmdldFZhbHVlPXRoaXMuR2V0dGVyQnlCaW5kaW5nVHlwZVtvXSx0aGlzLnNldFZhbHVlPXRoaXMuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmdbb11bYV19dW5iaW5kKCl7dGhpcy5ub2RlPW51bGwsdGhpcy5nZXRWYWx1ZT10aGlzLl9nZXRWYWx1ZV91bmJvdW5kLHRoaXMuc2V0VmFsdWU9dGhpcy5fc2V0VmFsdWVfdW5ib3VuZH19JGwuQ29tcG9zaXRlPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuKXtjb25zdCBpPW58fCRsLnBhcnNlVHJhY2tOYW1lKGUpO3RoaXMuX3RhcmdldEdyb3VwPXQsdGhpcy5fYmluZGluZ3M9dC5zdWJzY3JpYmVfKGUsaSl9Z2V0VmFsdWUodCxlKXt0aGlzLmJpbmQoKTtjb25zdCBuPXRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxpPXRoaXMuX2JpbmRpbmdzW25dO3ZvaWQgMCE9PWkmJmkuZ2V0VmFsdWUodCxlKX1zZXRWYWx1ZSh0LGUpe2NvbnN0IG49dGhpcy5fYmluZGluZ3M7Zm9yKGxldCBpPXRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxyPW4ubGVuZ3RoO2khPT1yOysraSluW2ldLnNldFZhbHVlKHQsZSl9YmluZCgpe2NvbnN0IHQ9dGhpcy5fYmluZGluZ3M7Zm9yKGxldCBlPXRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxuPXQubGVuZ3RoO2UhPT1uOysrZSl0W2VdLmJpbmQoKX11bmJpbmQoKXtjb25zdCB0PXRoaXMuX2JpbmRpbmdzO2ZvcihsZXQgZT10aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sbj10Lmxlbmd0aDtlIT09bjsrK2UpdFtlXS51bmJpbmQoKX19LCRsLnByb3RvdHlwZS5CaW5kaW5nVHlwZT17RGlyZWN0OjAsRW50aXJlQXJyYXk6MSxBcnJheUVsZW1lbnQ6MixIYXNGcm9tVG9BcnJheTozfSwkbC5wcm90b3R5cGUuVmVyc2lvbmluZz17Tm9uZTowLE5lZWRzVXBkYXRlOjEsTWF0cml4V29ybGROZWVkc1VwZGF0ZToyfSwkbC5wcm90b3R5cGUuR2V0dGVyQnlCaW5kaW5nVHlwZT1bJGwucHJvdG90eXBlLl9nZXRWYWx1ZV9kaXJlY3QsJGwucHJvdG90eXBlLl9nZXRWYWx1ZV9hcnJheSwkbC5wcm90b3R5cGUuX2dldFZhbHVlX2FycmF5RWxlbWVudCwkbC5wcm90b3R5cGUuX2dldFZhbHVlX3RvQXJyYXldLCRsLnByb3RvdHlwZS5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZz1bWyRsLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0LCRsLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlLCRsLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdLFskbC5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5LCRsLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUsJGwucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlXSxbJGwucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnQsJGwucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUsJGwucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sWyRsLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5LCRsLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlLCRsLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdXTtjbGFzcyBLbHtjb25zdHJ1Y3Rvcih0LGUsbj1udWxsLGk9ZS5ibGVuZE1vZGUpe3RoaXMuX21peGVyPXQsdGhpcy5fY2xpcD1lLHRoaXMuX2xvY2FsUm9vdD1uLHRoaXMuYmxlbmRNb2RlPWk7Y29uc3Qgcj1lLnRyYWNrcyxzPXIubGVuZ3RoLGE9bmV3IEFycmF5KHMpLG89e2VuZGluZ1N0YXJ0OjI0MDAsZW5kaW5nRW5kOjI0MDB9O2ZvcihsZXQgdD0wO3QhPT1zOysrdCl7Y29uc3QgZT1yW3RdLmNyZWF0ZUludGVycG9sYW50KG51bGwpO2FbdF09ZSxlLnNldHRpbmdzPW99dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncz1vLHRoaXMuX2ludGVycG9sYW50cz1hLHRoaXMuX3Byb3BlcnR5QmluZGluZ3M9bmV3IEFycmF5KHMpLHRoaXMuX2NhY2hlSW5kZXg9bnVsbCx0aGlzLl9ieUNsaXBDYWNoZUluZGV4PW51bGwsdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ9bnVsbCx0aGlzLl93ZWlnaHRJbnRlcnBvbGFudD1udWxsLHRoaXMubG9vcD0yMjAxLHRoaXMuX2xvb3BDb3VudD0tMSx0aGlzLl9zdGFydFRpbWU9bnVsbCx0aGlzLnRpbWU9MCx0aGlzLnRpbWVTY2FsZT0xLHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZT0xLHRoaXMud2VpZ2h0PTEsdGhpcy5fZWZmZWN0aXZlV2VpZ2h0PTEsdGhpcy5yZXBldGl0aW9ucz0xLzAsdGhpcy5wYXVzZWQ9ITEsdGhpcy5lbmFibGVkPSEwLHRoaXMuY2xhbXBXaGVuRmluaXNoZWQ9ITEsdGhpcy56ZXJvU2xvcGVBdFN0YXJ0PSEwLHRoaXMuemVyb1Nsb3BlQXRFbmQ9ITB9cGxheSgpe3JldHVybiB0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24odGhpcyksdGhpc31zdG9wKCl7cmV0dXJuIHRoaXMuX21peGVyLl9kZWFjdGl2YXRlQWN0aW9uKHRoaXMpLHRoaXMucmVzZXQoKX1yZXNldCgpe3JldHVybiB0aGlzLnBhdXNlZD0hMSx0aGlzLmVuYWJsZWQ9ITAsdGhpcy50aW1lPTAsdGhpcy5fbG9vcENvdW50PS0xLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKCl9aXNSdW5uaW5nKCl7cmV0dXJuIHRoaXMuZW5hYmxlZCYmIXRoaXMucGF1c2VkJiYwIT09dGhpcy50aW1lU2NhbGUmJm51bGw9PT10aGlzLl9zdGFydFRpbWUmJnRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbih0aGlzKX1pc1NjaGVkdWxlZCgpe3JldHVybiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24odGhpcyl9c3RhcnRBdCh0KXtyZXR1cm4gdGhpcy5fc3RhcnRUaW1lPXQsdGhpc31zZXRMb29wKHQsZSl7cmV0dXJuIHRoaXMubG9vcD10LHRoaXMucmVwZXRpdGlvbnM9ZSx0aGlzfXNldEVmZmVjdGl2ZVdlaWdodCh0KXtyZXR1cm4gdGhpcy53ZWlnaHQ9dCx0aGlzLl9lZmZlY3RpdmVXZWlnaHQ9dGhpcy5lbmFibGVkP3Q6MCx0aGlzLnN0b3BGYWRpbmcoKX1nZXRFZmZlY3RpdmVXZWlnaHQoKXtyZXR1cm4gdGhpcy5fZWZmZWN0aXZlV2VpZ2h0fWZhZGVJbih0KXtyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcodCwwLDEpfWZhZGVPdXQodCl7cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKHQsMSwwKX1jcm9zc0ZhZGVGcm9tKHQsZSxuKXtpZih0LmZhZGVPdXQoZSksdGhpcy5mYWRlSW4oZSksbil7Y29uc3Qgbj10aGlzLl9jbGlwLmR1cmF0aW9uLGk9dC5fY2xpcC5kdXJhdGlvbixyPWkvbixzPW4vaTt0LndhcnAoMSxyLGUpLHRoaXMud2FycChzLDEsZSl9cmV0dXJuIHRoaXN9Y3Jvc3NGYWRlVG8odCxlLG4pe3JldHVybiB0LmNyb3NzRmFkZUZyb20odGhpcyxlLG4pfXN0b3BGYWRpbmcoKXtjb25zdCB0PXRoaXMuX3dlaWdodEludGVycG9sYW50O3JldHVybiBudWxsIT09dCYmKHRoaXMuX3dlaWdodEludGVycG9sYW50PW51bGwsdGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KHQpKSx0aGlzfXNldEVmZmVjdGl2ZVRpbWVTY2FsZSh0KXtyZXR1cm4gdGhpcy50aW1lU2NhbGU9dCx0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU9dGhpcy5wYXVzZWQ/MDp0LHRoaXMuc3RvcFdhcnBpbmcoKX1nZXRFZmZlY3RpdmVUaW1lU2NhbGUoKXtyZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlfXNldER1cmF0aW9uKHQpe3JldHVybiB0aGlzLnRpbWVTY2FsZT10aGlzLl9jbGlwLmR1cmF0aW9uL3QsdGhpcy5zdG9wV2FycGluZygpfXN5bmNXaXRoKHQpe3JldHVybiB0aGlzLnRpbWU9dC50aW1lLHRoaXMudGltZVNjYWxlPXQudGltZVNjYWxlLHRoaXMuc3RvcFdhcnBpbmcoKX1oYWx0KHQpe3JldHVybiB0aGlzLndhcnAodGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlLDAsdCl9d2FycCh0LGUsbil7Y29uc3QgaT10aGlzLl9taXhlcixyPWkudGltZSxzPXRoaXMudGltZVNjYWxlO2xldCBhPXRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O251bGw9PT1hJiYoYT1pLl9sZW5kQ29udHJvbEludGVycG9sYW50KCksdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ9YSk7Y29uc3Qgbz1hLnBhcmFtZXRlclBvc2l0aW9ucyxsPWEuc2FtcGxlVmFsdWVzO3JldHVybiBvWzBdPXIsb1sxXT1yK24sbFswXT10L3MsbFsxXT1lL3MsdGhpc31zdG9wV2FycGluZygpe2NvbnN0IHQ9dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7cmV0dXJuIG51bGwhPT10JiYodGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ9bnVsbCx0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQodCkpLHRoaXN9Z2V0TWl4ZXIoKXtyZXR1cm4gdGhpcy5fbWl4ZXJ9Z2V0Q2xpcCgpe3JldHVybiB0aGlzLl9jbGlwfWdldFJvb3QoKXtyZXR1cm4gdGhpcy5fbG9jYWxSb290fHx0aGlzLl9taXhlci5fcm9vdH1fdXBkYXRlKHQsZSxuLGkpe2lmKCF0aGlzLmVuYWJsZWQpcmV0dXJuIHZvaWQgdGhpcy5fdXBkYXRlV2VpZ2h0KHQpO2NvbnN0IHI9dGhpcy5fc3RhcnRUaW1lO2lmKG51bGwhPT1yKXtjb25zdCBpPSh0LXIpKm47aWYoaTwwfHwwPT09bilyZXR1cm47dGhpcy5fc3RhcnRUaW1lPW51bGwsZT1uKml9ZSo9dGhpcy5fdXBkYXRlVGltZVNjYWxlKHQpO2NvbnN0IHM9dGhpcy5fdXBkYXRlVGltZShlKSxhPXRoaXMuX3VwZGF0ZVdlaWdodCh0KTtpZihhPjApe2NvbnN0IHQ9dGhpcy5faW50ZXJwb2xhbnRzLGU9dGhpcy5fcHJvcGVydHlCaW5kaW5ncztpZigyNTAxPT09dGhpcy5ibGVuZE1vZGUpZm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuIT09aTsrK24pdFtuXS5ldmFsdWF0ZShzKSxlW25dLmFjY3VtdWxhdGVBZGRpdGl2ZShhKTtlbHNlIGZvcihsZXQgbj0wLHI9dC5sZW5ndGg7biE9PXI7KytuKXRbbl0uZXZhbHVhdGUocyksZVtuXS5hY2N1bXVsYXRlKGksYSl9fV91cGRhdGVXZWlnaHQodCl7bGV0IGU9MDtpZih0aGlzLmVuYWJsZWQpe2U9dGhpcy53ZWlnaHQ7Y29uc3Qgbj10aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtpZihudWxsIT09bil7Y29uc3QgaT1uLmV2YWx1YXRlKHQpWzBdO2UqPWksdD5uLnBhcmFtZXRlclBvc2l0aW9uc1sxXSYmKHRoaXMuc3RvcEZhZGluZygpLDA9PT1pJiYodGhpcy5lbmFibGVkPSExKSl9fXJldHVybiB0aGlzLl9lZmZlY3RpdmVXZWlnaHQ9ZSxlfV91cGRhdGVUaW1lU2NhbGUodCl7bGV0IGU9MDtpZighdGhpcy5wYXVzZWQpe2U9dGhpcy50aW1lU2NhbGU7Y29uc3Qgbj10aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtpZihudWxsIT09bil7ZSo9bi5ldmFsdWF0ZSh0KVswXSx0Pm4ucGFyYW1ldGVyUG9zaXRpb25zWzFdJiYodGhpcy5zdG9wV2FycGluZygpLDA9PT1lP3RoaXMucGF1c2VkPSEwOnRoaXMudGltZVNjYWxlPWUpfX1yZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlPWUsZX1fdXBkYXRlVGltZSh0KXtjb25zdCBlPXRoaXMuX2NsaXAuZHVyYXRpb24sbj10aGlzLmxvb3A7bGV0IGk9dGhpcy50aW1lK3Qscj10aGlzLl9sb29wQ291bnQ7Y29uc3Qgcz0yMjAyPT09bjtpZigwPT09dClyZXR1cm4tMT09PXI/aTpzJiYxPT0oMSZyKT9lLWk6aTtpZigyMjAwPT09bil7LTE9PT1yJiYodGhpcy5fbG9vcENvdW50PTAsdGhpcy5fc2V0RW5kaW5ncyghMCwhMCwhMSkpO3Q6e2lmKGk+PWUpaT1lO2Vsc2V7aWYoIShpPDApKXt0aGlzLnRpbWU9aTticmVhayB0fWk9MH10aGlzLmNsYW1wV2hlbkZpbmlzaGVkP3RoaXMucGF1c2VkPSEwOnRoaXMuZW5hYmxlZD0hMSx0aGlzLnRpbWU9aSx0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZmluaXNoZWRcIixhY3Rpb246dGhpcyxkaXJlY3Rpb246dDwwPy0xOjF9KX19ZWxzZXtpZigtMT09PXImJih0Pj0wPyhyPTAsdGhpcy5fc2V0RW5kaW5ncyghMCwwPT09dGhpcy5yZXBldGl0aW9ucyxzKSk6dGhpcy5fc2V0RW5kaW5ncygwPT09dGhpcy5yZXBldGl0aW9ucywhMCxzKSksaT49ZXx8aTwwKXtjb25zdCBuPU1hdGguZmxvb3IoaS9lKTtpLT1lKm4scis9TWF0aC5hYnMobik7Y29uc3QgYT10aGlzLnJlcGV0aXRpb25zLXI7aWYoYTw9MCl0aGlzLmNsYW1wV2hlbkZpbmlzaGVkP3RoaXMucGF1c2VkPSEwOnRoaXMuZW5hYmxlZD0hMSxpPXQ+MD9lOjAsdGhpcy50aW1lPWksdGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCh7dHlwZTpcImZpbmlzaGVkXCIsYWN0aW9uOnRoaXMsZGlyZWN0aW9uOnQ+MD8xOi0xfSk7ZWxzZXtpZigxPT09YSl7Y29uc3QgZT10PDA7dGhpcy5fc2V0RW5kaW5ncyhlLCFlLHMpfWVsc2UgdGhpcy5fc2V0RW5kaW5ncyghMSwhMSxzKTt0aGlzLl9sb29wQ291bnQ9cix0aGlzLnRpbWU9aSx0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KHt0eXBlOlwibG9vcFwiLGFjdGlvbjp0aGlzLGxvb3BEZWx0YTpufSl9fWVsc2UgdGhpcy50aW1lPWk7aWYocyYmMT09KDEmcikpcmV0dXJuIGUtaX1yZXR1cm4gaX1fc2V0RW5kaW5ncyh0LGUsbil7Y29uc3QgaT10aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO24/KGkuZW5kaW5nU3RhcnQ9MjQwMSxpLmVuZGluZ0VuZD0yNDAxKTooaS5lbmRpbmdTdGFydD10P3RoaXMuemVyb1Nsb3BlQXRTdGFydD8yNDAxOjI0MDA6MjQwMixpLmVuZGluZ0VuZD1lP3RoaXMuemVyb1Nsb3BlQXRFbmQ/MjQwMToyNDAwOjI0MDIpfV9zY2hlZHVsZUZhZGluZyh0LGUsbil7Y29uc3QgaT10aGlzLl9taXhlcixyPWkudGltZTtsZXQgcz10aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtudWxsPT09cyYmKHM9aS5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpLHRoaXMuX3dlaWdodEludGVycG9sYW50PXMpO2NvbnN0IGE9cy5wYXJhbWV0ZXJQb3NpdGlvbnMsbz1zLnNhbXBsZVZhbHVlcztyZXR1cm4gYVswXT1yLG9bMF09ZSxhWzFdPXIrdCxvWzFdPW4sdGhpc319Y2xhc3MgUWwgZXh0ZW5kcyBwdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuX3Jvb3Q9dCx0aGlzLl9pbml0TWVtb3J5TWFuYWdlcigpLHRoaXMuX2FjY3VJbmRleD0wLHRoaXMudGltZT0wLHRoaXMudGltZVNjYWxlPTF9X2JpbmRBY3Rpb24odCxlKXtjb25zdCBuPXQuX2xvY2FsUm9vdHx8dGhpcy5fcm9vdCxpPXQuX2NsaXAudHJhY2tzLHI9aS5sZW5ndGgscz10Ll9wcm9wZXJ0eUJpbmRpbmdzLGE9dC5faW50ZXJwb2xhbnRzLG89bi51dWlkLGw9dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lO2xldCBjPWxbb107dm9pZCAwPT09YyYmKGM9e30sbFtvXT1jKTtmb3IobGV0IHQ9MDt0IT09cjsrK3Qpe2NvbnN0IHI9aVt0XSxsPXIubmFtZTtsZXQgaD1jW2xdO2lmKHZvaWQgMCE9PWgpc1t0XT1oO2Vsc2V7aWYoaD1zW3RdLHZvaWQgMCE9PWgpe251bGw9PT1oLl9jYWNoZUluZGV4JiYoKytoLnJlZmVyZW5jZUNvdW50LHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyhoLG8sbCkpO2NvbnRpbnVlfWNvbnN0IGk9ZSYmZS5fcHJvcGVydHlCaW5kaW5nc1t0XS5iaW5kaW5nLnBhcnNlZFBhdGg7aD1uZXcgVmwoJGwuY3JlYXRlKG4sbCxpKSxyLlZhbHVlVHlwZU5hbWUsci5nZXRWYWx1ZVNpemUoKSksKytoLnJlZmVyZW5jZUNvdW50LHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyhoLG8sbCksc1t0XT1ofWFbdF0ucmVzdWx0QnVmZmVyPWguYnVmZmVyfX1fYWN0aXZhdGVBY3Rpb24odCl7aWYoIXRoaXMuX2lzQWN0aXZlQWN0aW9uKHQpKXtpZihudWxsPT09dC5fY2FjaGVJbmRleCl7Y29uc3QgZT0odC5fbG9jYWxSb290fHx0aGlzLl9yb290KS51dWlkLG49dC5fY2xpcC51dWlkLGk9dGhpcy5fYWN0aW9uc0J5Q2xpcFtuXTt0aGlzLl9iaW5kQWN0aW9uKHQsaSYmaS5rbm93bkFjdGlvbnNbMF0pLHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKHQsbixlKX1jb25zdCBlPXQuX3Byb3BlcnR5QmluZGluZ3M7Zm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0IT09bjsrK3Qpe2NvbnN0IG49ZVt0XTswPT1uLnVzZUNvdW50KysmJih0aGlzLl9sZW5kQmluZGluZyhuKSxuLnNhdmVPcmlnaW5hbFN0YXRlKCkpfXRoaXMuX2xlbmRBY3Rpb24odCl9fV9kZWFjdGl2YXRlQWN0aW9uKHQpe2lmKHRoaXMuX2lzQWN0aXZlQWN0aW9uKHQpKXtjb25zdCBlPXQuX3Byb3BlcnR5QmluZGluZ3M7Zm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0IT09bjsrK3Qpe2NvbnN0IG49ZVt0XTswPT0tLW4udXNlQ291bnQmJihuLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCksdGhpcy5fdGFrZUJhY2tCaW5kaW5nKG4pKX10aGlzLl90YWtlQmFja0FjdGlvbih0KX19X2luaXRNZW1vcnlNYW5hZ2VyKCl7dGhpcy5fYWN0aW9ucz1bXSx0aGlzLl9uQWN0aXZlQWN0aW9ucz0wLHRoaXMuX2FjdGlvbnNCeUNsaXA9e30sdGhpcy5fYmluZGluZ3M9W10sdGhpcy5fbkFjdGl2ZUJpbmRpbmdzPTAsdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lPXt9LHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHM9W10sdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM9MDtjb25zdCB0PXRoaXM7dGhpcy5zdGF0cz17YWN0aW9uczp7Z2V0IHRvdGFsKCl7cmV0dXJuIHQuX2FjdGlvbnMubGVuZ3RofSxnZXQgaW5Vc2UoKXtyZXR1cm4gdC5fbkFjdGl2ZUFjdGlvbnN9fSxiaW5kaW5nczp7Z2V0IHRvdGFsKCl7cmV0dXJuIHQuX2JpbmRpbmdzLmxlbmd0aH0sZ2V0IGluVXNlKCl7cmV0dXJuIHQuX25BY3RpdmVCaW5kaW5nc319LGNvbnRyb2xJbnRlcnBvbGFudHM6e2dldCB0b3RhbCgpe3JldHVybiB0Ll9jb250cm9sSW50ZXJwb2xhbnRzLmxlbmd0aH0sZ2V0IGluVXNlKCl7cmV0dXJuIHQuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzfX19fV9pc0FjdGl2ZUFjdGlvbih0KXtjb25zdCBlPXQuX2NhY2hlSW5kZXg7cmV0dXJuIG51bGwhPT1lJiZlPHRoaXMuX25BY3RpdmVBY3Rpb25zfV9hZGRJbmFjdGl2ZUFjdGlvbih0LGUsbil7Y29uc3QgaT10aGlzLl9hY3Rpb25zLHI9dGhpcy5fYWN0aW9uc0J5Q2xpcDtsZXQgcz1yW2VdO2lmKHZvaWQgMD09PXMpcz17a25vd25BY3Rpb25zOlt0XSxhY3Rpb25CeVJvb3Q6e319LHQuX2J5Q2xpcENhY2hlSW5kZXg9MCxyW2VdPXM7ZWxzZXtjb25zdCBlPXMua25vd25BY3Rpb25zO3QuX2J5Q2xpcENhY2hlSW5kZXg9ZS5sZW5ndGgsZS5wdXNoKHQpfXQuX2NhY2hlSW5kZXg9aS5sZW5ndGgsaS5wdXNoKHQpLHMuYWN0aW9uQnlSb290W25dPXR9X3JlbW92ZUluYWN0aXZlQWN0aW9uKHQpe2NvbnN0IGU9dGhpcy5fYWN0aW9ucyxuPWVbZS5sZW5ndGgtMV0saT10Ll9jYWNoZUluZGV4O24uX2NhY2hlSW5kZXg9aSxlW2ldPW4sZS5wb3AoKSx0Ll9jYWNoZUluZGV4PW51bGw7Y29uc3Qgcj10Ll9jbGlwLnV1aWQscz10aGlzLl9hY3Rpb25zQnlDbGlwLGE9c1tyXSxvPWEua25vd25BY3Rpb25zLGw9b1tvLmxlbmd0aC0xXSxjPXQuX2J5Q2xpcENhY2hlSW5kZXg7bC5fYnlDbGlwQ2FjaGVJbmRleD1jLG9bY109bCxvLnBvcCgpLHQuX2J5Q2xpcENhY2hlSW5kZXg9bnVsbDtkZWxldGUgYS5hY3Rpb25CeVJvb3RbKHQuX2xvY2FsUm9vdHx8dGhpcy5fcm9vdCkudXVpZF0sMD09PW8ubGVuZ3RoJiZkZWxldGUgc1tyXSx0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKHQpfV9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKHQpe2NvbnN0IGU9dC5fcHJvcGVydHlCaW5kaW5ncztmb3IobGV0IHQ9MCxuPWUubGVuZ3RoO3QhPT1uOysrdCl7Y29uc3Qgbj1lW3RdOzA9PS0tbi5yZWZlcmVuY2VDb3VudCYmdGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKG4pfX1fbGVuZEFjdGlvbih0KXtjb25zdCBlPXRoaXMuX2FjdGlvbnMsbj10Ll9jYWNoZUluZGV4LGk9dGhpcy5fbkFjdGl2ZUFjdGlvbnMrKyxyPWVbaV07dC5fY2FjaGVJbmRleD1pLGVbaV09dCxyLl9jYWNoZUluZGV4PW4sZVtuXT1yfV90YWtlQmFja0FjdGlvbih0KXtjb25zdCBlPXRoaXMuX2FjdGlvbnMsbj10Ll9jYWNoZUluZGV4LGk9LS10aGlzLl9uQWN0aXZlQWN0aW9ucyxyPWVbaV07dC5fY2FjaGVJbmRleD1pLGVbaV09dCxyLl9jYWNoZUluZGV4PW4sZVtuXT1yfV9hZGRJbmFjdGl2ZUJpbmRpbmcodCxlLG4pe2NvbnN0IGk9dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLHI9dGhpcy5fYmluZGluZ3M7bGV0IHM9aVtlXTt2b2lkIDA9PT1zJiYocz17fSxpW2VdPXMpLHNbbl09dCx0Ll9jYWNoZUluZGV4PXIubGVuZ3RoLHIucHVzaCh0KX1fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKHQpe2NvbnN0IGU9dGhpcy5fYmluZGluZ3Msbj10LmJpbmRpbmcsaT1uLnJvb3ROb2RlLnV1aWQscj1uLnBhdGgscz10aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsYT1zW2ldLG89ZVtlLmxlbmd0aC0xXSxsPXQuX2NhY2hlSW5kZXg7by5fY2FjaGVJbmRleD1sLGVbbF09byxlLnBvcCgpLGRlbGV0ZSBhW3JdLDA9PT1PYmplY3Qua2V5cyhhKS5sZW5ndGgmJmRlbGV0ZSBzW2ldfV9sZW5kQmluZGluZyh0KXtjb25zdCBlPXRoaXMuX2JpbmRpbmdzLG49dC5fY2FjaGVJbmRleCxpPXRoaXMuX25BY3RpdmVCaW5kaW5ncysrLHI9ZVtpXTt0Ll9jYWNoZUluZGV4PWksZVtpXT10LHIuX2NhY2hlSW5kZXg9bixlW25dPXJ9X3Rha2VCYWNrQmluZGluZyh0KXtjb25zdCBlPXRoaXMuX2JpbmRpbmdzLG49dC5fY2FjaGVJbmRleCxpPS0tdGhpcy5fbkFjdGl2ZUJpbmRpbmdzLHI9ZVtpXTt0Ll9jYWNoZUluZGV4PWksZVtpXT10LHIuX2NhY2hlSW5kZXg9bixlW25dPXJ9X2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKXtjb25zdCB0PXRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsZT10aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cysrO2xldCBuPXRbZV07cmV0dXJuIHZvaWQgMD09PW4mJihuPW5ldyB0bChuZXcgRmxvYXQzMkFycmF5KDIpLG5ldyBGbG9hdDMyQXJyYXkoMiksMSx0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyKSxuLl9fY2FjaGVJbmRleD1lLHRbZV09biksbn1fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQodCl7Y29uc3QgZT10aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLG49dC5fX2NhY2hlSW5kZXgsaT0tLXRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLHI9ZVtpXTt0Ll9fY2FjaGVJbmRleD1pLGVbaV09dCxyLl9fY2FjaGVJbmRleD1uLGVbbl09cn1jbGlwQWN0aW9uKHQsZSxuKXtjb25zdCBpPWV8fHRoaXMuX3Jvb3Qscj1pLnV1aWQ7bGV0IHM9XCJzdHJpbmdcIj09dHlwZW9mIHQ/aGwuZmluZEJ5TmFtZShpLHQpOnQ7Y29uc3QgYT1udWxsIT09cz9zLnV1aWQ6dCxvPXRoaXMuX2FjdGlvbnNCeUNsaXBbYV07bGV0IGw9bnVsbDtpZih2b2lkIDA9PT1uJiYobj1udWxsIT09cz9zLmJsZW5kTW9kZToyNTAwKSx2b2lkIDAhPT1vKXtjb25zdCB0PW8uYWN0aW9uQnlSb290W3JdO2lmKHZvaWQgMCE9PXQmJnQuYmxlbmRNb2RlPT09bilyZXR1cm4gdDtsPW8ua25vd25BY3Rpb25zWzBdLG51bGw9PT1zJiYocz1sLl9jbGlwKX1pZihudWxsPT09cylyZXR1cm4gbnVsbDtjb25zdCBjPW5ldyBLbCh0aGlzLHMsZSxuKTtyZXR1cm4gdGhpcy5fYmluZEFjdGlvbihjLGwpLHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKGMsYSxyKSxjfWV4aXN0aW5nQWN0aW9uKHQsZSl7Y29uc3Qgbj1lfHx0aGlzLl9yb290LGk9bi51dWlkLHI9XCJzdHJpbmdcIj09dHlwZW9mIHQ/aGwuZmluZEJ5TmFtZShuLHQpOnQscz1yP3IudXVpZDp0LGE9dGhpcy5fYWN0aW9uc0J5Q2xpcFtzXTtyZXR1cm4gdm9pZCAwIT09YSYmYS5hY3Rpb25CeVJvb3RbaV18fG51bGx9c3RvcEFsbEFjdGlvbigpe2NvbnN0IHQ9dGhpcy5fYWN0aW9ucztmb3IobGV0IGU9dGhpcy5fbkFjdGl2ZUFjdGlvbnMtMTtlPj0wOy0tZSl0W2VdLnN0b3AoKTtyZXR1cm4gdGhpc311cGRhdGUodCl7dCo9dGhpcy50aW1lU2NhbGU7Y29uc3QgZT10aGlzLl9hY3Rpb25zLG49dGhpcy5fbkFjdGl2ZUFjdGlvbnMsaT10aGlzLnRpbWUrPXQscj1NYXRoLnNpZ24odCkscz10aGlzLl9hY2N1SW5kZXhePTE7Zm9yKGxldCBhPTA7YSE9PW47KythKXtlW2FdLl91cGRhdGUoaSx0LHIscyl9Y29uc3QgYT10aGlzLl9iaW5kaW5ncyxvPXRoaXMuX25BY3RpdmVCaW5kaW5ncztmb3IobGV0IHQ9MDt0IT09bzsrK3QpYVt0XS5hcHBseShzKTtyZXR1cm4gdGhpc31zZXRUaW1lKHQpe3RoaXMudGltZT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fYWN0aW9ucy5sZW5ndGg7dCsrKXRoaXMuX2FjdGlvbnNbdF0udGltZT0wO3JldHVybiB0aGlzLnVwZGF0ZSh0KX1nZXRSb290KCl7cmV0dXJuIHRoaXMuX3Jvb3R9dW5jYWNoZUNsaXAodCl7Y29uc3QgZT10aGlzLl9hY3Rpb25zLG49dC51dWlkLGk9dGhpcy5fYWN0aW9uc0J5Q2xpcCxyPWlbbl07aWYodm9pZCAwIT09cil7Y29uc3QgdD1yLmtub3duQWN0aW9ucztmb3IobGV0IG49MCxpPXQubGVuZ3RoO24hPT1pOysrbil7Y29uc3QgaT10W25dO3RoaXMuX2RlYWN0aXZhdGVBY3Rpb24oaSk7Y29uc3Qgcj1pLl9jYWNoZUluZGV4LHM9ZVtlLmxlbmd0aC0xXTtpLl9jYWNoZUluZGV4PW51bGwsaS5fYnlDbGlwQ2FjaGVJbmRleD1udWxsLHMuX2NhY2hlSW5kZXg9cixlW3JdPXMsZS5wb3AoKSx0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKGkpfWRlbGV0ZSBpW25dfX11bmNhY2hlUm9vdCh0KXtjb25zdCBlPXQudXVpZCxuPXRoaXMuX2FjdGlvbnNCeUNsaXA7Zm9yKGNvbnN0IHQgaW4gbil7Y29uc3QgaT1uW3RdLmFjdGlvbkJ5Um9vdFtlXTt2b2lkIDAhPT1pJiYodGhpcy5fZGVhY3RpdmF0ZUFjdGlvbihpKSx0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbihpKSl9Y29uc3QgaT10aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWVbZV07aWYodm9pZCAwIT09aSlmb3IoY29uc3QgdCBpbiBpKXtjb25zdCBlPWlbdF07ZS5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpLHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyhlKX19dW5jYWNoZUFjdGlvbih0LGUpe2NvbnN0IG49dGhpcy5leGlzdGluZ0FjdGlvbih0LGUpO251bGwhPT1uJiYodGhpcy5fZGVhY3RpdmF0ZUFjdGlvbihuKSx0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbihuKSl9fVFsLnByb3RvdHlwZS5fY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlcj1uZXcgRmxvYXQzMkFycmF5KDEpOyhjbGFzcyBleHRlbmRzIFpze2NvbnN0cnVjdG9yKHQsZSxuPTEpe3N1cGVyKHQsZSksdGhpcy5tZXNoUGVyQXR0cmlidXRlPW59Y29weSh0KXtyZXR1cm4gc3VwZXIuY29weSh0KSx0aGlzLm1lc2hQZXJBdHRyaWJ1dGU9dC5tZXNoUGVyQXR0cmlidXRlLHRoaXN9Y2xvbmUodCl7Y29uc3QgZT1zdXBlci5jbG9uZSh0KTtyZXR1cm4gZS5tZXNoUGVyQXR0cmlidXRlPXRoaXMubWVzaFBlckF0dHJpYnV0ZSxlfXRvSlNPTih0KXtjb25zdCBlPXN1cGVyLnRvSlNPTih0KTtyZXR1cm4gZS5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyPSEwLGUubWVzaFBlckF0dHJpYnV0ZT10aGlzLm1lc2hQZXJBdHRyaWJ1dGUsZX19KS5wcm90b3R5cGUuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcj0hMDtmdW5jdGlvbiB0Yyh0LGUpe3JldHVybiB0LmRpc3RhbmNlLWUuZGlzdGFuY2V9ZnVuY3Rpb24gZWModCxlLG4saSl7aWYodC5sYXllcnMudGVzdChlLmxheWVycykmJnQucmF5Y2FzdChlLG4pLCEwPT09aSl7Y29uc3QgaT10LmNoaWxkcmVuO2ZvcihsZXQgdD0wLHI9aS5sZW5ndGg7dDxyO3QrKyllYyhpW3RdLGUsbiwhMCl9fWNsYXNzIG5je2NvbnN0cnVjdG9yKHQ9MSxlPTAsbj0wKXtyZXR1cm4gdGhpcy5yYWRpdXM9dCx0aGlzLnBoaT1lLHRoaXMudGhldGE9bix0aGlzfXNldCh0LGUsbil7cmV0dXJuIHRoaXMucmFkaXVzPXQsdGhpcy5waGk9ZSx0aGlzLnRoZXRhPW4sdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLnJhZGl1cz10LnJhZGl1cyx0aGlzLnBoaT10LnBoaSx0aGlzLnRoZXRhPXQudGhldGEsdGhpc31tYWtlU2FmZSgpe2NvbnN0IHQ9MWUtNjtyZXR1cm4gdGhpcy5waGk9TWF0aC5tYXgodCxNYXRoLm1pbihNYXRoLlBJLXQsdGhpcy5waGkpKSx0aGlzfXNldEZyb21WZWN0b3IzKHQpe3JldHVybiB0aGlzLnNldEZyb21DYXJ0ZXNpYW5Db29yZHModC54LHQueSx0LnopfXNldEZyb21DYXJ0ZXNpYW5Db29yZHModCxlLG4pe3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQodCp0K2UqZStuKm4pLDA9PT10aGlzLnJhZGl1cz8odGhpcy50aGV0YT0wLHRoaXMucGhpPTApOih0aGlzLnRoZXRhPU1hdGguYXRhbjIodCxuKSx0aGlzLnBoaT1NYXRoLmFjb3MoYnQoZS90aGlzLnJhZGl1cywtMSwxKSkpLHRoaXN9Y2xvbmUoKXtyZXR1cm4obmV3IHRoaXMuY29uc3RydWN0b3IpLmNvcHkodGhpcyl9fShjbGFzcyBleHRlbmRzIFZle2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5tYXRlcmlhbD10LHRoaXMucmVuZGVyPWZ1bmN0aW9uKCl7fSx0aGlzLmhhc1Bvc2l0aW9ucz0hMSx0aGlzLmhhc05vcm1hbHM9ITEsdGhpcy5oYXNDb2xvcnM9ITEsdGhpcy5oYXNVdnM9ITEsdGhpcy5wb3NpdGlvbkFycmF5PW51bGwsdGhpcy5ub3JtYWxBcnJheT1udWxsLHRoaXMuY29sb3JBcnJheT1udWxsLHRoaXMudXZBcnJheT1udWxsLHRoaXMuY291bnQ9MH19KS5wcm90b3R5cGUuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3Q9ITA7Y29uc3QgaWM9bmV3IEJ0LHJjPW5ldyB2ZSxzYz1uZXcgdmU7ZnVuY3Rpb24gYWModCl7Y29uc3QgZT1bXTt0JiZ0LmlzQm9uZSYmZS5wdXNoKHQpO2ZvcihsZXQgbj0wO248dC5jaGlsZHJlbi5sZW5ndGg7bisrKWUucHVzaC5hcHBseShlLGFjKHQuY2hpbGRyZW5bbl0pKTtyZXR1cm4gZX1jb25zdCBvYz1uZXcgRmxvYXQzMkFycmF5KDEpLGxjPW5ldyBJbnQzMkFycmF5KG9jLmJ1ZmZlcik7Y2xhc3MgY2N7c3RhdGljIHRvSGFsZkZsb2F0KHQpe3Q+NjU1MDQmJihjb25zb2xlLndhcm4oXCJUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogdmFsdWUgZXhjZWVkcyA2NTUwNC5cIiksdD02NTUwNCksb2NbMF09dDtjb25zdCBlPWxjWzBdO2xldCBuPWU+PjE2JjMyNzY4LGk9ZT4+MTImMjA0Nztjb25zdCByPWU+PjIzJjI1NTtyZXR1cm4gcjwxMDM/bjpyPjE0Mj8obnw9MzE3NDQsbnw9KDI1NT09cj8wOjEpJiY4Mzg4NjA3JmUsbik6cjwxMTM/KGl8PTIwNDgsbnw9KGk+PjExNC1yKSsoaT4+MTEzLXImMSksbik6KG58PXItMTEyPDwxMHxpPj4xLG4rPTEmaSxuKX19WWEuY3JlYXRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGNvbnNvbGUubG9nKFwiVEhSRUUuQ3VydmUuY3JlYXRlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZFwiKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFlhLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dCx0LnByb3RvdHlwZS5nZXRQb2ludD1lLHR9LGZvLnByb3RvdHlwZS5mcm9tUG9pbnRzPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5QYXRoOiAuZnJvbVBvaW50cygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21Qb2ludHMoKS5cIiksdGhpcy5zZXRGcm9tUG9pbnRzKHQpfSxjbGFzcyBleHRlbmRzIGthe2NvbnN0cnVjdG9yKHQ9MTAsZT0xMCxuPTQ0NzM5MjQsaT04OTQ3ODQ4KXtuPW5ldyBjbihuKSxpPW5ldyBjbihpKTtjb25zdCByPWUvMixzPXQvZSxhPXQvMixvPVtdLGw9W107Zm9yKGxldCB0PTAsYz0wLGg9LWE7dDw9ZTt0KyssaCs9cyl7by5wdXNoKC1hLDAsaCxhLDAsaCksby5wdXNoKGgsMCwtYSxoLDAsYSk7Y29uc3QgZT10PT09cj9uOmk7ZS50b0FycmF5KGwsYyksYys9MyxlLnRvQXJyYXkobCxjKSxjKz0zLGUudG9BcnJheShsLGMpLGMrPTMsZS50b0FycmF5KGwsYyksYys9M31jb25zdCBjPW5ldyBTbjtjLnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsbmV3IGduKG8sMykpLGMuc2V0QXR0cmlidXRlKFwiY29sb3JcIixuZXcgZ24obCwzKSk7c3VwZXIoYyxuZXcgUmEoe3ZlcnRleENvbG9yczohMCx0b25lTWFwcGVkOiExfSkpLHRoaXMudHlwZT1cIkdyaWRIZWxwZXJcIn19LnByb3RvdHlwZS5zZXRDb2xvcnM9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuR3JpZEhlbHBlcjogc2V0Q29sb3JzKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGFzcyB0aGVtIGluIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLlwiKX0sY2xhc3MgZXh0ZW5kcyBrYXtjb25zdHJ1Y3Rvcih0KXtjb25zdCBlPWFjKHQpLG49bmV3IFNuLGk9W10scj1bXSxzPW5ldyBjbigwLDAsMSksYT1uZXcgY24oMCwxLDApO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBuPWVbdF07bi5wYXJlbnQmJm4ucGFyZW50LmlzQm9uZSYmKGkucHVzaCgwLDAsMCksaS5wdXNoKDAsMCwwKSxyLnB1c2gocy5yLHMuZyxzLmIpLHIucHVzaChhLnIsYS5nLGEuYikpfW4uc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgZ24oaSwzKSksbi5zZXRBdHRyaWJ1dGUoXCJjb2xvclwiLG5ldyBnbihyLDMpKTtzdXBlcihuLG5ldyBSYSh7dmVydGV4Q29sb3JzOiEwLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExLHRvbmVNYXBwZWQ6ITEsdHJhbnNwYXJlbnQ6ITB9KSksdGhpcy50eXBlPVwiU2tlbGV0b25IZWxwZXJcIix0aGlzLmlzU2tlbGV0b25IZWxwZXI9ITAsdGhpcy5yb290PXQsdGhpcy5ib25lcz1lLHRoaXMubWF0cml4PXQubWF0cml4V29ybGQsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExfXVwZGF0ZU1hdHJpeFdvcmxkKHQpe2NvbnN0IGU9dGhpcy5ib25lcyxuPXRoaXMuZ2VvbWV0cnksaT1uLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO3NjLmNvcHkodGhpcy5yb290Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtmb3IobGV0IHQ9MCxuPTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9ZVt0XTtyLnBhcmVudCYmci5wYXJlbnQuaXNCb25lJiYocmMubXVsdGlwbHlNYXRyaWNlcyhzYyxyLm1hdHJpeFdvcmxkKSxpYy5zZXRGcm9tTWF0cml4UG9zaXRpb24ocmMpLGkuc2V0WFlaKG4saWMueCxpYy55LGljLnopLHJjLm11bHRpcGx5TWF0cmljZXMoc2Msci5wYXJlbnQubWF0cml4V29ybGQpLGljLnNldEZyb21NYXRyaXhQb3NpdGlvbihyYyksaS5zZXRYWVoobisxLGljLngsaWMueSxpYy56KSxuKz0yKX1uLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpLm5lZWRzVXBkYXRlPSEwLHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKHQpfX0ucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5Ta2VsZXRvbkhlbHBlcjogdXBkYXRlKCkgbm8gbG9uZ2VyIG5lZWRzIHRvIGJlIGNhbGxlZC5cIil9LG1sLnByb3RvdHlwZS5leHRyYWN0VXJsQmFzZT1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuTG9hZGVyOiAuZXh0cmFjdFVybEJhc2UoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoKSBpbnN0ZWFkLlwiKSxVbC5leHRyYWN0VXJsQmFzZSh0KX0sbWwuSGFuZGxlcnM9e2FkZDpmdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5Mb2FkZXI6IEhhbmRsZXJzLmFkZCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBMb2FkaW5nTWFuYWdlci5hZGRIYW5kbGVyKCkgaW5zdGVhZC5cIil9LGdldDpmdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5Mb2FkZXI6IEhhbmRsZXJzLmdldCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBMb2FkaW5nTWFuYWdlci5nZXRIYW5kbGVyKCkgaW5zdGVhZC5cIil9fSxHdC5wcm90b3R5cGUuY2VudGVyPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5Cb3gzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuXCIpLHRoaXMuZ2V0Q2VudGVyKHQpfSxHdC5wcm90b3R5cGUuZW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuQm94MzogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLlwiKSx0aGlzLmlzRW1wdHkoKX0sR3QucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uQm94PWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuXCIpLHRoaXMuaW50ZXJzZWN0c0JveCh0KX0sR3QucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uU3BoZXJlPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuXCIpLHRoaXMuaW50ZXJzZWN0c1NwaGVyZSh0KX0sR3QucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLkJveDM6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLlwiKSx0aGlzLmdldFNpemUodCl9LGxlLnByb3RvdHlwZS5lbXB0eT1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5TcGhlcmU6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS5cIiksdGhpcy5pc0VtcHR5KCl9LGFpLnByb3RvdHlwZS5zZXRGcm9tTWF0cml4PWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5GcnVzdHVtOiAuc2V0RnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCkuXCIpLHRoaXMuc2V0RnJvbVByb2plY3Rpb25NYXRyaXgodCl9LEx0LnByb3RvdHlwZS5mbGF0dGVuVG9BcnJheU9mZnNldD1mdW5jdGlvbih0LGUpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXgzOiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlwiKSx0aGlzLnRvQXJyYXkodCxlKX0sTHQucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMz1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLlwiKSx0LmFwcGx5TWF0cml4Myh0aGlzKX0sTHQucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yM0FycmF5PWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxMdC5wcm90b3R5cGUuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4MzogLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYXR0cmlidXRlLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC5cIiksdC5hcHBseU1hdHJpeDModGhpcyl9LEx0LnByb3RvdHlwZS5hcHBseVRvVmVjdG9yM0FycmF5PWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDM6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LEx0LnByb3RvdHlwZS5nZXRJbnZlcnNlPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXgzOiAuZ2V0SW52ZXJzZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXhJbnYuY29weSggbWF0cml4ICkuaW52ZXJ0KCk7IGluc3RlYWQuXCIpLHRoaXMuY29weSh0KS5pbnZlcnQoKX0sdmUucHJvdG90eXBlLmV4dHJhY3RQb3NpdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLlwiKSx0aGlzLmNvcHlQb3NpdGlvbih0KX0sdmUucHJvdG90eXBlLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuXCIpLHRoaXMudG9BcnJheSh0LGUpfSx2ZS5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLlwiKSwobmV3IEJ0KS5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsMyl9LHZlLnByb3RvdHlwZS5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuXCIpLHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24odCl9LHZlLnByb3RvdHlwZS5tdWx0aXBseVRvQXJyYXk9ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlUb0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHZlLnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjM9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC5cIiksdC5hcHBseU1hdHJpeDQodGhpcyl9LHZlLnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjQ9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC5cIiksdC5hcHBseU1hdHJpeDQodGhpcyl9LHZlLnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjNBcnJheT1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sdmUucHJvdG90eXBlLnJvdGF0ZUF4aXM9ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuXCIpLHQudHJhbnNmb3JtRGlyZWN0aW9uKHRoaXMpfSx2ZS5wcm90b3R5cGUuY3Jvc3NWZWN0b3I9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLlwiKSx0LmFwcGx5TWF0cml4NCh0aGlzKX0sdmUucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHZlLnByb3RvdHlwZS5yb3RhdGVYPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHZlLnByb3RvdHlwZS5yb3RhdGVZPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHZlLnByb3RvdHlwZS5yb3RhdGVaPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHZlLnByb3RvdHlwZS5yb3RhdGVCeUF4aXM9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSx2ZS5wcm90b3R5cGUuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuTWF0cml4NDogLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYXR0cmlidXRlLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC5cIiksdC5hcHBseU1hdHJpeDQodGhpcyl9LHZlLnByb3RvdHlwZS5hcHBseVRvVmVjdG9yM0FycmF5PWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHZlLnByb3RvdHlwZS5tYWtlRnJ1c3R1bT1mdW5jdGlvbih0LGUsbixpLHIscyl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tYWtlRnJ1c3R1bSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIGluc3RlYWQuXCIpLHRoaXMubWFrZVBlcnNwZWN0aXZlKHQsZSxpLG4scixzKX0sdmUucHJvdG90eXBlLmdldEludmVyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5nZXRJbnZlcnNlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG1hdHJpeEludi5jb3B5KCBtYXRyaXggKS5pbnZlcnQoKTsgaW5zdGVhZC5cIiksdGhpcy5jb3B5KHQpLmludmVydCgpfSxpaS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25MaW5lPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5QbGFuZTogLmlzSW50ZXJzZWN0aW9uTGluZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNMaW5lKCkuXCIpLHRoaXMuaW50ZXJzZWN0c0xpbmUodCl9LHp0LnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjM9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLlwiKSx0LmFwcGx5UXVhdGVybmlvbih0aGlzKX0senQucHJvdG90eXBlLmludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuUXVhdGVybmlvbjogLmludmVyc2UoKSBoYXMgYmVlbiByZW5hbWVkIHRvIGludmVydCgpLlwiKSx0aGlzLmludmVydCgpfSxnZS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25Cb3g9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLlwiKSx0aGlzLmludGVyc2VjdHNCb3godCl9LGdlLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvblBsYW5lPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblBsYW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1BsYW5lKCkuXCIpLHRoaXMuaW50ZXJzZWN0c1BsYW5lKHQpfSxnZS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25TcGhlcmU9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLlwiKSx0aGlzLmludGVyc2VjdHNTcGhlcmUodCl9LFFlLnByb3RvdHlwZS5hcmVhPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlRyaWFuZ2xlOiAuYXJlYSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldEFyZWEoKS5cIiksdGhpcy5nZXRBcmVhKCl9LFFlLnByb3RvdHlwZS5iYXJ5Y29vcmRGcm9tUG9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuVHJpYW5nbGU6IC5iYXJ5Y29vcmRGcm9tUG9pbnQoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRCYXJ5Y29vcmQoKS5cIiksdGhpcy5nZXRCYXJ5Y29vcmQodCxlKX0sUWUucHJvdG90eXBlLm1pZHBvaW50PWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5UcmlhbmdsZTogLm1pZHBvaW50KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0TWlkcG9pbnQoKS5cIiksdGhpcy5nZXRNaWRwb2ludCh0KX0sUWUucHJvdG90eXBlbm9ybWFsPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5UcmlhbmdsZTogLm5vcm1hbCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE5vcm1hbCgpLlwiKSx0aGlzLmdldE5vcm1hbCh0KX0sUWUucHJvdG90eXBlLnBsYW5lPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5UcmlhbmdsZTogLnBsYW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0UGxhbmUoKS5cIiksdGhpcy5nZXRQbGFuZSh0KX0sUWUuYmFyeWNvb3JkRnJvbVBvaW50PWZ1bmN0aW9uKHQsZSxuLGkscil7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlRyaWFuZ2xlOiAuYmFyeWNvb3JkRnJvbVBvaW50KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0QmFyeWNvb3JkKCkuXCIpLFFlLmdldEJhcnljb29yZCh0LGUsbixpLHIpfSxRZS5ub3JtYWw9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlRyaWFuZ2xlOiAubm9ybWFsKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Tm9ybWFsKCkuXCIpLFFlLmdldE5vcm1hbCh0LGUsbixpKX0sZ28ucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHM9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlNoYXBlOiAuZXh0cmFjdEFsbFBvaW50cygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuZXh0cmFjdFBvaW50cygpIGluc3RlYWQuXCIpLHRoaXMuZXh0cmFjdFBvaW50cyh0KX0sZ28ucHJvdG90eXBlLmV4dHJ1ZGU9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlNoYXBlOiAuZXh0cnVkZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFeHRydWRlR2VvbWV0cnkoKSBpbnN0ZWFkLlwiKSxuZXcgam8odGhpcyx0KX0sZ28ucHJvdG90eXBlLm1ha2VHZW9tZXRyeT1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuU2hhcGU6IC5tYWtlR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgU2hhcGVHZW9tZXRyeSgpIGluc3RlYWQuXCIpLG5ldyBYbyh0aGlzLHQpfSxBdC5wcm90b3R5cGUuZnJvbUF0dHJpYnV0ZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjI6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLlwiKSx0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxlLG4pfSxBdC5wcm90b3R5cGUuZGlzdGFuY2VUb01hbmhhdHRhbj1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMjogLmRpc3RhbmNlVG9NYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5EaXN0YW5jZVRvKCkuXCIpLHRoaXMubWFuaGF0dGFuRGlzdGFuY2VUbyh0KX0sQXQucHJvdG90eXBlLmxlbmd0aE1hbmhhdHRhbj1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IyOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuXCIpLHRoaXMubWFuaGF0dGFuTGVuZ3RoKCl9LEJ0LnByb3RvdHlwZS5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeD1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgaW5zdGVhZC5cIil9LEJ0LnByb3RvdHlwZS5zZXRFdWxlckZyb21RdWF0ZXJuaW9uPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC5cIil9LEJ0LnByb3RvdHlwZS5nZXRQb3NpdGlvbkZyb21NYXRyaXg9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5nZXRQb3NpdGlvbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4UG9zaXRpb24oKS5cIiksdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24odCl9LEJ0LnByb3RvdHlwZS5nZXRTY2FsZUZyb21NYXRyaXg9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS5cIiksdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUodCl9LEJ0LnByb3RvdHlwZS5nZXRDb2x1bW5Gcm9tTWF0cml4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLlwiKSx0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oZSx0KX0sQnQucHJvdG90eXBlLmFwcGx5UHJvamVjdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLmFwcGx5UHJvamVjdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuYXBwbHlNYXRyaXg0KCBtICkgaW5zdGVhZC5cIiksdGhpcy5hcHBseU1hdHJpeDQodCl9LEJ0LnByb3RvdHlwZS5mcm9tQXR0cmlidXRlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuVmVjdG9yMzogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuXCIpLHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUsbil9LEJ0LnByb3RvdHlwZS5kaXN0YW5jZVRvTWFuaGF0dGFuPWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS5cIiksdGhpcy5tYW5oYXR0YW5EaXN0YW5jZVRvKHQpfSxCdC5wcm90b3R5cGUubGVuZ3RoTWFuaGF0dGFuPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5sZW5ndGhNYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5MZW5ndGgoKS5cIiksdGhpcy5tYW5oYXR0YW5MZW5ndGgoKX0sT3QucHJvdG90eXBlLmZyb21BdHRyaWJ1dGU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3I0OiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS5cIiksdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSxuKX0sT3QucHJvdG90eXBlLmxlbmd0aE1hbmhhdHRhbj1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5WZWN0b3I0OiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuXCIpLHRoaXMubWFuaGF0dGFuTGVuZ3RoKCl9LFZlLnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLlwiKSx0aGlzLmdldE9iamVjdEJ5TmFtZSh0KX0sVmUucHJvdG90eXBlLnJlbmRlckRlcHRoPWZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC5yZW5kZXJEZXB0aCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnJlbmRlck9yZGVyLCBpbnN0ZWFkLlwiKX0sVmUucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuXCIpLHRoaXMudHJhbnNsYXRlT25BeGlzKGUsdCl9LFZlLnByb3RvdHlwZS5nZXRXb3JsZFJvdGF0aW9uPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLk9iamVjdDNEOiAuZ2V0V29ybGRSb3RhdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5PYmplY3QzRC5nZXRXb3JsZFF1YXRlcm5pb24oIHRhcmdldCApIGluc3RlYWQuXCIpfSxWZS5wcm90b3R5cGUuYXBwbHlNYXRyaXg9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdDNEOiAuYXBwbHlNYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5hcHBseU1hdHJpeDQoKS5cIiksdGhpcy5hcHBseU1hdHJpeDQodCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZlLnByb3RvdHlwZSx7ZXVsZXJPcmRlcjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLlwiKSx0aGlzLnJvdGF0aW9uLm9yZGVyfSxzZXQ6ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuXCIpLHRoaXMucm90YXRpb24ub3JkZXI9dH19LHVzZVF1YXRlcm5pb246e2dldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LlwiKX0sc2V0OmZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuXCIpfX19KSxWbi5wcm90b3R5cGUuc2V0RHJhd01vZGU9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuTWVzaDogLnNldERyYXdNb2RlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIHJlbmRlcmVyIG5vdyBhbHdheXMgYXNzdW1lcyBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZS4gVHJhbnNmb3JtIHlvdXIgZ2VvbWV0cnkgdmlhIEJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpIGlmIG5lY2Vzc2FyeS5cIil9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZuLnByb3RvdHlwZSx7ZHJhd01vZGU6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLmVycm9yKFwiVEhSRUUuTWVzaDogLmRyYXdNb2RlIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSByZW5kZXJlciBub3cgYWx3YXlzIGFzc3VtZXMgVEhSRUUuVHJpYW5nbGVzRHJhd01vZGUuXCIpLDB9LHNldDpmdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5NZXNoOiAuZHJhd01vZGUgaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIHJlbmRlcmVyIG5vdyBhbHdheXMgYXNzdW1lcyBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZS4gVHJhbnNmb3JtIHlvdXIgZ2VvbWV0cnkgdmlhIEJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpIGlmIG5lY2Vzc2FyeS5cIil9fX0pLHlhLnByb3RvdHlwZS5pbml0Qm9uZXM9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuU2tpbm5lZE1lc2g6IGluaXRCb25lcygpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxKbi5wcm90b3R5cGUuc2V0TGVucz1mdW5jdGlvbih0LGUpe2NvbnNvbGUud2FybihcIlRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnNldExlbnMgaXMgZGVwcmVjYXRlZC4gVXNlIC5zZXRGb2NhbExlbmd0aCBhbmQgLmZpbG1HYXVnZSBmb3IgYSBwaG90b2dyYXBoaWMgc2V0dXAuXCIpLHZvaWQgMCE9PWUmJih0aGlzLmZpbG1HYXVnZT1lKSx0aGlzLnNldEZvY2FsTGVuZ3RoKHQpfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3bC5wcm90b3R5cGUse29ubHlTaGFkb3c6e3NldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAub25seVNoYWRvdyBoYXMgYmVlbiByZW1vdmVkLlwiKX19LHNoYWRvd0NhbWVyYUZvdjp7c2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRm92IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mb3YuXCIpLHRoaXMuc2hhZG93LmNhbWVyYS5mb3Y9dH19LHNoYWRvd0NhbWVyYUxlZnQ6e3NldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUxlZnQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmxlZnQuXCIpLHRoaXMuc2hhZG93LmNhbWVyYS5sZWZ0PXR9fSxzaGFkb3dDYW1lcmFSaWdodDp7c2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhUmlnaHQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLnJpZ2h0LlwiKSx0aGlzLnNoYWRvdy5jYW1lcmEucmlnaHQ9dH19LHNoYWRvd0NhbWVyYVRvcDp7c2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVG9wIGlzIG5vdyAuc2hhZG93LmNhbWVyYS50b3AuXCIpLHRoaXMuc2hhZG93LmNhbWVyYS50b3A9dH19LHNoYWRvd0NhbWVyYUJvdHRvbTp7c2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhQm90dG9tIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5ib3R0b20uXCIpLHRoaXMuc2hhZG93LmNhbWVyYS5ib3R0b209dH19LHNoYWRvd0NhbWVyYU5lYXI6e3NldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYU5lYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLm5lYXIuXCIpLHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyPXR9fSxzaGFkb3dDYW1lcmFGYXI6e3NldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZmFyLlwiKSx0aGlzLnNoYWRvdy5jYW1lcmEuZmFyPXR9fSxzaGFkb3dDYW1lcmFWaXNpYmxlOntzZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdy5jYW1lcmEgKSBpbnN0ZWFkLlwiKX19LHNoYWRvd0JpYXM6e3NldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5MaWdodDogLnNoYWRvd0JpYXMgaXMgbm93IC5zaGFkb3cuYmlhcy5cIiksdGhpcy5zaGFkb3cuYmlhcz10fX0sc2hhZG93RGFya25lc3M6e3NldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93RGFya25lc3MgaGFzIGJlZW4gcmVtb3ZlZC5cIil9fSxzaGFkb3dNYXBXaWR0aDp7c2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLkxpZ2h0OiAuc2hhZG93TWFwV2lkdGggaXMgbm93IC5zaGFkb3cubWFwU2l6ZS53aWR0aC5cIiksdGhpcy5zaGFkb3cubWFwU2l6ZS53aWR0aD10fX0sc2hhZG93TWFwSGVpZ2h0OntzZXQ6ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBIZWlnaHQgaXMgbm93IC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQuXCIpLHRoaXMuc2hhZG93Lm1hcFNpemUuaGVpZ2h0PXR9fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHBuLnByb3RvdHlwZSx7bGVuZ3RoOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuY291bnQgaW5zdGVhZC5cIiksdGhpcy5hcnJheS5sZW5ndGh9fSxkeW5hbWljOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAuZHluYW1pYyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnVzYWdlIGluc3RlYWQuXCIpLDM1MDQ4PT09dGhpcy51c2FnZX0sc2V0OmZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAuZHluYW1pYyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnVzYWdlIGluc3RlYWQuXCIpLHRoaXMuc2V0VXNhZ2UoMzUwNDgpfX19KSxwbi5wcm90b3R5cGUuc2V0RHluYW1pYz1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAuc2V0RHluYW1pYygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuc2V0VXNhZ2UoKSBpbnN0ZWFkLlwiKSx0aGlzLnNldFVzYWdlKCEwPT09dD8zNTA0ODozNTA0NCksdGhpc30scG4ucHJvdG90eXBlLmNvcHlJbmRpY2VzQXJyYXk9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAuY29weUluZGljZXNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxwbi5wcm90b3R5cGUuc2V0QXJyYXk9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAuc2V0QXJyYXkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEJ1ZmZlckdlb21ldHJ5IC5zZXRBdHRyaWJ1dGUgdG8gcmVwbGFjZS9yZXNpemUgYXR0cmlidXRlIGJ1ZmZlcnNcIil9LFNuLnByb3RvdHlwZS5hZGRJbmRleD1mdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS5cIiksdGhpcy5zZXRJbmRleCh0KX0sU24ucHJvdG90eXBlLmFkZEF0dHJpYnV0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEF0dHJpYnV0ZSgpLlwiKSxlJiZlLmlzQnVmZmVyQXR0cmlidXRlfHxlJiZlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU/XCJpbmRleFwiPT09dD8oY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnkuYWRkQXR0cmlidXRlOiBVc2UgLnNldEluZGV4KCkgZm9yIGluZGV4IGF0dHJpYnV0ZS5cIiksdGhpcy5zZXRJbmRleChlKSx0aGlzKTp0aGlzLnNldEF0dHJpYnV0ZSh0LGUpOihjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuXCIpLHRoaXMuc2V0QXR0cmlidXRlKHQsbmV3IHBuKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pKSl9LFNuLnByb3RvdHlwZS5hZGREcmF3Q2FsbD1mdW5jdGlvbih0LGUsbil7dm9pZCAwIT09biYmY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIG5vIGxvbmdlciBzdXBwb3J0cyBpbmRleE9mZnNldC5cIiksY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS5cIiksdGhpcy5hZGRHcm91cCh0LGUpfSxTbi5wcm90b3R5cGUuY2xlYXJEcmF3Q2FsbHM9ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLlwiKSx0aGlzLmNsZWFyR3JvdXBzKCl9LFNuLnByb3RvdHlwZS5jb21wdXRlT2Zmc2V0cz1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sU24ucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5yZW1vdmVBdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5kZWxldGVBdHRyaWJ1dGUoKS5cIiksdGhpcy5kZWxldGVBdHRyaWJ1dGUodCl9LFNuLnByb3RvdHlwZS5hcHBseU1hdHJpeD1mdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hcHBseU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmFwcGx5TWF0cml4NCgpLlwiKSx0aGlzLmFwcGx5TWF0cml4NCh0KX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU24ucHJvdG90eXBlLHtkcmF3Y2FsbHM6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLlwiKSx0aGlzLmdyb3Vwc319LG9mZnNldHM6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLlwiKSx0aGlzLmdyb3Vwc319fSksWnMucHJvdG90eXBlLnNldER5bmFtaWM9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLkludGVybGVhdmVkQnVmZmVyOiAuc2V0RHluYW1pYygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuc2V0VXNhZ2UoKSBpbnN0ZWFkLlwiKSx0aGlzLnNldFVzYWdlKCEwPT09dD8zNTA0ODozNTA0NCksdGhpc30sWnMucHJvdG90eXBlLnNldEFycmF5PWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlRIUkVFLkludGVybGVhdmVkQnVmZmVyOiAuc2V0QXJyYXkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEJ1ZmZlckdlb21ldHJ5IC5zZXRBdHRyaWJ1dGUgdG8gcmVwbGFjZS9yZXNpemUgYXR0cmlidXRlIGJ1ZmZlcnNcIil9LGpvLnByb3RvdHlwZS5nZXRBcnJheXM9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiAuZ2V0QXJyYXlzKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LGpvLnByb3RvdHlwZS5hZGRTaGFwZUxpc3Q9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiAuYWRkU2hhcGVMaXN0KCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LGpvLnByb3RvdHlwZS5hZGRTaGFwZT1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IC5hZGRTaGFwZSgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxZcy5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5TY2VuZTogLmRpc3Bvc2UoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZW4ucHJvdG90eXBlLHt3cmFwQXJvdW5kOntnZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRlcmlhbDogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHNldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLlwiKX19LG92ZXJkcmF3OntnZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRlcmlhbDogLm92ZXJkcmF3IGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxzZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5NYXRlcmlhbDogLm92ZXJkcmF3IGhhcyBiZWVuIHJlbW92ZWQuXCIpfX0sd3JhcFJHQjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLk1hdGVyaWFsOiAud3JhcFJHQiBoYXMgYmVlbiByZW1vdmVkLlwiKSxuZXcgY259fSxzaGFkaW5nOntnZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuXCIrdGhpcy50eXBlK1wiOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuXCIpfSxzZXQ6ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuXCIrdGhpcy50eXBlK1wiOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuXCIpLHRoaXMuZmxhdFNoYWRpbmc9MT09PXR9fSxzdGVuY2lsTWFzazp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLlwiK3RoaXMudHlwZStcIjogLnN0ZW5jaWxNYXNrIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuc3RlbmNpbEZ1bmNNYXNrIGluc3RlYWQuXCIpLHRoaXMuc3RlbmNpbEZ1bmNNYXNrfSxzZXQ6ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuXCIrdGhpcy50eXBlK1wiOiAuc3RlbmNpbE1hc2sgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5zdGVuY2lsRnVuY01hc2sgaW5zdGVhZC5cIiksdGhpcy5zdGVuY2lsRnVuY01hc2s9dH19LHZlcnRleFRhbmdlbnRzOntnZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5cIit0aGlzLnR5cGUrXCI6IC52ZXJ0ZXhUYW5nZW50cyBoYXMgYmVlbiByZW1vdmVkLlwiKX0sc2V0OmZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiVEhSRUUuXCIrdGhpcy50eXBlK1wiOiAudmVydGV4VGFuZ2VudHMgaGFzIGJlZW4gcmVtb3ZlZC5cIil9fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFluLnByb3RvdHlwZSx7ZGVyaXZhdGl2ZXM6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5TaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLlwiKSx0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXN9LHNldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS4gU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy5cIiksdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzPXR9fX0pLFhzLnByb3RvdHlwZS5jbGVhclRhcmdldD1mdW5jdGlvbih0LGUsbixpKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuY2xlYXJUYXJnZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnNldFJlbmRlclRhcmdldCgpIGFuZCAuY2xlYXIoKSBpbnN0ZWFkLlwiKSx0aGlzLnNldFJlbmRlclRhcmdldCh0KSx0aGlzLmNsZWFyKGUsbixpKX0sWHMucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFuaW1hdGUoKSBpcyBub3cgLnNldEFuaW1hdGlvbkxvb3AoKS5cIiksdGhpcy5zZXRBbmltYXRpb25Mb29wKHQpfSxYcy5wcm90b3R5cGUuZ2V0Q3VycmVudFJlbmRlclRhcmdldD1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0Q3VycmVudFJlbmRlclRhcmdldCgpIGlzIG5vdyAuZ2V0UmVuZGVyVGFyZ2V0KCkuXCIpLHRoaXMuZ2V0UmVuZGVyVGFyZ2V0KCl9LFhzLnByb3RvdHlwZS5nZXRNYXhBbmlzb3Ryb3B5PWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRNYXhBbmlzb3Ryb3B5KCkgaXMgbm93IC5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpLlwiKSx0aGlzLmNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCl9LFhzLnByb3RvdHlwZS5nZXRQcmVjaXNpb249ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldFByZWNpc2lvbigpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLnByZWNpc2lvbi5cIiksdGhpcy5jYXBhYmlsaXRpZXMucHJlY2lzaW9ufSxYcy5wcm90b3R5cGUucmVzZXRHTFN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5yZXNldEdMU3RhdGUoKSBpcyBub3cgLnN0YXRlLnJlc2V0KCkuXCIpLHRoaXMuc3RhdGUucmVzZXQoKX0sWHMucHJvdG90eXBlLnN1cHBvcnRzRmxvYXRUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApLlwiKSx0aGlzLmV4dGVuc2lvbnMuZ2V0KFwiT0VTX3RleHR1cmVfZmxvYXRcIil9LFhzLnByb3RvdHlwZS5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICkuXCIpLHRoaXMuZXh0ZW5zaW9ucy5nZXQoXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpfSxYcy5wcm90b3R5cGUuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApLlwiKSx0aGlzLmV4dGVuc2lvbnMuZ2V0KFwiT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXCIpfSxYcy5wcm90b3R5cGUuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEM9ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApLlwiKSx0aGlzLmV4dGVuc2lvbnMuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIil9LFhzLnByb3RvdHlwZS5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEM9ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkuXCIpLHRoaXMuZXh0ZW5zaW9ucy5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIil9LFhzLnByb3RvdHlwZS5zdXBwb3J0c0JsZW5kTWluTWF4PWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICkuXCIpLHRoaXMuZXh0ZW5zaW9ucy5nZXQoXCJFWFRfYmxlbmRfbWlubWF4XCIpfSxYcy5wcm90b3R5cGUuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcygpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLlwiKSx0aGlzLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlc30sWHMucHJvdG90eXBlLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0luc3RhbmNlZEFycmF5cygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApLlwiKSx0aGlzLmV4dGVuc2lvbnMuZ2V0KFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKX0sWHMucHJvdG90eXBlLmVuYWJsZVNjaXNzb3JUZXN0PWZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5lbmFibGVTY2lzc29yVGVzdCgpIGlzIG5vdyAuc2V0U2Npc3NvclRlc3QoKS5cIiksdGhpcy5zZXRTY2lzc29yVGVzdCh0KX0sWHMucHJvdG90eXBlLmluaXRNYXRlcmlhbD1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sWHMucHJvdG90eXBlLmFkZFByZVBsdWdpbj1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sWHMucHJvdG90eXBlLmFkZFBvc3RQbHVnaW49ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxYcy5wcm90b3R5cGUudXBkYXRlU2hhZG93TWFwPWZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxYcy5wcm90b3R5cGUuc2V0RmFjZUN1bGxpbmc9ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2V0RmFjZUN1bGxpbmcoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sWHMucHJvdG90eXBlLmFsbG9jVGV4dHVyZVVuaXQ9ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWxsb2NUZXh0dXJlVW5pdCgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxYcy5wcm90b3R5cGUuc2V0VGV4dHVyZT1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LFhzLnByb3RvdHlwZS5zZXRUZXh0dXJlMkQ9ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2V0VGV4dHVyZTJEKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LFhzLnByb3RvdHlwZS5zZXRUZXh0dXJlQ3ViZT1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlQ3ViZSgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxYcy5wcm90b3R5cGUuZ2V0QWN0aXZlTWlwTWFwTGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldEFjdGl2ZU1pcE1hcExldmVsKCkgaXMgbm93IC5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLlwiKSx0aGlzLmdldEFjdGl2ZU1pcG1hcExldmVsKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFhzLnByb3RvdHlwZSx7c2hhZG93TWFwRW5hYmxlZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hhZG93TWFwLmVuYWJsZWR9LHNldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLlwiKSx0aGlzLnNoYWRvd01hcC5lbmFibGVkPXR9fSxzaGFkb3dNYXBUeXBlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFkb3dNYXAudHlwZX0sc2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBUeXBlIGlzIG5vdyAuc2hhZG93TWFwLnR5cGUuXCIpLHRoaXMuc2hhZG93TWFwLnR5cGU9dH19LHNoYWRvd01hcEN1bGxGYWNlOntnZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC5cIil9LHNldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLlwiKX19LGNvbnRleHQ6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuY29udGV4dCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLmdldENvbnRleHQoKSBpbnN0ZWFkLlwiKSx0aGlzLmdldENvbnRleHQoKX19LHZyOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnZyIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnhyXCIpLHRoaXMueHJ9fSxnYW1tYUlucHV0OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdhbW1hSW5wdXQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IHRoZSBlbmNvZGluZyBmb3IgdGV4dHVyZXMgdmlhIFRleHR1cmUuZW5jb2RpbmcgaW5zdGVhZC5cIiksITF9LHNldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5nYW1tYUlucHV0IGhhcyBiZWVuIHJlbW92ZWQuIFNldCB0aGUgZW5jb2RpbmcgZm9yIHRleHR1cmVzIHZpYSBUZXh0dXJlLmVuY29kaW5nIGluc3RlYWQuXCIpfX0sZ2FtbWFPdXRwdXQ6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFPdXRwdXQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IFdlYkdMUmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgaW5zdGVhZC5cIiksITF9LHNldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFPdXRwdXQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IFdlYkdMUmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgaW5zdGVhZC5cIiksdGhpcy5vdXRwdXRFbmNvZGluZz0hMD09PXQ/MzAwMTozZTN9fSx0b25lTWFwcGluZ1doaXRlUG9pbnQ6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAudG9uZU1hcHBpbmdXaGl0ZVBvaW50IGhhcyBiZWVuIHJlbW92ZWQuXCIpLDF9LHNldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC50b25lTWFwcGluZ1doaXRlUG9pbnQgaGFzIGJlZW4gcmVtb3ZlZC5cIil9fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFVzLnByb3RvdHlwZSx7Y3VsbEZhY2U6e2dldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAuY3VsbEZhY2UgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC5cIil9LHNldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAuY3VsbEZhY2UgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC5cIil9fSxyZW5kZXJSZXZlcnNlU2lkZWQ6e2dldDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuXCIpfSxzZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLnJlbmRlclJldmVyc2VTaWRlZCBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLlwiKX19LHJlbmRlclNpbmdsZVNpZGVkOntnZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLnJlbmRlclNpbmdsZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuXCIpfSxzZXQ6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLnJlbmRlclNpbmdsZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuXCIpfX19KSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhVdC5wcm90b3R5cGUse3dyYXBTOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuXCIpLHRoaXMudGV4dHVyZS53cmFwU30sc2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLlwiKSx0aGlzLnRleHR1cmUud3JhcFM9dH19LHdyYXBUOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuXCIpLHRoaXMudGV4dHVyZS53cmFwVH0sc2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULlwiKSx0aGlzLnRleHR1cmUud3JhcFQ9dH19LG1hZ0ZpbHRlcjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuXCIpLHRoaXMudGV4dHVyZS5tYWdGaWx0ZXJ9LHNldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLlwiKSx0aGlzLnRleHR1cmUubWFnRmlsdGVyPXR9fSxtaW5GaWx0ZXI6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLlwiKSx0aGlzLnRleHR1cmUubWluRmlsdGVyfSxzZXQ6ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci5cIiksdGhpcy50ZXh0dXJlLm1pbkZpbHRlcj10fX0sYW5pc290cm9weTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS5cIiksdGhpcy50ZXh0dXJlLmFuaXNvdHJvcHl9LHNldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuXCIpLHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5PXR9fSxvZmZzZXQ6e2dldDpmdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LlwiKSx0aGlzLnRleHR1cmUub2Zmc2V0fSxzZXQ6ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC5cIiksdGhpcy50ZXh0dXJlLm9mZnNldD10fX0scmVwZWF0OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC5cIiksdGhpcy50ZXh0dXJlLnJlcGVhdH0sc2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuXCIpLHRoaXMudGV4dHVyZS5yZXBlYXQ9dH19LGZvcm1hdDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuXCIpLHRoaXMudGV4dHVyZS5mb3JtYXR9LHNldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LlwiKSx0aGlzLnRleHR1cmUuZm9ybWF0PXR9fSx0eXBlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC50eXBlIGlzIG5vdyAudGV4dHVyZS50eXBlLlwiKSx0aGlzLnRleHR1cmUudHlwZX0sc2V0OmZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS5cIiksdGhpcy50ZXh0dXJlLnR5cGU9dH19LGdlbmVyYXRlTWlwbWFwczp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuXCIpLHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHN9LHNldDpmdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLlwiKSx0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPXR9fX0pLGNsYXNzIGV4dGVuZHMgVmV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnR5cGU9XCJBdWRpb1wiLHRoaXMubGlzdGVuZXI9dCx0aGlzLmNvbnRleHQ9dC5jb250ZXh0LHRoaXMuZ2Fpbj10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpLHRoaXMuZ2Fpbi5jb25uZWN0KHQuZ2V0SW5wdXQoKSksdGhpcy5hdXRvcGxheT0hMSx0aGlzLmJ1ZmZlcj1udWxsLHRoaXMuZGV0dW5lPTAsdGhpcy5sb29wPSExLHRoaXMubG9vcFN0YXJ0PTAsdGhpcy5sb29wRW5kPTAsdGhpcy5vZmZzZXQ9MCx0aGlzLmR1cmF0aW9uPXZvaWQgMCx0aGlzLnBsYXliYWNrUmF0ZT0xLHRoaXMuaXNQbGF5aW5nPSExLHRoaXMuaGFzUGxheWJhY2tDb250cm9sPSEwLHRoaXMuc291cmNlPW51bGwsdGhpcy5zb3VyY2VUeXBlPVwiZW1wdHlcIix0aGlzLl9zdGFydGVkQXQ9MCx0aGlzLl9wcm9ncmVzcz0wLHRoaXMuX2Nvbm5lY3RlZD0hMSx0aGlzLmZpbHRlcnM9W119Z2V0T3V0cHV0KCl7cmV0dXJuIHRoaXMuZ2Fpbn1zZXROb2RlU291cmNlKHQpe3JldHVybiB0aGlzLmhhc1BsYXliYWNrQ29udHJvbD0hMSx0aGlzLnNvdXJjZVR5cGU9XCJhdWRpb05vZGVcIix0aGlzLnNvdXJjZT10LHRoaXMuY29ubmVjdCgpLHRoaXN9c2V0TWVkaWFFbGVtZW50U291cmNlKHQpe3JldHVybiB0aGlzLmhhc1BsYXliYWNrQ29udHJvbD0hMSx0aGlzLnNvdXJjZVR5cGU9XCJtZWRpYU5vZGVcIix0aGlzLnNvdXJjZT10aGlzLmNvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKHQpLHRoaXMuY29ubmVjdCgpLHRoaXN9c2V0TWVkaWFTdHJlYW1Tb3VyY2UodCl7cmV0dXJuIHRoaXMuaGFzUGxheWJhY2tDb250cm9sPSExLHRoaXMuc291cmNlVHlwZT1cIm1lZGlhU3RyZWFtTm9kZVwiLHRoaXMuc291cmNlPXRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSh0KSx0aGlzLmNvbm5lY3QoKSx0aGlzfXNldEJ1ZmZlcih0KXtyZXR1cm4gdGhpcy5idWZmZXI9dCx0aGlzLnNvdXJjZVR5cGU9XCJidWZmZXJcIix0aGlzLmF1dG9wbGF5JiZ0aGlzLnBsYXkoKSx0aGlzfXBsYXkodD0wKXtpZighMD09PXRoaXMuaXNQbGF5aW5nKXJldHVybiB2b2lkIGNvbnNvbGUud2FybihcIlRIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuXCIpO2lmKCExPT09dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFwiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuXCIpO3RoaXMuX3N0YXJ0ZWRBdD10aGlzLmNvbnRleHQuY3VycmVudFRpbWUrdDtjb25zdCBlPXRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtyZXR1cm4gZS5idWZmZXI9dGhpcy5idWZmZXIsZS5sb29wPXRoaXMubG9vcCxlLmxvb3BTdGFydD10aGlzLmxvb3BTdGFydCxlLmxvb3BFbmQ9dGhpcy5sb29wRW5kLGUub25lbmRlZD10aGlzLm9uRW5kZWQuYmluZCh0aGlzKSxlLnN0YXJ0KHRoaXMuX3N0YXJ0ZWRBdCx0aGlzLl9wcm9ncmVzcyt0aGlzLm9mZnNldCx0aGlzLmR1cmF0aW9uKSx0aGlzLmlzUGxheWluZz0hMCx0aGlzLnNvdXJjZT1lLHRoaXMuc2V0RGV0dW5lKHRoaXMuZGV0dW5lKSx0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBsYXliYWNrUmF0ZSksdGhpcy5jb25uZWN0KCl9cGF1c2UoKXtpZighMSE9PXRoaXMuaGFzUGxheWJhY2tDb250cm9sKXJldHVybiEwPT09dGhpcy5pc1BsYXlpbmcmJih0aGlzLl9wcm9ncmVzcys9TWF0aC5tYXgodGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLXRoaXMuX3N0YXJ0ZWRBdCwwKSp0aGlzLnBsYXliYWNrUmF0ZSwhMD09PXRoaXMubG9vcCYmKHRoaXMuX3Byb2dyZXNzPXRoaXMuX3Byb2dyZXNzJSh0aGlzLmR1cmF0aW9ufHx0aGlzLmJ1ZmZlci5kdXJhdGlvbikpLHRoaXMuc291cmNlLnN0b3AoKSx0aGlzLnNvdXJjZS5vbmVuZGVkPW51bGwsdGhpcy5pc1BsYXlpbmc9ITEpLHRoaXM7Y29uc29sZS53YXJuKFwiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuXCIpfXN0b3AoKXtpZighMSE9PXRoaXMuaGFzUGxheWJhY2tDb250cm9sKXJldHVybiB0aGlzLl9wcm9ncmVzcz0wLHRoaXMuc291cmNlLnN0b3AoKSx0aGlzLnNvdXJjZS5vbmVuZGVkPW51bGwsdGhpcy5pc1BsYXlpbmc9ITEsdGhpcztjb25zb2xlLndhcm4oXCJUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC5cIil9Y29ubmVjdCgpe2lmKHRoaXMuZmlsdGVycy5sZW5ndGg+MCl7dGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLmZpbHRlcnNbMF0pO2ZvcihsZXQgdD0xLGU9dGhpcy5maWx0ZXJzLmxlbmd0aDt0PGU7dCsrKXRoaXMuZmlsdGVyc1t0LTFdLmNvbm5lY3QodGhpcy5maWx0ZXJzW3RdKTt0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aC0xXS5jb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpfWVsc2UgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLmdldE91dHB1dCgpKTtyZXR1cm4gdGhpcy5fY29ubmVjdGVkPSEwLHRoaXN9ZGlzY29ubmVjdCgpe2lmKHRoaXMuZmlsdGVycy5sZW5ndGg+MCl7dGhpcy5zb3VyY2UuZGlzY29ubmVjdCh0aGlzLmZpbHRlcnNbMF0pO2ZvcihsZXQgdD0xLGU9dGhpcy5maWx0ZXJzLmxlbmd0aDt0PGU7dCsrKXRoaXMuZmlsdGVyc1t0LTFdLmRpc2Nvbm5lY3QodGhpcy5maWx0ZXJzW3RdKTt0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aC0xXS5kaXNjb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpfWVsc2UgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCh0aGlzLmdldE91dHB1dCgpKTtyZXR1cm4gdGhpcy5fY29ubmVjdGVkPSExLHRoaXN9Z2V0RmlsdGVycygpe3JldHVybiB0aGlzLmZpbHRlcnN9c2V0RmlsdGVycyh0KXtyZXR1cm4gdHx8KHQ9W10pLCEwPT09dGhpcy5fY29ubmVjdGVkPyh0aGlzLmRpc2Nvbm5lY3QoKSx0aGlzLmZpbHRlcnM9dC5zbGljZSgpLHRoaXMuY29ubmVjdCgpKTp0aGlzLmZpbHRlcnM9dC5zbGljZSgpLHRoaXN9c2V0RGV0dW5lKHQpe2lmKHRoaXMuZGV0dW5lPXQsdm9pZCAwIT09dGhpcy5zb3VyY2UuZGV0dW5lKXJldHVybiEwPT09dGhpcy5pc1BsYXlpbmcmJnRoaXMuc291cmNlLmRldHVuZS5zZXRUYXJnZXRBdFRpbWUodGhpcy5kZXR1bmUsdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLC4wMSksdGhpc31nZXREZXR1bmUoKXtyZXR1cm4gdGhpcy5kZXR1bmV9Z2V0RmlsdGVyKCl7cmV0dXJuIHRoaXMuZ2V0RmlsdGVycygpWzBdfXNldEZpbHRlcih0KXtyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKHQ/W3RdOltdKX1zZXRQbGF5YmFja1JhdGUodCl7aWYoITEhPT10aGlzLmhhc1BsYXliYWNrQ29udHJvbClyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU9dCwhMD09PXRoaXMuaXNQbGF5aW5nJiZ0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VGFyZ2V0QXRUaW1lKHRoaXMucGxheWJhY2tSYXRlLHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwuMDEpLHRoaXM7Y29uc29sZS53YXJuKFwiVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuXCIpfWdldFBsYXliYWNrUmF0ZSgpe3JldHVybiB0aGlzLnBsYXliYWNrUmF0ZX1vbkVuZGVkKCl7dGhpcy5pc1BsYXlpbmc9ITF9Z2V0TG9vcCgpe3JldHVybiExPT09dGhpcy5oYXNQbGF5YmFja0NvbnRyb2w/KGNvbnNvbGUud2FybihcIlRIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLlwiKSwhMSk6dGhpcy5sb29wfXNldExvb3AodCl7aWYoITEhPT10aGlzLmhhc1BsYXliYWNrQ29udHJvbClyZXR1cm4gdGhpcy5sb29wPXQsITA9PT10aGlzLmlzUGxheWluZyYmKHRoaXMuc291cmNlLmxvb3A9dGhpcy5sb29wKSx0aGlzO2NvbnNvbGUud2FybihcIlRIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLlwiKX1zZXRMb29wU3RhcnQodCl7cmV0dXJuIHRoaXMubG9vcFN0YXJ0PXQsdGhpc31zZXRMb29wRW5kKHQpe3JldHVybiB0aGlzLmxvb3BFbmQ9dCx0aGlzfWdldFZvbHVtZSgpe3JldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZX1zZXRWb2x1bWUodCl7cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnNldFRhcmdldEF0VGltZSh0LHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwuMDEpLHRoaXN9fS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbih0KXtjb25zb2xlLndhcm4oXCJUSFJFRS5BdWRpbzogLmxvYWQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkF1ZGlvTG9hZGVyIGluc3RlYWQuXCIpO2NvbnN0IGU9dGhpcztyZXR1cm4obmV3IEhsKS5sb2FkKHQsKGZ1bmN0aW9uKHQpe2Uuc2V0QnVmZmVyKHQpfSkpLHRoaXN9LCRuLnByb3RvdHlwZS51cGRhdGVDdWJlTWFwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRIUkVFLkN1YmVDYW1lcmE6IC51cGRhdGVDdWJlTWFwKCkgaXMgbm93IC51cGRhdGUoKS5cIiksdGhpcy51cGRhdGUodCxlKX0sJG4ucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5DdWJlQ2FtZXJhOiAuY2xlYXIoKSBpcyBub3cgLnJlbmRlclRhcmdldC5jbGVhcigpLlwiKSx0aGlzLnJlbmRlclRhcmdldC5jbGVhcih0LGUsbixpKX0sSXQuY3Jvc3NPcmlnaW49dm9pZCAwLEl0LmxvYWRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLGkpe2NvbnNvbGUud2FybihcIlRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLlRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLlwiKTtjb25zdCByPW5ldyBibDtyLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO2NvbnN0IHM9ci5sb2FkKHQsbix2b2lkIDAsaSk7cmV0dXJuIGUmJihzLm1hcHBpbmc9ZSksc30sSXQubG9hZFRleHR1cmVDdWJlPWZ1bmN0aW9uKHQsZSxuLGkpe2NvbnNvbGUud2FybihcIlRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuXCIpO2NvbnN0IHI9bmV3IHlsO3Iuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7Y29uc3Qgcz1yLmxvYWQodCxuLHZvaWQgMCxpKTtyZXR1cm4gZSYmKHMubWFwcGluZz1lKSxzfSxJdC5sb2FkQ29tcHJlc3NlZFRleHR1cmU9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLlwiKX0sSXQubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZT1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLlwiKX0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyYmX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicmVnaXN0ZXJcIix7ZGV0YWlsOntyZXZpc2lvbjpcIjEzM1wifX0pKSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93Ll9fVEhSRUVfXz9jb25zb2xlLndhcm4oXCJXQVJOSU5HOiBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgVGhyZWUuanMgYmVpbmcgaW1wb3J0ZWQuXCIpOndpbmRvdy5fX1RIUkVFX189XCIxMzNcIik7Y29uc3QgaGM9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gdWMoKXtsZXQgdCxlO2Z1bmN0aW9uIG4odCxlLG4saSxyLHMpe2NvbnN0IGE9cy5udW1fY29tcG9uZW50cygpLG89bi5udW1fcG9pbnRzKCkqYSxsPW8qci5CWVRFU19QRVJfRUxFTUVOVCxjPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKGUpe2Nhc2UgRmxvYXQzMkFycmF5OnJldHVybiB0LkRUX0ZMT0FUMzI7Y2FzZSBJbnQ4QXJyYXk6cmV0dXJuIHQuRFRfSU5UODtjYXNlIEludDE2QXJyYXk6cmV0dXJuIHQuRFRfSU5UMTY7Y2FzZSBJbnQzMkFycmF5OnJldHVybiB0LkRUX0lOVDMyO2Nhc2UgVWludDhBcnJheTpyZXR1cm4gdC5EVF9VSU5UODtjYXNlIFVpbnQxNkFycmF5OnJldHVybiB0LkRUX1VJTlQxNjtjYXNlIFVpbnQzMkFycmF5OnJldHVybiB0LkRUX1VJTlQzMn19KHQsciksaD10Ll9tYWxsb2MobCk7ZS5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMobixzLGMsbCxoKTtjb25zdCB1PW5ldyByKHQuSEVBUEYzMi5idWZmZXIsaCxvKS5zbGljZSgpO3JldHVybiB0Ll9mcmVlKGgpLHtuYW1lOmksYXJyYXk6dSxpdGVtU2l6ZTphfX1vbm1lc3NhZ2U9ZnVuY3Rpb24oaSl7Y29uc3Qgcj1pLmRhdGE7c3dpdGNoKHIudHlwZSl7Y2FzZVwiaW5pdFwiOnQ9ci5kZWNvZGVyQ29uZmlnLGU9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3Qub25Nb2R1bGVMb2FkZWQ9ZnVuY3Rpb24odCl7ZSh7ZHJhY286dH0pfSxEcmFjb0RlY29kZXJNb2R1bGUodCl9KSk7YnJlYWs7Y2FzZVwiZGVjb2RlXCI6Y29uc3QgaT1yLmJ1ZmZlcixzPXIudGFza0NvbmZpZztlLnRoZW4oKHQ9Pntjb25zdCBlPXQuZHJhY28sYT1uZXcgZS5EZWNvZGVyLG89bmV3IGUuRGVjb2RlckJ1ZmZlcjtvLkluaXQobmV3IEludDhBcnJheShpKSxpLmJ5dGVMZW5ndGgpO3RyeXtjb25zdCB0PWZ1bmN0aW9uKHQsZSxpLHIpe2NvbnN0IHM9ci5hdHRyaWJ1dGVJRHMsYT1yLmF0dHJpYnV0ZVR5cGVzO2xldCBvLGw7Y29uc3QgYz1lLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoaSk7aWYoYz09PXQuVFJJQU5HVUxBUl9NRVNIKW89bmV3IHQuTWVzaCxsPWUuRGVjb2RlQnVmZmVyVG9NZXNoKGksbyk7ZWxzZXtpZihjIT09dC5QT0lOVF9DTE9VRCl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBnZW9tZXRyeSB0eXBlLlwiKTtvPW5ldyB0LlBvaW50Q2xvdWQsbD1lLkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZChpLG8pfWlmKCFsLm9rKCl8fDA9PT1vLnB0cil0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogRGVjb2RpbmcgZmFpbGVkOiBcIitsLmVycm9yX21zZygpKTtjb25zdCBoPXtpbmRleDpudWxsLGF0dHJpYnV0ZXM6W119O2Zvcihjb25zdCBpIGluIHMpe2NvbnN0IGw9c2VsZlthW2ldXTtsZXQgYyx1O2lmKHIudXNlVW5pcXVlSURzKXU9c1tpXSxjPWUuR2V0QXR0cmlidXRlQnlVbmlxdWVJZChvLHUpO2Vsc2V7aWYodT1lLkdldEF0dHJpYnV0ZUlkKG8sdFtzW2ldXSksLTE9PT11KWNvbnRpbnVlO2M9ZS5HZXRBdHRyaWJ1dGUobyx1KX1oLmF0dHJpYnV0ZXMucHVzaChuKHQsZSxvLGksbCxjKSl9Yz09PXQuVFJJQU5HVUxBUl9NRVNIJiYoaC5pbmRleD1mdW5jdGlvbih0LGUsbil7Y29uc3QgaT0zKm4ubnVtX2ZhY2VzKCkscj00Kmkscz10Ll9tYWxsb2Mocik7ZS5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShuLHIscyk7Y29uc3QgYT1uZXcgVWludDMyQXJyYXkodC5IRUFQRjMyLmJ1ZmZlcixzLGkpLnNsaWNlKCk7cmV0dXJuIHQuX2ZyZWUocykse2FycmF5OmEsaXRlbVNpemU6MX19KHQsZSxvKSk7cmV0dXJuIHQuZGVzdHJveShvKSxofShlLGEsbyxzKSxpPXQuYXR0cmlidXRlcy5tYXAoKHQ9PnQuYXJyYXkuYnVmZmVyKSk7dC5pbmRleCYmaS5wdXNoKHQuaW5kZXguYXJyYXkuYnVmZmVyKSxzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlXCIsaWQ6ci5pZCxnZW9tZXRyeTp0fSxpKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKHQpLHNlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6XCJlcnJvclwiLGlkOnIuaWQsZXJyb3I6dC5tZXNzYWdlfSl9ZmluYWxseXtlLmRlc3Ryb3kobyksZS5kZXN0cm95KGEpfX0pKX19fWNsYXNzIGRjIGV4dGVuZHMgbWx7Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5kcmFjb0xvYWRlcj1udWxsLHRoaXMua3R4MkxvYWRlcj1udWxsLHRoaXMubWVzaG9wdERlY29kZXI9bnVsbCx0aGlzLnBsdWdpbkNhbGxiYWNrcz1bXSx0aGlzLnJlZ2lzdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHZjKHQpfSkpLHRoaXMucmVnaXN0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgX2ModCl9KSksdGhpcy5yZWdpc3RlcigoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBNYyh0KX0pKSx0aGlzLnJlZ2lzdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHljKHQpfSkpLHRoaXMucmVnaXN0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeGModCl9KSksdGhpcy5yZWdpc3RlcigoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBiYyh0KX0pKSx0aGlzLnJlZ2lzdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHdjKHQpfSkpLHRoaXMucmVnaXN0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZmModCl9KSksdGhpcy5yZWdpc3RlcigoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBTYyh0KX0pKX1sb2FkKHQsZSxuLGkpe2NvbnN0IHI9dGhpcztsZXQgcztzPVwiXCIhPT10aGlzLnJlc291cmNlUGF0aD90aGlzLnJlc291cmNlUGF0aDpcIlwiIT09dGhpcy5wYXRoP3RoaXMucGF0aDpVbC5leHRyYWN0VXJsQmFzZSh0KSx0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHQpO2NvbnN0IGE9ZnVuY3Rpb24oZSl7aT9pKGUpOmNvbnNvbGUuZXJyb3IoZSksci5tYW5hZ2VyLml0ZW1FcnJvcih0KSxyLm1hbmFnZXIuaXRlbUVuZCh0KX0sbz1uZXcgZ2wodGhpcy5tYW5hZ2VyKTtvLnNldFBhdGgodGhpcy5wYXRoKSxvLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpLG8uc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpLG8uc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKSxvLmxvYWQodCwoZnVuY3Rpb24obil7dHJ5e3IucGFyc2UobixzLChmdW5jdGlvbihuKXtlKG4pLHIubWFuYWdlci5pdGVtRW5kKHQpfSksYSl9Y2F0Y2godCl7YSh0KX19KSxuLGEpfXNldERSQUNPTG9hZGVyKHQpe3JldHVybiB0aGlzLmRyYWNvTG9hZGVyPXQsdGhpc31zZXRERFNMb2FkZXIoKXt0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IFwiTVNGVF90ZXh0dXJlX2Rkc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gXCJLSFJfdGV4dHVyZV9iYXNpc3VcIi4nKX1zZXRLVFgyTG9hZGVyKHQpe3JldHVybiB0aGlzLmt0eDJMb2FkZXI9dCx0aGlzfXNldE1lc2hvcHREZWNvZGVyKHQpe3JldHVybiB0aGlzLm1lc2hvcHREZWNvZGVyPXQsdGhpc31yZWdpc3Rlcih0KXtyZXR1cm4tMT09PXRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YodCkmJnRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2godCksdGhpc311bnJlZ2lzdGVyKHQpe3JldHVybi0xIT09dGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZih0KSYmdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YodCksMSksdGhpc31wYXJzZSh0LGUsbixpKXtsZXQgcjtjb25zdCBzPXt9LGE9e307aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcj10O2Vsc2V7aWYoVWwuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheSh0LDAsNCkpPT09VGMpe3RyeXtzW21jLktIUl9CSU5BUllfR0xURl09bmV3IExjKHQpfWNhdGNoKHQpe3JldHVybiB2b2lkKGkmJmkodCkpfXI9c1ttYy5LSFJfQklOQVJZX0dMVEZdLmNvbnRlbnR9ZWxzZSByPVVsLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkodCkpfWNvbnN0IG89SlNPTi5wYXJzZShyKTtpZih2b2lkIDA9PT1vLmFzc2V0fHxvLmFzc2V0LnZlcnNpb25bMF08MilyZXR1cm4gdm9pZChpJiZpKG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuXCIpKSk7Y29uc3QgbD1uZXcgbGgobyx7cGF0aDplfHx0aGlzLnJlc291cmNlUGF0aHx8XCJcIixjcm9zc09yaWdpbjp0aGlzLmNyb3NzT3JpZ2luLHJlcXVlc3RIZWFkZXI6dGhpcy5yZXF1ZXN0SGVhZGVyLG1hbmFnZXI6dGhpcy5tYW5hZ2VyLGt0eDJMb2FkZXI6dGhpcy5rdHgyTG9hZGVyLG1lc2hvcHREZWNvZGVyOnRoaXMubWVzaG9wdERlY29kZXJ9KTtsLmZpbGVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO2ZvcihsZXQgdD0wO3Q8dGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoO3QrKyl7Y29uc3QgZT10aGlzLnBsdWdpbkNhbGxiYWNrc1t0XShsKTthW2UubmFtZV09ZSxzW2UubmFtZV09ITB9aWYoby5leHRlbnNpb25zVXNlZClmb3IobGV0IHQ9MDt0PG8uZXh0ZW5zaW9uc1VzZWQubGVuZ3RoOysrdCl7Y29uc3QgZT1vLmV4dGVuc2lvbnNVc2VkW3RdLG49by5leHRlbnNpb25zUmVxdWlyZWR8fFtdO3N3aXRjaChlKXtjYXNlIG1jLktIUl9NQVRFUklBTFNfVU5MSVQ6c1tlXT1uZXcgZ2M7YnJlYWs7Y2FzZSBtYy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTOnNbZV09bmV3IEljO2JyZWFrO2Nhc2UgbWMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046c1tlXT1uZXcgUmMobyx0aGlzLmRyYWNvTG9hZGVyKTticmVhaztjYXNlIG1jLktIUl9URVhUVVJFX1RSQU5TRk9STTpzW2VdPW5ldyBDYzticmVhaztjYXNlIG1jLktIUl9NRVNIX1FVQU5USVpBVElPTjpzW2VdPW5ldyBEYzticmVhaztkZWZhdWx0Om4uaW5kZXhPZihlKT49MCYmdm9pZCAwPT09YVtlXSYmY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicrZSsnXCIuJyl9fWwuc2V0RXh0ZW5zaW9ucyhzKSxsLnNldFBsdWdpbnMoYSksbC5wYXJzZShuLGkpfX1mdW5jdGlvbiBwYygpe2xldCB0PXt9O3JldHVybntnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LGFkZDpmdW5jdGlvbihlLG4pe3RbZV09bn0scmVtb3ZlOmZ1bmN0aW9uKGUpe2RlbGV0ZSB0W2VdfSxyZW1vdmVBbGw6ZnVuY3Rpb24oKXt0PXt9fX19Y29uc3QgbWM9e0tIUl9CSU5BUllfR0xURjpcIktIUl9iaW5hcnlfZ2xURlwiLEtIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOlwiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIixLSFJfTElHSFRTX1BVTkNUVUFMOlwiS0hSX2xpZ2h0c19wdW5jdHVhbFwiLEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOlwiS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcIixLSFJfTUFURVJJQUxTX0lPUjpcIktIUl9tYXRlcmlhbHNfaW9yXCIsS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUzpcIktIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzXCIsS0hSX01BVEVSSUFMU19TUEVDVUxBUjpcIktIUl9tYXRlcmlhbHNfc3BlY3VsYXJcIixLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjpcIktIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXCIsS0hSX01BVEVSSUFMU19VTkxJVDpcIktIUl9tYXRlcmlhbHNfdW5saXRcIixLSFJfTUFURVJJQUxTX1ZPTFVNRTpcIktIUl9tYXRlcmlhbHNfdm9sdW1lXCIsS0hSX1RFWFRVUkVfQkFTSVNVOlwiS0hSX3RleHR1cmVfYmFzaXN1XCIsS0hSX1RFWFRVUkVfVFJBTlNGT1JNOlwiS0hSX3RleHR1cmVfdHJhbnNmb3JtXCIsS0hSX01FU0hfUVVBTlRJWkFUSU9OOlwiS0hSX21lc2hfcXVhbnRpemF0aW9uXCIsRVhUX1RFWFRVUkVfV0VCUDpcIkVYVF90ZXh0dXJlX3dlYnBcIixFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjpcIkVYVF9tZXNob3B0X2NvbXByZXNzaW9uXCJ9O2NsYXNzIGZje2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPW1jLktIUl9MSUdIVFNfUFVOQ1RVQUwsdGhpcy5jYWNoZT17cmVmczp7fSx1c2VzOnt9fX1fbWFya0RlZnMoKXtjb25zdCB0PXRoaXMucGFyc2VyLGU9dGhpcy5wYXJzZXIuanNvbi5ub2Rlc3x8W107Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXtjb25zdCBpPWVbbl07aS5leHRlbnNpb25zJiZpLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSYmdm9pZCAwIT09aS5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQmJnQuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSxpLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCl9fV9sb2FkTGlnaHQodCl7Y29uc3QgZT10aGlzLnBhcnNlcixuPVwibGlnaHQ6XCIrdDtsZXQgaT1lLmNhY2hlLmdldChuKTtpZihpKXJldHVybiBpO2NvbnN0IHI9ZS5qc29uLHM9KChyLmV4dGVuc2lvbnMmJnIuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdfHx7fSkubGlnaHRzfHxbXSlbdF07bGV0IGE7Y29uc3Qgbz1uZXcgY24oMTY3NzcyMTUpO3ZvaWQgMCE9PXMuY29sb3ImJm8uZnJvbUFycmF5KHMuY29sb3IpO2NvbnN0IGw9dm9pZCAwIT09cy5yYW5nZT9zLnJhbmdlOjA7c3dpdGNoKHMudHlwZSl7Y2FzZVwiZGlyZWN0aW9uYWxcIjphPW5ldyBObChvKSxhLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwwLC0xKSxhLmFkZChhLnRhcmdldCk7YnJlYWs7Y2FzZVwicG9pbnRcIjphPW5ldyBJbChvKSxhLmRpc3RhbmNlPWw7YnJlYWs7Y2FzZVwic3BvdFwiOmE9bmV3IEFsKG8pLGEuZGlzdGFuY2U9bCxzLnNwb3Q9cy5zcG90fHx7fSxzLnNwb3QuaW5uZXJDb25lQW5nbGU9dm9pZCAwIT09cy5zcG90LmlubmVyQ29uZUFuZ2xlP3Muc3BvdC5pbm5lckNvbmVBbmdsZTowLHMuc3BvdC5vdXRlckNvbmVBbmdsZT12b2lkIDAhPT1zLnNwb3Qub3V0ZXJDb25lQW5nbGU/cy5zcG90Lm91dGVyQ29uZUFuZ2xlOk1hdGguUEkvNCxhLmFuZ2xlPXMuc3BvdC5vdXRlckNvbmVBbmdsZSxhLnBlbnVtYnJhPTEtcy5zcG90LmlubmVyQ29uZUFuZ2xlL3Muc3BvdC5vdXRlckNvbmVBbmdsZSxhLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwwLC0xKSxhLmFkZChhLnRhcmdldCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbmV4cGVjdGVkIGxpZ2h0IHR5cGU6IFwiK3MudHlwZSl9cmV0dXJuIGEucG9zaXRpb24uc2V0KDAsMCwwKSxhLmRlY2F5PTIsdm9pZCAwIT09cy5pbnRlbnNpdHkmJihhLmludGVuc2l0eT1zLmludGVuc2l0eSksYS5uYW1lPWUuY3JlYXRlVW5pcXVlTmFtZShzLm5hbWV8fFwibGlnaHRfXCIrdCksaT1Qcm9taXNlLnJlc29sdmUoYSksZS5jYWNoZS5hZGQobixpKSxpfWNyZWF0ZU5vZGVBdHRhY2htZW50KHQpe2NvbnN0IGU9dGhpcyxuPXRoaXMucGFyc2VyLGk9bi5qc29uLm5vZGVzW3RdLHI9KGkuZXh0ZW5zaW9ucyYmaS5leHRlbnNpb25zW3RoaXMubmFtZV18fHt9KS5saWdodDtyZXR1cm4gdm9pZCAwPT09cj9udWxsOnRoaXMuX2xvYWRMaWdodChyKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gbi5fZ2V0Tm9kZVJlZihlLmNhY2hlLHIsdCl9KSl9fWNsYXNzIGdje2NvbnN0cnVjdG9yKCl7dGhpcy5uYW1lPW1jLktIUl9NQVRFUklBTFNfVU5MSVR9Z2V0TWF0ZXJpYWxUeXBlKCl7cmV0dXJuIGhufWV4dGVuZFBhcmFtcyh0LGUsbil7Y29uc3QgaT1bXTt0LmNvbG9yPW5ldyBjbigxLDEsMSksdC5vcGFjaXR5PTE7Y29uc3Qgcj1lLnBick1ldGFsbGljUm91Z2huZXNzO2lmKHIpe2lmKEFycmF5LmlzQXJyYXkoci5iYXNlQ29sb3JGYWN0b3IpKXtjb25zdCBlPXIuYmFzZUNvbG9yRmFjdG9yO3QuY29sb3IuZnJvbUFycmF5KGUpLHQub3BhY2l0eT1lWzNdfXZvaWQgMCE9PXIuYmFzZUNvbG9yVGV4dHVyZSYmaS5wdXNoKG4uYXNzaWduVGV4dHVyZSh0LFwibWFwXCIsci5iYXNlQ29sb3JUZXh0dXJlKSl9cmV0dXJuIFByb21pc2UuYWxsKGkpfX1jbGFzcyB2Y3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj10LHRoaXMubmFtZT1tYy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVH1nZXRNYXRlcmlhbFR5cGUodCl7Y29uc3QgZT10aGlzLnBhcnNlci5qc29uLm1hdGVyaWFsc1t0XTtyZXR1cm4gZS5leHRlbnNpb25zJiZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT9KbzpudWxsfWV4dGVuZE1hdGVyaWFsUGFyYW1zKHQsZSl7Y29uc3Qgbj10aGlzLnBhcnNlcixpPW4uanNvbi5tYXRlcmlhbHNbdF07aWYoIWkuZXh0ZW5zaW9uc3x8IWkuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtjb25zdCByPVtdLHM9aS5leHRlbnNpb25zW3RoaXMubmFtZV07aWYodm9pZCAwIT09cy5jbGVhcmNvYXRGYWN0b3ImJihlLmNsZWFyY29hdD1zLmNsZWFyY29hdEZhY3Rvciksdm9pZCAwIT09cy5jbGVhcmNvYXRUZXh0dXJlJiZyLnB1c2gobi5hc3NpZ25UZXh0dXJlKGUsXCJjbGVhcmNvYXRNYXBcIixzLmNsZWFyY29hdFRleHR1cmUpKSx2b2lkIDAhPT1zLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciYmKGUuY2xlYXJjb2F0Um91Z2huZXNzPXMuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yKSx2b2lkIDAhPT1zLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUmJnIucHVzaChuLmFzc2lnblRleHR1cmUoZSxcImNsZWFyY29hdFJvdWdobmVzc01hcFwiLHMuY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSkpLHZvaWQgMCE9PXMuY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSYmKHIucHVzaChuLmFzc2lnblRleHR1cmUoZSxcImNsZWFyY29hdE5vcm1hbE1hcFwiLHMuY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSkpLHZvaWQgMCE9PXMuY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSkpe2NvbnN0IHQ9cy5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO2UuY2xlYXJjb2F0Tm9ybWFsU2NhbGU9bmV3IEF0KHQsdCl9cmV0dXJuIFByb21pc2UuYWxsKHIpfX1jbGFzcyB5Y3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj10LHRoaXMubmFtZT1tYy5LSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTn1nZXRNYXRlcmlhbFR5cGUodCl7Y29uc3QgZT10aGlzLnBhcnNlci5qc29uLm1hdGVyaWFsc1t0XTtyZXR1cm4gZS5leHRlbnNpb25zJiZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT9KbzpudWxsfWV4dGVuZE1hdGVyaWFsUGFyYW1zKHQsZSl7Y29uc3Qgbj10aGlzLnBhcnNlcixpPW4uanNvbi5tYXRlcmlhbHNbdF07aWYoIWkuZXh0ZW5zaW9uc3x8IWkuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtjb25zdCByPVtdLHM9aS5leHRlbnNpb25zW3RoaXMubmFtZV07cmV0dXJuIHZvaWQgMCE9PXMudHJhbnNtaXNzaW9uRmFjdG9yJiYoZS50cmFuc21pc3Npb249cy50cmFuc21pc3Npb25GYWN0b3IpLHZvaWQgMCE9PXMudHJhbnNtaXNzaW9uVGV4dHVyZSYmci5wdXNoKG4uYXNzaWduVGV4dHVyZShlLFwidHJhbnNtaXNzaW9uTWFwXCIscy50cmFuc21pc3Npb25UZXh0dXJlKSksUHJvbWlzZS5hbGwocil9fWNsYXNzIHhje2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPW1jLktIUl9NQVRFUklBTFNfVk9MVU1FfWdldE1hdGVyaWFsVHlwZSh0KXtjb25zdCBlPXRoaXMucGFyc2VyLmpzb24ubWF0ZXJpYWxzW3RdO3JldHVybiBlLmV4dGVuc2lvbnMmJmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdP0pvOm51bGx9ZXh0ZW5kTWF0ZXJpYWxQYXJhbXModCxlKXtjb25zdCBuPXRoaXMucGFyc2VyLGk9bi5qc29uLm1hdGVyaWFsc1t0XTtpZighaS5leHRlbnNpb25zfHwhaS5leHRlbnNpb25zW3RoaXMubmFtZV0pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2NvbnN0IHI9W10scz1pLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtlLnRoaWNrbmVzcz12b2lkIDAhPT1zLnRoaWNrbmVzc0ZhY3Rvcj9zLnRoaWNrbmVzc0ZhY3RvcjowLHZvaWQgMCE9PXMudGhpY2tuZXNzVGV4dHVyZSYmci5wdXNoKG4uYXNzaWduVGV4dHVyZShlLFwidGhpY2tuZXNzTWFwXCIscy50aGlja25lc3NUZXh0dXJlKSksZS5hdHRlbnVhdGlvbkRpc3RhbmNlPXMuYXR0ZW51YXRpb25EaXN0YW5jZXx8MDtjb25zdCBhPXMuYXR0ZW51YXRpb25Db2xvcnx8WzEsMSwxXTtyZXR1cm4gZS5hdHRlbnVhdGlvblRpbnQ9bmV3IGNuKGFbMF0sYVsxXSxhWzJdKSxQcm9taXNlLmFsbChyKX19Y2xhc3MgYmN7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9dCx0aGlzLm5hbWU9bWMuS0hSX01BVEVSSUFMU19JT1J9Z2V0TWF0ZXJpYWxUeXBlKHQpe2NvbnN0IGU9dGhpcy5wYXJzZXIuanNvbi5tYXRlcmlhbHNbdF07cmV0dXJuIGUuZXh0ZW5zaW9ucyYmZS5leHRlbnNpb25zW3RoaXMubmFtZV0/Sm86bnVsbH1leHRlbmRNYXRlcmlhbFBhcmFtcyh0LGUpe2NvbnN0IG49dGhpcy5wYXJzZXIuanNvbi5tYXRlcmlhbHNbdF07aWYoIW4uZXh0ZW5zaW9uc3x8IW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtjb25zdCBpPW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO3JldHVybiBlLmlvcj12b2lkIDAhPT1pLmlvcj9pLmlvcjoxLjUsUHJvbWlzZS5yZXNvbHZlKCl9fWNsYXNzIHdje2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPW1jLktIUl9NQVRFUklBTFNfU1BFQ1VMQVJ9Z2V0TWF0ZXJpYWxUeXBlKHQpe2NvbnN0IGU9dGhpcy5wYXJzZXIuanNvbi5tYXRlcmlhbHNbdF07cmV0dXJuIGUuZXh0ZW5zaW9ucyYmZS5leHRlbnNpb25zW3RoaXMubmFtZV0/Sm86bnVsbH1leHRlbmRNYXRlcmlhbFBhcmFtcyh0LGUpe2NvbnN0IG49dGhpcy5wYXJzZXIsaT1uLmpzb24ubWF0ZXJpYWxzW3RdO2lmKCFpLmV4dGVuc2lvbnN8fCFpLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7Y29uc3Qgcj1bXSxzPWkuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO2Uuc3BlY3VsYXJJbnRlbnNpdHk9dm9pZCAwIT09cy5zcGVjdWxhckZhY3Rvcj9zLnNwZWN1bGFyRmFjdG9yOjEsdm9pZCAwIT09cy5zcGVjdWxhclRleHR1cmUmJnIucHVzaChuLmFzc2lnblRleHR1cmUoZSxcInNwZWN1bGFySW50ZW5zaXR5TWFwXCIscy5zcGVjdWxhclRleHR1cmUpKTtjb25zdCBhPXMuc3BlY3VsYXJDb2xvckZhY3Rvcnx8WzEsMSwxXTtyZXR1cm4gZS5zcGVjdWxhclRpbnQ9bmV3IGNuKGFbMF0sYVsxXSxhWzJdKSx2b2lkIDAhPT1zLnNwZWN1bGFyQ29sb3JUZXh0dXJlJiZyLnB1c2gobi5hc3NpZ25UZXh0dXJlKGUsXCJzcGVjdWxhclRpbnRNYXBcIixzLnNwZWN1bGFyQ29sb3JUZXh0dXJlKS50aGVuKChmdW5jdGlvbih0KXt0LmVuY29kaW5nPTMwMDF9KSkpLFByb21pc2UuYWxsKHIpfX1jbGFzcyBfY3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj10LHRoaXMubmFtZT1tYy5LSFJfVEVYVFVSRV9CQVNJU1V9bG9hZFRleHR1cmUodCl7Y29uc3QgZT10aGlzLnBhcnNlcixuPWUuanNvbixpPW4udGV4dHVyZXNbdF07aWYoIWkuZXh0ZW5zaW9uc3x8IWkuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXJldHVybiBudWxsO2NvbnN0IHI9aS5leHRlbnNpb25zW3RoaXMubmFtZV0scz1uLmltYWdlc1tyLnNvdXJjZV0sYT1lLm9wdGlvbnMua3R4MkxvYWRlcjtpZighYSl7aWYobi5leHRlbnNpb25zUmVxdWlyZWQmJm4uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKT49MCl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRLVFgyTG9hZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIEtUWDIgdGV4dHVyZXNcIik7cmV0dXJuIG51bGx9cmV0dXJuIGUubG9hZFRleHR1cmVJbWFnZSh0LHMsYSl9fWNsYXNzIE1je2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPW1jLkVYVF9URVhUVVJFX1dFQlAsdGhpcy5pc1N1cHBvcnRlZD1udWxsfWxvYWRUZXh0dXJlKHQpe2NvbnN0IGU9dGhpcy5uYW1lLG49dGhpcy5wYXJzZXIsaT1uLmpzb24scj1pLnRleHR1cmVzW3RdO2lmKCFyLmV4dGVuc2lvbnN8fCFyLmV4dGVuc2lvbnNbZV0pcmV0dXJuIG51bGw7Y29uc3Qgcz1yLmV4dGVuc2lvbnNbZV0sYT1pLmltYWdlc1tzLnNvdXJjZV07bGV0IG89bi50ZXh0dXJlTG9hZGVyO2lmKGEudXJpKXtjb25zdCB0PW4ub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoYS51cmkpO251bGwhPT10JiYobz10KX1yZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbigoZnVuY3Rpb24ocil7aWYocilyZXR1cm4gbi5sb2FkVGV4dHVyZUltYWdlKHQsYSxvKTtpZihpLmV4dGVuc2lvbnNSZXF1aXJlZCYmaS5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihlKT49MCl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBXZWJQIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC5cIik7cmV0dXJuIG4ubG9hZFRleHR1cmUodCl9KSl9ZGV0ZWN0U3VwcG9ydCgpe3JldHVybiB0aGlzLmlzU3VwcG9ydGVkfHwodGhpcy5pc1N1cHBvcnRlZD1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgSW1hZ2U7ZS5zcmM9XCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBXCIsZS5vbmxvYWQ9ZS5vbmVycm9yPWZ1bmN0aW9uKCl7dCgxPT09ZS5oZWlnaHQpfX0pKSksdGhpcy5pc1N1cHBvcnRlZH19Y2xhc3MgU2N7Y29uc3RydWN0b3IodCl7dGhpcy5uYW1lPW1jLkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OLHRoaXMucGFyc2VyPXR9bG9hZEJ1ZmZlclZpZXcodCl7Y29uc3QgZT10aGlzLnBhcnNlci5qc29uLG49ZS5idWZmZXJWaWV3c1t0XTtpZihuLmV4dGVuc2lvbnMmJm4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKXtjb25zdCB0PW4uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLGk9dGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLHQuYnVmZmVyKSxyPXRoaXMucGFyc2VyLm9wdGlvbnMubWVzaG9wdERlY29kZXI7aWYoIXJ8fCFyLnN1cHBvcnRlZCl7aWYoZS5leHRlbnNpb25zUmVxdWlyZWQmJmUuZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKT49MCl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRNZXNob3B0RGVjb2RlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBjb21wcmVzc2VkIGZpbGVzXCIpO3JldHVybiBudWxsfXJldHVybiBQcm9taXNlLmFsbChbaSxyLnJlYWR5XSkudGhlbigoZnVuY3Rpb24oZSl7Y29uc3Qgbj10LmJ5dGVPZmZzZXR8fDAsaT10LmJ5dGVMZW5ndGh8fDAscz10LmNvdW50LGE9dC5ieXRlU3RyaWRlLG89bmV3IEFycmF5QnVmZmVyKHMqYSksbD1uZXcgVWludDhBcnJheShlWzBdLG4saSk7cmV0dXJuIHIuZGVjb2RlR2x0ZkJ1ZmZlcihuZXcgVWludDhBcnJheShvKSxzLGEsbCx0Lm1vZGUsdC5maWx0ZXIpLG99KSl9cmV0dXJuIG51bGx9fWNvbnN0IFRjPVwiZ2xURlwiLEVjPTEzMTM4MjE1MTQsQWM9NTEzMDU2MjtjbGFzcyBMY3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm5hbWU9bWMuS0hSX0JJTkFSWV9HTFRGLHRoaXMuY29udGVudD1udWxsLHRoaXMuYm9keT1udWxsO2NvbnN0IGU9bmV3IERhdGFWaWV3KHQsMCwxMik7aWYodGhpcy5oZWFkZXI9e21hZ2ljOlVsLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkodC5zbGljZSgwLDQpKSksdmVyc2lvbjplLmdldFVpbnQzMig0LCEwKSxsZW5ndGg6ZS5nZXRVaW50MzIoOCwhMCl9LHRoaXMuaGVhZGVyLm1hZ2ljIT09VGMpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtpZih0aGlzLmhlYWRlci52ZXJzaW9uPDIpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLlwiKTtjb25zdCBuPXRoaXMuaGVhZGVyLmxlbmd0aC0xMixpPW5ldyBEYXRhVmlldyh0LDEyKTtsZXQgcj0wO2Zvcig7cjxuOyl7Y29uc3QgZT1pLmdldFVpbnQzMihyLCEwKTtyKz00O2NvbnN0IG49aS5nZXRVaW50MzIociwhMCk7aWYocis9NCxuPT09RWMpe2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkodCwxMityLGUpO3RoaXMuY29udGVudD1VbC5kZWNvZGVUZXh0KG4pfWVsc2UgaWYobj09PUFjKXtjb25zdCBuPTEyK3I7dGhpcy5ib2R5PXQuc2xpY2UobixuK2UpfXIrPWV9aWYobnVsbD09PXRoaXMuY29udGVudCl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBKU09OIGNvbnRlbnQgbm90IGZvdW5kLlwiKX19Y2xhc3MgUmN7Y29uc3RydWN0b3IodCxlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC5cIik7dGhpcy5uYW1lPW1jLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OLHRoaXMuanNvbj10LHRoaXMuZHJhY29Mb2FkZXI9ZSx0aGlzLmRyYWNvTG9hZGVyLnByZWxvYWQoKX1kZWNvZGVQcmltaXRpdmUodCxlKXtjb25zdCBuPXRoaXMuanNvbixpPXRoaXMuZHJhY29Mb2FkZXIscj10LmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3LHM9dC5leHRlbnNpb25zW3RoaXMubmFtZV0uYXR0cmlidXRlcyxhPXt9LG89e30sbD17fTtmb3IoY29uc3QgdCBpbiBzKXtjb25zdCBlPVljW3RdfHx0LnRvTG93ZXJDYXNlKCk7YVtlXT1zW3RdfWZvcihjb25zdCBlIGluIHQuYXR0cmlidXRlcyl7Y29uc3QgaT1ZY1tlXXx8ZS50b0xvd2VyQ2FzZSgpO2lmKHZvaWQgMCE9PXNbZV0pe2NvbnN0IHI9bi5hY2Nlc3NvcnNbdC5hdHRyaWJ1dGVzW2VdXSxzPVdjW3IuY29tcG9uZW50VHlwZV07bFtpXT1zLG9baV09ITA9PT1yLm5vcm1hbGl6ZWR9fXJldHVybiBlLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIscikudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlKXtpLmRlY29kZURyYWNvRmlsZSh0LChmdW5jdGlvbih0KXtmb3IoY29uc3QgZSBpbiB0LmF0dHJpYnV0ZXMpe2NvbnN0IG49dC5hdHRyaWJ1dGVzW2VdLGk9b1tlXTt2b2lkIDAhPT1pJiYobi5ub3JtYWxpemVkPWkpfWUodCl9KSxhLGwpfSkpfSkpfX1jbGFzcyBDY3tjb25zdHJ1Y3Rvcigpe3RoaXMubmFtZT1tYy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk19ZXh0ZW5kVGV4dHVyZSh0LGUpe3JldHVybiB2b2lkIDAhPT1lLnRleENvb3JkJiZjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IEN1c3RvbSBVViBzZXRzIGluIFwiJyt0aGlzLm5hbWUrJ1wiIGV4dGVuc2lvbiBub3QgeWV0IHN1cHBvcnRlZC4nKSx2b2lkIDA9PT1lLm9mZnNldCYmdm9pZCAwPT09ZS5yb3RhdGlvbiYmdm9pZCAwPT09ZS5zY2FsZXx8KHQ9dC5jbG9uZSgpLHZvaWQgMCE9PWUub2Zmc2V0JiZ0Lm9mZnNldC5mcm9tQXJyYXkoZS5vZmZzZXQpLHZvaWQgMCE9PWUucm90YXRpb24mJih0LnJvdGF0aW9uPWUucm90YXRpb24pLHZvaWQgMCE9PWUuc2NhbGUmJnQucmVwZWF0LmZyb21BcnJheShlLnNjYWxlKSx0Lm5lZWRzVXBkYXRlPSEwKSx0fX1jbGFzcyBQYyBleHRlbmRzIFpve2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5pc0dMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbD0hMDtjb25zdCBlPVtcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcIixcIlxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1wiLFwiI2VuZGlmXCJdLmpvaW4oXCJcXG5cIiksbj1bXCIjaWZkZWYgVVNFX0dMT1NTSU5FU1NNQVBcIixcIlxcdHVuaWZvcm0gc2FtcGxlcjJEIGdsb3NzaW5lc3NNYXA7XCIsXCIjZW5kaWZcIl0uam9pbihcIlxcblwiKSxpPVtcInZlYzMgc3BlY3VsYXJGYWN0b3IgPSBzcGVjdWxhcjtcIixcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcIixcIlxcdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1wiLFwiXFx0dGV4ZWxTcGVjdWxhciA9IHNSR0JUb0xpbmVhciggdGV4ZWxTcGVjdWxhciApO1wiLFwiXFx0Ly8gcmVhZHMgY2hhbm5lbCBSR0IsIGNvbXBhdGlibGUgd2l0aCBhIGdsVEYgU3BlY3VsYXItR2xvc3NpbmVzcyAoUkdCQSkgdGV4dHVyZVwiLFwiXFx0c3BlY3VsYXJGYWN0b3IgKj0gdGV4ZWxTcGVjdWxhci5yZ2I7XCIsXCIjZW5kaWZcIl0uam9pbihcIlxcblwiKSxyPVtcImZsb2F0IGdsb3NzaW5lc3NGYWN0b3IgPSBnbG9zc2luZXNzO1wiLFwiI2lmZGVmIFVTRV9HTE9TU0lORVNTTUFQXCIsXCJcXHR2ZWM0IHRleGVsR2xvc3NpbmVzcyA9IHRleHR1cmUyRCggZ2xvc3NpbmVzc01hcCwgdlV2ICk7XCIsXCJcXHQvLyByZWFkcyBjaGFubmVsIEEsIGNvbXBhdGlibGUgd2l0aCBhIGdsVEYgU3BlY3VsYXItR2xvc3NpbmVzcyAoUkdCQSkgdGV4dHVyZVwiLFwiXFx0Z2xvc3NpbmVzc0ZhY3RvciAqPSB0ZXhlbEdsb3NzaW5lc3MuYTtcIixcIiNlbmRpZlwiXS5qb2luKFwiXFxuXCIpLHM9W1wiUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDtcIixcIm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuIC0gbWF4KCBzcGVjdWxhckZhY3Rvci5yLCBtYXgoIHNwZWN1bGFyRmFjdG9yLmcsIHNwZWN1bGFyRmFjdG9yLmIgKSApICk7XCIsXCJ2ZWMzIGR4eSA9IG1heCggYWJzKCBkRmR4KCBnZW9tZXRyeU5vcm1hbCApICksIGFicyggZEZkeSggZ2VvbWV0cnlOb3JtYWwgKSApICk7XCIsXCJmbG9hdCBnZW9tZXRyeVJvdWdobmVzcyA9IG1heCggbWF4KCBkeHkueCwgZHh5LnkgKSwgZHh5LnogKTtcIixcIm1hdGVyaWFsLnJvdWdobmVzcyA9IG1heCggMS4wIC0gZ2xvc3NpbmVzc0ZhY3RvciwgMC4wNTI1ICk7IC8vIDAuMDUyNSBjb3JyZXNwb25kcyB0byB0aGUgYmFzZSBtaXAgb2YgYSAyNTYgY3ViZW1hcC5cIixcIm1hdGVyaWFsLnJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcIixcIm1hdGVyaWFsLnJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwucm91Z2huZXNzLCAxLjAgKTtcIixcIm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhckZhY3RvcjtcIl0uam9pbihcIlxcblwiKSxhPXtzcGVjdWxhcjp7dmFsdWU6KG5ldyBjbikuc2V0SGV4KDE2Nzc3MjE1KX0sZ2xvc3NpbmVzczp7dmFsdWU6MX0sc3BlY3VsYXJNYXA6e3ZhbHVlOm51bGx9LGdsb3NzaW5lc3NNYXA6e3ZhbHVlOm51bGx9fTt0aGlzLl9leHRyYVVuaWZvcm1zPWEsdGhpcy5vbkJlZm9yZUNvbXBpbGU9ZnVuY3Rpb24odCl7Zm9yKGNvbnN0IGUgaW4gYSl0LnVuaWZvcm1zW2VdPWFbZV07dC5mcmFnbWVudFNoYWRlcj10LmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXCJ1bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcIixcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIikucmVwbGFjZShcInVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1wiLFwidW5pZm9ybSBmbG9hdCBnbG9zc2luZXNzO1wiKS5yZXBsYWNlKFwiI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlwiLGUpLnJlcGxhY2UoXCIjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XCIsbikucmVwbGFjZShcIiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+XCIsaSkucmVwbGFjZShcIiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+XCIscikucmVwbGFjZShcIiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+XCIscyl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMse3NwZWN1bGFyOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5zcGVjdWxhci52YWx1ZX0sc2V0OmZ1bmN0aW9uKHQpe2Euc3BlY3VsYXIudmFsdWU9dH19LHNwZWN1bGFyTWFwOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5zcGVjdWxhck1hcC52YWx1ZX0sc2V0OmZ1bmN0aW9uKHQpe2Euc3BlY3VsYXJNYXAudmFsdWU9dCx0P3RoaXMuZGVmaW5lcy5VU0VfU1BFQ1VMQVJNQVA9XCJcIjpkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9TUEVDVUxBUk1BUH19LGdsb3NzaW5lc3M6e2dldDpmdW5jdGlvbigpe3JldHVybiBhLmdsb3NzaW5lc3MudmFsdWV9LHNldDpmdW5jdGlvbih0KXthLmdsb3NzaW5lc3MudmFsdWU9dH19LGdsb3NzaW5lc3NNYXA6e2dldDpmdW5jdGlvbigpe3JldHVybiBhLmdsb3NzaW5lc3NNYXAudmFsdWV9LHNldDpmdW5jdGlvbih0KXthLmdsb3NzaW5lc3NNYXAudmFsdWU9dCx0Pyh0aGlzLmRlZmluZXMuVVNFX0dMT1NTSU5FU1NNQVA9XCJcIix0aGlzLmRlZmluZXMuVVNFX1VWPVwiXCIpOihkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9HTE9TU0lORVNTTUFQLGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX1VWKX19fSksZGVsZXRlIHRoaXMubWV0YWxuZXNzLGRlbGV0ZSB0aGlzLnJvdWdobmVzcyxkZWxldGUgdGhpcy5tZXRhbG5lc3NNYXAsZGVsZXRlIHRoaXMucm91Z2huZXNzTWFwLHRoaXMuc2V0VmFsdWVzKHQpfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5zcGVjdWxhck1hcD10LnNwZWN1bGFyTWFwLHRoaXMuc3BlY3VsYXIuY29weSh0LnNwZWN1bGFyKSx0aGlzLmdsb3NzaW5lc3NNYXA9dC5nbG9zc2luZXNzTWFwLHRoaXMuZ2xvc3NpbmVzcz10Lmdsb3NzaW5lc3MsZGVsZXRlIHRoaXMubWV0YWxuZXNzLGRlbGV0ZSB0aGlzLnJvdWdobmVzcyxkZWxldGUgdGhpcy5tZXRhbG5lc3NNYXAsZGVsZXRlIHRoaXMucm91Z2huZXNzTWFwLHRoaXN9fWNsYXNzIElje2NvbnN0cnVjdG9yKCl7dGhpcy5uYW1lPW1jLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MsdGhpcy5zcGVjdWxhckdsb3NzaW5lc3NQYXJhbXM9W1wiY29sb3JcIixcIm1hcFwiLFwibGlnaHRNYXBcIixcImxpZ2h0TWFwSW50ZW5zaXR5XCIsXCJhb01hcFwiLFwiYW9NYXBJbnRlbnNpdHlcIixcImVtaXNzaXZlXCIsXCJlbWlzc2l2ZUludGVuc2l0eVwiLFwiZW1pc3NpdmVNYXBcIixcImJ1bXBNYXBcIixcImJ1bXBTY2FsZVwiLFwibm9ybWFsTWFwXCIsXCJub3JtYWxNYXBUeXBlXCIsXCJkaXNwbGFjZW1lbnRNYXBcIixcImRpc3BsYWNlbWVudFNjYWxlXCIsXCJkaXNwbGFjZW1lbnRCaWFzXCIsXCJzcGVjdWxhck1hcFwiLFwic3BlY3VsYXJcIixcImdsb3NzaW5lc3NNYXBcIixcImdsb3NzaW5lc3NcIixcImFscGhhTWFwXCIsXCJlbnZNYXBcIixcImVudk1hcEludGVuc2l0eVwiLFwicmVmcmFjdGlvblJhdGlvXCJdfWdldE1hdGVyaWFsVHlwZSgpe3JldHVybiBQY31leHRlbmRQYXJhbXModCxlLG4pe2NvbnN0IGk9ZS5leHRlbnNpb25zW3RoaXMubmFtZV07dC5jb2xvcj1uZXcgY24oMSwxLDEpLHQub3BhY2l0eT0xO2NvbnN0IHI9W107aWYoQXJyYXkuaXNBcnJheShpLmRpZmZ1c2VGYWN0b3IpKXtjb25zdCBlPWkuZGlmZnVzZUZhY3Rvcjt0LmNvbG9yLmZyb21BcnJheShlKSx0Lm9wYWNpdHk9ZVszXX1pZih2b2lkIDAhPT1pLmRpZmZ1c2VUZXh0dXJlJiZyLnB1c2gobi5hc3NpZ25UZXh0dXJlKHQsXCJtYXBcIixpLmRpZmZ1c2VUZXh0dXJlKSksdC5lbWlzc2l2ZT1uZXcgY24oMCwwLDApLHQuZ2xvc3NpbmVzcz12b2lkIDAhPT1pLmdsb3NzaW5lc3NGYWN0b3I/aS5nbG9zc2luZXNzRmFjdG9yOjEsdC5zcGVjdWxhcj1uZXcgY24oMSwxLDEpLEFycmF5LmlzQXJyYXkoaS5zcGVjdWxhckZhY3RvcikmJnQuc3BlY3VsYXIuZnJvbUFycmF5KGkuc3BlY3VsYXJGYWN0b3IpLHZvaWQgMCE9PWkuc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSl7Y29uc3QgZT1pLnNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmU7ci5wdXNoKG4uYXNzaWduVGV4dHVyZSh0LFwiZ2xvc3NpbmVzc01hcFwiLGUpKSxyLnB1c2gobi5hc3NpZ25UZXh0dXJlKHQsXCJzcGVjdWxhck1hcFwiLGUpKX1yZXR1cm4gUHJvbWlzZS5hbGwocil9Y3JlYXRlTWF0ZXJpYWwodCl7Y29uc3QgZT1uZXcgUGModCk7cmV0dXJuIGUuZm9nPSEwLGUuY29sb3I9dC5jb2xvcixlLm1hcD12b2lkIDA9PT10Lm1hcD9udWxsOnQubWFwLGUubGlnaHRNYXA9bnVsbCxlLmxpZ2h0TWFwSW50ZW5zaXR5PTEsZS5hb01hcD12b2lkIDA9PT10LmFvTWFwP251bGw6dC5hb01hcCxlLmFvTWFwSW50ZW5zaXR5PTEsZS5lbWlzc2l2ZT10LmVtaXNzaXZlLGUuZW1pc3NpdmVJbnRlbnNpdHk9MSxlLmVtaXNzaXZlTWFwPXZvaWQgMD09PXQuZW1pc3NpdmVNYXA/bnVsbDp0LmVtaXNzaXZlTWFwLGUuYnVtcE1hcD12b2lkIDA9PT10LmJ1bXBNYXA/bnVsbDp0LmJ1bXBNYXAsZS5idW1wU2NhbGU9MSxlLm5vcm1hbE1hcD12b2lkIDA9PT10Lm5vcm1hbE1hcD9udWxsOnQubm9ybWFsTWFwLGUubm9ybWFsTWFwVHlwZT0wLHQubm9ybWFsU2NhbGUmJihlLm5vcm1hbFNjYWxlPXQubm9ybWFsU2NhbGUpLGUuZGlzcGxhY2VtZW50TWFwPW51bGwsZS5kaXNwbGFjZW1lbnRTY2FsZT0xLGUuZGlzcGxhY2VtZW50Qmlhcz0wLGUuc3BlY3VsYXJNYXA9dm9pZCAwPT09dC5zcGVjdWxhck1hcD9udWxsOnQuc3BlY3VsYXJNYXAsZS5zcGVjdWxhcj10LnNwZWN1bGFyLGUuZ2xvc3NpbmVzc01hcD12b2lkIDA9PT10Lmdsb3NzaW5lc3NNYXA/bnVsbDp0Lmdsb3NzaW5lc3NNYXAsZS5nbG9zc2luZXNzPXQuZ2xvc3NpbmVzcyxlLmFscGhhTWFwPW51bGwsZS5lbnZNYXA9dm9pZCAwPT09dC5lbnZNYXA/bnVsbDp0LmVudk1hcCxlLmVudk1hcEludGVuc2l0eT0xLGUucmVmcmFjdGlvblJhdGlvPS45OCxlfX1jbGFzcyBEY3tjb25zdHJ1Y3Rvcigpe3RoaXMubmFtZT1tYy5LSFJfTUVTSF9RVUFOVElaQVRJT059fWNsYXNzIE5jIGV4dGVuZHMgS297Y29uc3RydWN0b3IodCxlLG4saSl7c3VwZXIodCxlLG4saSl9Y29weVNhbXBsZVZhbHVlXyh0KXtjb25zdCBlPXRoaXMucmVzdWx0QnVmZmVyLG49dGhpcy5zYW1wbGVWYWx1ZXMsaT10aGlzLnZhbHVlU2l6ZSxyPXQqaSozK2k7Zm9yKGxldCB0PTA7dCE9PWk7dCsrKWVbdF09bltyK3RdO3JldHVybiBlfX1OYy5wcm90b3R5cGUuYmVmb3JlU3RhcnRfPU5jLnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfLE5jLnByb3RvdHlwZS5hZnRlckVuZF89TmMucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8sTmMucHJvdG90eXBlLmludGVycG9sYXRlXz1mdW5jdGlvbih0LGUsbixpKXtjb25zdCByPXRoaXMucmVzdWx0QnVmZmVyLHM9dGhpcy5zYW1wbGVWYWx1ZXMsYT10aGlzLnZhbHVlU2l6ZSxvPTIqYSxsPTMqYSxjPWktZSxoPShuLWUpL2MsdT1oKmgsZD11KmgscD10KmwsbT1wLWwsZj0tMipkKzMqdSxnPWQtdSx2PTEtZix5PWctdStoO2ZvcihsZXQgdD0wO3QhPT1hO3QrKyl7Y29uc3QgZT1zW20rdCthXSxuPXNbbSt0K29dKmMsaT1zW3ArdCthXSxsPXNbcCt0XSpjO3JbdF09diplK3kqbitmKmkrZypsfXJldHVybiByfTtjb25zdCBGYz1uZXcgenQ7Y2xhc3MgT2MgZXh0ZW5kcyBOY3tpbnRlcnBvbGF0ZV8odCxlLG4saSl7Y29uc3Qgcj1zdXBlci5pbnRlcnBvbGF0ZV8odCxlLG4saSk7cmV0dXJuIEZjLmZyb21BcnJheShyKS5ub3JtYWxpemUoKS50b0FycmF5KHIpLHJ9fWNvbnN0IFVjPTAsa2M9MSx6Yz0yLEJjPTMsSGM9NCxWYz01LEdjPTYsV2M9ezUxMjA6SW50OEFycmF5LDUxMjE6VWludDhBcnJheSw1MTIyOkludDE2QXJyYXksNTEyMzpVaW50MTZBcnJheSw1MTI1OlVpbnQzMkFycmF5LDUxMjY6RmxvYXQzMkFycmF5fSxqYz17OTcyODoxMDAzLDk3Mjk6MTAwNiw5OTg0OjEwMDQsOTk4NToxMDA3LDk5ODY6MTAwNSw5OTg3OjEwMDh9LHFjPXszMzA3MToxMDAxLDMzNjQ4OjEwMDIsMTA0OTc6MWUzfSxYYz17U0NBTEFSOjEsVkVDMjoyLFZFQzM6MyxWRUM0OjQsTUFUMjo0LE1BVDM6OSxNQVQ0OjE2fSxZYz17UE9TSVRJT046XCJwb3NpdGlvblwiLE5PUk1BTDpcIm5vcm1hbFwiLFRBTkdFTlQ6XCJ0YW5nZW50XCIsVEVYQ09PUkRfMDpcInV2XCIsVEVYQ09PUkRfMTpcInV2MlwiLENPTE9SXzA6XCJjb2xvclwiLFdFSUdIVFNfMDpcInNraW5XZWlnaHRcIixKT0lOVFNfMDpcInNraW5JbmRleFwifSxaYz17c2NhbGU6XCJzY2FsZVwiLHRyYW5zbGF0aW9uOlwicG9zaXRpb25cIixyb3RhdGlvbjpcInF1YXRlcm5pb25cIix3ZWlnaHRzOlwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCJ9LEpjPXtDVUJJQ1NQTElORTp2b2lkIDAsTElORUFSOjIzMDEsU1RFUDoyMzAwfSwkYz1cIk9QQVFVRVwiLEtjPVwiTUFTS1wiLFFjPVwiQkxFTkRcIjtmdW5jdGlvbiB0aCh0LGUpe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiB0fHxcIlwiPT09dD9cIlwiOigvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KGUpJiYvXlxcLy8udGVzdCh0KSYmKGU9ZS5yZXBsYWNlKC8oXmh0dHBzPzpcXC9cXC9bXlxcL10rKS4qL2ksXCIkMVwiKSksL14oaHR0cHM/Oik/XFwvXFwvL2kudGVzdCh0KXx8L15kYXRhOi4qLC4qJC9pLnRlc3QodCl8fC9eYmxvYjouKiQvaS50ZXN0KHQpP3Q6ZSt0KX1mdW5jdGlvbiBlaCh0KXtyZXR1cm4gdm9pZCAwPT09dC5EZWZhdWx0TWF0ZXJpYWwmJih0LkRlZmF1bHRNYXRlcmlhbD1uZXcgWm8oe2NvbG9yOjE2Nzc3MjE1LGVtaXNzaXZlOjAsbWV0YWxuZXNzOjEscm91Z2huZXNzOjEsdHJhbnNwYXJlbnQ6ITEsZGVwdGhUZXN0OiEwLHNpZGU6MH0pKSx0LkRlZmF1bHRNYXRlcmlhbH1mdW5jdGlvbiBuaCh0LGUsbil7Zm9yKGNvbnN0IGkgaW4gbi5leHRlbnNpb25zKXZvaWQgMD09PXRbaV0mJihlLnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zPWUudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnN8fHt9LGUudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnNbaV09bi5leHRlbnNpb25zW2ldKX1mdW5jdGlvbiBpaCh0LGUpe3ZvaWQgMCE9PWUuZXh0cmFzJiYoXCJvYmplY3RcIj09dHlwZW9mIGUuZXh0cmFzP09iamVjdC5hc3NpZ24odC51c2VyRGF0YSxlLmV4dHJhcyk6Y29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogSWdub3JpbmcgcHJpbWl0aXZlIHR5cGUgLmV4dHJhcywgXCIrZS5leHRyYXMpKX1mdW5jdGlvbiByaCh0LGUpe2lmKHQudXBkYXRlTW9ycGhUYXJnZXRzKCksdm9pZCAwIT09ZS53ZWlnaHRzKWZvcihsZXQgbj0wLGk9ZS53ZWlnaHRzLmxlbmd0aDtuPGk7bisrKXQubW9ycGhUYXJnZXRJbmZsdWVuY2VzW25dPWUud2VpZ2h0c1tuXTtpZihlLmV4dHJhcyYmQXJyYXkuaXNBcnJheShlLmV4dHJhcy50YXJnZXROYW1lcykpe2NvbnN0IG49ZS5leHRyYXMudGFyZ2V0TmFtZXM7aWYodC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoPT09bi5sZW5ndGgpe3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5PXt9O2ZvcihsZXQgZT0wLGk9bi5sZW5ndGg7ZTxpO2UrKyl0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtuW2VdXT1lfWVsc2UgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBleHRyYXMudGFyZ2V0TmFtZXMgbGVuZ3RoLiBJZ25vcmluZyBuYW1lcy5cIil9fWZ1bmN0aW9uIHNoKHQpe2NvbnN0IGU9dC5leHRlbnNpb25zJiZ0LmV4dGVuc2lvbnNbbWMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dO2xldCBuO3JldHVybiBuPWU/XCJkcmFjbzpcIitlLmJ1ZmZlclZpZXcrXCI6XCIrZS5pbmRpY2VzK1wiOlwiK2FoKGUuYXR0cmlidXRlcyk6dC5pbmRpY2VzK1wiOlwiK2FoKHQuYXR0cmlidXRlcykrXCI6XCIrdC5tb2RlLG59ZnVuY3Rpb24gYWgodCl7bGV0IGU9XCJcIjtjb25zdCBuPU9iamVjdC5rZXlzKHQpLnNvcnQoKTtmb3IobGV0IGk9MCxyPW4ubGVuZ3RoO2k8cjtpKyspZSs9bltpXStcIjpcIit0W25baV1dK1wiO1wiO3JldHVybiBlfWZ1bmN0aW9uIG9oKHQpe3N3aXRjaCh0KXtjYXNlIEludDhBcnJheTpyZXR1cm4gMS8xMjc7Y2FzZSBVaW50OEFycmF5OnJldHVybiAxLzI1NTtjYXNlIEludDE2QXJyYXk6cmV0dXJuIDEvMzI3Njc7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gMS82NTUzNTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIG5vcm1hbGl6ZWQgYWNjZXNzb3IgY29tcG9uZW50IHR5cGUuXCIpfX1jbGFzcyBsaHtjb25zdHJ1Y3Rvcih0PXt9LGU9e30pe3RoaXMuanNvbj10LHRoaXMuZXh0ZW5zaW9ucz17fSx0aGlzLnBsdWdpbnM9e30sdGhpcy5vcHRpb25zPWUsdGhpcy5jYWNoZT1uZXcgcGMsdGhpcy5hc3NvY2lhdGlvbnM9bmV3IE1hcCx0aGlzLnByaW1pdGl2ZUNhY2hlPXt9LHRoaXMubWVzaENhY2hlPXtyZWZzOnt9LHVzZXM6e319LHRoaXMuY2FtZXJhQ2FjaGU9e3JlZnM6e30sdXNlczp7fX0sdGhpcy5saWdodENhY2hlPXtyZWZzOnt9LHVzZXM6e319LHRoaXMudGV4dHVyZUNhY2hlPXt9LHRoaXMubm9kZU5hbWVzVXNlZD17fSxcInVuZGVmaW5lZFwiIT10eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAmJiExPT09L0ZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk/dGhpcy50ZXh0dXJlTG9hZGVyPW5ldyBrbCh0aGlzLm9wdGlvbnMubWFuYWdlcik6dGhpcy50ZXh0dXJlTG9hZGVyPW5ldyBibCh0aGlzLm9wdGlvbnMubWFuYWdlciksdGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiksdGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIpLHRoaXMuZmlsZUxvYWRlcj1uZXcgZ2wodGhpcy5vcHRpb25zLm1hbmFnZXIpLHRoaXMuZmlsZUxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKSxcInVzZS1jcmVkZW50aWFsc1wiPT09dGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luJiZ0aGlzLmZpbGVMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCEwKX1zZXRFeHRlbnNpb25zKHQpe3RoaXMuZXh0ZW5zaW9ucz10fXNldFBsdWdpbnModCl7dGhpcy5wbHVnaW5zPXR9cGFyc2UodCxlKXtjb25zdCBuPXRoaXMsaT10aGlzLmpzb24scj10aGlzLmV4dGVuc2lvbnM7dGhpcy5jYWNoZS5yZW1vdmVBbGwoKSx0aGlzLl9pbnZva2VBbGwoKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9tYXJrRGVmcyYmdC5fbWFya0RlZnMoKX0pKSxQcm9taXNlLmFsbCh0aGlzLl9pbnZva2VBbGwoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmJlZm9yZVJvb3QmJnQuYmVmb3JlUm9vdCgpfSkpKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLmFsbChbbi5nZXREZXBlbmRlbmNpZXMoXCJzY2VuZVwiKSxuLmdldERlcGVuZGVuY2llcyhcImFuaW1hdGlvblwiKSxuLmdldERlcGVuZGVuY2llcyhcImNhbWVyYVwiKV0pfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe2NvbnN0IHM9e3NjZW5lOmVbMF1baS5zY2VuZXx8MF0sc2NlbmVzOmVbMF0sYW5pbWF0aW9uczplWzFdLGNhbWVyYXM6ZVsyXSxhc3NldDppLmFzc2V0LHBhcnNlcjpuLHVzZXJEYXRhOnt9fTtuaChyLHMsaSksaWgocyxpKSxQcm9taXNlLmFsbChuLl9pbnZva2VBbGwoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFmdGVyUm9vdCYmdC5hZnRlclJvb3Qocyl9KSkpLnRoZW4oKGZ1bmN0aW9uKCl7dChzKX0pKX0pKS5jYXRjaChlKX1fbWFya0RlZnMoKXtjb25zdCB0PXRoaXMuanNvbi5ub2Rlc3x8W10sZT10aGlzLmpzb24uc2tpbnN8fFtdLG49dGhpcy5qc29uLm1lc2hlc3x8W107Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXtjb25zdCBpPWVbbl0uam9pbnRzO2ZvcihsZXQgZT0wLG49aS5sZW5ndGg7ZTxuO2UrKyl0W2lbZV1dLmlzQm9uZT0hMH1mb3IobGV0IGU9MCxpPXQubGVuZ3RoO2U8aTtlKyspe2NvbnN0IGk9dFtlXTt2b2lkIDAhPT1pLm1lc2gmJih0aGlzLl9hZGROb2RlUmVmKHRoaXMubWVzaENhY2hlLGkubWVzaCksdm9pZCAwIT09aS5za2luJiYobltpLm1lc2hdLmlzU2tpbm5lZE1lc2g9ITApKSx2b2lkIDAhPT1pLmNhbWVyYSYmdGhpcy5fYWRkTm9kZVJlZih0aGlzLmNhbWVyYUNhY2hlLGkuY2FtZXJhKX19X2FkZE5vZGVSZWYodCxlKXt2b2lkIDAhPT1lJiYodm9pZCAwPT09dC5yZWZzW2VdJiYodC5yZWZzW2VdPXQudXNlc1tlXT0wKSx0LnJlZnNbZV0rKyl9X2dldE5vZGVSZWYodCxlLG4pe2lmKHQucmVmc1tlXTw9MSlyZXR1cm4gbjtjb25zdCBpPW4uY2xvbmUoKSxyPSh0LGUpPT57Y29uc3Qgbj10aGlzLmFzc29jaWF0aW9ucy5nZXQodCk7bnVsbCE9biYmdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGUsbik7Zm9yKGNvbnN0W24saV1vZiB0LmNoaWxkcmVuLmVudHJpZXMoKSlyKGksZS5jaGlsZHJlbltuXSl9O3JldHVybiByKG4saSksaS5uYW1lKz1cIl9pbnN0YW5jZV9cIit0LnVzZXNbZV0rKyxpfV9pbnZva2VPbmUodCl7Y29uc3QgZT1PYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7ZS5wdXNoKHRoaXMpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCBpPXQoZVtuXSk7aWYoaSlyZXR1cm4gaX1yZXR1cm4gbnVsbH1faW52b2tlQWxsKHQpe2NvbnN0IGU9T2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbnMpO2UudW5zaGlmdCh0aGlzKTtjb25zdCBuPVtdO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKXtjb25zdCByPXQoZVtpXSk7ciYmbi5wdXNoKHIpfXJldHVybiBufWdldERlcGVuZGVuY3kodCxlKXtjb25zdCBuPXQrXCI6XCIrZTtsZXQgaT10aGlzLmNhY2hlLmdldChuKTtpZighaSl7c3dpdGNoKHQpe2Nhc2VcInNjZW5lXCI6aT10aGlzLmxvYWRTY2VuZShlKTticmVhaztjYXNlXCJub2RlXCI6aT10aGlzLmxvYWROb2RlKGUpO2JyZWFrO2Nhc2VcIm1lc2hcIjppPXRoaXMuX2ludm9rZU9uZSgoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9hZE1lc2gmJnQubG9hZE1lc2goZSl9KSk7YnJlYWs7Y2FzZVwiYWNjZXNzb3JcIjppPXRoaXMubG9hZEFjY2Vzc29yKGUpO2JyZWFrO2Nhc2VcImJ1ZmZlclZpZXdcIjppPXRoaXMuX2ludm9rZU9uZSgoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9hZEJ1ZmZlclZpZXcmJnQubG9hZEJ1ZmZlclZpZXcoZSl9KSk7YnJlYWs7Y2FzZVwiYnVmZmVyXCI6aT10aGlzLmxvYWRCdWZmZXIoZSk7YnJlYWs7Y2FzZVwibWF0ZXJpYWxcIjppPXRoaXMuX2ludm9rZU9uZSgoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9hZE1hdGVyaWFsJiZ0LmxvYWRNYXRlcmlhbChlKX0pKTticmVhaztjYXNlXCJ0ZXh0dXJlXCI6aT10aGlzLl9pbnZva2VPbmUoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvYWRUZXh0dXJlJiZ0LmxvYWRUZXh0dXJlKGUpfSkpO2JyZWFrO2Nhc2VcInNraW5cIjppPXRoaXMubG9hZFNraW4oZSk7YnJlYWs7Y2FzZVwiYW5pbWF0aW9uXCI6aT10aGlzLmxvYWRBbmltYXRpb24oZSk7YnJlYWs7Y2FzZVwiY2FtZXJhXCI6aT10aGlzLmxvYWRDYW1lcmEoZSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiK3QpfXRoaXMuY2FjaGUuYWRkKG4saSl9cmV0dXJuIGl9Z2V0RGVwZW5kZW5jaWVzKHQpe2xldCBlPXRoaXMuY2FjaGUuZ2V0KHQpO2lmKCFlKXtjb25zdCBuPXRoaXMsaT10aGlzLmpzb25bdCsoXCJtZXNoXCI9PT10P1wiZXNcIjpcInNcIildfHxbXTtlPVByb21pc2UuYWxsKGkubWFwKChmdW5jdGlvbihlLGkpe3JldHVybiBuLmdldERlcGVuZGVuY3kodCxpKX0pKSksdGhpcy5jYWNoZS5hZGQodCxlKX1yZXR1cm4gZX1sb2FkQnVmZmVyKHQpe2NvbnN0IGU9dGhpcy5qc29uLmJ1ZmZlcnNbdF0sbj10aGlzLmZpbGVMb2FkZXI7aWYoZS50eXBlJiZcImFycmF5YnVmZmVyXCIhPT1lLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogXCIrZS50eXBlK1wiIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO2lmKHZvaWQgMD09PWUudXJpJiYwPT09dClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZXh0ZW5zaW9uc1ttYy5LSFJfQklOQVJZX0dMVEZdLmJvZHkpO2NvbnN0IGk9dGhpcy5vcHRpb25zO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxyKXtuLmxvYWQodGgoZS51cmksaS5wYXRoKSx0LHZvaWQgMCwoZnVuY3Rpb24oKXtyKG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJytlLnVyaSsnXCIuJykpfSkpfSkpfWxvYWRCdWZmZXJWaWV3KHQpe2NvbnN0IGU9dGhpcy5qc29uLmJ1ZmZlclZpZXdzW3RdO3JldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJcIixlLmJ1ZmZlcikudGhlbigoZnVuY3Rpb24odCl7Y29uc3Qgbj1lLmJ5dGVMZW5ndGh8fDAsaT1lLmJ5dGVPZmZzZXR8fDA7cmV0dXJuIHQuc2xpY2UoaSxpK24pfSkpfWxvYWRBY2Nlc3Nvcih0KXtjb25zdCBlPXRoaXMsbj10aGlzLmpzb24saT10aGlzLmpzb24uYWNjZXNzb3JzW3RdO2lmKHZvaWQgMD09PWkuYnVmZmVyVmlldyYmdm9pZCAwPT09aS5zcGFyc2UpcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtjb25zdCByPVtdO3JldHVybiB2b2lkIDAhPT1pLmJ1ZmZlclZpZXc/ci5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIixpLmJ1ZmZlclZpZXcpKTpyLnB1c2gobnVsbCksdm9pZCAwIT09aS5zcGFyc2UmJihyLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLGkuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldykpLHIucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsaS5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpKSksUHJvbWlzZS5hbGwocikudGhlbigoZnVuY3Rpb24odCl7Y29uc3Qgcj10WzBdLHM9WGNbaS50eXBlXSxhPVdjW2kuY29tcG9uZW50VHlwZV0sbz1hLkJZVEVTX1BFUl9FTEVNRU5ULGw9bypzLGM9aS5ieXRlT2Zmc2V0fHwwLGg9dm9pZCAwIT09aS5idWZmZXJWaWV3P24uYnVmZmVyVmlld3NbaS5idWZmZXJWaWV3XS5ieXRlU3RyaWRlOnZvaWQgMCx1PSEwPT09aS5ub3JtYWxpemVkO2xldCBkLHA7aWYoaCYmaCE9PWwpe2NvbnN0IHQ9TWF0aC5mbG9vcihjL2gpLG49XCJJbnRlcmxlYXZlZEJ1ZmZlcjpcIitpLmJ1ZmZlclZpZXcrXCI6XCIraS5jb21wb25lbnRUeXBlK1wiOlwiK3QrXCI6XCIraS5jb3VudDtsZXQgbD1lLmNhY2hlLmdldChuKTtsfHwoZD1uZXcgYShyLHQqaCxpLmNvdW50KmgvbyksbD1uZXcgWnMoZCxoL28pLGUuY2FjaGUuYWRkKG4sbCkpLHA9bmV3ICRzKGwscyxjJWgvbyx1KX1lbHNlIGQ9bnVsbD09PXI/bmV3IGEoaS5jb3VudCpzKTpuZXcgYShyLGMsaS5jb3VudCpzKSxwPW5ldyBwbihkLHMsdSk7aWYodm9pZCAwIT09aS5zcGFyc2Upe2NvbnN0IGU9WGMuU0NBTEFSLG49V2NbaS5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlXSxvPWkuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldHx8MCxsPWkuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0fHwwLGM9bmV3IG4odFsxXSxvLGkuc3BhcnNlLmNvdW50KmUpLGg9bmV3IGEodFsyXSxsLGkuc3BhcnNlLmNvdW50KnMpO251bGwhPT1yJiYocD1uZXcgcG4ocC5hcnJheS5zbGljZSgpLHAuaXRlbVNpemUscC5ub3JtYWxpemVkKSk7Zm9yKGxldCB0PTAsZT1jLmxlbmd0aDt0PGU7dCsrKXtjb25zdCBlPWNbdF07aWYocC5zZXRYKGUsaFt0KnNdKSxzPj0yJiZwLnNldFkoZSxoW3QqcysxXSkscz49MyYmcC5zZXRaKGUsaFt0KnMrMl0pLHM+PTQmJnAuc2V0VyhlLGhbdCpzKzNdKSxzPj01KXRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGl0ZW1TaXplIGluIHNwYXJzZSBCdWZmZXJBdHRyaWJ1dGUuXCIpfX1yZXR1cm4gcH0pKX1sb2FkVGV4dHVyZSh0KXtjb25zdCBlPXRoaXMuanNvbixuPXRoaXMub3B0aW9ucyxpPWUudGV4dHVyZXNbdF0scj1lLmltYWdlc1tpLnNvdXJjZV07bGV0IHM9dGhpcy50ZXh0dXJlTG9hZGVyO2lmKHIudXJpKXtjb25zdCB0PW4ubWFuYWdlci5nZXRIYW5kbGVyKHIudXJpKTtudWxsIT09dCYmKHM9dCl9cmV0dXJuIHRoaXMubG9hZFRleHR1cmVJbWFnZSh0LHIscyl9bG9hZFRleHR1cmVJbWFnZSh0LGUsbil7Y29uc3QgaT10aGlzLHI9dGhpcy5qc29uLHM9dGhpcy5vcHRpb25zLGE9ci50ZXh0dXJlc1t0XSxvPShlLnVyaXx8ZS5idWZmZXJWaWV3KStcIjpcIithLnNhbXBsZXI7aWYodGhpcy50ZXh0dXJlQ2FjaGVbb10pcmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW29dO2NvbnN0IGw9c2VsZi5VUkx8fHNlbGYud2Via2l0VVJMO2xldCBjPWUudXJpfHxcIlwiLGg9ITE7aWYodm9pZCAwIT09ZS5idWZmZXJWaWV3KWM9aS5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLGUuYnVmZmVyVmlldykudGhlbigoZnVuY3Rpb24odCl7aD0hMDtjb25zdCBuPW5ldyBCbG9iKFt0XSx7dHlwZTplLm1pbWVUeXBlfSk7cmV0dXJuIGM9bC5jcmVhdGVPYmplY3RVUkwobiksY30pKTtlbHNlIGlmKHZvaWQgMD09PWUudXJpKXRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEltYWdlIFwiK3QrXCIgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXdcIik7Y29uc3QgdT1Qcm9taXNlLnJlc29sdmUoYykudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlLGkpe2xldCByPWU7ITA9PT1uLmlzSW1hZ2VCaXRtYXBMb2FkZXImJihyPWZ1bmN0aW9uKHQpe2NvbnN0IG49bmV3IE50KHQpO24ubmVlZHNVcGRhdGU9ITAsZShuKX0pLG4ubG9hZCh0aCh0LHMucGF0aCkscix2b2lkIDAsaSl9KSl9KSkudGhlbigoZnVuY3Rpb24oZSl7ITA9PT1oJiZsLnJldm9rZU9iamVjdFVSTChjKSxlLmZsaXBZPSExLGEubmFtZSYmKGUubmFtZT1hLm5hbWUpO2NvbnN0IG49KHIuc2FtcGxlcnN8fHt9KVthLnNhbXBsZXJdfHx7fTtyZXR1cm4gZS5tYWdGaWx0ZXI9amNbbi5tYWdGaWx0ZXJdfHwxMDA2LGUubWluRmlsdGVyPWpjW24ubWluRmlsdGVyXXx8MTAwOCxlLndyYXBTPXFjW24ud3JhcFNdfHwxZTMsZS53cmFwVD1xY1tuLndyYXBUXXx8MWUzLGkuYXNzb2NpYXRpb25zLnNldChlLHt0ZXh0dXJlczp0fSksZX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IENvdWxkbid0IGxvYWQgdGV4dHVyZVwiLGMpLG51bGx9KSk7cmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW29dPXUsdX1hc3NpZ25UZXh0dXJlKHQsZSxuKXtjb25zdCBpPXRoaXM7cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcInRleHR1cmVcIixuLmluZGV4KS50aGVuKChmdW5jdGlvbihyKXtpZih2b2lkIDA9PT1uLnRleENvb3JkfHwwPT1uLnRleENvb3JkfHxcImFvTWFwXCI9PT1lJiYxPT1uLnRleENvb3JkfHxjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBDdXN0b20gVVYgc2V0IFwiK24udGV4Q29vcmQrXCIgZm9yIHRleHR1cmUgXCIrZStcIiBub3QgeWV0IHN1cHBvcnRlZC5cIiksaS5leHRlbnNpb25zW21jLktIUl9URVhUVVJFX1RSQU5TRk9STV0pe2NvbnN0IHQ9dm9pZCAwIT09bi5leHRlbnNpb25zP24uZXh0ZW5zaW9uc1ttYy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dOnZvaWQgMDtpZih0KXtjb25zdCBlPWkuYXNzb2NpYXRpb25zLmdldChyKTtyPWkuZXh0ZW5zaW9uc1ttYy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dLmV4dGVuZFRleHR1cmUocix0KSxpLmFzc29jaWF0aW9ucy5zZXQocixlKX19cmV0dXJuIHRbZV09cixyfSkpfWFzc2lnbkZpbmFsTWF0ZXJpYWwodCl7Y29uc3QgZT10Lmdlb21ldHJ5O2xldCBuPXQubWF0ZXJpYWw7Y29uc3QgaT12b2lkIDA9PT1lLmF0dHJpYnV0ZXMudGFuZ2VudCxyPXZvaWQgMCE9PWUuYXR0cmlidXRlcy5jb2xvcixzPXZvaWQgMD09PWUuYXR0cmlidXRlcy5ub3JtYWw7aWYodC5pc1BvaW50cyl7Y29uc3QgdD1cIlBvaW50c01hdGVyaWFsOlwiK24udXVpZDtsZXQgZT10aGlzLmNhY2hlLmdldCh0KTtlfHwoZT1uZXcgQmEsZW4ucHJvdG90eXBlLmNvcHkuY2FsbChlLG4pLGUuY29sb3IuY29weShuLmNvbG9yKSxlLm1hcD1uLm1hcCxlLnNpemVBdHRlbnVhdGlvbj0hMSx0aGlzLmNhY2hlLmFkZCh0LGUpKSxuPWV9ZWxzZSBpZih0LmlzTGluZSl7Y29uc3QgdD1cIkxpbmVCYXNpY01hdGVyaWFsOlwiK24udXVpZDtsZXQgZT10aGlzLmNhY2hlLmdldCh0KTtlfHwoZT1uZXcgUmEsZW4ucHJvdG90eXBlLmNvcHkuY2FsbChlLG4pLGUuY29sb3IuY29weShuLmNvbG9yKSx0aGlzLmNhY2hlLmFkZCh0LGUpKSxuPWV9aWYoaXx8cnx8cyl7bGV0IHQ9XCJDbG9uZWRNYXRlcmlhbDpcIituLnV1aWQrXCI6XCI7bi5pc0dMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCYmKHQrPVwic3BlY3VsYXItZ2xvc3NpbmVzczpcIiksaSYmKHQrPVwiZGVyaXZhdGl2ZS10YW5nZW50czpcIiksciYmKHQrPVwidmVydGV4LWNvbG9yczpcIikscyYmKHQrPVwiZmxhdC1zaGFkaW5nOlwiKTtsZXQgZT10aGlzLmNhY2hlLmdldCh0KTtlfHwoZT1uLmNsb25lKCksciYmKGUudmVydGV4Q29sb3JzPSEwKSxzJiYoZS5mbGF0U2hhZGluZz0hMCksaSYmKGUubm9ybWFsU2NhbGUmJihlLm5vcm1hbFNjYWxlLnkqPS0xKSxlLmNsZWFyY29hdE5vcm1hbFNjYWxlJiYoZS5jbGVhcmNvYXROb3JtYWxTY2FsZS55Kj0tMSkpLHRoaXMuY2FjaGUuYWRkKHQsZSksdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGUsdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG4pKSksbj1lfW4uYW9NYXAmJnZvaWQgMD09PWUuYXR0cmlidXRlcy51djImJnZvaWQgMCE9PWUuYXR0cmlidXRlcy51diYmZS5zZXRBdHRyaWJ1dGUoXCJ1djJcIixlLmF0dHJpYnV0ZXMudXYpLHQubWF0ZXJpYWw9bn1nZXRNYXRlcmlhbFR5cGUoKXtyZXR1cm4gWm99bG9hZE1hdGVyaWFsKHQpe2NvbnN0IGU9dGhpcyxuPXRoaXMuanNvbixpPXRoaXMuZXh0ZW5zaW9ucyxyPW4ubWF0ZXJpYWxzW3RdO2xldCBzO2NvbnN0IGE9e30sbz1yLmV4dGVuc2lvbnN8fHt9LGw9W107aWYob1ttYy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTXSl7Y29uc3QgdD1pW21jLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1NdO3M9dC5nZXRNYXRlcmlhbFR5cGUoKSxsLnB1c2godC5leHRlbmRQYXJhbXMoYSxyLGUpKX1lbHNlIGlmKG9bbWMuS0hSX01BVEVSSUFMU19VTkxJVF0pe2NvbnN0IHQ9aVttYy5LSFJfTUFURVJJQUxTX1VOTElUXTtzPXQuZ2V0TWF0ZXJpYWxUeXBlKCksbC5wdXNoKHQuZXh0ZW5kUGFyYW1zKGEscixlKSl9ZWxzZXtjb25zdCBuPXIucGJyTWV0YWxsaWNSb3VnaG5lc3N8fHt9O2lmKGEuY29sb3I9bmV3IGNuKDEsMSwxKSxhLm9wYWNpdHk9MSxBcnJheS5pc0FycmF5KG4uYmFzZUNvbG9yRmFjdG9yKSl7Y29uc3QgdD1uLmJhc2VDb2xvckZhY3RvcjthLmNvbG9yLmZyb21BcnJheSh0KSxhLm9wYWNpdHk9dFszXX12b2lkIDAhPT1uLmJhc2VDb2xvclRleHR1cmUmJmwucHVzaChlLmFzc2lnblRleHR1cmUoYSxcIm1hcFwiLG4uYmFzZUNvbG9yVGV4dHVyZSkpLGEubWV0YWxuZXNzPXZvaWQgMCE9PW4ubWV0YWxsaWNGYWN0b3I/bi5tZXRhbGxpY0ZhY3RvcjoxLGEucm91Z2huZXNzPXZvaWQgMCE9PW4ucm91Z2huZXNzRmFjdG9yP24ucm91Z2huZXNzRmFjdG9yOjEsdm9pZCAwIT09bi5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUmJihsLnB1c2goZS5hc3NpZ25UZXh0dXJlKGEsXCJtZXRhbG5lc3NNYXBcIixuLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpLGwucHVzaChlLmFzc2lnblRleHR1cmUoYSxcInJvdWdobmVzc01hcFwiLG4ubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSkpLHM9dGhpcy5faW52b2tlT25lKChmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRNYXRlcmlhbFR5cGUmJmUuZ2V0TWF0ZXJpYWxUeXBlKHQpfSkpLGwucHVzaChQcm9taXNlLmFsbCh0aGlzLl9pbnZva2VBbGwoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV4dGVuZE1hdGVyaWFsUGFyYW1zJiZlLmV4dGVuZE1hdGVyaWFsUGFyYW1zKHQsYSl9KSkpKX0hMD09PXIuZG91YmxlU2lkZWQmJihhLnNpZGU9Mik7Y29uc3QgYz1yLmFscGhhTW9kZXx8JGM7aWYoYz09PVFjPyhhLnRyYW5zcGFyZW50PSEwLGEuZGVwdGhXcml0ZT0hMSk6KGEuZm9ybWF0PTEwMjIsYS50cmFuc3BhcmVudD0hMSxjPT09S2MmJihhLmFscGhhVGVzdD12b2lkIDAhPT1yLmFscGhhQ3V0b2ZmP3IuYWxwaGFDdXRvZmY6LjUpKSx2b2lkIDAhPT1yLm5vcm1hbFRleHR1cmUmJnMhPT1obiYmKGwucHVzaChlLmFzc2lnblRleHR1cmUoYSxcIm5vcm1hbE1hcFwiLHIubm9ybWFsVGV4dHVyZSkpLGEubm9ybWFsU2NhbGU9bmV3IEF0KDEsMSksdm9pZCAwIT09ci5ub3JtYWxUZXh0dXJlLnNjYWxlKSl7Y29uc3QgdD1yLm5vcm1hbFRleHR1cmUuc2NhbGU7YS5ub3JtYWxTY2FsZS5zZXQodCx0KX1yZXR1cm4gdm9pZCAwIT09ci5vY2NsdXNpb25UZXh0dXJlJiZzIT09aG4mJihsLnB1c2goZS5hc3NpZ25UZXh0dXJlKGEsXCJhb01hcFwiLHIub2NjbHVzaW9uVGV4dHVyZSkpLHZvaWQgMCE9PXIub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCYmKGEuYW9NYXBJbnRlbnNpdHk9ci5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoKSksdm9pZCAwIT09ci5lbWlzc2l2ZUZhY3RvciYmcyE9PWhuJiYoYS5lbWlzc2l2ZT0obmV3IGNuKS5mcm9tQXJyYXkoci5lbWlzc2l2ZUZhY3RvcikpLHZvaWQgMCE9PXIuZW1pc3NpdmVUZXh0dXJlJiZzIT09aG4mJmwucHVzaChlLmFzc2lnblRleHR1cmUoYSxcImVtaXNzaXZlTWFwXCIsci5lbWlzc2l2ZVRleHR1cmUpKSxQcm9taXNlLmFsbChsKS50aGVuKChmdW5jdGlvbigpe2xldCBuO3JldHVybiBuPXM9PT1QYz9pW21jLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1NdLmNyZWF0ZU1hdGVyaWFsKGEpOm5ldyBzKGEpLHIubmFtZSYmKG4ubmFtZT1yLm5hbWUpLG4ubWFwJiYobi5tYXAuZW5jb2Rpbmc9MzAwMSksbi5lbWlzc2l2ZU1hcCYmKG4uZW1pc3NpdmVNYXAuZW5jb2Rpbmc9MzAwMSksaWgobixyKSxlLmFzc29jaWF0aW9ucy5zZXQobix7bWF0ZXJpYWxzOnR9KSxyLmV4dGVuc2lvbnMmJm5oKGksbixyKSxufSkpfWNyZWF0ZVVuaXF1ZU5hbWUodCl7Y29uc3QgZT0kbC5zYW5pdGl6ZU5vZGVOYW1lKHR8fFwiXCIpO2xldCBuPWU7Zm9yKGxldCB0PTE7dGhpcy5ub2RlTmFtZXNVc2VkW25dOysrdCluPWUrXCJfXCIrdDtyZXR1cm4gdGhpcy5ub2RlTmFtZXNVc2VkW25dPSEwLG59bG9hZEdlb21ldHJpZXModCl7Y29uc3QgZT10aGlzLG49dGhpcy5leHRlbnNpb25zLGk9dGhpcy5wcmltaXRpdmVDYWNoZTtmdW5jdGlvbiByKHQpe3JldHVybiBuW21jLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXS5kZWNvZGVQcmltaXRpdmUodCxlKS50aGVuKChmdW5jdGlvbihuKXtyZXR1cm4gaGgobix0LGUpfSkpfWNvbnN0IHM9W107Zm9yKGxldCBuPTAsYT10Lmxlbmd0aDtuPGE7bisrKXtjb25zdCBhPXRbbl0sbz1zaChhKSxsPWlbb107aWYobClzLnB1c2gobC5wcm9taXNlKTtlbHNle2xldCB0O3Q9YS5leHRlbnNpb25zJiZhLmV4dGVuc2lvbnNbbWMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dP3IoYSk6aGgobmV3IFNuLGEsZSksaVtvXT17cHJpbWl0aXZlOmEscHJvbWlzZTp0fSxzLnB1c2godCl9fXJldHVybiBQcm9taXNlLmFsbChzKX1sb2FkTWVzaCh0KXtjb25zdCBlPXRoaXMsbj10aGlzLmpzb24saT10aGlzLmV4dGVuc2lvbnMscj1uLm1lc2hlc1t0XSxzPXIucHJpbWl0aXZlcyxhPVtdO2ZvcihsZXQgdD0wLGU9cy5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT12b2lkIDA9PT1zW3RdLm1hdGVyaWFsP2VoKHRoaXMuY2FjaGUpOnRoaXMuZ2V0RGVwZW5kZW5jeShcIm1hdGVyaWFsXCIsc1t0XS5tYXRlcmlhbCk7YS5wdXNoKGUpfXJldHVybiBhLnB1c2goZS5sb2FkR2VvbWV0cmllcyhzKSksUHJvbWlzZS5hbGwoYSkudGhlbigoZnVuY3Rpb24obil7Y29uc3QgYT1uLnNsaWNlKDAsbi5sZW5ndGgtMSksbz1uW24ubGVuZ3RoLTFdLGw9W107Zm9yKGxldCBuPTAsYz1vLmxlbmd0aDtuPGM7bisrKXtjb25zdCBjPW9bbl0saD1zW25dO2xldCB1O2NvbnN0IGQ9YVtuXTtpZihoLm1vZGU9PT1IY3x8aC5tb2RlPT09VmN8fGgubW9kZT09PUdjfHx2b2lkIDA9PT1oLm1vZGUpdT0hMD09PXIuaXNTa2lubmVkTWVzaD9uZXcgeWEoYyxkKTpuZXcgVm4oYyxkKSwhMCE9PXUuaXNTa2lubmVkTWVzaHx8dS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQubm9ybWFsaXplZHx8dS5ub3JtYWxpemVTa2luV2VpZ2h0cygpLGgubW9kZT09PVZjP3UuZ2VvbWV0cnk9dWgodS5nZW9tZXRyeSwxKTpoLm1vZGU9PT1HYyYmKHUuZ2VvbWV0cnk9dWgodS5nZW9tZXRyeSwyKSk7ZWxzZSBpZihoLm1vZGU9PT1rYyl1PW5ldyBrYShjLGQpO2Vsc2UgaWYoaC5tb2RlPT09QmMpdT1uZXcgRmEoYyxkKTtlbHNlIGlmKGgubW9kZT09PXpjKXU9bmV3IHphKGMsZCk7ZWxzZXtpZihoLm1vZGUhPT1VYyl0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogXCIraC5tb2RlKTt1PW5ldyBqYShjLGQpfU9iamVjdC5rZXlzKHUuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKS5sZW5ndGg+MCYmcmgodSxyKSx1Lm5hbWU9ZS5jcmVhdGVVbmlxdWVOYW1lKHIubmFtZXx8XCJtZXNoX1wiK3QpLGloKHUsciksaC5leHRlbnNpb25zJiZuaChpLHUsaCksZS5hc3NpZ25GaW5hbE1hdGVyaWFsKHUpLGwucHVzaCh1KX1mb3IobGV0IG49MCxpPWwubGVuZ3RoO248aTtuKyspZS5hc3NvY2lhdGlvbnMuc2V0KGxbbl0se21lc2hlczp0LHByaW1pdGl2ZXM6bn0pO2lmKDE9PT1sLmxlbmd0aClyZXR1cm4gbFswXTtjb25zdCBjPW5ldyBWcztlLmFzc29jaWF0aW9ucy5zZXQoYyx7bWVzaGVzOnR9KTtmb3IobGV0IHQ9MCxlPWwubGVuZ3RoO3Q8ZTt0KyspYy5hZGQobFt0XSk7cmV0dXJuIGN9KSl9bG9hZENhbWVyYSh0KXtsZXQgZTtjb25zdCBuPXRoaXMuanNvbi5jYW1lcmFzW3RdLGk9bltuLnR5cGVdO2lmKGkpcmV0dXJuXCJwZXJzcGVjdGl2ZVwiPT09bi50eXBlP2U9bmV3IEpuKEV0LnJhZFRvRGVnKGkueWZvdiksaS5hc3BlY3RSYXRpb3x8MSxpLnpuZWFyfHwxLGkuemZhcnx8MmU2KTpcIm9ydGhvZ3JhcGhpY1wiPT09bi50eXBlJiYoZT1uZXcgeGkoLWkueG1hZyxpLnhtYWcsaS55bWFnLC1pLnltYWcsaS56bmVhcixpLnpmYXIpKSxuLm5hbWUmJihlLm5hbWU9dGhpcy5jcmVhdGVVbmlxdWVOYW1lKG4ubmFtZSkpLGloKGUsbiksUHJvbWlzZS5yZXNvbHZlKGUpO2NvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgY2FtZXJhIHBhcmFtZXRlcnMuXCIpfWxvYWRTa2luKHQpe2NvbnN0IGU9dGhpcy5qc29uLnNraW5zW3RdLG49e2pvaW50czplLmpvaW50c307cmV0dXJuIHZvaWQgMD09PWUuaW52ZXJzZUJpbmRNYXRyaWNlcz9Qcm9taXNlLnJlc29sdmUobik6dGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIixlLmludmVyc2VCaW5kTWF0cmljZXMpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBuLmludmVyc2VCaW5kTWF0cmljZXM9dCxufSkpfWxvYWRBbmltYXRpb24odCl7Y29uc3QgZT10aGlzLmpzb24uYW5pbWF0aW9uc1t0XSxuPVtdLGk9W10scj1bXSxzPVtdLGE9W107Zm9yKGxldCB0PTAsbz1lLmNoYW5uZWxzLmxlbmd0aDt0PG87dCsrKXtjb25zdCBvPWUuY2hhbm5lbHNbdF0sbD1lLnNhbXBsZXJzW28uc2FtcGxlcl0sYz1vLnRhcmdldCxoPXZvaWQgMCE9PWMubm9kZT9jLm5vZGU6Yy5pZCx1PXZvaWQgMCE9PWUucGFyYW1ldGVycz9lLnBhcmFtZXRlcnNbbC5pbnB1dF06bC5pbnB1dCxkPXZvaWQgMCE9PWUucGFyYW1ldGVycz9lLnBhcmFtZXRlcnNbbC5vdXRwdXRdOmwub3V0cHV0O24ucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJub2RlXCIsaCkpLGkucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLHUpKSxyLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIixkKSkscy5wdXNoKGwpLGEucHVzaChjKX1yZXR1cm4gUHJvbWlzZS5hbGwoW1Byb21pc2UuYWxsKG4pLFByb21pc2UuYWxsKGkpLFByb21pc2UuYWxsKHIpLFByb21pc2UuYWxsKHMpLFByb21pc2UuYWxsKGEpXSkudGhlbigoZnVuY3Rpb24obil7Y29uc3QgaT1uWzBdLHI9blsxXSxzPW5bMl0sYT1uWzNdLG89bls0XSxsPVtdO2ZvcihsZXQgdD0wLGU9aS5sZW5ndGg7dDxlO3QrKyl7Y29uc3QgZT1pW3RdLG49clt0XSxjPXNbdF0saD1hW3RdLHU9b1t0XTtpZih2b2lkIDA9PT1lKWNvbnRpbnVlO2xldCBkO3N3aXRjaChlLnVwZGF0ZU1hdHJpeCgpLGUubWF0cml4QXV0b1VwZGF0ZT0hMCxaY1t1LnBhdGhdKXtjYXNlIFpjLndlaWdodHM6ZD1zbDticmVhaztjYXNlIFpjLnJvdGF0aW9uOmQ9b2w7YnJlYWs7ZGVmYXVsdDpkPWNsfWNvbnN0IHA9ZS5uYW1lP2UubmFtZTplLnV1aWQsbT12b2lkIDAhPT1oLmludGVycG9sYXRpb24/SmNbaC5pbnRlcnBvbGF0aW9uXToyMzAxLGY9W107WmNbdS5wYXRoXT09PVpjLndlaWdodHM/ZS50cmF2ZXJzZSgoZnVuY3Rpb24odCl7ITA9PT10LmlzTWVzaCYmdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMmJmYucHVzaCh0Lm5hbWU/dC5uYW1lOnQudXVpZCl9KSk6Zi5wdXNoKHApO2xldCBnPWMuYXJyYXk7aWYoYy5ub3JtYWxpemVkKXtjb25zdCB0PW9oKGcuY29uc3RydWN0b3IpLGU9bmV3IEZsb2F0MzJBcnJheShnLmxlbmd0aCk7Zm9yKGxldCBuPTAsaT1nLmxlbmd0aDtuPGk7bisrKWVbbl09Z1tuXSp0O2c9ZX1mb3IobGV0IHQ9MCxlPWYubGVuZ3RoO3Q8ZTt0Kyspe2NvbnN0IGU9bmV3IGQoZlt0XStcIi5cIitaY1t1LnBhdGhdLG4uYXJyYXksZyxtKTtcIkNVQklDU1BMSU5FXCI9PT1oLmludGVycG9sYXRpb24mJihlLmNyZWF0ZUludGVycG9sYW50PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcodGhpcyBpbnN0YW5jZW9mIG9sP09jOk5jKSh0aGlzLnRpbWVzLHRoaXMudmFsdWVzLHRoaXMuZ2V0VmFsdWVTaXplKCkvMyx0KX0sZS5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZT0hMCksbC5wdXNoKGUpfX1jb25zdCBjPWUubmFtZT9lLm5hbWU6XCJhbmltYXRpb25fXCIrdDtyZXR1cm4gbmV3IGhsKGMsdm9pZCAwLGwpfSkpfWNyZWF0ZU5vZGVNZXNoKHQpe2NvbnN0IGU9dGhpcy5qc29uLG49dGhpcyxpPWUubm9kZXNbdF07cmV0dXJuIHZvaWQgMD09PWkubWVzaD9udWxsOm4uZ2V0RGVwZW5kZW5jeShcIm1lc2hcIixpLm1lc2gpLnRoZW4oKGZ1bmN0aW9uKHQpe2NvbnN0IGU9bi5fZ2V0Tm9kZVJlZihuLm1lc2hDYWNoZSxpLm1lc2gsdCk7cmV0dXJuIHZvaWQgMCE9PWkud2VpZ2h0cyYmZS50cmF2ZXJzZSgoZnVuY3Rpb24odCl7aWYodC5pc01lc2gpZm9yKGxldCBlPTAsbj1pLndlaWdodHMubGVuZ3RoO2U8bjtlKyspdC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZV09aS53ZWlnaHRzW2VdfSkpLGV9KSl9bG9hZE5vZGUodCl7Y29uc3QgZT10aGlzLmpzb24sbj10aGlzLmV4dGVuc2lvbnMsaT10aGlzLHI9ZS5ub2Rlc1t0XSxzPXIubmFtZT9pLmNyZWF0ZVVuaXF1ZU5hbWUoci5uYW1lKTpcIlwiO3JldHVybiBmdW5jdGlvbigpe2NvbnN0IGU9W10sbj1pLl9pbnZva2VPbmUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNyZWF0ZU5vZGVNZXNoJiZlLmNyZWF0ZU5vZGVNZXNoKHQpfSkpO3JldHVybiBuJiZlLnB1c2gobiksdm9pZCAwIT09ci5jYW1lcmEmJmUucHVzaChpLmdldERlcGVuZGVuY3koXCJjYW1lcmFcIixyLmNhbWVyYSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIGkuX2dldE5vZGVSZWYoaS5jYW1lcmFDYWNoZSxyLmNhbWVyYSx0KX0pKSksaS5faW52b2tlQWxsKChmdW5jdGlvbihlKXtyZXR1cm4gZS5jcmVhdGVOb2RlQXR0YWNobWVudCYmZS5jcmVhdGVOb2RlQXR0YWNobWVudCh0KX0pKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlLnB1c2godCl9KSksUHJvbWlzZS5hbGwoZSl9KCkudGhlbigoZnVuY3Rpb24oZSl7bGV0IGE7aWYoYT0hMD09PXIuaXNCb25lP25ldyB4YTplLmxlbmd0aD4xP25ldyBWczoxPT09ZS5sZW5ndGg/ZVswXTpuZXcgVmUsYSE9PWVbMF0pZm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0PG47dCsrKWEuYWRkKGVbdF0pO2lmKHIubmFtZSYmKGEudXNlckRhdGEubmFtZT1yLm5hbWUsYS5uYW1lPXMpLGloKGEsciksci5leHRlbnNpb25zJiZuaChuLGEsciksdm9pZCAwIT09ci5tYXRyaXgpe2NvbnN0IHQ9bmV3IHZlO3QuZnJvbUFycmF5KHIubWF0cml4KSxhLmFwcGx5TWF0cml4NCh0KX1lbHNlIHZvaWQgMCE9PXIudHJhbnNsYXRpb24mJmEucG9zaXRpb24uZnJvbUFycmF5KHIudHJhbnNsYXRpb24pLHZvaWQgMCE9PXIucm90YXRpb24mJmEucXVhdGVybmlvbi5mcm9tQXJyYXkoci5yb3RhdGlvbiksdm9pZCAwIT09ci5zY2FsZSYmYS5zY2FsZS5mcm9tQXJyYXkoci5zY2FsZSk7cmV0dXJuIGkuYXNzb2NpYXRpb25zLmhhcyhhKXx8aS5hc3NvY2lhdGlvbnMuc2V0KGEse30pLGkuYXNzb2NpYXRpb25zLmdldChhKS5ub2Rlcz10LGF9KSl9bG9hZFNjZW5lKHQpe2NvbnN0IGU9dGhpcy5qc29uLG49dGhpcy5leHRlbnNpb25zLGk9dGhpcy5qc29uLnNjZW5lc1t0XSxyPXRoaXMscz1uZXcgVnM7aS5uYW1lJiYocy5uYW1lPXIuY3JlYXRlVW5pcXVlTmFtZShpLm5hbWUpKSxpaChzLGkpLGkuZXh0ZW5zaW9ucyYmbmgobixzLGkpO2NvbnN0IGE9aS5ub2Rlc3x8W10sbz1bXTtmb3IobGV0IHQ9MCxuPWEubGVuZ3RoO3Q8bjt0Kyspby5wdXNoKGNoKGFbdF0scyxlLHIpKTtyZXR1cm4gUHJvbWlzZS5hbGwobykudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gci5hc3NvY2lhdGlvbnM9KHQ9Pntjb25zdCBlPW5ldyBNYXA7Zm9yKGNvbnN0W3Qsbl1vZiByLmFzc29jaWF0aW9ucykodCBpbnN0YW5jZW9mIGVufHx0IGluc3RhbmNlb2YgTnQpJiZlLnNldCh0LG4pO3JldHVybiB0LnRyYXZlcnNlKCh0PT57Y29uc3Qgbj1yLmFzc29jaWF0aW9ucy5nZXQodCk7bnVsbCE9biYmZS5zZXQodCxuKX0pKSxlfSkocyksc30pKX19ZnVuY3Rpb24gY2godCxlLG4saSl7Y29uc3Qgcj1uLm5vZGVzW3RdO3JldHVybiBpLmdldERlcGVuZGVuY3koXCJub2RlXCIsdCkudGhlbigoZnVuY3Rpb24odCl7aWYodm9pZCAwPT09ci5za2luKXJldHVybiB0O2xldCBlO3JldHVybiBpLmdldERlcGVuZGVuY3koXCJza2luXCIsci5za2luKS50aGVuKChmdW5jdGlvbih0KXtlPXQ7Y29uc3Qgbj1bXTtmb3IobGV0IHQ9MCxyPWUuam9pbnRzLmxlbmd0aDt0PHI7dCsrKW4ucHVzaChpLmdldERlcGVuZGVuY3koXCJub2RlXCIsZS5qb2ludHNbdF0pKTtyZXR1cm4gUHJvbWlzZS5hbGwobil9KSkudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIHQudHJhdmVyc2UoKGZ1bmN0aW9uKHQpe2lmKCF0LmlzTWVzaClyZXR1cm47Y29uc3QgaT1bXSxyPVtdO2ZvcihsZXQgdD0wLHM9bi5sZW5ndGg7dDxzO3QrKyl7Y29uc3Qgcz1uW3RdO2lmKHMpe2kucHVzaChzKTtjb25zdCBuPW5ldyB2ZTt2b2lkIDAhPT1lLmludmVyc2VCaW5kTWF0cmljZXMmJm4uZnJvbUFycmF5KGUuaW52ZXJzZUJpbmRNYXRyaWNlcy5hcnJheSwxNip0KSxyLnB1c2gobil9ZWxzZSBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IEpvaW50IFwiJXNcIiBjb3VsZCBub3QgYmUgZm91bmQuJyxlLmpvaW50c1t0XSl9dC5iaW5kKG5ldyBNYShpLHIpLHQubWF0cml4V29ybGQpfSkpLHR9KSl9KSkudGhlbigoZnVuY3Rpb24odCl7ZS5hZGQodCk7Y29uc3Qgcz1bXTtpZihyLmNoaWxkcmVuKXtjb25zdCBlPXIuY2hpbGRyZW47Zm9yKGxldCByPTAsYT1lLmxlbmd0aDtyPGE7cisrKXtjb25zdCBhPWVbcl07cy5wdXNoKGNoKGEsdCxuLGkpKX19cmV0dXJuIFByb21pc2UuYWxsKHMpfSkpfWZ1bmN0aW9uIGhoKHQsZSxuKXtjb25zdCBpPWUuYXR0cmlidXRlcyxyPVtdO2Z1bmN0aW9uIHMoZSxpKXtyZXR1cm4gbi5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIixlKS50aGVuKChmdW5jdGlvbihlKXt0LnNldEF0dHJpYnV0ZShpLGUpfSkpfWZvcihjb25zdCBlIGluIGkpe2NvbnN0IG49WWNbZV18fGUudG9Mb3dlckNhc2UoKTtuIGluIHQuYXR0cmlidXRlc3x8ci5wdXNoKHMoaVtlXSxuKSl9aWYodm9pZCAwIT09ZS5pbmRpY2VzJiYhdC5pbmRleCl7Y29uc3QgaT1uLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLGUuaW5kaWNlcykudGhlbigoZnVuY3Rpb24oZSl7dC5zZXRJbmRleChlKX0pKTtyLnB1c2goaSl9cmV0dXJuIGloKHQsZSksZnVuY3Rpb24odCxlLG4pe2NvbnN0IGk9ZS5hdHRyaWJ1dGVzLHI9bmV3IEd0O2lmKHZvaWQgMD09PWkuUE9TSVRJT04pcmV0dXJuO3tjb25zdCB0PW4uanNvbi5hY2Nlc3NvcnNbaS5QT1NJVElPTl0sZT10Lm1pbixzPXQubWF4O2lmKHZvaWQgMD09PWV8fHZvaWQgMD09PXMpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtpZihyLnNldChuZXcgQnQoZVswXSxlWzFdLGVbMl0pLG5ldyBCdChzWzBdLHNbMV0sc1syXSkpLHQubm9ybWFsaXplZCl7Y29uc3QgZT1vaChXY1t0LmNvbXBvbmVudFR5cGVdKTtyLm1pbi5tdWx0aXBseVNjYWxhcihlKSxyLm1heC5tdWx0aXBseVNjYWxhcihlKX19Y29uc3Qgcz1lLnRhcmdldHM7aWYodm9pZCAwIT09cyl7Y29uc3QgdD1uZXcgQnQsZT1uZXcgQnQ7Zm9yKGxldCBpPTAscj1zLmxlbmd0aDtpPHI7aSsrKXtjb25zdCByPXNbaV07aWYodm9pZCAwIT09ci5QT1NJVElPTil7Y29uc3QgaT1uLmpzb24uYWNjZXNzb3JzW3IuUE9TSVRJT05dLHM9aS5taW4sYT1pLm1heDtpZih2b2lkIDAhPT1zJiZ2b2lkIDAhPT1hKXtpZihlLnNldFgoTWF0aC5tYXgoTWF0aC5hYnMoc1swXSksTWF0aC5hYnMoYVswXSkpKSxlLnNldFkoTWF0aC5tYXgoTWF0aC5hYnMoc1sxXSksTWF0aC5hYnMoYVsxXSkpKSxlLnNldFooTWF0aC5tYXgoTWF0aC5hYnMoc1syXSksTWF0aC5hYnMoYVsyXSkpKSxpLm5vcm1hbGl6ZWQpe2NvbnN0IHQ9b2goV2NbaS5jb21wb25lbnRUeXBlXSk7ZS5tdWx0aXBseVNjYWxhcih0KX10Lm1heChlKX1lbHNlIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIil9fXIuZXhwYW5kQnlWZWN0b3IodCl9dC5ib3VuZGluZ0JveD1yO2NvbnN0IGE9bmV3IGxlO3IuZ2V0Q2VudGVyKGEuY2VudGVyKSxhLnJhZGl1cz1yLm1pbi5kaXN0YW5jZVRvKHIubWF4KS8yLHQuYm91bmRpbmdTcGhlcmU9YX0odCxlLG4pLFByb21pc2UuYWxsKHIpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PWUudGFyZ2V0cz9mdW5jdGlvbih0LGUsbil7bGV0IGk9ITEscj0hMTtmb3IobGV0IHQ9MCxuPWUubGVuZ3RoO3Q8bjt0Kyspe2NvbnN0IG49ZVt0XTtpZih2b2lkIDAhPT1uLlBPU0lUSU9OJiYoaT0hMCksdm9pZCAwIT09bi5OT1JNQUwmJihyPSEwKSxpJiZyKWJyZWFrfWlmKCFpJiYhcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHQpO2NvbnN0IHM9W10sYT1bXTtmb3IobGV0IG89MCxsPWUubGVuZ3RoO288bDtvKyspe2NvbnN0IGw9ZVtvXTtpZihpKXtjb25zdCBlPXZvaWQgMCE9PWwuUE9TSVRJT04/bi5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIixsLlBPU0lUSU9OKTp0LmF0dHJpYnV0ZXMucG9zaXRpb247cy5wdXNoKGUpfWlmKHIpe2NvbnN0IGU9dm9pZCAwIT09bC5OT1JNQUw/bi5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIixsLk5PUk1BTCk6dC5hdHRyaWJ1dGVzLm5vcm1hbDthLnB1c2goZSl9fXJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwocyksUHJvbWlzZS5hbGwoYSldKS50aGVuKChmdW5jdGlvbihlKXtjb25zdCBuPWVbMF0scz1lWzFdO3JldHVybiBpJiYodC5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb249biksciYmKHQubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbD1zKSx0Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSEwLHR9KSl9KHQsZS50YXJnZXRzLG4pOnR9KSl9ZnVuY3Rpb24gdWgodCxlKXtsZXQgbj10LmdldEluZGV4KCk7aWYobnVsbD09PW4pe2NvbnN0IGU9W10saT10LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO2lmKHZvaWQgMD09PWkpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuXCIpLHQ7Zm9yKGxldCB0PTA7dDxpLmNvdW50O3QrKyllLnB1c2godCk7dC5zZXRJbmRleChlKSxuPXQuZ2V0SW5kZXgoKX1jb25zdCBpPW4uY291bnQtMixyPVtdO2lmKDI9PT1lKWZvcihsZXQgdD0xO3Q8PWk7dCsrKXIucHVzaChuLmdldFgoMCkpLHIucHVzaChuLmdldFgodCkpLHIucHVzaChuLmdldFgodCsxKSk7ZWxzZSBmb3IobGV0IHQ9MDt0PGk7dCsrKXQlMj09MD8oci5wdXNoKG4uZ2V0WCh0KSksci5wdXNoKG4uZ2V0WCh0KzEpKSxyLnB1c2gobi5nZXRYKHQrMikpKTooci5wdXNoKG4uZ2V0WCh0KzIpKSxyLnB1c2gobi5nZXRYKHQrMSkpLHIucHVzaChuLmdldFgodCkpKTtyLmxlbmd0aC8zIT09aSYmY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXIudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLlwiKTtjb25zdCBzPXQuY2xvbmUoKTtyZXR1cm4gcy5zZXRJbmRleChyKSxzfWNsYXNzIGRoe2NvbnN0cnVjdG9yKHQ9NCl7dGhpcy5wb29sPXQsdGhpcy5xdWV1ZT1bXSx0aGlzLndvcmtlcnM9W10sdGhpcy53b3JrZXJzUmVzb2x2ZT1bXSx0aGlzLndvcmtlclN0YXR1cz0wfV9pbml0V29ya2VyKHQpe2lmKCF0aGlzLndvcmtlcnNbdF0pe2NvbnN0IGU9dGhpcy53b3JrZXJDcmVhdG9yKCk7ZS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMsdCkpLHRoaXMud29ya2Vyc1t0XT1lfX1fZ2V0SWRsZVdvcmtlcigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5wb29sO3QrKylpZighKHRoaXMud29ya2VyU3RhdHVzJjE8PHQpKXJldHVybiB0O3JldHVybi0xfV9vbk1lc3NhZ2UodCxlKXtjb25zdCBuPXRoaXMud29ya2Vyc1Jlc29sdmVbdF07aWYobiYmbihlKSx0aGlzLnF1ZXVlLmxlbmd0aCl7Y29uc3R7cmVzb2x2ZTplLG1zZzpuLHRyYW5zZmVyOml9PXRoaXMucXVldWUuc2hpZnQoKTt0aGlzLndvcmtlcnNSZXNvbHZlW3RdPWUsdGhpcy53b3JrZXJzW3RdLnBvc3RNZXNzYWdlKG4saSl9ZWxzZSB0aGlzLndvcmtlclN0YXR1c149MTw8dH1zZXRXb3JrZXJDcmVhdG9yKHQpe3RoaXMud29ya2VyQ3JlYXRvcj10fXNldFdvcmtlckxpbWl0KHQpe3RoaXMucG9vbD10fXBvc3RNZXNzYWdlKHQsZSl7cmV0dXJuIG5ldyBQcm9taXNlKChuPT57Y29uc3QgaT10aGlzLl9nZXRJZGxlV29ya2VyKCk7LTEhPT1pPyh0aGlzLl9pbml0V29ya2VyKGkpLHRoaXMud29ya2VyU3RhdHVzfD0xPDxpLHRoaXMud29ya2Vyc1Jlc29sdmVbaV09bix0aGlzLndvcmtlcnNbaV0ucG9zdE1lc3NhZ2UodCxlKSk6dGhpcy5xdWV1ZS5wdXNoKHtyZXNvbHZlOm4sbXNnOnQsdHJhbnNmZXI6ZX0pfSkpfWRpc3Bvc2UoKXt0aGlzLndvcmtlcnMuZm9yRWFjaCgodD0+dC50ZXJtaW5hdGUoKSkpLHRoaXMud29ya2Vyc1Jlc29sdmUubGVuZ3RoPTAsdGhpcy53b3JrZXJzLmxlbmd0aD0wLHRoaXMucXVldWUubGVuZ3RoPTAsdGhpcy53b3JrZXJTdGF0dXM9MH19Y29uc3QgcGg9bmV3IFdlYWtNYXA7Y2xhc3MgbWggZXh0ZW5kcyBtbHtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLnRyYW5zY29kZXJQYXRoPVwiXCIsdGhpcy50cmFuc2NvZGVyQmluYXJ5PW51bGwsdGhpcy50cmFuc2NvZGVyUGVuZGluZz1udWxsLHRoaXMud29ya2VyUG9vbD1uZXcgZGgsdGhpcy53b3JrZXJTb3VyY2VVUkw9XCJcIix0aGlzLndvcmtlckNvbmZpZz1udWxsLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNU0NfVFJBTlNDT0RFUiYmY29uc29sZS53YXJuKCdUSFJFRS5LVFgyTG9hZGVyOiBQbGVhc2UgdXBkYXRlIHRvIGxhdGVzdCBcImJhc2lzX3RyYW5zY29kZXJcIi4gXCJtc2NfYmFzaXNfdHJhbnNjb2RlclwiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gdGhyZWUuanMgcjEyNSsuJyl9c2V0VHJhbnNjb2RlclBhdGgodCl7cmV0dXJuIHRoaXMudHJhbnNjb2RlclBhdGg9dCx0aGlzfXNldFdvcmtlckxpbWl0KHQpe3JldHVybiB0aGlzLndvcmtlclBvb2wuc2V0V29ya2VyTGltaXQodCksdGhpc31kZXRlY3RTdXBwb3J0KHQpe3JldHVybiB0aGlzLndvcmtlckNvbmZpZz17YXN0Y1N1cHBvcnRlZDp0LmV4dGVuc2lvbnMuaGFzKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGNcIiksZXRjMVN1cHBvcnRlZDp0LmV4dGVuc2lvbnMuaGFzKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcIiksZXRjMlN1cHBvcnRlZDp0LmV4dGVuc2lvbnMuaGFzKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1wiKSxkeHRTdXBwb3J0ZWQ6dC5leHRlbnNpb25zLmhhcyhcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpLGJwdGNTdXBwb3J0ZWQ6dC5leHRlbnNpb25zLmhhcyhcIkVYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGNcIikscHZydGNTdXBwb3J0ZWQ6dC5leHRlbnNpb25zLmhhcyhcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKXx8dC5leHRlbnNpb25zLmhhcyhcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIil9LHRoaXN9ZGlzcG9zZSgpe3JldHVybiB0aGlzLndvcmtlclBvb2wuZGlzcG9zZSgpLHRoaXMud29ya2VyU291cmNlVVJMJiZVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMud29ya2VyU291cmNlVVJMKSx0aGlzfWluaXQoKXtpZighdGhpcy50cmFuc2NvZGVyUGVuZGluZyl7Y29uc3QgdD1uZXcgZ2wodGhpcy5tYW5hZ2VyKTt0LnNldFBhdGgodGhpcy50cmFuc2NvZGVyUGF0aCksdC5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO2NvbnN0IGU9dC5sb2FkQXN5bmMoXCJiYXNpc190cmFuc2NvZGVyLmpzXCIpLG49bmV3IGdsKHRoaXMubWFuYWdlcik7bi5zZXRQYXRoKHRoaXMudHJhbnNjb2RlclBhdGgpLG4uc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIiksbi5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO2NvbnN0IGk9bi5sb2FkQXN5bmMoXCJiYXNpc190cmFuc2NvZGVyLndhc21cIik7dGhpcy50cmFuc2NvZGVyUGVuZGluZz1Qcm9taXNlLmFsbChbZSxpXSkudGhlbigoKFt0LGVdKT0+e2NvbnN0IG49bWguQmFzaXNXb3JrZXIudG9TdHJpbmcoKSxpPVtcIi8qIGNvbnN0YW50cyAqL1wiLFwibGV0IF9FbmdpbmVGb3JtYXQgPSBcIitKU09OLnN0cmluZ2lmeShtaC5FbmdpbmVGb3JtYXQpLFwibGV0IF9UcmFuc2NvZGVyRm9ybWF0ID0gXCIrSlNPTi5zdHJpbmdpZnkobWguVHJhbnNjb2RlckZvcm1hdCksXCJsZXQgX0Jhc2lzRm9ybWF0ID0gXCIrSlNPTi5zdHJpbmdpZnkobWguQmFzaXNGb3JtYXQpLFwiLyogYmFzaXNfdHJhbnNjb2Rlci5qcyAqL1wiLHQsXCIvKiB3b3JrZXIgKi9cIixuLnN1YnN0cmluZyhuLmluZGV4T2YoXCJ7XCIpKzEsbi5sYXN0SW5kZXhPZihcIn1cIikpXS5qb2luKFwiXFxuXCIpO3RoaXMud29ya2VyU291cmNlVVJMPVVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2ldKSksdGhpcy50cmFuc2NvZGVyQmluYXJ5PWUsdGhpcy53b3JrZXJQb29sLnNldFdvcmtlckNyZWF0b3IoKCgpPT57Y29uc3QgdD1uZXcgV29ya2VyKHRoaXMud29ya2VyU291cmNlVVJMKSxlPXRoaXMudHJhbnNjb2RlckJpbmFyeS5zbGljZSgwKTtyZXR1cm4gdC5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXRcIixjb25maWc6dGhpcy53b3JrZXJDb25maWcsdHJhbnNjb2RlckJpbmFyeTplfSxbZV0pLHR9KSl9KSl9cmV0dXJuIHRoaXMudHJhbnNjb2RlclBlbmRpbmd9bG9hZCh0LGUsbixpKXtpZihudWxsPT09dGhpcy53b3JrZXJDb25maWcpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuS1RYMkxvYWRlcjogTWlzc2luZyBpbml0aWFsaXphdGlvbiB3aXRoIGAuZGV0ZWN0U3VwcG9ydCggcmVuZGVyZXIgKWAuXCIpO2NvbnN0IHI9bmV3IGdsKHRoaXMubWFuYWdlcik7ci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKSxyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7Y29uc3Qgcz1uZXcgWGE7cmV0dXJuIHIubG9hZCh0LCh0PT57aWYocGguaGFzKHQpKXtyZXR1cm4gcGguZ2V0KHQpLnByb21pc2UudGhlbihlKS5jYXRjaChpKX10aGlzLl9jcmVhdGVUZXh0dXJlKFt0XSkudGhlbigoZnVuY3Rpb24odCl7cy5jb3B5KHQpLHMubmVlZHNVcGRhdGU9ITAsZSYmZShzKX0pKS5jYXRjaChpKX0pLG4saSksc31fY3JlYXRlVGV4dHVyZUZyb20odCl7Y29uc3R7bWlwbWFwczplLHdpZHRoOm4saGVpZ2h0OmksZm9ybWF0OnIsdHlwZTpzLGVycm9yOmEsZGZkVHJhbnNmZXJGbjpvLGRmZEZsYWdzOmx9PXQ7aWYoXCJlcnJvclwiPT09cylyZXR1cm4gUHJvbWlzZS5yZWplY3QoYSk7Y29uc3QgYz1uZXcgWGEoZSxuLGksciwxMDA5KTtyZXR1cm4gYy5taW5GaWx0ZXI9MT09PWUubGVuZ3RoPzEwMDY6MTAwOCxjLm1hZ0ZpbHRlcj0xMDA2LGMuZ2VuZXJhdGVNaXBtYXBzPSExLGMubmVlZHNVcGRhdGU9ITAsYy5lbmNvZGluZz0yPT09bz8zMDAxOjNlMyxjLnByZW11bHRpcGx5QWxwaGE9ISEoMSZsKSxjfV9jcmVhdGVUZXh0dXJlKHQsZT17fSl7Y29uc3Qgbj1lLGk9dGhpcy5pbml0KCkudGhlbigoKCk9PnRoaXMud29ya2VyUG9vbC5wb3N0TWVzc2FnZSh7dHlwZTpcInRyYW5zY29kZVwiLGJ1ZmZlcnM6dCx0YXNrQ29uZmlnOm59LHQpKSkudGhlbigodD0+dGhpcy5fY3JlYXRlVGV4dHVyZUZyb20odC5kYXRhKSkpO3JldHVybiBwaC5zZXQodFswXSx7cHJvbWlzZTppfSksaX1kaXNwb3NlKCl7cmV0dXJuIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53b3JrZXJTb3VyY2VVUkwpLHRoaXMud29ya2VyUG9vbC5kaXNwb3NlKCksdGhpc319XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgZmgsZ2g7bWguQmFzaXNGb3JtYXQ9e0VUQzFTOjAsVUFTVENfNHg0OjF9LG1oLlRyYW5zY29kZXJGb3JtYXQ9e0VUQzE6MCxFVEMyOjEsQkMxOjIsQkMzOjMsQkM0OjQsQkM1OjUsQkM3X002X09QQVFVRV9PTkxZOjYsQkM3X001OjcsUFZSVEMxXzRfUkdCOjgsUFZSVEMxXzRfUkdCQTo5LEFTVENfNHg0OjEwLEFUQ19SR0I6MTEsQVRDX1JHQkFfSU5URVJQT0xBVEVEX0FMUEhBOjEyLFJHQkEzMjoxMyxSR0I1NjU6MTQsQkdSNTY1OjE1LFJHQkE0NDQ0OjE2fSxtaC5FbmdpbmVGb3JtYXQ9e1JHQkFGb3JtYXQ6MTAyMyxSR0JBX0FTVENfNHg0X0Zvcm1hdDozNzgwOCxSR0JBX0JQVENfRm9ybWF0OjM2NDkyLFJHQkFfRVRDMl9FQUNfRm9ybWF0OjM3NDk2LFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdDozNTg0MixSR0JBX1MzVENfRFhUNV9Gb3JtYXQ6MzM3NzksUkdCX0VUQzFfRm9ybWF0OjM2MTk2LFJHQl9FVEMyX0Zvcm1hdDozNzQ5MixSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdDozNTg0MCxSR0JfUzNUQ19EWFQxX0Zvcm1hdDozMzc3Nn0sbWguQmFzaXNXb3JrZXI9ZnVuY3Rpb24oKXtsZXQgdCxlLG47Y29uc3QgaT1fRW5naW5lRm9ybWF0LHI9X1RyYW5zY29kZXJGb3JtYXQscz1fQmFzaXNGb3JtYXQ7c2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChmdW5jdGlvbihhKXtjb25zdCBoPWEuZGF0YTtzd2l0Y2goaC50eXBlKXtjYXNlXCJpbml0XCI6dD1oLmNvbmZpZyx1PWgudHJhbnNjb2RlckJpbmFyeSxlPW5ldyBQcm9taXNlKCh0PT57bj17d2FzbUJpbmFyeTp1LG9uUnVudGltZUluaXRpYWxpemVkOnR9LEJBU0lTKG4pfSkpLnRoZW4oKCgpPT57bi5pbml0aWFsaXplQmFzaXMoKSx2b2lkIDA9PT1uLktUWDJGaWxlJiZjb25zb2xlLndhcm4oXCJUSFJFRS5LVFgyTG9hZGVyOiBQbGVhc2UgdXBkYXRlIEJhc2lzIFVuaXZlcnNhbCB0cmFuc2NvZGVyLlwiKX0pKTticmVhaztjYXNlXCJ0cmFuc2NvZGVcIjplLnRoZW4oKCgpPT57dHJ5e2NvbnN0e3dpZHRoOmUsaGVpZ2h0OmEsaGFzQWxwaGE6dSxtaXBtYXBzOmQsZm9ybWF0OnAsZGZkVHJhbnNmZXJGbjptLGRmZEZsYWdzOmZ9PWZ1bmN0aW9uKGUpe2NvbnN0IGE9bmV3IG4uS1RYMkZpbGUobmV3IFVpbnQ4QXJyYXkoZSkpO2Z1bmN0aW9uIGgoKXthLmNsb3NlKCksYS5kZWxldGUoKX1pZighYS5pc1ZhbGlkKCkpdGhyb3cgaCgpLG5ldyBFcnJvcihcIlRIUkVFLktUWDJMb2FkZXI6XFx0SW52YWxpZCBvciB1bnN1cHBvcnRlZCAua3R4MiBmaWxlXCIpO2NvbnN0IHU9YS5pc1VBU1RDKCk/cy5VQVNUQ180eDQ6cy5FVEMxUyxkPWEuZ2V0V2lkdGgoKSxwPWEuZ2V0SGVpZ2h0KCksbT1hLmdldExldmVscygpLGY9YS5nZXRIYXNBbHBoYSgpLGc9YS5nZXRERkRUcmFuc2ZlckZ1bmMoKSx2PWEuZ2V0REZERmxhZ3MoKSx7dHJhbnNjb2RlckZvcm1hdDp5LGVuZ2luZUZvcm1hdDp4fT1mdW5jdGlvbihlLG4sYSxoKXtsZXQgdSxkO2NvbnN0IHA9ZT09PXMuRVRDMVM/bzpsO2ZvcihsZXQgaT0wO2k8cC5sZW5ndGg7aSsrKXtjb25zdCByPXBbaV07aWYodFtyLmlmXSYmKHIuYmFzaXNGb3JtYXQuaW5jbHVkZXMoZSkmJighci5uZWVkc1Bvd2VyT2ZUd298fGMobikmJmMoYSkpKSlyZXR1cm4gdT1yLnRyYW5zY29kZXJGb3JtYXRbaD8xOjBdLGQ9ci5lbmdpbmVGb3JtYXRbaD8xOjBdLHt0cmFuc2NvZGVyRm9ybWF0OnUsZW5naW5lRm9ybWF0OmR9fXJldHVybiBjb25zb2xlLndhcm4oXCJUSFJFRS5LVFgyTG9hZGVyOiBObyBzdWl0YWJsZSBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGZvdW5kLiBEZWNvZGluZyB0byBSR0JBMzIuXCIpLHU9ci5SR0JBMzIsZD1pLlJHQkFGb3JtYXQse3RyYW5zY29kZXJGb3JtYXQ6dSxlbmdpbmVGb3JtYXQ6ZH19KHUsZCxwLGYpO2lmKCFkfHwhcHx8IW0pdGhyb3cgaCgpLG5ldyBFcnJvcihcIlRIUkVFLktUWDJMb2FkZXI6XFx0SW52YWxpZCB0ZXh0dXJlXCIpO2lmKCFhLnN0YXJ0VHJhbnNjb2RpbmcoKSl0aHJvdyBoKCksbmV3IEVycm9yKFwiVEhSRUUuS1RYMkxvYWRlcjogLnN0YXJ0VHJhbnNjb2RpbmcgZmFpbGVkXCIpO2NvbnN0IGI9W107Zm9yKGxldCB0PTA7dDxtO3QrKyl7Y29uc3QgZT1hLmdldEltYWdlTGV2ZWxJbmZvKHQsMCwwKSxuPWUub3JpZ1dpZHRoLGk9ZS5vcmlnSGVpZ2h0LHI9bmV3IFVpbnQ4QXJyYXkoYS5nZXRJbWFnZVRyYW5zY29kZWRTaXplSW5CeXRlcyh0LDAsMCx5KSk7aWYoIWEudHJhbnNjb2RlSW1hZ2Uocix0LDAsMCx5LDAsLTEsLTEpKXRocm93IGgoKSxuZXcgRXJyb3IoXCJUSFJFRS5LVFgyTG9hZGVyOiAudHJhbnNjb2RlSW1hZ2UgZmFpbGVkLlwiKTtiLnB1c2goe2RhdGE6cix3aWR0aDpuLGhlaWdodDppfSl9cmV0dXJuIGgoKSx7d2lkdGg6ZCxoZWlnaHQ6cCxoYXNBbHBoYTpmLG1pcG1hcHM6Yixmb3JtYXQ6eCxkZmRUcmFuc2ZlckZuOmcsZGZkRmxhZ3M6dn19KGguYnVmZmVyc1swXSksZz1bXTtmb3IobGV0IHQ9MDt0PGQubGVuZ3RoOysrdClnLnB1c2goZFt0XS5kYXRhLmJ1ZmZlcik7c2VsZi5wb3N0TWVzc2FnZSh7dHlwZTpcInRyYW5zY29kZVwiLGlkOmguaWQsd2lkdGg6ZSxoZWlnaHQ6YSxoYXNBbHBoYTp1LG1pcG1hcHM6ZCxmb3JtYXQ6cCxkZmRUcmFuc2ZlckZuOm0sZGZkRmxhZ3M6Zn0sZyl9Y2F0Y2godCl7Y29uc29sZS5lcnJvcih0KSxzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOlwiZXJyb3JcIixpZDpoLmlkLGVycm9yOnQubWVzc2FnZX0pfX0pKX12YXIgdX0pKTtjb25zdCBhPVt7aWY6XCJhc3RjU3VwcG9ydGVkXCIsYmFzaXNGb3JtYXQ6W3MuVUFTVENfNHg0XSx0cmFuc2NvZGVyRm9ybWF0OltyLkFTVENfNHg0LHIuQVNUQ180eDRdLGVuZ2luZUZvcm1hdDpbaS5SR0JBX0FTVENfNHg0X0Zvcm1hdCxpLlJHQkFfQVNUQ180eDRfRm9ybWF0XSxwcmlvcml0eUVUQzFTOjEvMCxwcmlvcml0eVVBU1RDOjEsbmVlZHNQb3dlck9mVHdvOiExfSx7aWY6XCJicHRjU3VwcG9ydGVkXCIsYmFzaXNGb3JtYXQ6W3MuRVRDMVMscy5VQVNUQ180eDRdLHRyYW5zY29kZXJGb3JtYXQ6W3IuQkM3X001LHIuQkM3X001XSxlbmdpbmVGb3JtYXQ6W2kuUkdCQV9CUFRDX0Zvcm1hdCxpLlJHQkFfQlBUQ19Gb3JtYXRdLHByaW9yaXR5RVRDMVM6Myxwcmlvcml0eVVBU1RDOjIsbmVlZHNQb3dlck9mVHdvOiExfSx7aWY6XCJkeHRTdXBwb3J0ZWRcIixiYXNpc0Zvcm1hdDpbcy5FVEMxUyxzLlVBU1RDXzR4NF0sdHJhbnNjb2RlckZvcm1hdDpbci5CQzEsci5CQzNdLGVuZ2luZUZvcm1hdDpbaS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCxpLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdF0scHJpb3JpdHlFVEMxUzo0LHByaW9yaXR5VUFTVEM6NSxuZWVkc1Bvd2VyT2ZUd286ITF9LHtpZjpcImV0YzJTdXBwb3J0ZWRcIixiYXNpc0Zvcm1hdDpbcy5FVEMxUyxzLlVBU1RDXzR4NF0sdHJhbnNjb2RlckZvcm1hdDpbci5FVEMxLHIuRVRDMl0sZW5naW5lRm9ybWF0OltpLlJHQl9FVEMyX0Zvcm1hdCxpLlJHQkFfRVRDMl9FQUNfRm9ybWF0XSxwcmlvcml0eUVUQzFTOjEscHJpb3JpdHlVQVNUQzozLG5lZWRzUG93ZXJPZlR3bzohMX0se2lmOlwiZXRjMVN1cHBvcnRlZFwiLGJhc2lzRm9ybWF0OltzLkVUQzFTLHMuVUFTVENfNHg0XSx0cmFuc2NvZGVyRm9ybWF0OltyLkVUQzEsci5FVEMxXSxlbmdpbmVGb3JtYXQ6W2kuUkdCX0VUQzFfRm9ybWF0LGkuUkdCX0VUQzFfRm9ybWF0XSxwcmlvcml0eUVUQzFTOjIscHJpb3JpdHlVQVNUQzo0LG5lZWRzUG93ZXJPZlR3bzohMX0se2lmOlwicHZydGNTdXBwb3J0ZWRcIixiYXNpc0Zvcm1hdDpbcy5FVEMxUyxzLlVBU1RDXzR4NF0sdHJhbnNjb2RlckZvcm1hdDpbci5QVlJUQzFfNF9SR0Isci5QVlJUQzFfNF9SR0JBXSxlbmdpbmVGb3JtYXQ6W2kuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsaS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXRdLHByaW9yaXR5RVRDMVM6NSxwcmlvcml0eVVBU1RDOjYsbmVlZHNQb3dlck9mVHdvOiEwfV0sbz1hLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQucHJpb3JpdHlFVEMxUy1lLnByaW9yaXR5RVRDMVN9KSksbD1hLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQucHJpb3JpdHlVQVNUQy1lLnByaW9yaXR5VUFTVEN9KSk7ZnVuY3Rpb24gYyh0KXtyZXR1cm4gdDw9Mnx8MD09KHQmdC0xKSYmMCE9PXR9fTtjb25zdCB2aD1TeW1ib2woXCJyZXRhaW5lckNvdW50XCIpLHloPVN5bWJvbChcInJlY2VudGx5VXNlZFwiKSx4aD1TeW1ib2woXCJldmljdFwiKSxiaD1TeW1ib2woXCJldmljdGlvblRocmVzaG9sZFwiKSx3aD1TeW1ib2woXCJjYWNoZVwiKTtjbGFzcyBfaHtjb25zdHJ1Y3Rvcih0LGU9NSl7dGhpc1tmaF09bmV3IE1hcCx0aGlzW2doXT1bXSx0aGlzW3doXT10LHRoaXNbYmhdPWV9c2V0IGV2aWN0aW9uVGhyZXNob2xkKHQpe3RoaXNbYmhdPXQsdGhpc1t4aF0oKX1nZXQgZXZpY3Rpb25UaHJlc2hvbGQoKXtyZXR1cm4gdGhpc1tiaF19Z2V0IGNhY2hlKCl7cmV0dXJuIHRoaXNbd2hdfXJldGFpbmVyQ291bnQodCl7cmV0dXJuIHRoaXNbdmhdLmdldCh0KXx8MH1yZXNldCgpe3RoaXNbdmhdLmNsZWFyKCksdGhpc1t5aF09W119cmV0YWluKHQpe3RoaXNbdmhdLmhhcyh0KXx8dGhpc1t2aF0uc2V0KHQsMCksdGhpc1t2aF0uc2V0KHQsdGhpc1t2aF0uZ2V0KHQpKzEpO2NvbnN0IGU9dGhpc1t5aF0uaW5kZXhPZih0KTstMSE9PWUmJnRoaXNbeWhdLnNwbGljZShlLDEpLHRoaXNbeWhdLnVuc2hpZnQodCksdGhpc1t4aF0oKX1yZWxlYXNlKHQpe3RoaXNbdmhdLmhhcyh0KSYmdGhpc1t2aF0uc2V0KHQsTWF0aC5tYXgodGhpc1t2aF0uZ2V0KHQpLTEsMCkpLHRoaXNbeGhdKCl9WyhmaD12aCxnaD15aCx4aCldKCl7aWYoISh0aGlzW3loXS5sZW5ndGg8dGhpc1tiaF0pKWZvcihsZXQgdD10aGlzW3loXS5sZW5ndGgtMTt0Pj10aGlzW2JoXTstLXQpe2NvbnN0IGU9dGhpc1t5aF1bdF07MD09PXRoaXNbdmhdLmdldChlKSYmKHRoaXNbd2hdLmRlbGV0ZShlKSx0aGlzW3loXS5zcGxpY2UodCwxKSl9fX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jb25zdCBNaD0odCxlKT0+e2NvbnN0IG49bmV3IE1hcDtmb3IoY29uc3QgaSBvZiB0Lm1hcHBpbmdzKWZvcihjb25zdCB0IG9mIGkudmFyaWFudHMpbi5zZXQoZVt0XSx7bWF0ZXJpYWw6bnVsbCxnbHRmTWF0ZXJpYWxJbmRleDppLm1hdGVyaWFsfSk7cmV0dXJuIG59O2NsYXNzIFNoe2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPXQsdGhpcy5uYW1lPVwiS0hSX21hdGVyaWFsc192YXJpYW50c1wifWFmdGVyUm9vdCh0KXtjb25zdCBlPXRoaXMucGFyc2VyLG49ZS5qc29uO2lmKHZvaWQgMD09PW4uZXh0ZW5zaW9uc3x8dm9pZCAwPT09bi5leHRlbnNpb25zW3RoaXMubmFtZV0pcmV0dXJuIG51bGw7Y29uc3QgaT0odD0+e2NvbnN0IGU9W10sbj1uZXcgU2V0O2Zvcihjb25zdCBpIG9mIHQpe2xldCB0PWkscj0wO2Zvcig7bi5oYXModCk7KXQ9aStcIi5cIisgKytyO24uYWRkKHQpLGUucHVzaCh0KX1yZXR1cm4gZX0pKChuLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS52YXJpYW50c3x8W10pLm1hcCgodD0+dC5uYW1lKSkpO2Zvcihjb25zdCByIG9mIHQuc2NlbmVzKXIudHJhdmVyc2UoKHQ9Pntjb25zdCByPWUuYXNzb2NpYXRpb25zLmdldCh0KTtpZihudWxsPT1yfHxudWxsPT1yLm1lc2hlcylyZXR1cm47Y29uc3Qgcz1yLm1lc2hlcyxhPW4ubWVzaGVzW3NdLnByaW1pdGl2ZXMsbz1cImlzTWVzaFwiaW4gdD9bdF06dC5jaGlsZHJlbjtmb3IobGV0IHQ9MDt0PGEubGVuZ3RoO3QrKyl7Y29uc3QgZT1hW3RdLmV4dGVuc2lvbnM7ZSYmZVt0aGlzLm5hbWVdJiYob1t0XS51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzPU1oKGVbdGhpcy5uYW1lXSxpKSl9fSkpO3JldHVybiB0LnVzZXJEYXRhLnZhcmlhbnRzPWksUHJvbWlzZS5yZXNvbHZlKCl9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL3ZhciBUaCxFaDtjb25zdCBBaD1uZXcgTWFwLExoPW5ldyBNYXA7bGV0IFJoO2NvbnN0IENoPW5ldyBjbGFzcyBleHRlbmRzIG1se2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuZGVjb2RlclBhdGg9XCJcIix0aGlzLmRlY29kZXJDb25maWc9e30sdGhpcy5kZWNvZGVyQmluYXJ5PW51bGwsdGhpcy5kZWNvZGVyUGVuZGluZz1udWxsLHRoaXMud29ya2VyTGltaXQ9NCx0aGlzLndvcmtlclBvb2w9W10sdGhpcy53b3JrZXJOZXh0VGFza0lEPTEsdGhpcy53b3JrZXJTb3VyY2VVUkw9XCJcIix0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHM9e3Bvc2l0aW9uOlwiUE9TSVRJT05cIixub3JtYWw6XCJOT1JNQUxcIixjb2xvcjpcIkNPTE9SXCIsdXY6XCJURVhfQ09PUkRcIn0sdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXM9e3Bvc2l0aW9uOlwiRmxvYXQzMkFycmF5XCIsbm9ybWFsOlwiRmxvYXQzMkFycmF5XCIsY29sb3I6XCJGbG9hdDMyQXJyYXlcIix1djpcIkZsb2F0MzJBcnJheVwifX1zZXREZWNvZGVyUGF0aCh0KXtyZXR1cm4gdGhpcy5kZWNvZGVyUGF0aD10LHRoaXN9c2V0RGVjb2RlckNvbmZpZyh0KXtyZXR1cm4gdGhpcy5kZWNvZGVyQ29uZmlnPXQsdGhpc31zZXRXb3JrZXJMaW1pdCh0KXtyZXR1cm4gdGhpcy53b3JrZXJMaW1pdD10LHRoaXN9bG9hZCh0LGUsbixpKXtjb25zdCByPW5ldyBnbCh0aGlzLm1hbmFnZXIpO3Iuc2V0UGF0aCh0aGlzLnBhdGgpLHIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIiksci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlciksci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpLHIubG9hZCh0LCh0PT57Y29uc3Qgbj17YXR0cmlidXRlSURzOnRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxhdHRyaWJ1dGVUeXBlczp0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyx1c2VVbmlxdWVJRHM6ITF9O3RoaXMuZGVjb2RlR2VvbWV0cnkodCxuKS50aGVuKGUpLmNhdGNoKGkpfSksbixpKX1kZWNvZGVEcmFjb0ZpbGUodCxlLG4saSl7Y29uc3Qgcj17YXR0cmlidXRlSURzOm58fHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxhdHRyaWJ1dGVUeXBlczppfHx0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyx1c2VVbmlxdWVJRHM6ISFufTt0aGlzLmRlY29kZUdlb21ldHJ5KHQscikudGhlbihlKX1kZWNvZGVHZW9tZXRyeSh0LGUpe2Zvcihjb25zdCB0IGluIGUuYXR0cmlidXRlVHlwZXMpe2NvbnN0IG49ZS5hdHRyaWJ1dGVUeXBlc1t0XTt2b2lkIDAhPT1uLkJZVEVTX1BFUl9FTEVNRU5UJiYoZS5hdHRyaWJ1dGVUeXBlc1t0XT1uLm5hbWUpfWNvbnN0IG49SlNPTi5zdHJpbmdpZnkoZSk7aWYoaGMuaGFzKHQpKXtjb25zdCBlPWhjLmdldCh0KTtpZihlLmtleT09PW4pcmV0dXJuIGUucHJvbWlzZTtpZigwPT09dC5ieXRlTGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC5cIil9bGV0IGk7Y29uc3Qgcj10aGlzLndvcmtlck5leHRUYXNrSUQrKyxzPXQuYnl0ZUxlbmd0aCxhPXRoaXMuX2dldFdvcmtlcihyLHMpLnRoZW4oKG49PihpPW4sbmV3IFByb21pc2UoKChuLHMpPT57aS5fY2FsbGJhY2tzW3JdPXtyZXNvbHZlOm4scmVqZWN0OnN9LGkucG9zdE1lc3NhZ2Uoe3R5cGU6XCJkZWNvZGVcIixpZDpyLHRhc2tDb25maWc6ZSxidWZmZXI6dH0sW3RdKX0pKSkpKS50aGVuKCh0PT50aGlzLl9jcmVhdGVHZW9tZXRyeSh0Lmdlb21ldHJ5KSkpO3JldHVybiBhLmNhdGNoKCgoKT0+ITApKS50aGVuKCgoKT0+e2kmJnImJnRoaXMuX3JlbGVhc2VUYXNrKGkscil9KSksaGMuc2V0KHQse2tleTpuLHByb21pc2U6YX0pLGF9X2NyZWF0ZUdlb21ldHJ5KHQpe2NvbnN0IGU9bmV3IFNuO3QuaW5kZXgmJmUuc2V0SW5kZXgobmV3IHBuKHQuaW5kZXguYXJyYXksMSkpO2ZvcihsZXQgbj0wO248dC5hdHRyaWJ1dGVzLmxlbmd0aDtuKyspe2NvbnN0IGk9dC5hdHRyaWJ1dGVzW25dLHI9aS5uYW1lLHM9aS5hcnJheSxhPWkuaXRlbVNpemU7ZS5zZXRBdHRyaWJ1dGUocixuZXcgcG4ocyxhKSl9cmV0dXJuIGV9X2xvYWRMaWJyYXJ5KHQsZSl7Y29uc3Qgbj1uZXcgZ2wodGhpcy5tYW5hZ2VyKTtyZXR1cm4gbi5zZXRQYXRoKHRoaXMuZGVjb2RlclBhdGgpLG4uc2V0UmVzcG9uc2VUeXBlKGUpLG4uc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKSxuZXcgUHJvbWlzZSgoKGUsaSk9PntuLmxvYWQodCxlLHZvaWQgMCxpKX0pKX1wcmVsb2FkKCl7cmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCksdGhpc31faW5pdERlY29kZXIoKXtpZih0aGlzLmRlY29kZXJQZW5kaW5nKXJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO2NvbnN0IHQ9XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5fHxcImpzXCI9PT10aGlzLmRlY29kZXJDb25maWcudHlwZSxlPVtdO3JldHVybiB0P2UucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIuanNcIixcInRleHRcIikpOihlLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb193YXNtX3dyYXBwZXIuanNcIixcInRleHRcIikpLGUucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIud2FzbVwiLFwiYXJyYXlidWZmZXJcIikpKSx0aGlzLmRlY29kZXJQZW5kaW5nPVByb21pc2UuYWxsKGUpLnRoZW4oKGU9Pntjb25zdCBuPWVbMF07dHx8KHRoaXMuZGVjb2RlckNvbmZpZy53YXNtQmluYXJ5PWVbMV0pO2NvbnN0IGk9dWMudG9TdHJpbmcoKSxyPVtcIi8qIGRyYWNvIGRlY29kZXIgKi9cIixuLFwiXCIsXCIvKiB3b3JrZXIgKi9cIixpLnN1YnN0cmluZyhpLmluZGV4T2YoXCJ7XCIpKzEsaS5sYXN0SW5kZXhPZihcIn1cIikpXS5qb2luKFwiXFxuXCIpO3RoaXMud29ya2VyU291cmNlVVJMPVVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3JdKSl9KSksdGhpcy5kZWNvZGVyUGVuZGluZ31fZ2V0V29ya2VyKHQsZSl7cmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbigoKCk9PntpZih0aGlzLndvcmtlclBvb2wubGVuZ3RoPHRoaXMud29ya2VyTGltaXQpe2NvbnN0IHQ9bmV3IFdvcmtlcih0aGlzLndvcmtlclNvdXJjZVVSTCk7dC5fY2FsbGJhY2tzPXt9LHQuX3Rhc2tDb3N0cz17fSx0Ll90YXNrTG9hZD0wLHQucG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0XCIsZGVjb2RlckNvbmZpZzp0aGlzLmRlY29kZXJDb25maWd9KSx0Lm9ubWVzc2FnZT1mdW5jdGlvbihlKXtjb25zdCBuPWUuZGF0YTtzd2l0Y2gobi50eXBlKXtjYXNlXCJkZWNvZGVcIjp0Ll9jYWxsYmFja3Nbbi5pZF0ucmVzb2x2ZShuKTticmVhaztjYXNlXCJlcnJvclwiOnQuX2NhbGxiYWNrc1tuLmlkXS5yZWplY3Qobik7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKCdUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBtZXNzYWdlLCBcIicrbi50eXBlKydcIicpfX0sdGhpcy53b3JrZXJQb29sLnB1c2godCl9ZWxzZSB0aGlzLndvcmtlclBvb2wuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fdGFza0xvYWQ+ZS5fdGFza0xvYWQ/LTE6MX0pKTtjb25zdCBuPXRoaXMud29ya2VyUG9vbFt0aGlzLndvcmtlclBvb2wubGVuZ3RoLTFdO3JldHVybiBuLl90YXNrQ29zdHNbdF09ZSxuLl90YXNrTG9hZCs9ZSxufSkpfV9yZWxlYXNlVGFzayh0LGUpe3QuX3Rhc2tMb2FkLT10Ll90YXNrQ29zdHNbZV0sZGVsZXRlIHQuX2NhbGxiYWNrc1tlXSxkZWxldGUgdC5fdGFza0Nvc3RzW2VdfWRlYnVnKCl7Y29uc29sZS5sb2coXCJUYXNrIGxvYWQ6IFwiLHRoaXMud29ya2VyUG9vbC5tYXAoKHQ9PnQuX3Rhc2tMb2FkKSkpfWRpc3Bvc2UoKXtmb3IobGV0IHQ9MDt0PHRoaXMud29ya2VyUG9vbC5sZW5ndGg7Kyt0KXRoaXMud29ya2VyUG9vbFt0XS50ZXJtaW5hdGUoKTtyZXR1cm4gdGhpcy53b3JrZXJQb29sLmxlbmd0aD0wLHRoaXN9fTtsZXQgUGg7Y29uc3QgSWg9bmV3IG1oO2xldCBEaCxOaDtjb25zdCBGaD1TeW1ib2woXCJsb2FkZXJcIiksT2g9U3ltYm9sKFwiZXZpY3Rpb25Qb2xpY3lcIiksVWg9U3ltYm9sKFwiR0xURkluc3RhbmNlXCIpO2NsYXNzIGtoIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzW0VoXT0obmV3IGRjKS5yZWdpc3RlcigodD0+bmV3IFNoKHQpKSksdGhpc1tVaF09dCx0aGlzW0ZoXS5zZXREUkFDT0xvYWRlcihDaCksdGhpc1tGaF0uc2V0S1RYMkxvYWRlcihJaCl9c3RhdGljIHNldERSQUNPRGVjb2RlckxvY2F0aW9uKHQpe1JoPXQsQ2guc2V0RGVjb2RlclBhdGgodCl9c3RhdGljIGdldERSQUNPRGVjb2RlckxvY2F0aW9uKCl7cmV0dXJuIFJofXN0YXRpYyBzZXRLVFgyVHJhbnNjb2RlckxvY2F0aW9uKHQpe1BoPXQsSWguc2V0VHJhbnNjb2RlclBhdGgodCl9c3RhdGljIGdldEtUWDJUcmFuc2NvZGVyTG9jYXRpb24oKXtyZXR1cm4gUGh9c3RhdGljIHNldE1lc2hvcHREZWNvZGVyTG9jYXRpb24odCl7dmFyIGU7RGghPT10JiYoRGg9dCxOaD0oZT10LG5ldyBQcm9taXNlKCgodCxuKT0+e2NvbnN0IGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGkpLGkub25sb2FkPXQsaS5vbmVycm9yPW4saS5hc3luYz0hMCxpLnNyYz1lfSkpKS50aGVuKCgoKT0+TWVzaG9wdERlY29kZXIucmVhZHkpKS50aGVuKCgoKT0+TWVzaG9wdERlY29kZXIpKSl9c3RhdGljIGdldE1lc2hvcHREZWNvZGVyTG9jYXRpb24oKXtyZXR1cm4gRGh9c3RhdGljIGluaXRpYWxpemVLVFgyTG9hZGVyKHQpe0loLmRldGVjdFN1cHBvcnQodCl9c3RhdGljIGdldCBjYWNoZSgpe3JldHVybiBBaH1zdGF0aWMgY2xlYXJDYWNoZSgpe0FoLmZvckVhY2goKCh0LGUpPT57dGhpcy5kZWxldGUoZSl9KSksdGhpc1tPaF0ucmVzZXQoKX1zdGF0aWMgaGFzKHQpe3JldHVybiBBaC5oYXModCl9c3RhdGljIGFzeW5jIGRlbGV0ZSh0KXtpZighdGhpcy5oYXModCkpcmV0dXJuO2NvbnN0IGU9QWguZ2V0KHQpO0xoLmRlbGV0ZSh0KSxBaC5kZWxldGUodCk7KGF3YWl0IGUpLmRpc3Bvc2UoKX1zdGF0aWMgaGFzRmluaXNoZWRMb2FkaW5nKHQpe3JldHVybiEhTGguZ2V0KHQpfWdldFsoVGg9T2gsRWg9RmgsT2gpXSgpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yW09oXX1hc3luYyBwcmVsb2FkKHQsZSxuPSgoKT0+e30pKXtpZih0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJwcmVsb2FkXCIsZWxlbWVudDplLHNyYzp0fSksIUFoLmhhcyh0KSl7bnVsbCE9TmgmJnRoaXNbRmhdLnNldE1lc2hvcHREZWNvZGVyKGF3YWl0IE5oKTtjb25zdCBlPSgodCxlLG49KCgpPT57fSkpPT57Y29uc3QgaT10PT57Y29uc3QgZT10LmxvYWRlZC90LnRvdGFsO24oTWF0aC5tYXgoMCxNYXRoLm1pbigxLGlzRmluaXRlKGUpP2U6MSkpKX07cmV0dXJuIG5ldyBQcm9taXNlKCgobixyKT0+e2UubG9hZCh0LG4saSxyKX0pKX0pKHQsdGhpc1tGaF0sKHQ9PntuKC44KnQpfSkpLGk9dGhpc1tVaF0scj1lLnRoZW4oKHQ9PmkucHJlcGFyZSh0KSkpLnRoZW4oKHQ9PihuKC45KSxuZXcgaSh0KSkpKTtBaC5zZXQodCxyKX1hd2FpdCBBaC5nZXQodCksTGguc2V0KHQsITApLG4mJm4oMSl9YXN5bmMgbG9hZCh0LGUsbj0oKCk9Pnt9KSl7YXdhaXQgdGhpcy5wcmVsb2FkKHQsZSxuKTtjb25zdCBpPWF3YWl0IEFoLmdldCh0KSxyPWF3YWl0IGkuY2xvbmUoKTtyZXR1cm4gdGhpc1tPaF0ucmV0YWluKHQpLHIuZGlzcG9zZT0oKCk9Pntjb25zdCBlPXIuZGlzcG9zZTtsZXQgbj0hMTtyZXR1cm4oKT0+e258fChuPSEwLGUuYXBwbHkociksdGhpc1tPaF0ucmVsZWFzZSh0KSl9fSkoKSxyfX1raFtUaF09bmV3IF9oKGtoKTtjbGFzcyB6aCBleHRlbmRzIFZle2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5lbGVtZW50PXR8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLmVsZW1lbnQuc3R5bGUudXNlclNlbGVjdD1cIm5vbmVcIix0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsITEpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZWRcIiwoZnVuY3Rpb24oKXt0aGlzLnRyYXZlcnNlKChmdW5jdGlvbih0KXt0LmVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50JiZudWxsIT09dC5lbGVtZW50LnBhcmVudE5vZGUmJnQuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQuZWxlbWVudCl9KSl9KSl9Y29weSh0LGUpe3JldHVybiBzdXBlci5jb3B5KHQsZSksdGhpcy5lbGVtZW50PXQuZWxlbWVudC5jbG9uZU5vZGUoITApLHRoaXN9fXpoLnByb3RvdHlwZS5pc0NTUzJET2JqZWN0PSEwO2NvbnN0IEJoPW5ldyBCdCxIaD1uZXcgdmUsVmg9bmV3IHZlLEdoPW5ldyBCdCxXaD1uZXcgQnQ7Y2xhc3Mgamh7Y29uc3RydWN0b3IoKXtjb25zdCB0PXRoaXM7bGV0IGUsbixpLHI7Y29uc3Qgcz17b2JqZWN0czpuZXcgV2Vha01hcH0sYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2Z1bmN0aW9uIG8oZSxuLGMpe2lmKGUuaXNDU1MyRE9iamVjdCl7ZS5vbkJlZm9yZVJlbmRlcih0LG4sYyksQmguc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpLEJoLmFwcGx5TWF0cml4NChWaCk7Y29uc3Qgbz1lLmVsZW1lbnQ7L2FwcGxlL2kudGVzdChuYXZpZ2F0b3IudmVuZG9yKT9vLnN0eWxlLnRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtNTAlLC01MCUpIHRyYW5zbGF0ZShcIitNYXRoLnJvdW5kKEJoLngqaStpKStcInB4LFwiK01hdGgucm91bmQoLUJoLnkqcityKStcInB4KVwiOm8uc3R5bGUudHJhbnNmb3JtPVwidHJhbnNsYXRlKC01MCUsLTUwJSkgdHJhbnNsYXRlKFwiKyhCaC54KmkraSkrXCJweCxcIisoLUJoLnkqcityKStcInB4KVwiLG8uc3R5bGUuZGlzcGxheT1lLnZpc2libGUmJkJoLno+PS0xJiZCaC56PD0xP1wiXCI6XCJub25lXCI7Y29uc3QgaD17ZGlzdGFuY2VUb0NhbWVyYVNxdWFyZWQ6bChjLGUpfTtzLm9iamVjdHMuc2V0KGUsaCksby5wYXJlbnROb2RlIT09YSYmYS5hcHBlbmRDaGlsZChvKSxlLm9uQWZ0ZXJSZW5kZXIodCxuLGMpfWZvcihsZXQgdD0wLGk9ZS5jaGlsZHJlbi5sZW5ndGg7dDxpO3QrKylvKGUuY2hpbGRyZW5bdF0sbixjKX1mdW5jdGlvbiBsKHQsZSl7cmV0dXJuIEdoLnNldEZyb21NYXRyaXhQb3NpdGlvbih0Lm1hdHJpeFdvcmxkKSxXaC5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS5tYXRyaXhXb3JsZCksR2guZGlzdGFuY2VUb1NxdWFyZWQoV2gpfWEuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIix0aGlzLmRvbUVsZW1lbnQ9YSx0aGlzLmdldFNpemU9ZnVuY3Rpb24oKXtyZXR1cm57d2lkdGg6ZSxoZWlnaHQ6bn19LHRoaXMucmVuZGVyPWZ1bmN0aW9uKHQsZSl7ITA9PT10LmF1dG9VcGRhdGUmJnQudXBkYXRlTWF0cml4V29ybGQoKSxudWxsPT09ZS5wYXJlbnQmJmUudXBkYXRlTWF0cml4V29ybGQoKSxIaC5jb3B5KGUubWF0cml4V29ybGRJbnZlcnNlKSxWaC5tdWx0aXBseU1hdHJpY2VzKGUucHJvamVjdGlvbk1hdHJpeCxIaCksbyh0LHQsZSksZnVuY3Rpb24odCl7Y29uc3QgZT1mdW5jdGlvbih0KXtjb25zdCBlPVtdO3JldHVybiB0LnRyYXZlcnNlKChmdW5jdGlvbih0KXt0LmlzQ1NTMkRPYmplY3QmJmUucHVzaCh0KX0pKSxlfSh0KS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBzLm9iamVjdHMuZ2V0KHQpLmRpc3RhbmNlVG9DYW1lcmFTcXVhcmVkLXMub2JqZWN0cy5nZXQoZSkuZGlzdGFuY2VUb0NhbWVyYVNxdWFyZWR9KSksbj1lLmxlbmd0aDtmb3IobGV0IHQ9MCxpPWUubGVuZ3RoO3Q8aTt0KyspZVt0XS5lbGVtZW50LnN0eWxlLnpJbmRleD1uLXR9KHQpfSx0aGlzLnNldFNpemU9ZnVuY3Rpb24odCxzKXtlPXQsbj1zLGk9ZS8yLHI9bi8yLGEuc3R5bGUud2lkdGg9dCtcInB4XCIsYS5zdHlsZS5oZWlnaHQ9cytcInB4XCJ9fX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jb25zdCBxaD10PT50JiZcIm51bGxcIiE9PXQ/WWgodCk6bnVsbCxYaD0oKT0+e2lmKHN0KXJldHVybjtjb25zdCB0PVtdO3Rocm93IGV0fHx0LnB1c2goXCJXZWJYUiBEZXZpY2UgQVBJXCIpLG50fHx0LnB1c2goXCJXZWJYUiBIaXQgVGVzdCBBUElcIiksbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIEFQSXMgYXJlIHJlcXVpcmVkIGZvciBBUiwgYnV0IGFyZSBtaXNzaW5nIGluIHRoaXMgYnJvd3NlcjogJHt0LmpvaW4oXCIsIFwiKX1gKX0sWWg9dD0+bmV3IFVSTCh0LHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKS50b1N0cmluZygpLFpoPSh0LGUpPT57bGV0IG49bnVsbDtyZXR1cm4oLi4uaSk9PntudWxsIT1uJiZzZWxmLmNsZWFyVGltZW91dChuKSxuPXNlbGYuc2V0VGltZW91dCgoKCk9PntuPW51bGwsdCguLi5pKX0pLGUpfX0sSmg9KHQsZSxuKT0+TWF0aC5tYXgoZSxNYXRoLm1pbihuLHQpKSwkaD0oKCk9Pntjb25zdCB0PSgoKT0+e2NvbnN0IHQ9bnVsbCE9ZG9jdW1lbnQuaGVhZD9BcnJheS5mcm9tKGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvckFsbChcIm1ldGFcIikpOltdO2Zvcihjb25zdCBlIG9mIHQpaWYoXCJ2aWV3cG9ydFwiPT09ZS5uYW1lKXJldHVybiEwO3JldHVybiExfSkoKTtyZXR1cm4gdHx8Y29uc29sZS53YXJuKCdObyA8bWV0YSBuYW1lPVwidmlld3BvcnRcIj4gZGV0ZWN0ZWQ7IDxtb2RlbC12aWV3ZXI+IHdpbGwgY2FwIHBpeGVsIGRlbnNpdHkgYXQgMS4nKSwoKT0+dD93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzoxfSkoKSxLaD0oKCk9Pntjb25zdCB0PW5ldyBSZWdFeHAoXCJbPyZdbW9kZWwtdmlld2VyLWRlYnVnLW1vZGUoJnwkKVwiKTtyZXR1cm4oKT0+c2VsZi5Nb2RlbFZpZXdlckVsZW1lbnQmJnNlbGYuTW9kZWxWaWV3ZXJFbGVtZW50LmRlYnVnTW9kZXx8c2VsZi5sb2NhdGlvbiYmc2VsZi5sb2NhdGlvbi5zZWFyY2gmJnNlbGYubG9jYXRpb24uc2VhcmNoLm1hdGNoKHQpfSkoKSxRaD0odD0wKT0+bmV3IFByb21pc2UoKGU9PnNldFRpbWVvdXQoZSx0KSkpO2NsYXNzIHR1e2NvbnN0cnVjdG9yKHQ9NTApe3RoaXMudmVsb2NpdHk9MCx0aGlzLm5hdHVyYWxGcmVxdWVuY3k9MCx0aGlzLnNldERlY2F5VGltZSh0KX1zZXREZWNheVRpbWUodCl7dGhpcy5uYXR1cmFsRnJlcXVlbmN5PTEvTWF0aC5tYXgoLjAwMSx0KX11cGRhdGUodCxlLG4saSl7Y29uc3Qgcj0yZS00KnRoaXMubmF0dXJhbEZyZXF1ZW5jeTtpZihudWxsPT10fHwwPT09aSlyZXR1cm4gZTtpZih0PT09ZSYmMD09PXRoaXMudmVsb2NpdHkpcmV0dXJuIGU7aWYobjwwKXJldHVybiB0O2NvbnN0IHM9dC1lLGE9dGhpcy52ZWxvY2l0eSt0aGlzLm5hdHVyYWxGcmVxdWVuY3kqcyxvPXMrbiphLGw9TWF0aC5leHAoLXRoaXMubmF0dXJhbEZyZXF1ZW5jeSpuKSxjPShhLXRoaXMubmF0dXJhbEZyZXF1ZW5jeSpvKSpsLGg9LXRoaXMubmF0dXJhbEZyZXF1ZW5jeSooYythKmwpO3JldHVybiBNYXRoLmFicyhjKTxyKk1hdGguYWJzKGkpJiZoKnM+PTA/KHRoaXMudmVsb2NpdHk9MCxlKToodGhpcy52ZWxvY2l0eT1jLGUrbypsKX19XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovY29uc3QgZXU9KHQsZSk9Pih7dHlwZTpcIm51bWJlclwiLG51bWJlcjp0LHVuaXQ6ZX0pLG51PSgoKT0+e2NvbnN0IHQ9e307cmV0dXJuIGU9Pntjb25zdCBuPWU7aWYobiBpbiB0KXJldHVybiB0W25dO2NvbnN0IGk9W107bGV0IHI9MDtmb3IoO2U7KXtpZigrK3I+MWUzKXtlPVwiXCI7YnJlYWt9Y29uc3QgdD1pdShlKSxuPXQubm9kZXNbMF07aWYobnVsbD09bnx8MD09PW4udGVybXMubGVuZ3RoKWJyZWFrO2kucHVzaChuKSxlPXQucmVtYWluaW5nSW5wdXR9cmV0dXJuIHRbbl09aX19KSgpLGl1PSgoKT0+e2NvbnN0IHQ9L14oXFwtXFwtfFthLXpcXHUwMjQwLVxcdWZmZmZdKS9pLGU9L14oW1xcKlxcK1xcL118W1xcLV1cXHMpL2ksbj0vXltcXCksXS87cmV0dXJuIGk9Pntjb25zdCByPVtdO2Zvcig7aS5sZW5ndGgmJihpPWkudHJpbSgpLCFuLnRlc3QoaSkpOylpZihcIihcIj09PWlbMF0pe2NvbnN0e25vZGVzOnQscmVtYWluaW5nSW5wdXQ6ZX09b3UoaSk7aT1lLHIucHVzaCh7dHlwZTpcImZ1bmN0aW9uXCIsbmFtZTp7dHlwZTpcImlkZW50XCIsdmFsdWU6XCJjYWxjXCJ9LGFyZ3VtZW50czp0fSl9ZWxzZSBpZih0LnRlc3QoaSkpe2NvbnN0IHQ9cnUoaSksZT10Lm5vZGVzWzBdO2lmKFwiKFwiPT09KGk9dC5yZW1haW5pbmdJbnB1dClbMF0pe2NvbnN0e25vZGVzOnQscmVtYWluaW5nSW5wdXQ6bn09b3UoaSk7ci5wdXNoKHt0eXBlOlwiZnVuY3Rpb25cIixuYW1lOmUsYXJndW1lbnRzOnR9KSxpPW59ZWxzZSByLnB1c2goZSl9ZWxzZSBpZihlLnRlc3QoaSkpci5wdXNoKHt0eXBlOlwib3BlcmF0b3JcIix2YWx1ZTppWzBdfSksaT1pLnNsaWNlKDEpO2Vsc2V7Y29uc3R7bm9kZXM6dCxyZW1haW5pbmdJbnB1dDplfT1cIiNcIj09PWlbMF0/YXUoaSk6c3UoaSk7aWYoMD09PXQubGVuZ3RoKWJyZWFrO3IucHVzaCh0WzBdKSxpPWV9cmV0dXJue25vZGVzOlt7dHlwZTpcImV4cHJlc3Npb25cIix0ZXJtczpyfV0scmVtYWluaW5nSW5wdXQ6aX19fSkoKSxydT0oKCk9Pntjb25zdCB0PS9bXmEtejAtOV9cXC1cXHUwMjQwLVxcdWZmZmZdL2k7cmV0dXJuIGU9Pntjb25zdCBuPWUubWF0Y2godCk7cmV0dXJue25vZGVzOlt7dHlwZTpcImlkZW50XCIsdmFsdWU6bnVsbD09bj9lOmUuc3Vic3RyKDAsbi5pbmRleCl9XSxyZW1haW5pbmdJbnB1dDpudWxsPT1uP1wiXCI6ZS5zdWJzdHIobi5pbmRleCl9fX0pKCksc3U9KCgpPT57Y29uc3QgdD0vW1xcK1xcLV0/KFxcZCtbXFwuXVxcZCt8XFxkK3xbXFwuXVxcZCspKFtlRV1bXFwrXFwtXT9cXGQrKT8vLGU9L15bYS16JV0rL2ksbj0vXihtfG1tfGNtfHJhZHxkZWd8WyVdKSQvO3JldHVybiBpPT57Y29uc3Qgcj1pLm1hdGNoKHQpLHM9bnVsbD09cj9cIjBcIjpyWzBdLGE9KGk9bnVsbD09cz9pOmkuc2xpY2Uocy5sZW5ndGgpKS5tYXRjaChlKTtsZXQgbz1udWxsIT1hJiZcIlwiIT09YVswXT9hWzBdOm51bGw7Y29uc3QgbD1udWxsPT1hP2k6aS5zbGljZShvLmxlbmd0aCk7cmV0dXJuIG51bGw9PW98fG4udGVzdChvKXx8KG89bnVsbCkse25vZGVzOlt7dHlwZTpcIm51bWJlclwiLG51bWJlcjpwYXJzZUZsb2F0KHMpfHwwLHVuaXQ6b31dLHJlbWFpbmluZ0lucHV0Omx9fX0pKCksYXU9KCgpPT57Y29uc3QgdD0vXlthLWYwLTldKi9pO3JldHVybiBlPT57Y29uc3Qgbj0oZT1lLnNsaWNlKDEpLnRyaW0oKSkubWF0Y2godCk7cmV0dXJue25vZGVzOm51bGw9PW4/W106W3t0eXBlOlwiaGV4XCIsdmFsdWU6blswXX1dLHJlbWFpbmluZ0lucHV0Om51bGw9PW4/ZTplLnNsaWNlKG5bMF0ubGVuZ3RoKX19fSkoKSxvdT10PT57Y29uc3QgZT1bXTtmb3IodD10LnNsaWNlKDEpLnRyaW0oKTt0Lmxlbmd0aDspe2NvbnN0IG49aXUodCk7aWYoZS5wdXNoKG4ubm9kZXNbMF0pLFwiLFwiPT09KHQ9bi5yZW1haW5pbmdJbnB1dC50cmltKCkpWzBdKXQ9dC5zbGljZSgxKS50cmltKCk7ZWxzZSBpZihcIilcIj09PXRbMF0pe3Q9dC5zbGljZSgxKTticmVha319cmV0dXJue25vZGVzOmUscmVtYWluaW5nSW5wdXQ6dH19LGx1PVN5bWJvbChcInZpc2l0ZWRUeXBlc1wiKTtjbGFzcyBjdXtjb25zdHJ1Y3Rvcih0KXt0aGlzW2x1XT10fXdhbGsodCxlKXtjb25zdCBuPXQuc2xpY2UoKTtmb3IoO24ubGVuZ3RoOyl7Y29uc3QgdD1uLnNoaWZ0KCk7c3dpdGNoKHRoaXNbbHVdLmluZGV4T2YodC50eXBlKT4tMSYmZSh0KSx0LnR5cGUpe2Nhc2VcImV4cHJlc3Npb25cIjpuLnVuc2hpZnQoLi4udC50ZXJtcyk7YnJlYWs7Y2FzZVwiZnVuY3Rpb25cIjpuLnVuc2hpZnQodC5uYW1lLC4uLnQuYXJndW1lbnRzKX19fX1jb25zdCBodT1PYmplY3QuZnJlZXplKHt0eXBlOlwibnVtYmVyXCIsbnVtYmVyOjAsdW5pdDpudWxsfSksdXU9KHQsZT0wKT0+e2xldHtudW1iZXI6bix1bml0Oml9PXQ7aWYoaXNGaW5pdGUobikpe2lmKFwicmFkXCI9PT10LnVuaXR8fG51bGw9PXQudW5pdClyZXR1cm4gdH1lbHNlIG49ZSxpPVwicmFkXCI7cmV0dXJue3R5cGU6XCJudW1iZXJcIixudW1iZXI6KFwiZGVnXCI9PT1pJiZudWxsIT1uP246MCkqTWF0aC5QSS8xODAsdW5pdDpcInJhZFwifX0sZHU9KHQsZT0wKT0+e2xldCBuLHtudW1iZXI6aSx1bml0OnJ9PXQ7aWYoaXNGaW5pdGUoaSkpe2lmKFwibVwiPT09dC51bml0KXJldHVybiB0fWVsc2UgaT1lLHI9XCJtXCI7c3dpdGNoKHIpe2RlZmF1bHQ6bj0xO2JyZWFrO2Nhc2VcImNtXCI6bj0uMDE7YnJlYWs7Y2FzZVwibW1cIjpuPS4wMDF9cmV0dXJue3R5cGU6XCJudW1iZXJcIixudW1iZXI6bippLHVuaXQ6XCJtXCJ9fSxwdT0oKCk9Pntjb25zdCB0PXQ9PnQsZT17cmFkOnQsZGVnOnV1LG06dCxtbTpkdSxjbTpkdX07cmV0dXJuKHQsbj1odSk9Pntpc0Zpbml0ZSh0Lm51bWJlcil8fCh0Lm51bWJlcj1uLm51bWJlcix0LnVuaXQ9bi51bml0KTtjb25zdHt1bml0Oml9PXQ7aWYobnVsbD09aSlyZXR1cm4gdDtjb25zdCByPWVbaV07cmV0dXJuIG51bGw9PXI/bjpyKHQpfX0pKCk7XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBtdSBleHRlbmRzIHpoe2NvbnN0cnVjdG9yKHQpe3N1cGVyKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLHRoaXMubm9ybWFsPW5ldyBCdCgwLDEsMCksdGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLnJlZmVyZW5jZUNvdW50PTEsdGhpcy5waXZvdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuc2xvdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2xvdFwiKSx0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb24td3JhcHBlclwiKSx0aGlzLnNsb3QubmFtZT10Lm5hbWUsdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucGl2b3QpLHRoaXMucGl2b3QuYXBwZW5kQ2hpbGQodGhpcy5zbG90KSx0aGlzLnVwZGF0ZVBvc2l0aW9uKHQucG9zaXRpb24pLHRoaXMudXBkYXRlTm9ybWFsKHQubm9ybWFsKX1nZXQgZmFjaW5nQ2FtZXJhKCl7cmV0dXJuIXRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRlXCIpfXNob3coKXt0aGlzLmZhY2luZ0NhbWVyYSYmdGhpcy5pbml0aWFsaXplZHx8dGhpcy51cGRhdGVWaXNpYmlsaXR5KCEwKX1oaWRlKCl7IXRoaXMuZmFjaW5nQ2FtZXJhJiZ0aGlzLmluaXRpYWxpemVkfHx0aGlzLnVwZGF0ZVZpc2liaWxpdHkoITEpfWluY3JlbWVudCgpe3RoaXMucmVmZXJlbmNlQ291bnQrK31kZWNyZW1lbnQoKXtyZXR1cm4gdGhpcy5yZWZlcmVuY2VDb3VudD4wJiYtLXRoaXMucmVmZXJlbmNlQ291bnQsMD09PXRoaXMucmVmZXJlbmNlQ291bnR9dXBkYXRlUG9zaXRpb24odCl7aWYobnVsbD09dClyZXR1cm47Y29uc3QgZT1udSh0KVswXS50ZXJtcztmb3IobGV0IHQ9MDt0PDM7Kyt0KXRoaXMucG9zaXRpb24uc2V0Q29tcG9uZW50KHQscHUoZVt0XSkubnVtYmVyKTt0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCl9dXBkYXRlTm9ybWFsKHQpe2lmKG51bGw9PXQpcmV0dXJuO2NvbnN0IGU9bnUodClbMF0udGVybXM7Zm9yKGxldCB0PTA7dDwzOysrdCl0aGlzLm5vcm1hbC5zZXRDb21wb25lbnQodCxwdShlW3RdKS5udW1iZXIpfW9yaWVudCh0KXt0aGlzLnBpdm90LnN0eWxlLnRyYW5zZm9ybT1gcm90YXRlKCR7dH1yYWQpYH11cGRhdGVWaXNpYmlsaXR5KHQpe3Q/dGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRlXCIpOnRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlkZVwiKSx0aGlzLnNsb3QuYXNzaWduZWROb2RlcygpLmZvckVhY2goKGU9PntpZihlLm5vZGVUeXBlIT09Tm9kZS5FTEVNRU5UX05PREUpcmV0dXJuO2NvbnN0IG49ZSxpPW4uZGF0YXNldC52aXNpYmlsaXR5QXR0cmlidXRlO2lmKG51bGwhPWkpe2NvbnN0IGU9YGRhdGEtJHtpfWA7dD9uLnNldEF0dHJpYnV0ZShlLFwiXCIpOm4ucmVtb3ZlQXR0cmlidXRlKGUpfW4uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJob3RzcG90LXZpc2liaWxpdHlcIix7ZGV0YWlsOnt2aXNpYmxlOnR9fSkpfSkpLHRoaXMuaW5pdGlhbGl6ZWQ9ITB9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL2NvbnN0IGZ1PSh0LGUsbik9PntsZXQgaT1uO2NvbnN0IHI9bmV3IEJ0O3JldHVybiB0LnRyYXZlcnNlKCh0PT57bGV0IG4sczt0LnVwZGF0ZVdvcmxkTWF0cml4KCExLCExKTtjb25zdCBhPXQuZ2VvbWV0cnk7aWYodm9pZCAwIT09YSlpZihhLmlzR2VvbWV0cnkpe2NvbnN0IG89YS52ZXJ0aWNlcztmb3Iobj0wLHM9by5sZW5ndGg7bjxzO24rKylyLmNvcHkob1tuXSksci5hcHBseU1hdHJpeDQodC5tYXRyaXhXb3JsZCksaT1lKGkscil9ZWxzZSBpZihhLmlzQnVmZmVyR2VvbWV0cnkpe2NvbnN0e3Bvc2l0aW9uOm99PWEuYXR0cmlidXRlcztpZih2b2lkIDAhPT1vKXtjb25zdCBhPSh0PT57aWYoIXQubm9ybWFsaXplZClyZXR1cm4gMTtjb25zdCBlPXQuYXJyYXk7cmV0dXJuIGUgaW5zdGFuY2VvZiBJbnQ4QXJyYXk/MS8xMjc6ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/MS8yNTU6ZSBpbnN0YW5jZW9mIEludDE2QXJyYXk/MS8zMjc2NzplIGluc3RhbmNlb2YgVWludDE2QXJyYXk/MS82NTUzNToxfSkobyk7Zm9yKG49MCxzPW8uY291bnQ7bjxzO24rKylyLmZyb21CdWZmZXJBdHRyaWJ1dGUobyxuKSxyLm11bHRpcGx5U2NhbGFyKGEpLHIuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLGk9ZShpLHIpfX19KSksaX07Y2xhc3MgZ3UgZXh0ZW5kcyBObHtjb25zdHJ1Y3Rvcih0LGUsbil7c3VwZXIoKSx0aGlzLnNoYWRvd01hdGVyaWFsPW5ldyBZbyx0aGlzLmJvdW5kaW5nQm94PW5ldyBHdCx0aGlzLnNpemU9bmV3IEJ0LHRoaXMuc2hhZG93U2NhbGU9MSx0aGlzLmlzQW5pbWF0ZWQ9ITEsdGhpcy5zaWRlPVwiYm90dG9tXCIsdGhpcy5uZWVkc1VwZGF0ZT0hMSx0aGlzLmludGVuc2l0eT0wLHRoaXMuY2FzdFNoYWRvdz0hMCx0aGlzLmZydXN0dW1DdWxsZWQ9ITEsdGhpcy5mbG9vcj1uZXcgVm4obmV3IGNpLHRoaXMuc2hhZG93TWF0ZXJpYWwpLHRoaXMuZmxvb3Iucm90YXRlWCgtTWF0aC5QSS8yKSx0aGlzLmZsb29yLnJlY2VpdmVTaGFkb3c9ITAsdGhpcy5mbG9vci5jYXN0U2hhZG93PSExLHRoaXMuZmxvb3IuZnJ1c3R1bUN1bGxlZD0hMSx0aGlzLmFkZCh0aGlzLmZsb29yKSx0LnRhcmdldC5hZGQodGhpcyksdGhpcy50YXJnZXQ9dC50YXJnZXQsdGhpcy5zZXRTY2VuZSh0LGUsbil9c2V0U2NlbmUodCxlLG4pe2lmKHRoaXMuc2lkZT1uLHRoaXMuaXNBbmltYXRlZD10LmFuaW1hdGlvbk5hbWVzLmxlbmd0aD4wLHRoaXMuYm91bmRpbmdCb3guY29weSh0LmJvdW5kaW5nQm94KSx0aGlzLnNpemUuY29weSh0LnNpemUpLFwiYmFja1wiPT09dGhpcy5zaWRlKXtjb25zdHttaW46dCxtYXg6ZX09dGhpcy5ib3VuZGluZ0JveDtbdC55LHQuel09W3Queix0LnldLFtlLnksZS56XT1bZS56LGUueV0sW3RoaXMuc2l6ZS55LHRoaXMuc2l6ZS56XT1bdGhpcy5zaXplLnosdGhpcy5zaXplLnldLHRoaXMucm90YXRpb24ueD1NYXRoLlBJLzIsdGhpcy5yb3RhdGlvbi55PU1hdGguUEl9ZWxzZSB0aGlzLnJvdGF0aW9uLng9MCx0aGlzLnJvdGF0aW9uLnk9MDtjb25zdHtib3VuZGluZ0JveDppLHNpemU6cn09dGhpcztpZih0aGlzLmlzQW5pbWF0ZWQpe2NvbnN0IHQ9MipNYXRoLm1heChyLngsci55LHIueik7ci55PXQsaS5leHBhbmRCeVZlY3RvcihyLnN1YlNjYWxhcih0KS5tdWx0aXBseVNjYWxhcigtLjUpKSxpLm1heC55PWkubWluLnkrdCxyLnNldCh0LHQsdCl9aS5nZXRDZW50ZXIodGhpcy5mbG9vci5wb3NpdGlvbik7Y29uc3Qgcz1pLm1heC55Ky4wMDIqci55O1wiYm90dG9tXCI9PT1uPyh0aGlzLnBvc2l0aW9uLnk9cyx0aGlzLnBvc2l0aW9uLno9MCk6KHRoaXMucG9zaXRpb24ueT0wLHRoaXMucG9zaXRpb24uej1zKSx0aGlzLnNldFNvZnRuZXNzKGUpfXNldFNvZnRuZXNzKHQpe2NvbnN0IGU9TWF0aC5wb3coMiw5LTMqdCk7dGhpcy5zZXRNYXBTaXplKGUpfXNldE1hcFNpemUodCl7Y29uc3R7Y2FtZXJhOmUsbWFwU2l6ZTpuLG1hcDppfT10aGlzLnNoYWRvdyx7c2l6ZTpyLGJvdW5kaW5nQm94OnN9PXRoaXM7bnVsbCE9aSYmKGkuZGlzcG9zZSgpLHRoaXMuc2hhZG93Lm1hcD1udWxsKSx0aGlzLmlzQW5pbWF0ZWQmJih0Kj0yKTtjb25zdCBhPU1hdGguZmxvb3Ioci54PnIuej90OnQqci54L3Iueiksbz1NYXRoLmZsb29yKHIueD5yLno/dCpyLnovci54OnQpO24uc2V0KGEsbyk7Y29uc3QgbD0yLjUqci54L2EsYz0yLjUqci56L287ZS5sZWZ0PS1zLm1heC54LWwsZS5yaWdodD0tcy5taW4ueCtsLGUuYm90dG9tPXMubWluLnotYyxlLnRvcD1zLm1heC56K2MsdGhpcy5zZXRTY2FsZUFuZE9mZnNldCh0aGlzLnNoYWRvd1NjYWxlLDApLHRoaXMuZmxvb3Iuc2NhbGUuc2V0KHIueCsyKmwsci56KzIqYywxKSx0aGlzLm5lZWRzVXBkYXRlPSEwLHRoaXMuc2hhZG93Lm5lZWRzVXBkYXRlPSEwfXNldEludGVuc2l0eSh0KXt0aGlzLnNoYWRvd01hdGVyaWFsLm9wYWNpdHk9dCx0PjA/KHRoaXMudmlzaWJsZT0hMCx0aGlzLmZsb29yLnZpc2libGU9ITApOih0aGlzLnZpc2libGU9ITEsdGhpcy5mbG9vci52aXNpYmxlPSExKX1nZXRJbnRlbnNpdHkoKXtyZXR1cm4gdGhpcy5zaGFkb3dNYXRlcmlhbC5vcGFjaXR5fXNldFJvdGF0aW9uKHQpe2lmKFwiYm90dG9tXCIhPT10aGlzLnNpZGUpcmV0dXJuIHRoaXMuc2hhZG93LmNhbWVyYS51cC5zZXQoMCwxLDApLHZvaWQgdGhpcy5zaGFkb3cudXBkYXRlTWF0cmljZXModGhpcyk7dGhpcy5zaGFkb3cuY2FtZXJhLnVwLnNldChNYXRoLnNpbih0KSwwLE1hdGguY29zKHQpKSx0aGlzLnNoYWRvdy51cGRhdGVNYXRyaWNlcyh0aGlzKX1zZXRTY2FsZUFuZE9mZnNldCh0LGUpe2NvbnN0IG49dGhpcy5zaXplLnkse2NhbWVyYTppfT10aGlzLnNoYWRvdzt0aGlzLnNoYWRvd1NjYWxlPXQsaS5uZWFyPTAsaS5mYXI9bi1lL3QsaS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCksaS5zY2FsZS5zZXRTY2FsYXIodCk7Y29uc3Qgcj0uMDAyKm47dGhpcy5mbG9vci5wb3NpdGlvbi55PTIqci1pLmZhcn19XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovY29uc3QgdnU9MjIuNSpNYXRoLlBJLzE4MCx5dT1NYXRoLnNpbih2dSkseHU9TWF0aC50YW4odnUpLGJ1PW5ldyBCdCx3dT1uZXcgQnQsX3U9bmV3IEJ0LE11PW5ldyBjbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbj0wLGk9MS8wKXt0aGlzLnJheT1uZXcgZ2UodCxlKSx0aGlzLm5lYXI9bix0aGlzLmZhcj1pLHRoaXMuY2FtZXJhPW51bGwsdGhpcy5sYXllcnM9bmV3IExlLHRoaXMucGFyYW1zPXtNZXNoOnt9LExpbmU6e3RocmVzaG9sZDoxfSxMT0Q6e30sUG9pbnRzOnt0aHJlc2hvbGQ6MX0sU3ByaXRlOnt9fX1zZXQodCxlKXt0aGlzLnJheS5zZXQodCxlKX1zZXRGcm9tQ2FtZXJhKHQsZSl7ZSYmZS5pc1BlcnNwZWN0aXZlQ2FtZXJhPyh0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpLHRoaXMucmF5LmRpcmVjdGlvbi5zZXQodC54LHQueSwuNSkudW5wcm9qZWN0KGUpLnN1Yih0aGlzLnJheS5vcmlnaW4pLm5vcm1hbGl6ZSgpLHRoaXMuY2FtZXJhPWUpOmUmJmUuaXNPcnRob2dyYXBoaWNDYW1lcmE/KHRoaXMucmF5Lm9yaWdpbi5zZXQodC54LHQueSwoZS5uZWFyK2UuZmFyKS8oZS5uZWFyLWUuZmFyKSkudW5wcm9qZWN0KGUpLHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoMCwwLC0xKS50cmFuc2Zvcm1EaXJlY3Rpb24oZS5tYXRyaXhXb3JsZCksdGhpcy5jYW1lcmE9ZSk6Y29uc29sZS5lcnJvcihcIlRIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGU6IFwiK2UudHlwZSl9aW50ZXJzZWN0T2JqZWN0KHQsZT0hMCxuPVtdKXtyZXR1cm4gZWModCx0aGlzLG4sZSksbi5zb3J0KHRjKSxufWludGVyc2VjdE9iamVjdHModCxlPSEwLG49W10pe2ZvcihsZXQgaT0wLHI9dC5sZW5ndGg7aTxyO2krKyllYyh0W2ldLHRoaXMsbixlKTtyZXR1cm4gbi5zb3J0KHRjKSxufX0sU3U9bmV3IEJ0LFR1PW5ldyBBdDtjbGFzcyBFdSBleHRlbmRzIFlze2NvbnN0cnVjdG9yKHtjYW52YXM6dCxlbGVtZW50OmUsd2lkdGg6bixoZWlnaHQ6aX0pe3N1cGVyKCksdGhpcy5jb250ZXh0PW51bGwsdGhpcy5hbm5vdGF0aW9uUmVuZGVyZXI9bmV3IGpoLHRoaXMuc2NoZW1hRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLHRoaXMud2lkdGg9MSx0aGlzLmhlaWdodD0xLHRoaXMuYXNwZWN0PTEsdGhpcy5yZW5kZXJDb3VudD0wLHRoaXMuZXh0ZXJuYWxSZW5kZXJlcj1udWxsLHRoaXMuY2FtZXJhPW5ldyBKbig0NSwxLC4xLDEwMCksdGhpcy54ckNhbWVyYT1udWxsLHRoaXMudXJsPW51bGwsdGhpcy50YXJnZXQ9bmV3IFZlLHRoaXMubW9kZWxDb250YWluZXI9bmV3IFZlLHRoaXMuYW5pbWF0aW9uTmFtZXM9W10sdGhpcy5ib3VuZGluZ0JveD1uZXcgR3QsdGhpcy5zaXplPW5ldyBCdCx0aGlzLmlkZWFsQ2FtZXJhRGlzdGFuY2U9MCx0aGlzLmZpZWxkT2ZWaWV3QXNwZWN0PTAsdGhpcy5mcmFtZWRGaWVsZE9mVmlldz00NSx0aGlzLnNoYWRvdz1udWxsLHRoaXMuc2hhZG93SW50ZW5zaXR5PTAsdGhpcy5zaGFkb3dTb2Z0bmVzcz0xLHRoaXMuZXhwb3N1cmU9MSx0aGlzLmNhblNjYWxlPSEwLHRoaXMudGlnaHRCb3VuZHM9ITEsdGhpcy5pc0RpcnR5PSExLHRoaXMuZ29hbFRhcmdldD1uZXcgQnQsdGhpcy50YXJnZXREYW1wZXJYPW5ldyB0dSx0aGlzLnRhcmdldERhbXBlclk9bmV3IHR1LHRoaXMudGFyZ2V0RGFtcGVyWj1uZXcgdHUsdGhpcy5fY3VycmVudEdMVEY9bnVsbCx0aGlzLmNhbmNlbFBlbmRpbmdTb3VyY2VDaGFuZ2U9bnVsbCx0aGlzLmFuaW1hdGlvbnNCeU5hbWU9bmV3IE1hcCx0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb249bnVsbCx0aGlzLm5hbWU9XCJNb2RlbFNjZW5lXCIsdGhpcy5lbGVtZW50PWUsdGhpcy5jYW52YXM9dCx0aGlzLmNhbWVyYT1uZXcgSm4oNDUsMSwuMSwxMDApLHRoaXMuY2FtZXJhLm5hbWU9XCJNYWluQ2FtZXJhXCIsdGhpcy5hZGQodGhpcy50YXJnZXQpLHRoaXMuc2V0U2l6ZShuLGkpLHRoaXMudGFyZ2V0Lm5hbWU9XCJUYXJnZXRcIix0aGlzLm1vZGVsQ29udGFpbmVyLm5hbWU9XCJNb2RlbENvbnRhaW5lclwiLHRoaXMudGFyZ2V0LmFkZCh0aGlzLm1vZGVsQ29udGFpbmVyKSx0aGlzLm1peGVyPW5ldyBRbCh0aGlzLm1vZGVsQ29udGFpbmVyKTtjb25zdHtkb21FbGVtZW50OnJ9PXRoaXMuYW5ub3RhdGlvblJlbmRlcmVyLHtzdHlsZTpzfT1yO3MuZGlzcGxheT1cIm5vbmVcIixzLnBvaW50ZXJFdmVudHM9XCJub25lXCIscy5wb3NpdGlvbj1cImFic29sdXRlXCIscy50b3A9XCIwXCIsdGhpcy5lbGVtZW50LnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5kZWZhdWx0XCIpLmFwcGVuZENoaWxkKHIpLHRoaXMuc2NoZW1hRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJhcHBsaWNhdGlvbi9sZCtqc29uXCIpfWNyZWF0ZUNvbnRleHQoKXt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpfWdldENhbWVyYSgpe3JldHVybiBudWxsIT10aGlzLnhyQ2FtZXJhP3RoaXMueHJDYW1lcmE6dGhpcy5jYW1lcmF9cXVldWVSZW5kZXIoKXt0aGlzLmlzRGlydHk9ITB9c2hvdWxkUmVuZGVyKCl7cmV0dXJuIHRoaXMuaXNEaXJ0eX1oYXNSZW5kZXJlZCgpe3RoaXMuaXNEaXJ0eT0hMX1hc3luYyBzZXRPYmplY3QodCl7dGhpcy5yZXNldCgpLHRoaXMubW9kZWxDb250YWluZXIuYWRkKHQpLGF3YWl0IHRoaXMuc2V0dXBTY2VuZSgpfWFzeW5jIHNldFNvdXJjZSh0LGU9KCgpPT57fSkpe2lmKCF0fHx0PT09dGhpcy51cmwpcmV0dXJuIHZvaWQgZSgxKTtpZih0aGlzLnJlc2V0KCksdGhpcy51cmw9dCxudWxsIT10aGlzLmV4dGVybmFsUmVuZGVyZXIpe2NvbnN0IHQ9YXdhaXQgdGhpcy5leHRlcm5hbFJlbmRlcmVyLmxvYWQoZSk7cmV0dXJuIHRoaXMuaWRlYWxDYW1lcmFEaXN0YW5jZT10LmZyYW1lZFJhZGl1cy95dSx0aGlzLmZpZWxkT2ZWaWV3QXNwZWN0PXQuZmllbGRPZlZpZXdBc3BlY3QsdGhpcy5mcmFtZU1vZGVsKCksdm9pZCB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJtb2RlbC1sb2FkXCIsdXJsOnRoaXMudXJsfSl9bGV0IG47bnVsbCE9dGhpcy5jYW5jZWxQZW5kaW5nU291cmNlQ2hhbmdlJiYodGhpcy5jYW5jZWxQZW5kaW5nU291cmNlQ2hhbmdlKCksdGhpcy5jYW5jZWxQZW5kaW5nU291cmNlQ2hhbmdlPW51bGwpO3RyeXtuPWF3YWl0IG5ldyBQcm9taXNlKChhc3luYyhuLGkpPT57dGhpcy5jYW5jZWxQZW5kaW5nU291cmNlQ2hhbmdlPSgpPT5pKCk7dHJ5e24oYXdhaXQgdGhpcy5lbGVtZW50W3ZwXS5sb2FkZXIubG9hZCh0LHRoaXMuZWxlbWVudCxlKSl9Y2F0Y2godCl7aSh0KX19KSl9Y2F0Y2godCl7aWYobnVsbD09dClyZXR1cm47dGhyb3cgdH10aGlzLnJlc2V0KCksdGhpcy51cmw9dCx0aGlzLl9jdXJyZW50R0xURj1uLG51bGwhPW4mJnRoaXMubW9kZWxDb250YWluZXIuYWRkKG4uc2NlbmUpO2NvbnN0e2FuaW1hdGlvbnM6aX09bixyPW5ldyBNYXAscz1bXTtmb3IoY29uc3QgdCBvZiBpKXIuc2V0KHQubmFtZSx0KSxzLnB1c2godC5uYW1lKTt0aGlzLmFuaW1hdGlvbnM9aSx0aGlzLmFuaW1hdGlvbnNCeU5hbWU9cix0aGlzLmFuaW1hdGlvbk5hbWVzPXMsYXdhaXQgdGhpcy5zZXR1cFNjZW5lKCl9YXN5bmMgc2V0dXBTY2VuZSgpe3RoaXMudXBkYXRlQm91bmRpbmdCb3goKTtsZXQgdD1udWxsOyEwPT09dGhpcy50aWdodEJvdW5kcyYmKGF3YWl0IHRoaXMuZWxlbWVudC5yZXF1ZXN0VXBkYXRlKFwiY2FtZXJhVGFyZ2V0XCIpLHQ9dGhpcy5nZXRUYXJnZXQoKSksdGhpcy51cGRhdGVGcmFtaW5nKHQpLHRoaXMuZnJhbWVNb2RlbCgpLHRoaXMudXBkYXRlU2hhZG93KCksdGhpcy5zZXRTaGFkb3dJbnRlbnNpdHkodGhpcy5zaGFkb3dJbnRlbnNpdHkpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTpcIm1vZGVsLWxvYWRcIix1cmw6dGhpcy51cmx9KX1yZXNldCgpe3RoaXMudXJsPW51bGwsdGhpcy5xdWV1ZVJlbmRlcigpLG51bGwhPXRoaXMuc2hhZG93JiZ0aGlzLnNoYWRvdy5zZXRJbnRlbnNpdHkoMCk7Y29uc3QgdD10aGlzLl9jdXJyZW50R0xURjtpZihudWxsIT10KXtmb3IoY29uc3QgdCBvZiB0aGlzLm1vZGVsQ29udGFpbmVyLmNoaWxkcmVuKXRoaXMubW9kZWxDb250YWluZXIucmVtb3ZlKHQpO3QuZGlzcG9zZSgpLHRoaXMuX2N1cnJlbnRHTFRGPW51bGx9bnVsbCE9dGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uJiYodGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uLnN0b3AoKSx0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb249bnVsbCksdGhpcy5taXhlci5zdG9wQWxsQWN0aW9uKCksdGhpcy5taXhlci51bmNhY2hlUm9vdCh0aGlzKX1nZXQgY3VycmVudEdMVEYoKXtyZXR1cm4gdGhpcy5fY3VycmVudEdMVEZ9c2V0U2l6ZSh0LGUpe2lmKHRoaXMud2lkdGghPT10fHx0aGlzLmhlaWdodCE9PWUpe2lmKHRoaXMud2lkdGg9TWF0aC5tYXgodCwxKSx0aGlzLmhlaWdodD1NYXRoLm1heChlLDEpLHRoaXMuYW5ub3RhdGlvblJlbmRlcmVyLnNldFNpemUodCxlKSx0aGlzLmFzcGVjdD10aGlzLndpZHRoL3RoaXMuaGVpZ2h0LHRoaXMuZnJhbWVNb2RlbCgpLG51bGwhPXRoaXMuZXh0ZXJuYWxSZW5kZXJlcil7Y29uc3Qgbj0kaCgpO3RoaXMuZXh0ZXJuYWxSZW5kZXJlci5yZXNpemUodCpuLGUqbil9dGhpcy5xdWV1ZVJlbmRlcigpfX11cGRhdGVCb3VuZGluZ0JveCgpe2lmKHRoaXMudGFyZ2V0LnJlbW92ZSh0aGlzLm1vZGVsQ29udGFpbmVyKSwhMD09PXRoaXMudGlnaHRCb3VuZHMpe2NvbnN0IHQ9KHQsZSk9PnQuZXhwYW5kQnlQb2ludChlKTt0aGlzLmJvdW5kaW5nQm94PWZ1KHRoaXMubW9kZWxDb250YWluZXIsdCxuZXcgR3QpfWVsc2UgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tT2JqZWN0KHRoaXMubW9kZWxDb250YWluZXIpO3RoaXMuYm91bmRpbmdCb3guZ2V0U2l6ZSh0aGlzLnNpemUpLHRoaXMudGFyZ2V0LmFkZCh0aGlzLm1vZGVsQ29udGFpbmVyKX11cGRhdGVGcmFtaW5nKHQ9bnVsbCl7dGhpcy50YXJnZXQucmVtb3ZlKHRoaXMubW9kZWxDb250YWluZXIpLG51bGw9PXQmJih0PXRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKG5ldyBCdCkpO2NvbnN0IGU9TWF0aC5zcXJ0KGZ1KHRoaXMubW9kZWxDb250YWluZXIsKChlLG4pPT5NYXRoLm1heChlLHQuZGlzdGFuY2VUb1NxdWFyZWQobikpKSwwKSk7dGhpcy5pZGVhbENhbWVyYURpc3RhbmNlPWUveXU7dGhpcy5maWVsZE9mVmlld0FzcGVjdD1mdSh0aGlzLm1vZGVsQ29udGFpbmVyLCgoZSxuKT0+e24uc3ViKHQpO2NvbnN0IGk9TWF0aC5zcXJ0KG4ueCpuLngrbi56Km4ueik7cmV0dXJuIE1hdGgubWF4KGUsaS8odGhpcy5pZGVhbENhbWVyYURpc3RhbmNlLU1hdGguYWJzKG4ueSkpKX0pLDApL3h1LHRoaXMudGFyZ2V0LmFkZCh0aGlzLm1vZGVsQ29udGFpbmVyKX1mcmFtZU1vZGVsKCl7Y29uc3QgdD14dSpNYXRoLm1heCgxLHRoaXMuZmllbGRPZlZpZXdBc3BlY3QvdGhpcy5hc3BlY3QpO3RoaXMuZnJhbWVkRmllbGRPZlZpZXc9MipNYXRoLmF0YW4odCkqMTgwL01hdGguUEl9Z2V0TkRDKHQsZSl7aWYobnVsbCE9dGhpcy54ckNhbWVyYSlUdS5zZXQodC93aW5kb3cuc2NyZWVuLndpZHRoLGUvd2luZG93LnNjcmVlbi5oZWlnaHQpO2Vsc2V7Y29uc3Qgbj10aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7VHUuc2V0KCh0LW4ueCkvdGhpcy53aWR0aCwoZS1uLnkpL3RoaXMuaGVpZ2h0KX1yZXR1cm4gVHUubXVsdGlwbHlTY2FsYXIoMikuc3ViU2NhbGFyKDEpLFR1LnkqPS0xLFR1fWdldFNpemUoKXtyZXR1cm57d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHR9fXNldFRhcmdldCh0LGUsbil7dGhpcy5nb2FsVGFyZ2V0LnNldCgtdCwtZSwtbil9c2V0VGFyZ2V0RGFtcGVyRGVjYXlUaW1lKHQpe3RoaXMudGFyZ2V0RGFtcGVyWC5zZXREZWNheVRpbWUodCksdGhpcy50YXJnZXREYW1wZXJZLnNldERlY2F5VGltZSh0KSx0aGlzLnRhcmdldERhbXBlclouc2V0RGVjYXlUaW1lKHQpfWdldFRhcmdldCgpe3JldHVybiBTdS5jb3B5KHRoaXMuZ29hbFRhcmdldCkubXVsdGlwbHlTY2FsYXIoLTEpfWp1bXBUb0dvYWwoKXt0aGlzLnVwZGF0ZVRhcmdldCgxZTQpfXVwZGF0ZVRhcmdldCh0KXtjb25zdCBlPXRoaXMuZ29hbFRhcmdldCxuPXRoaXMudGFyZ2V0LnBvc2l0aW9uO2lmKCFlLmVxdWFscyhuKSl7Y29uc3QgaT10aGlzLmlkZWFsQ2FtZXJhRGlzdGFuY2U7bGV0e3g6cix5OnMsejphfT1uO3I9dGhpcy50YXJnZXREYW1wZXJYLnVwZGF0ZShyLGUueCx0LGkpLHM9dGhpcy50YXJnZXREYW1wZXJZLnVwZGF0ZShzLGUueSx0LGkpLGE9dGhpcy50YXJnZXREYW1wZXJaLnVwZGF0ZShhLGUueix0LGkpLHRoaXMudGFyZ2V0LnBvc2l0aW9uLnNldChyLHMsYSksdGhpcy50YXJnZXQudXBkYXRlTWF0cml4V29ybGQoKSx0aGlzLnNldFNoYWRvd1JvdGF0aW9uKHRoaXMueWF3KSx0aGlzLnF1ZXVlUmVuZGVyKCl9fXBvaW50VG93YXJkcyh0LGUpe2NvbnN0e3g6bix6Oml9PXRoaXMucG9zaXRpb247dGhpcy55YXc9TWF0aC5hdGFuMih0LW4sZS1pKX1zZXQgeWF3KHQpe3RoaXMucm90YXRpb24ueT10LHRoaXMudXBkYXRlTWF0cml4V29ybGQoITApLHRoaXMuc2V0U2hhZG93Um90YXRpb24odCksdGhpcy5xdWV1ZVJlbmRlcigpfWdldCB5YXcoKXtyZXR1cm4gdGhpcy5yb3RhdGlvbi55fXNldCBhbmltYXRpb25UaW1lKHQpe3RoaXMubWl4ZXIuc2V0VGltZSh0KX1nZXQgYW5pbWF0aW9uVGltZSgpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb24/dGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uLnRpbWU6MH1nZXQgZHVyYXRpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uJiZ0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb24uZ2V0Q2xpcCgpP3RoaXMuY3VycmVudEFuaW1hdGlvbkFjdGlvbi5nZXRDbGlwKCkuZHVyYXRpb246MH1nZXQgaGFzQWN0aXZlQW5pbWF0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuY3VycmVudEFuaW1hdGlvbkFjdGlvbn1wbGF5QW5pbWF0aW9uKHQ9bnVsbCxlPTApe2lmKG51bGw9PXRoaXMuX2N1cnJlbnRHTFRGKXJldHVybjtjb25zdHthbmltYXRpb25zOm59PXRoaXM7aWYobnVsbD09bnx8MD09PW4ubGVuZ3RoKXJldHVybiB2b2lkIGNvbnNvbGUud2FybihcIkNhbm5vdCBwbGF5IGFuaW1hdGlvbiAobW9kZWwgZG9lcyBub3QgaGF2ZSBhbnkgYW5pbWF0aW9ucylcIik7bGV0IGk9bnVsbDtudWxsIT10JiYoaT10aGlzLmFuaW1hdGlvbnNCeU5hbWUuZ2V0KHQpKSxudWxsPT1pJiYoaT1uWzBdKTt0cnl7Y29uc3R7Y3VycmVudEFuaW1hdGlvbkFjdGlvbjp0fT10aGlzLG49dGhpcy5taXhlci5jbGlwQWN0aW9uKGksdGhpcyk7dGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uPW4sdGhpcy5lbGVtZW50LnBhdXNlZD90aGlzLm1peGVyLnN0b3BBbGxBY3Rpb24oKTpudWxsIT10JiZuIT09dCYmbi5jcm9zc0ZhZGVGcm9tKHQsZSwhMSksbi5lbmFibGVkPSEwLG4ucGxheSgpfWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IodCl9fXN0b3BBbmltYXRpb24oKXt0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb249bnVsbCx0aGlzLm1peGVyLnN0b3BBbGxBY3Rpb24oKX11cGRhdGVBbmltYXRpb24odCl7dGhpcy5taXhlci51cGRhdGUodCl9dXBkYXRlU2hhZG93KCl7Y29uc3QgdD10aGlzLnNoYWRvdztpZihudWxsIT10KXtjb25zdCBlPVwid2FsbFwiPT09dGhpcy5lbGVtZW50LmFyUGxhY2VtZW50P1wiYmFja1wiOlwiYm90dG9tXCI7dC5zZXRTY2VuZSh0aGlzLHRoaXMuc2hhZG93U29mdG5lc3MsZSksdC5zZXRSb3RhdGlvbih0aGlzLnlhdyl9fXNldFNoYWRvd0ludGVuc2l0eSh0KXtpZih0aGlzLnNoYWRvd0ludGVuc2l0eT10LG51bGwhPXRoaXMuX2N1cnJlbnRHTFRGJiYhKHQ8PTAmJm51bGw9PXRoaXMuc2hhZG93KSl7aWYobnVsbD09dGhpcy5zaGFkb3cpe2NvbnN0IHQ9XCJ3YWxsXCI9PT10aGlzLmVsZW1lbnQuYXJQbGFjZW1lbnQ/XCJiYWNrXCI6XCJib3R0b21cIjt0aGlzLnNoYWRvdz1uZXcgZ3UodGhpcyx0aGlzLnNoYWRvd1NvZnRuZXNzLHQpLHRoaXMuc2hhZG93LnNldFJvdGF0aW9uKHRoaXMueWF3KX10aGlzLnNoYWRvdy5zZXRJbnRlbnNpdHkodCl9fXNldFNoYWRvd1NvZnRuZXNzKHQpe3RoaXMuc2hhZG93U29mdG5lc3M9dDtjb25zdCBlPXRoaXMuc2hhZG93O251bGwhPWUmJmUuc2V0U29mdG5lc3ModCl9c2V0U2hhZG93Um90YXRpb24odCl7Y29uc3QgZT10aGlzLnNoYWRvdztudWxsIT1lJiZlLnNldFJvdGF0aW9uKHQpfWlzU2hhZG93RGlydHkoKXtjb25zdCB0PXRoaXMuc2hhZG93O2lmKG51bGw9PXQpcmV0dXJuITE7e2NvbnN0e25lZWRzVXBkYXRlOmV9PXQ7cmV0dXJuIHQubmVlZHNVcGRhdGU9ITEsZX19c2V0U2hhZG93U2NhbGVBbmRPZmZzZXQodCxlKXtjb25zdCBuPXRoaXMuc2hhZG93O251bGwhPW4mJm4uc2V0U2NhbGVBbmRPZmZzZXQodCxlKX1nZXQgcmF5Y2FzdGVyKCl7cmV0dXJuIE11fXBvc2l0aW9uQW5kTm9ybWFsRnJvbVBvaW50KHQsZT10aGlzKXt0aGlzLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHQsdGhpcy5nZXRDYW1lcmEoKSk7Y29uc3Qgbj10aGlzLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QoZSwhMCk7aWYoMD09PW4ubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IGk9blswXTtyZXR1cm4gbnVsbD09aS5mYWNlP251bGw6KGkuZmFjZS5ub3JtYWwuYXBwbHlOb3JtYWxNYXRyaXgoKG5ldyBMdCkuZ2V0Tm9ybWFsTWF0cml4KGkub2JqZWN0Lm1hdHJpeFdvcmxkKSkse3Bvc2l0aW9uOmkucG9pbnQsbm9ybWFsOmkuZmFjZS5ub3JtYWx9KX1hZGRIb3RzcG90KHQpe3RoaXMudGFyZ2V0LmFkZCh0KSx0aGlzLmFubm90YXRpb25SZW5kZXJlci5kb21FbGVtZW50LmFwcGVuZENoaWxkKHQuZWxlbWVudCl9cmVtb3ZlSG90c3BvdCh0KXt0aGlzLnRhcmdldC5yZW1vdmUodCl9Zm9ySG90c3BvdHModCl7Y29uc3R7Y2hpbGRyZW46ZX09dGhpcy50YXJnZXQ7Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXtjb25zdCBpPWVbbl07aSBpbnN0YW5jZW9mIG11JiZ0KGkpfX11cGRhdGVIb3RzcG90cyh0KXt0aGlzLmZvckhvdHNwb3RzKChlPT57YnUuY29weSh0KSx3dS5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS5tYXRyaXhXb3JsZCksYnUuc3ViKHd1KSxfdS5jb3B5KGUubm9ybWFsKS50cmFuc2Zvcm1EaXJlY3Rpb24odGhpcy50YXJnZXQubWF0cml4V29ybGQpLGJ1LmRvdChfdSk8MD9lLmhpZGUoKTplLnNob3coKX0pKX1vcmllbnRIb3RzcG90cyh0KXt0aGlzLmZvckhvdHNwb3RzKChlPT57ZS5vcmllbnQodCl9KSl9c2V0SG90c3BvdHNWaXNpYmlsaXR5KHQpe3RoaXMuZm9ySG90c3BvdHMoKGU9PntlLnZpc2libGU9dH0pKX11cGRhdGVTY2hlbWEodCl7dmFyIGU7Y29uc3R7c2NoZW1hRWxlbWVudDpuLGVsZW1lbnQ6aX09dGhpcyx7YWx0OnIscG9zdGVyOnMsaW9zU3JjOmF9PWk7aWYobnVsbCE9dCl7Y29uc3QgaT1be1wiQHR5cGVcIjpcIk1lZGlhT2JqZWN0XCIsY29udGVudFVybDp0LGVuY29kaW5nRm9ybWF0OlwiZ2x0ZlwiPT09KG51bGw9PT0oZT10LnNwbGl0KFwiLlwiKS5wb3AoKSl8fHZvaWQgMD09PWU/dm9pZCAwOmUudG9Mb3dlckNhc2UoKSk/XCJtb2RlbC9nbHRmK2pzb25cIjpcIm1vZGVsL2dsdGYtYmluYXJ5XCJ9XTthJiZpLnB1c2goe1wiQHR5cGVcIjpcIk1lZGlhT2JqZWN0XCIsY29udGVudFVybDphLGVuY29kaW5nRm9ybWF0OlwibW9kZWwvdm5kLnVzZHoremlwXCJ9KTtjb25zdCBvPXtcIkBjb250ZXh0XCI6XCJodHRwOi8vc2NoZW1hLm9yZy9cIixcIkB0eXBlXCI6XCIzRE1vZGVsXCIsaW1hZ2U6bnVsbCE9cz9zOnZvaWQgMCxuYW1lOm51bGwhPXI/cjp2b2lkIDAsZW5jb2Rpbmc6aX07bi50ZXh0Q29udGVudD1KU09OLnN0cmluZ2lmeShvKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG4pfWVsc2UgbnVsbCE9bi5wYXJlbnRFbGVtZW50JiZuLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQobil9fWNvbnN0IEF1PWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgYmkoe3VuaWZvcm1zOntyb3VnaG5lc3NNYXA6e3ZhbHVlOm51bGx9LG5vcm1hbE1hcDp7dmFsdWU6bnVsbH0sdGV4ZWxTaXplOnt2YWx1ZTpuZXcgQXQoMSwxKX19LHZlcnRleFNoYWRlcjpcIlxcblxcdFxcdFxcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcdFxcdFxcdHByZWNpc2lvbiBtZWRpdW1wIGludDtcXG5cXG5cXHRcXHRcXHRhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5cXHRcXHRcXHRhdHRyaWJ1dGUgdmVjMiB1djtcXG5cXG5cXHRcXHRcXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcblxcdFxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHRcXHR2VXYgPSB1djtcXG5cXG5cXHRcXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIsZnJhZ21lbnRTaGFkZXI6XCJcXG5cXHRcXHRcXHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXHRcXHRcXHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XFxuXFxuXFx0XFx0XFx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuXFx0XFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblxcdFxcdFxcdHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxuXFxuXFx0XFx0XFx0I2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBUZXhlbFRvTGluZWFyKCB2ZWM0IGEgKSB7IHJldHVybiBhOyB9XFxuXFxuXFx0XFx0XFx0I2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG5cXG5cXHRcXHRcXHRmbG9hdCByb3VnaG5lc3NUb1ZhcmlhbmNlKCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgdmFyaWFuY2UgPSAwLjA7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByb3VnaG5lc3MgPj0gcjEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyaWFuY2UgPSAoIHIwIC0gcm91Z2huZXNzICkgKiAoIHYxIC0gdjAgKSAvICggcjAgLSByMSApICsgdjA7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IHI0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhcmlhbmNlID0gKCByMSAtIHJvdWdobmVzcyApICogKCB2NCAtIHYxICkgLyAoIHIxIC0gcjQgKSArIHYxO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSByNSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXJpYW5jZSA9ICggcjQgLSByb3VnaG5lc3MgKSAqICggdjUgLSB2NCApIC8gKCByNCAtIHI1ICkgKyB2NDtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGZsb2F0IHJvdWdobmVzczIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyaWFuY2UgPSAxLjc5ICogcm91Z2huZXNzMiAqIHJvdWdobmVzczI7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB2YXJpYW5jZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZmxvYXQgdmFyaWFuY2VUb1JvdWdobmVzcyggZmxvYXQgdmFyaWFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgcm91Z2huZXNzID0gMC4wO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmFyaWFuY2UgPj0gdjEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cm91Z2huZXNzID0gKCB2MCAtIHZhcmlhbmNlICkgKiAoIHIxIC0gcjAgKSAvICggdjAgLSB2MSApICsgcjA7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggdmFyaWFuY2UgPj0gdjQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cm91Z2huZXNzID0gKCB2MSAtIHZhcmlhbmNlICkgKiAoIHI0IC0gcjEgKSAvICggdjEgLSB2NCApICsgcjE7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggdmFyaWFuY2UgPj0gdjUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cm91Z2huZXNzID0gKCB2NCAtIHZhcmlhbmNlICkgKiAoIHI1IC0gcjQgKSAvICggdjQgLSB2NSApICsgcjQ7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyb3VnaG5lc3MgPSBwb3coIDAuNTU5ICogdmFyaWFuY2UsIDAuMjUgKTsgLy8gMC41NTkgPSAxLjAgLyAxLjc5XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiByb3VnaG5lc3M7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2LCAtIDEuMCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4ZWxTaXplLnggPT0gMC4wICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IGdsX0ZyYWdDb2xvci5nO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHZhcmlhbmNlID0gcm91Z2huZXNzVG9WYXJpYW5jZSggcm91Z2huZXNzICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBhdmdOb3JtYWw7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggZmxvYXQgeCA9IC0gMS4wOyB4IDwgMi4wOyB4ICs9IDIuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBmbG9hdCB5ID0gLSAxLjA7IHkgPCAyLjA7IHkgKz0gMi4wICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZlYzIgdXYgPSB2VXYgKyB2ZWMyKCB4LCB5ICkgKiAwLjI1ICogdGV4ZWxTaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGF2Z05vcm1hbCArPSBub3JtYWxpemUoIHRleHR1cmUyRCggbm9ybWFsTWFwLCB1diwgLSAxLjAgKS54eXogLSAwLjUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhcmlhbmNlICs9IDEuMCAtIDAuMjUgKiBsZW5ndGgoIGF2Z05vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvci5nID0gdmFyaWFuY2VUb1JvdWdobmVzcyggdmFyaWFuY2UgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIsYmxlbmRpbmc6MCxkZXB0aFRlc3Q6ITEsZGVwdGhXcml0ZTohMX0pO3JldHVybiB0LnR5cGU9XCJSb3VnaG5lc3NNaXBtYXBwZXJcIix0fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLygpLEx1PW5ldyBWbihuZXcgY2koMiwyKSxBdSksUnU9bmV3IHhpKDAsMSwwLDEsMCwxKTtsZXQgQ3U9bnVsbCxQdT1udWxsO2NsYXNzIEl1e2NvbnN0cnVjdG9yKHQpe1B1PXQsUHUuY29tcGlsZShMdSxSdSl9Z2VuZXJhdGVNaXBtYXBzKHQpe2lmKFwicm91Z2huZXNzTWFwXCJpbiB0PT0hMSlyZXR1cm47Y29uc3R7cm91Z2huZXNzTWFwOmUsbm9ybWFsTWFwOm59PXQ7aWYobnVsbD09PWV8fG51bGw9PT1ufHwhZS5nZW5lcmF0ZU1pcG1hcHN8fHQudXNlckRhdGEucm91Z2huZXNzVXBkYXRlZClyZXR1cm47dC51c2VyRGF0YS5yb3VnaG5lc3NVcGRhdGVkPSEwO2xldCBpPU1hdGgubWF4KGUuaW1hZ2Uud2lkdGgsbi5pbWFnZS53aWR0aCkscj1NYXRoLm1heChlLmltYWdlLmhlaWdodCxuLmltYWdlLmhlaWdodCk7aWYoIUV0LmlzUG93ZXJPZlR3byhpKXx8IUV0LmlzUG93ZXJPZlR3byhyKSlyZXR1cm47Y29uc3Qgcz1QdS5nZXRSZW5kZXJUYXJnZXQoKSxhPVB1LmF1dG9DbGVhcjtpZihQdS5hdXRvQ2xlYXI9ITEsbnVsbCE9PUN1JiZDdS53aWR0aD09PWkmJkN1LmhlaWdodD09PXJ8fChudWxsIT09Q3UmJkN1LmRpc3Bvc2UoKSxDdT1uZXcgVXQoaSxyLHtkZXB0aEJ1ZmZlcjohMX0pLEN1LnNjaXNzb3JUZXN0PSEwKSxpIT09ZS5pbWFnZS53aWR0aHx8ciE9PWUuaW1hZ2UuaGVpZ2h0KXtjb25zdCBuPXt3cmFwUzplLndyYXBTLHdyYXBUOmUud3JhcFQsbWFnRmlsdGVyOmUubWFnRmlsdGVyLG1pbkZpbHRlcjplLm1pbkZpbHRlcixkZXB0aEJ1ZmZlcjohMX0scz1uZXcgVXQoaSxyLG4pO3MudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM9ITAsUHUuc2V0UmVuZGVyVGFyZ2V0KHMpLHQucm91Z2huZXNzTWFwPXMudGV4dHVyZSx0Lm1ldGFsbmVzc01hcD09ZSYmKHQubWV0YWxuZXNzTWFwPXQucm91Z2huZXNzTWFwKSx0LmFvTWFwPT1lJiYodC5hb01hcD10LnJvdWdobmVzc01hcCksdC5yb3VnaG5lc3NNYXAub2Zmc2V0LmNvcHkoZS5vZmZzZXQpLHQucm91Z2huZXNzTWFwLnJlcGVhdC5jb3B5KGUucmVwZWF0KSx0LnJvdWdobmVzc01hcC5jZW50ZXIuY29weShlLmNlbnRlciksdC5yb3VnaG5lc3NNYXAucm90YXRpb249ZS5yb3RhdGlvbix0LnJvdWdobmVzc01hcC5tYXRyaXhBdXRvVXBkYXRlPWUubWF0cml4QXV0b1VwZGF0ZSx0LnJvdWdobmVzc01hcC5tYXRyaXguY29weShlLm1hdHJpeCl9QXUudW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlPWUsQXUudW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlPW47Y29uc3Qgbz1uZXcgQXQoMCwwKSxsPUF1LnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZTtmb3IobGV0IGU9MDtpPj0xJiZyPj0xOysrZSxpLz0yLHIvPTIpbC5zZXQoMS9pLDEvciksMD09ZSYmbC5zZXQoMCwwKSxDdS52aWV3cG9ydC5zZXQoby54LG8ueSxpLHIpLEN1LnNjaXNzb3Iuc2V0KG8ueCxvLnksaSxyKSxQdS5zZXRSZW5kZXJUYXJnZXQoQ3UpLFB1LnJlbmRlcihMdSxSdSksUHUuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlKG8sdC5yb3VnaG5lc3NNYXAsZSksQXUudW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlPXQucm91Z2huZXNzTWFwO2UhPT10LnJvdWdobmVzc01hcCYmZS5kaXNwb3NlKCksUHUuc2V0UmVuZGVyVGFyZ2V0KHMpLFB1LmF1dG9DbGVhcj1hfWRpc3Bvc2UoKXtBdS5kaXNwb3NlKCksTHUuZ2VvbWV0cnkuZGlzcG9zZSgpLG51bGwhPUN1JiZDdS5kaXNwb3NlKCl9fXZhciBEdT1mdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHIscz1hcmd1bWVudHMubGVuZ3RoLGE9czwzP2U6bnVsbD09PWk/aT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik6aSxvPXQubGVuZ3RoLTE7bz49MDtvLS0pKHI9dFtvXSkmJihhPShzPDM/cihhKTpzPjM/cihlLG4sYSk6cihlLG4pKXx8YSk7cmV0dXJuIHM+MyYmYSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbixhKSxhfTtjb25zdCBOdT1TeW1ib2woXCJjdXJyZW50RW52aXJvbm1lbnRNYXBcIiksRnU9U3ltYm9sKFwiYXBwbHlFbnZpcm9ubWVudE1hcFwiKSxPdT1TeW1ib2woXCJ1cGRhdGVFbnZpcm9ubWVudFwiKSxVdT1TeW1ib2woXCJjYW5jZWxFbnZpcm9ubWVudFVwZGF0ZVwiKSxrdT1TeW1ib2woXCJvblByZWxvYWRcIik7Y2xhc3MgenV7Y29uc3RydWN0b3IodCxlLG4saSxyKXt0aGlzLnhyTGlnaHQ9dCx0aGlzLnJlbmRlcmVyPWUsdGhpcy5saWdodFByb2JlPW4sdGhpcy54cldlYkdMQmluZGluZz1udWxsLHRoaXMuZXN0aW1hdGlvblN0YXJ0Q2FsbGJhY2s9cix0aGlzLmZyYW1lQ2FsbGJhY2s9dGhpcy5vblhSRnJhbWUuYmluZCh0aGlzKTtjb25zdCBzPWUueHIuZ2V0U2Vzc2lvbigpO2lmKGkmJlwiWFJXZWJHTEJpbmRpbmdcImluIHdpbmRvdyl7Y29uc3Qgbj1uZXcgUW4oMTYpO3QuZW52aXJvbm1lbnQ9bi50ZXh0dXJlO2NvbnN0IGk9ZS5nZXRDb250ZXh0KCk7c3dpdGNoKHMucHJlZmVycmVkUmVmbGVjdGlvbkZvcm1hdCl7Y2FzZVwic3JnYmE4XCI6aS5nZXRFeHRlbnNpb24oXCJFWFRfc1JHQlwiKTticmVhaztjYXNlXCJyZ2JhMTZmXCI6aS5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpfXRoaXMueHJXZWJHTEJpbmRpbmc9bmV3IFhSV2ViR0xCaW5kaW5nKHMsaSksdGhpcy5saWdodFByb2JlLmFkZEV2ZW50TGlzdGVuZXIoXCJyZWZsZWN0aW9uY2hhbmdlXCIsKCgpPT57dGhpcy51cGRhdGVSZWZsZWN0aW9uKCl9KSl9cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5mcmFtZUNhbGxiYWNrKX11cGRhdGVSZWZsZWN0aW9uKCl7Y29uc3QgdD10aGlzLnJlbmRlcmVyLnByb3BlcnRpZXMuZ2V0KHRoaXMueHJMaWdodC5lbnZpcm9ubWVudCk7aWYodCl7Y29uc3QgZT10aGlzLnhyV2ViR0xCaW5kaW5nLmdldFJlZmxlY3Rpb25DdWJlTWFwKHRoaXMubGlnaHRQcm9iZSk7ZSYmKHQuX193ZWJnbFRleHR1cmU9ZSl9fW9uWFJGcmFtZSh0LGUpe2lmKCF0aGlzLnhyTGlnaHQpcmV0dXJuO2Uuc2Vzc2lvbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5mcmFtZUNhbGxiYWNrKTtjb25zdCBuPWUuZ2V0TGlnaHRFc3RpbWF0ZSh0aGlzLmxpZ2h0UHJvYmUpO2lmKG4pe3RoaXMueHJMaWdodC5saWdodFByb2JlLnNoLmZyb21BcnJheShuLnNwaGVyaWNhbEhhcm1vbmljc0NvZWZmaWNpZW50cyksdGhpcy54ckxpZ2h0LmxpZ2h0UHJvYmUuaW50ZW5zaXR5PTE7Y29uc3QgdD1NYXRoLm1heCgxLE1hdGgubWF4KG4ucHJpbWFyeUxpZ2h0SW50ZW5zaXR5LngsTWF0aC5tYXgobi5wcmltYXJ5TGlnaHRJbnRlbnNpdHkueSxuLnByaW1hcnlMaWdodEludGVuc2l0eS56KSkpO3RoaXMueHJMaWdodC5kaXJlY3Rpb25hbExpZ2h0LmNvbG9yLnNldFJHQihuLnByaW1hcnlMaWdodEludGVuc2l0eS54L3Qsbi5wcmltYXJ5TGlnaHRJbnRlbnNpdHkueS90LG4ucHJpbWFyeUxpZ2h0SW50ZW5zaXR5LnovdCksdGhpcy54ckxpZ2h0LmRpcmVjdGlvbmFsTGlnaHQuaW50ZW5zaXR5PXQsdGhpcy54ckxpZ2h0LmRpcmVjdGlvbmFsTGlnaHQucG9zaXRpb24uY29weShuLnByaW1hcnlMaWdodERpcmVjdGlvbiksdGhpcy5lc3RpbWF0aW9uU3RhcnRDYWxsYmFjayYmKHRoaXMuZXN0aW1hdGlvblN0YXJ0Q2FsbGJhY2soKSx0aGlzLmVzdGltYXRpb25TdGFydENhbGxiYWNrPW51bGwpfX1kaXNwb3NlKCl7dGhpcy54ckxpZ2h0PW51bGwsdGhpcy5yZW5kZXJlcj1udWxsLHRoaXMubGlnaHRQcm9iZT1udWxsLHRoaXMueHJXZWJHTEJpbmRpbmc9bnVsbH19Y2xhc3MgQnUgZXh0ZW5kcyBWc3tjb25zdHJ1Y3Rvcih0LGU9ITApe3N1cGVyKCksdGhpcy5saWdodFByb2JlPW5ldyBPbCx0aGlzLmxpZ2h0UHJvYmUuaW50ZW5zaXR5PTAsdGhpcy5hZGQodGhpcy5saWdodFByb2JlKSx0aGlzLmRpcmVjdGlvbmFsTGlnaHQ9bmV3IE5sLHRoaXMuZGlyZWN0aW9uYWxMaWdodC5pbnRlbnNpdHk9MCx0aGlzLmFkZCh0aGlzLmRpcmVjdGlvbmFsTGlnaHQpLHRoaXMuZW52aXJvbm1lbnQ9bnVsbDtsZXQgbj1udWxsLGk9ITE7dC54ci5hZGRFdmVudExpc3RlbmVyKFwic2Vzc2lvbnN0YXJ0XCIsKCgpPT57Y29uc3Qgcj10LnhyLmdldFNlc3Npb24oKTtcInJlcXVlc3RMaWdodFByb2JlXCJpbiByJiZyLnJlcXVlc3RMaWdodFByb2JlKHtyZWZsZWN0aW9uRm9ybWF0OnIucHJlZmVycmVkUmVmbGVjdGlvbkZvcm1hdH0pLnRoZW4oKHI9PntuPW5ldyB6dSh0aGlzLHQscixlLCgoKT0+e2k9ITAsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZXN0aW1hdGlvbnN0YXJ0XCJ9KX0pKX0pKX0pKSx0LnhyLmFkZEV2ZW50TGlzdGVuZXIoXCJzZXNzaW9uZW5kXCIsKCgpPT57biYmKG4uZGlzcG9zZSgpLG49bnVsbCksaSYmdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZXN0aW1hdGlvbmVuZFwifSl9KSksdGhpcy5kaXNwb3NlPSgpPT57biYmKG4uZGlzcG9zZSgpLG49bnVsbCksdGhpcy5yZW1vdmUodGhpcy5saWdodFByb2JlKSx0aGlzLmxpZ2h0UHJvYmU9bnVsbCx0aGlzLnJlbW92ZSh0aGlzLmRpcmVjdGlvbmFsTGlnaHQpLHRoaXMuZGlyZWN0aW9uYWxMaWdodD1udWxsLHRoaXMuZW52aXJvbm1lbnQ9bnVsbH19fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL2NvbnN0IEh1PU1hdGguUEkvMjQsVnU9bmV3IEF0LEd1PSh0LGUsbik9PntsZXQgaT1lPjA/bj4wPzA6LU1hdGguUEkvMjpuPjA/TWF0aC5QSS8yOk1hdGguUEk7Zm9yKGxldCByPTA7cjw9MTI7KytyKXQucHVzaChlKy4xNypNYXRoLmNvcyhpKSxuKy4xNypNYXRoLnNpbihpKSwwLGUrLjIqTWF0aC5jb3MoaSksbisuMipNYXRoLnNpbihpKSwwKSxpKz1IdX07Y2xhc3MgV3UgZXh0ZW5kcyBWbntjb25zdHJ1Y3Rvcih0LGUpe2NvbnN0IG49bmV3IFNuLGk9W10scj1bXSx7c2l6ZTpzLGJvdW5kaW5nQm94OmF9PXQsbz1zLngvMixsPShcImJhY2tcIj09PWU/cy55OnMueikvMjtHdShyLG8sbCksR3UociwtbyxsKSxHdShyLC1vLC1sKSxHdShyLG8sLWwpO2NvbnN0IGM9ci5sZW5ndGgvMztmb3IobGV0IHQ9MDt0PGMtMjt0Kz0yKWkucHVzaCh0LHQrMSx0KzMsdCx0KzMsdCsyKTtjb25zdCBoPWMtMjtpLnB1c2goaCxoKzEsMSxoLDEsMCksbi5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBnbihyLDMpKSxuLnNldEluZGV4KGkpLHN1cGVyKG4pLHRoaXMuc2lkZT1lO2NvbnN0IHU9dGhpcy5tYXRlcmlhbDtzd2l0Y2godS5zaWRlPTIsdS50cmFuc3BhcmVudD0hMCx1Lm9wYWNpdHk9MCx0aGlzLmdvYWxPcGFjaXR5PTAsdGhpcy5vcGFjaXR5RGFtcGVyPW5ldyB0dSx0aGlzLmhpdFBsYW5lPW5ldyBWbihuZXcgY2koMioobysuMiksMioobCsuMikpKSx0aGlzLmhpdFBsYW5lLnZpc2libGU9ITEsdGhpcy5hZGQodGhpcy5oaXRQbGFuZSksYS5nZXRDZW50ZXIodGhpcy5wb3NpdGlvbiksZSl7Y2FzZVwiYm90dG9tXCI6dGhpcy5yb3RhdGVYKC1NYXRoLlBJLzIpLHRoaXMuc2hhZG93SGVpZ2h0PWEubWluLnksdGhpcy5wb3NpdGlvbi55PXRoaXMuc2hhZG93SGVpZ2h0O2JyZWFrO2Nhc2VcImJhY2tcIjp0aGlzLnNoYWRvd0hlaWdodD1hLm1pbi56LHRoaXMucG9zaXRpb24uej10aGlzLnNoYWRvd0hlaWdodH10LnRhcmdldC5hZGQodGhpcyl9Z2V0SGl0KHQsZSxuKXtWdS5zZXQoZSwtbiksdGhpcy5oaXRQbGFuZS52aXNpYmxlPSEwO2NvbnN0IGk9dC5wb3NpdGlvbkFuZE5vcm1hbEZyb21Qb2ludChWdSx0aGlzLmhpdFBsYW5lKTtyZXR1cm4gdGhpcy5oaXRQbGFuZS52aXNpYmxlPSExLG51bGw9PWk/bnVsbDppLnBvc2l0aW9ufWdldEV4cGFuZGVkSGl0KHQsZSxuKXt0aGlzLmhpdFBsYW5lLnNjYWxlLnNldCgxZTMsMWUzLDFlMyk7Y29uc3QgaT10aGlzLmdldEhpdCh0LGUsbik7cmV0dXJuIHRoaXMuaGl0UGxhbmUuc2NhbGUuc2V0KDEsMSwxKSxpfXNldCBvZmZzZXRIZWlnaHQodCl7XCJiYWNrXCI9PT10aGlzLnNpZGU/dGhpcy5wb3NpdGlvbi56PXRoaXMuc2hhZG93SGVpZ2h0K3Q6dGhpcy5wb3NpdGlvbi55PXRoaXMuc2hhZG93SGVpZ2h0K3R9Z2V0IG9mZnNldEhlaWdodCgpe3JldHVyblwiYmFja1wiPT09dGhpcy5zaWRlP3RoaXMucG9zaXRpb24uei10aGlzLnNoYWRvd0hlaWdodDp0aGlzLnBvc2l0aW9uLnktdGhpcy5zaGFkb3dIZWlnaHR9c2V0IHNob3codCl7dGhpcy5nb2FsT3BhY2l0eT10Py43NTowfXVwZGF0ZU9wYWNpdHkodCl7Y29uc3QgZT10aGlzLm1hdGVyaWFsO2Uub3BhY2l0eT10aGlzLm9wYWNpdHlEYW1wZXIudXBkYXRlKGUub3BhY2l0eSx0aGlzLmdvYWxPcGFjaXR5LHQsMSksdGhpcy52aXNpYmxlPWUub3BhY2l0eT4wfWRpc3Bvc2UoKXt2YXIgdDtjb25zdHtnZW9tZXRyeTplLG1hdGVyaWFsOm59PXRoaXMuaGl0UGxhbmU7ZS5kaXNwb3NlKCksbi5kaXNwb3NlKCksdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCksdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCksbnVsbD09PSh0PXRoaXMucGFyZW50KXx8dm9pZCAwPT09dHx8dC5yZW1vdmUodGhpcyl9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL2NvbnN0IGp1PVwibm90LXByZXNlbnRpbmdcIixxdT1cInNlc3Npb24tc3RhcnRlZFwiLFh1PVwib2JqZWN0LXBsYWNlZFwiLFl1PVwiZmFpbGVkXCIsWnU9XCJ0cmFja2luZ1wiLEp1PVwibm90LXRyYWNraW5nXCIsJHU9bmV3IEJ0LEt1PW5ldyB2ZSxRdT1uZXcgQnQsdGQ9bmV3IEpuKDQ1LDEsLjEsMTAwKTtjbGFzcyBlZCBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5yZW5kZXJlcj10LHRoaXMuY3VycmVudFNlc3Npb249bnVsbCx0aGlzLnBsYWNlT25XYWxsPSExLHRoaXMucGxhY2VtZW50Qm94PW51bGwsdGhpcy5sYXN0VGljaz1udWxsLHRoaXMudHVybnRhYmxlUm90YXRpb249bnVsbCx0aGlzLm9sZFNoYWRvd0ludGVuc2l0eT1udWxsLHRoaXMub2xkQmFja2dyb3VuZD1udWxsLHRoaXMub2xkRW52aXJvbm1lbnQ9bnVsbCx0aGlzLmZyYW1lPW51bGwsdGhpcy5pbml0aWFsSGl0U291cmNlPW51bGwsdGhpcy50cmFuc2llbnRIaXRUZXN0U291cmNlPW51bGwsdGhpcy5pbnB1dFNvdXJjZT1udWxsLHRoaXMuX3ByZXNlbnRlZFNjZW5lPW51bGwsdGhpcy5yZXNvbHZlQ2xlYW51cD1udWxsLHRoaXMuZXhpdFdlYlhSQnV0dG9uQ29udGFpbmVyPW51bGwsdGhpcy5vdmVybGF5PW51bGwsdGhpcy54ckxpZ2h0PW51bGwsdGhpcy50cmFja2luZz0hMCx0aGlzLmZyYW1lcz0wLHRoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5vbGRUYXJnZXQ9bmV3IEJ0LHRoaXMub2xkRnJhbWVkRmllbGRPZlZpZXc9NDUsdGhpcy5wbGFjZW1lbnRDb21wbGV0ZT0hMSx0aGlzLmlzVHJhbnNsYXRpbmc9ITEsdGhpcy5pc1JvdGF0aW5nPSExLHRoaXMuaXNUd29GaW5nZXJpbmc9ITEsdGhpcy5sYXN0RHJhZ1Bvc2l0aW9uPW5ldyBCdCx0aGlzLmZpcnN0UmF0aW89MCx0aGlzLmxhc3RBbmdsZT0wLHRoaXMuZ29hbFBvc2l0aW9uPW5ldyBCdCx0aGlzLmdvYWxZYXc9MCx0aGlzLmdvYWxTY2FsZT0xLHRoaXMueERhbXBlcj1uZXcgdHUsdGhpcy55RGFtcGVyPW5ldyB0dSx0aGlzLnpEYW1wZXI9bmV3IHR1LHRoaXMueWF3RGFtcGVyPW5ldyB0dSx0aGlzLnNjYWxlRGFtcGVyPW5ldyB0dSx0aGlzLm9uRXhpdFdlYlhSQnV0dG9uQ29udGFpbmVyQ2xpY2s9KCk9PnRoaXMuc3RvcFByZXNlbnRpbmcoKSx0aGlzLm9uVXBkYXRlU2NlbmU9KCk9PntudWxsIT10aGlzLnBsYWNlbWVudEJveCYmdGhpcy5pc1ByZXNlbnRpbmcmJih0aGlzLnBsYWNlbWVudEJveC5kaXNwb3NlKCksdGhpcy5wbGFjZW1lbnRCb3g9bmV3IFd1KHRoaXMucHJlc2VudGVkU2NlbmUsdGhpcy5wbGFjZU9uV2FsbD9cImJhY2tcIjpcImJvdHRvbVwiKSl9LHRoaXMub25TZWxlY3RTdGFydD10PT57Y29uc3QgZT10aGlzLnRyYW5zaWVudEhpdFRlc3RTb3VyY2U7aWYobnVsbD09ZSlyZXR1cm47Y29uc3Qgbj10aGlzLmZyYW1lLmdldEhpdFRlc3RSZXN1bHRzRm9yVHJhbnNpZW50SW5wdXQoZSksaT10aGlzLnByZXNlbnRlZFNjZW5lLHI9dGhpcy5wbGFjZW1lbnRCb3g7aWYoMT09PW4ubGVuZ3RoKXt0aGlzLmlucHV0U291cmNlPXQuaW5wdXRTb3VyY2U7Y29uc3R7YXhlczplfT10aGlzLmlucHV0U291cmNlLmdhbWVwYWQsbj1yLmdldEhpdCh0aGlzLnByZXNlbnRlZFNjZW5lLGVbMF0sZVsxXSk7ci5zaG93PSEwLG51bGwhPW4/KHRoaXMuaXNUcmFuc2xhdGluZz0hMCx0aGlzLmxhc3REcmFnUG9zaXRpb24uY29weShuKSk6ITE9PT10aGlzLnBsYWNlT25XYWxsJiYodGhpcy5pc1JvdGF0aW5nPSEwLHRoaXMubGFzdEFuZ2xlPTEuNSplWzBdKX1lbHNlIGlmKDI9PT1uLmxlbmd0aCl7ci5zaG93PSEwLHRoaXMuaXNUd29GaW5nZXJpbmc9ITA7Y29uc3R7c2VwYXJhdGlvbjp0fT10aGlzLmZpbmdlclBvbGFyKG4pO3RoaXMuZmlyc3RSYXRpbz10L2kuc2NhbGUueH19LHRoaXMub25TZWxlY3RFbmQ9KCk9Pnt0aGlzLmlzVHJhbnNsYXRpbmc9ITEsdGhpcy5pc1JvdGF0aW5nPSExLHRoaXMuaXNUd29GaW5nZXJpbmc9ITEsdGhpcy5pbnB1dFNvdXJjZT1udWxsLHRoaXMuZ29hbFBvc2l0aW9uLnkrPXRoaXMucGxhY2VtZW50Qm94Lm9mZnNldEhlaWdodCp0aGlzLnByZXNlbnRlZFNjZW5lLnNjYWxlLngsdGhpcy5wbGFjZW1lbnRCb3guc2hvdz0hMX0sdGhpcy50aHJlZVJlbmRlcmVyPXQudGhyZWVSZW5kZXJlcix0aGlzLnRocmVlUmVuZGVyZXIueHIuZW5hYmxlZD0hMH1hc3luYyByZXNvbHZlQVJTZXNzaW9uKCl7WGgoKTtjb25zdCB0PWF3YWl0IG5hdmlnYXRvci54ci5yZXF1ZXN0U2Vzc2lvbihcImltbWVyc2l2ZS1hclwiLHtyZXF1aXJlZEZlYXR1cmVzOltcImhpdC10ZXN0XCJdLG9wdGlvbmFsRmVhdHVyZXM6W1wiZG9tLW92ZXJsYXlcIixcImxpZ2h0LWVzdGltYXRpb25cIl0sZG9tT3ZlcmxheTp7cm9vdDp0aGlzLm92ZXJsYXl9fSk7cmV0dXJuIHRoaXMudGhyZWVSZW5kZXJlci54ci5zZXRSZWZlcmVuY2VTcGFjZVR5cGUoXCJsb2NhbFwiKSxhd2FpdCB0aGlzLnRocmVlUmVuZGVyZXIueHIuc2V0U2Vzc2lvbih0KSx0aGlzLnRocmVlUmVuZGVyZXIueHIuY2FtZXJhQXV0b1VwZGF0ZT0hMSx0fWdldCBwcmVzZW50ZWRTY2VuZSgpe3JldHVybiB0aGlzLl9wcmVzZW50ZWRTY2VuZX1hc3luYyBzdXBwb3J0c1ByZXNlbnRhdGlvbigpe3RyeXtyZXR1cm4gWGgoKSxhd2FpdCBuYXZpZ2F0b3IueHIuaXNTZXNzaW9uU3VwcG9ydGVkKFwiaW1tZXJzaXZlLWFyXCIpfWNhdGNoKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJSZXF1ZXN0IHRvIHByZXNlbnQgaW4gV2ViWFIgZGVuaWVkOlwiKSxjb25zb2xlLndhcm4odCksY29uc29sZS53YXJuKFwiRmFsbGluZyBiYWNrIHRvIG5leHQgYXItbW9kZVwiKSwhMX19YXN5bmMgcHJlc2VudCh0LGU9ITEpe3RoaXMuaXNQcmVzZW50aW5nJiZjb25zb2xlLndhcm4oXCJDYW5ub3QgcHJlc2VudCB3aGlsZSBhIG1vZGVsIGlzIGFscmVhZHkgcHJlc2VudGluZ1wiKTtsZXQgbj1uZXcgUHJvbWlzZSgoKHQsZSk9PntyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT50KCkpKX0pKTt0LnNldEhvdHNwb3RzVmlzaWJpbGl0eSghMSksdC5xdWV1ZVJlbmRlcigpLGF3YWl0IG4sdGhpcy5fcHJlc2VudGVkU2NlbmU9dCx0aGlzLm92ZXJsYXk9dC5lbGVtZW50LnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImRpdi5kZWZhdWx0XCIpLCEwPT09ZSYmKHRoaXMueHJMaWdodD1uZXcgQnUodGhpcy50aHJlZVJlbmRlcmVyKSx0aGlzLnhyTGlnaHQuYWRkRXZlbnRMaXN0ZW5lcihcImVzdGltYXRpb25zdGFydFwiLCgoKT0+e2lmKCF0aGlzLmlzUHJlc2VudGluZ3x8bnVsbD09dGhpcy54ckxpZ2h0KXJldHVybjtjb25zdCB0PXRoaXMucHJlc2VudGVkU2NlbmU7dC5hZGQodGhpcy54ckxpZ2h0KSx0aGlzLm9sZEVudmlyb25tZW50PXQuZW52aXJvbm1lbnQsdC5lbnZpcm9ubWVudD10aGlzLnhyTGlnaHQuZW52aXJvbm1lbnR9KSkpO2NvbnN0IGk9YXdhaXQgdGhpcy5yZXNvbHZlQVJTZXNzaW9uKCk7aS5hZGRFdmVudExpc3RlbmVyKFwiZW5kXCIsKCgpPT57dGhpcy5wb3N0U2Vzc2lvbkNsZWFudXAoKX0pLHtvbmNlOiEwfSk7Y29uc3Qgcj10LmVsZW1lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLnNsb3QuZXhpdC13ZWJ4ci1hci1idXR0b25cIik7ci5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMub25FeGl0V2ViWFJCdXR0b25Db250YWluZXJDbGljayksdGhpcy5leGl0V2ViWFJCdXR0b25Db250YWluZXI9cjtjb25zdCBzPWF3YWl0IGkucmVxdWVzdFJlZmVyZW5jZVNwYWNlKFwidmlld2VyXCIpO3RoaXMudHJhY2tpbmc9ITAsdGhpcy5mcmFtZXM9MCx0aGlzLmluaXRpYWxpemVkPSExLHRoaXMudHVybnRhYmxlUm90YXRpb249dC55YXcsdGhpcy5nb2FsWWF3PXQueWF3LHRoaXMuZ29hbFNjYWxlPTEsdGhpcy5vbGRCYWNrZ3JvdW5kPXQuYmFja2dyb3VuZCx0LmJhY2tncm91bmQ9bnVsbCx0aGlzLm9sZFNoYWRvd0ludGVuc2l0eT10LnNoYWRvd0ludGVuc2l0eSx0LnNldFNoYWRvd0ludGVuc2l0eSgwKSx0aGlzLm9sZFRhcmdldC5jb3B5KHQuZ2V0VGFyZ2V0KCkpLHRoaXMub2xkRnJhbWVkRmllbGRPZlZpZXc9dC5mcmFtZWRGaWVsZE9mVmlldyx0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb2RlbC1sb2FkXCIsdGhpcy5vblVwZGF0ZVNjZW5lKTtjb25zdCBhPTIwKk1hdGguUEkvMTgwLG89ITA9PT10aGlzLnBsYWNlT25XYWxsP3ZvaWQgMDpuZXcgWFJSYXkobmV3IERPTVBvaW50KDAsMCwwKSx7eDowLHk6LU1hdGguc2luKGEpLHo6LU1hdGguY29zKGEpfSk7aS5yZXF1ZXN0SGl0VGVzdFNvdXJjZSh7c3BhY2U6cyxvZmZzZXRSYXk6b30pLnRoZW4oKHQ9Pnt0aGlzLmluaXRpYWxIaXRTb3VyY2U9dH0pKSx0aGlzLmN1cnJlbnRTZXNzaW9uPWksdGhpcy5wbGFjZW1lbnRCb3g9bmV3IFd1KHQsdGhpcy5wbGFjZU9uV2FsbD9cImJhY2tcIjpcImJvdHRvbVwiKSx0aGlzLnBsYWNlbWVudENvbXBsZXRlPSExLHRoaXMubGFzdFRpY2s9cGVyZm9ybWFuY2Uubm93KCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwic3RhdHVzXCIsc3RhdHVzOnF1fSl9YXN5bmMgc3RvcFByZXNlbnRpbmcoKXtpZighdGhpcy5pc1ByZXNlbnRpbmcpcmV0dXJuO2NvbnN0IHQ9bmV3IFByb21pc2UoKHQ9Pnt0aGlzLnJlc29sdmVDbGVhbnVwPXR9KSk7dHJ5e2F3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZW5kKCksYXdhaXQgdH1jYXRjaCh0KXtjb25zb2xlLndhcm4oXCJFcnJvciB3aGlsZSB0cnlpbmcgdG8gZW5kIFdlYlhSIEFSIHNlc3Npb25cIiksY29uc29sZS53YXJuKHQpLHRoaXMucG9zdFNlc3Npb25DbGVhbnVwKCl9fWdldCBpc1ByZXNlbnRpbmcoKXtyZXR1cm4gbnVsbCE9dGhpcy5wcmVzZW50ZWRTY2VuZX1nZXQgdGFyZ2V0KCl7cmV0dXJuIHRoaXMub2xkVGFyZ2V0fXVwZGF0ZVRhcmdldCgpe2NvbnN0IHQ9dGhpcy5wcmVzZW50ZWRTY2VuZTtpZihudWxsIT10KXtjb25zdCBlPXQuZ2V0VGFyZ2V0KCk7dGhpcy5vbGRUYXJnZXQuY29weShlKSx0aGlzLnBsYWNlT25XYWxsP2Uuej10LmJvdW5kaW5nQm94Lm1pbi56OmUueT10LmJvdW5kaW5nQm94Lm1pbi55LHQuc2V0VGFyZ2V0KGUueCxlLnksZS56KX19cG9zdFNlc3Npb25DbGVhbnVwKCl7Y29uc3QgdD10aGlzLmN1cnJlbnRTZXNzaW9uO251bGwhPXQmJih0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLHRoaXMub25TZWxlY3RTdGFydCksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0ZW5kXCIsdGhpcy5vblNlbGVjdEVuZCksdGhpcy5jdXJyZW50U2Vzc2lvbj1udWxsKTtjb25zdCBlPXRoaXMucHJlc2VudGVkU2NlbmU7aWYobnVsbCE9ZSl7Y29uc3R7ZWxlbWVudDp0fT1lO251bGwhPXRoaXMueHJMaWdodCYmKGUucmVtb3ZlKHRoaXMueHJMaWdodCksbnVsbCE9dGhpcy5vbGRFbnZpcm9ubWVudCYmKGUuZW52aXJvbm1lbnQ9dGhpcy5vbGRFbnZpcm9ubWVudCx0aGlzLm9sZEVudmlyb25tZW50PW51bGwpLHRoaXMueHJMaWdodC5kaXNwb3NlKCksdGhpcy54ckxpZ2h0PW51bGwpLGUucG9zaXRpb24uc2V0KDAsMCwwKSxlLnNjYWxlLnNldCgxLDEsMSksZS5zZXRTaGFkb3dTY2FsZUFuZE9mZnNldCgxLDApO2NvbnN0IG49dGhpcy50dXJudGFibGVSb3RhdGlvbjtudWxsIT1uJiYoZS55YXc9bik7Y29uc3QgaT10aGlzLm9sZFNoYWRvd0ludGVuc2l0eTtudWxsIT1pJiZlLnNldFNoYWRvd0ludGVuc2l0eShpKTtjb25zdCByPXRoaXMub2xkQmFja2dyb3VuZDtudWxsIT1yJiYoZS5iYWNrZ3JvdW5kPXIpO2NvbnN0IHM9dGhpcy5vbGRUYXJnZXQ7ZS5zZXRUYXJnZXQocy54LHMueSxzLnopLGUuZnJhbWVkRmllbGRPZlZpZXc9dGhpcy5vbGRGcmFtZWRGaWVsZE9mVmlldyxlLnhyQ2FtZXJhPW51bGwsZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW9kZWwtbG9hZFwiLHRoaXMub25VcGRhdGVTY2VuZSksZS5vcmllbnRIb3RzcG90cygwKSx0LnJlcXVlc3RVcGRhdGUoXCJjYW1lcmFUYXJnZXRcIiksdC5yZXF1ZXN0VXBkYXRlKFwibWF4Q2FtZXJhT3JiaXRcIiksdFtncF0odC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSl9dGhpcy5yZW5kZXJlci5oZWlnaHQ9MDtjb25zdCBuPXRoaXMuZXhpdFdlYlhSQnV0dG9uQ29udGFpbmVyO251bGwhPW4mJihuLmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpLG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5vbkV4aXRXZWJYUkJ1dHRvbkNvbnRhaW5lckNsaWNrKSx0aGlzLmV4aXRXZWJYUkJ1dHRvbkNvbnRhaW5lcj1udWxsKTtjb25zdCBpPXRoaXMudHJhbnNpZW50SGl0VGVzdFNvdXJjZTtudWxsIT1pJiYoaS5jYW5jZWwoKSx0aGlzLnRyYW5zaWVudEhpdFRlc3RTb3VyY2U9bnVsbCk7Y29uc3Qgcj10aGlzLmluaXRpYWxIaXRTb3VyY2U7bnVsbCE9ciYmKHIuY2FuY2VsKCksdGhpcy5pbml0aWFsSGl0U291cmNlPW51bGwpLG51bGwhPXRoaXMucGxhY2VtZW50Qm94JiYodGhpcy5wbGFjZW1lbnRCb3guZGlzcG9zZSgpLHRoaXMucGxhY2VtZW50Qm94PW51bGwpLHRoaXMubGFzdFRpY2s9bnVsbCx0aGlzLnR1cm50YWJsZVJvdGF0aW9uPW51bGwsdGhpcy5vbGRTaGFkb3dJbnRlbnNpdHk9bnVsbCx0aGlzLm9sZEJhY2tncm91bmQ9bnVsbCx0aGlzLl9wcmVzZW50ZWRTY2VuZT1udWxsLHRoaXMuZnJhbWU9bnVsbCx0aGlzLmlucHV0U291cmNlPW51bGwsdGhpcy5vdmVybGF5PW51bGwsbnVsbCE9dGhpcy5yZXNvbHZlQ2xlYW51cCYmdGhpcy5yZXNvbHZlQ2xlYW51cCgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTpcInN0YXR1c1wiLHN0YXR1czpqdX0pfXVwZGF0ZVZpZXcodCl7Y29uc3QgZT10aGlzLnByZXNlbnRlZFNjZW5lLG49dGhpcy50aHJlZVJlbmRlcmVyLnhyO24udXBkYXRlQ2FtZXJhKHRkKSxlLnhyQ2FtZXJhPW4uZ2V0Q2FtZXJhKCk7Y29uc3R7ZWxlbWVudHM6aX09ZS5nZXRDYW1lcmEoKS5tYXRyaXhXb3JsZDtpZihlLm9yaWVudEhvdHNwb3RzKE1hdGguYXRhbjIoaVsxXSxpWzVdKSksdGhpcy5pbml0aWFsaXplZHx8KHRoaXMucGxhY2VJbml0aWFsbHkoKSx0aGlzLmluaXRpYWxpemVkPSEwKSx0LnJlcXVlc3RWaWV3cG9ydFNjYWxlJiZ0LnJlY29tbWVuZGVkVmlld3BvcnRTY2FsZSl7Y29uc3QgZT10LnJlY29tbWVuZGVkVmlld3BvcnRTY2FsZTt0LnJlcXVlc3RWaWV3cG9ydFNjYWxlKE1hdGgubWF4KGUsLjI1KSl9Y29uc3Qgcj10aGlzLmN1cnJlbnRTZXNzaW9uLnJlbmRlclN0YXRlLmJhc2VMYXllci5nZXRWaWV3cG9ydCh0KTt0aGlzLnRocmVlUmVuZGVyZXIuc2V0Vmlld3BvcnQoci54LHIueSxyLndpZHRoLHIuaGVpZ2h0KX1wbGFjZUluaXRpYWxseSgpe2NvbnN0IHQ9dGhpcy5wcmVzZW50ZWRTY2VuZSx7cG9zaXRpb246ZSxlbGVtZW50Om59PXQsaT10LmdldENhbWVyYSgpLHt3aWR0aDpyLGhlaWdodDpzfT10aGlzLm92ZXJsYXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dC5zZXRTaXplKHIscyksaS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KGkucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7Y29uc3R7dGhldGE6YSxyYWRpdXM6b309bi5nZXRDYW1lcmFPcmJpdCgpLGw9aS5nZXRXb3JsZERpcmVjdGlvbigkdSk7dC55YXc9TWF0aC5hdGFuMigtbC54LC1sLnopLWEsdGhpcy5nb2FsWWF3PXQueWF3LGUuY29weShpLnBvc2l0aW9uKS5hZGQobC5tdWx0aXBseVNjYWxhcihvKSksdGhpcy51cGRhdGVUYXJnZXQoKTtjb25zdCBjPXQuZ2V0VGFyZ2V0KCk7ZS5hZGQoYykuc3ViKHRoaXMub2xkVGFyZ2V0KSx0aGlzLmdvYWxQb3NpdGlvbi5jb3B5KGUpLHQuc2V0SG90c3BvdHNWaXNpYmlsaXR5KCEwKTtjb25zdHtzZXNzaW9uOmh9PXRoaXMuZnJhbWU7aC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIix0aGlzLm9uU2VsZWN0U3RhcnQpLGguYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGVuZFwiLHRoaXMub25TZWxlY3RFbmQpLGgucmVxdWVzdEhpdFRlc3RTb3VyY2VGb3JUcmFuc2llbnRJbnB1dCh7cHJvZmlsZTpcImdlbmVyaWMtdG91Y2hzY3JlZW5cIn0pLnRoZW4oKHQ9Pnt0aGlzLnRyYW5zaWVudEhpdFRlc3RTb3VyY2U9dH0pKX1nZXRUb3VjaExvY2F0aW9uKCl7Y29uc3R7YXhlczp0fT10aGlzLmlucHV0U291cmNlLmdhbWVwYWQ7bGV0IGU9dGhpcy5wbGFjZW1lbnRCb3guZ2V0RXhwYW5kZWRIaXQodGhpcy5wcmVzZW50ZWRTY2VuZSx0WzBdLHRbMV0pO3JldHVybiBudWxsIT1lJiYoJHUuY29weShlKS5zdWIodGhpcy5wcmVzZW50ZWRTY2VuZS5nZXRDYW1lcmEoKS5wb3NpdGlvbiksJHUubGVuZ3RoKCk+MTApP251bGw6ZX1nZXRIaXRQb2ludCh0KXtjb25zdCBlPXRoaXMudGhyZWVSZW5kZXJlci54ci5nZXRSZWZlcmVuY2VTcGFjZSgpLG49dC5nZXRQb3NlKGUpO2lmKG51bGw9PW4pcmV0dXJuIG51bGw7Y29uc3QgaT1LdS5mcm9tQXJyYXkobi50cmFuc2Zvcm0ubWF0cml4KTtyZXR1cm4hMD09PXRoaXMucGxhY2VPbldhbGwmJih0aGlzLmdvYWxZYXc9TWF0aC5hdGFuMihpLmVsZW1lbnRzWzRdLGkuZWxlbWVudHNbNl0pKSxpLmVsZW1lbnRzWzVdPi43NSE9PXRoaXMucGxhY2VPbldhbGw/UXUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGkpOm51bGx9bW92ZVRvRmxvb3IodCl7Y29uc3QgZT10aGlzLmluaXRpYWxIaXRTb3VyY2U7aWYobnVsbD09ZSlyZXR1cm47Y29uc3Qgbj10LmdldEhpdFRlc3RSZXN1bHRzKGUpO2lmKDA9PW4ubGVuZ3RoKXJldHVybjtjb25zdCBpPW5bMF0scj10aGlzLmdldEhpdFBvaW50KGkpO251bGwhPXImJih0aGlzLnBsYWNlbWVudEJveC5zaG93PSEwLHRoaXMuaXNUcmFuc2xhdGluZ3x8KHRoaXMucGxhY2VPbldhbGw/dGhpcy5nb2FsUG9zaXRpb24uY29weShyKTp0aGlzLmdvYWxQb3NpdGlvbi55PXIueSksZS5jYW5jZWwoKSx0aGlzLmluaXRpYWxIaXRTb3VyY2U9bnVsbCx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJzdGF0dXNcIixzdGF0dXM6WHV9KSl9ZmluZ2VyUG9sYXIodCl7Y29uc3QgZT10WzBdLmlucHV0U291cmNlLmdhbWVwYWQuYXhlcyxuPXRbMV0uaW5wdXRTb3VyY2UuZ2FtZXBhZC5heGVzLGk9blswXS1lWzBdLHI9blsxXS1lWzFdLHM9TWF0aC5hdGFuMihyLGkpO2xldCBhPXRoaXMubGFzdEFuZ2xlLXM7cmV0dXJuIGE+TWF0aC5QST9hLT0yKk1hdGguUEk6YTwtTWF0aC5QSSYmKGErPTIqTWF0aC5QSSksdGhpcy5sYXN0QW5nbGU9cyx7c2VwYXJhdGlvbjpNYXRoLnNxcnQoaSppK3IqciksZGVsdGFZYXc6YX19cHJvY2Vzc0lucHV0KHQpe2NvbnN0IGU9dGhpcy50cmFuc2llbnRIaXRUZXN0U291cmNlO2lmKG51bGw9PWUpcmV0dXJuO2lmKCF0aGlzLmlzVHJhbnNsYXRpbmcmJiF0aGlzLmlzVHdvRmluZ2VyaW5nJiYhdGhpcy5pc1JvdGF0aW5nKXJldHVybjtjb25zdCBuPXQuZ2V0SGl0VGVzdFJlc3VsdHNGb3JUcmFuc2llbnRJbnB1dChlKSxpPXRoaXMucHJlc2VudGVkU2NlbmUscj1pLnNjYWxlLng7aWYodGhpcy5pc1R3b0ZpbmdlcmluZylpZihuLmxlbmd0aDwyKXRoaXMuaXNUd29GaW5nZXJpbmc9ITE7ZWxzZXtjb25zdHtzZXBhcmF0aW9uOnQsZGVsdGFZYXc6ZX09dGhpcy5maW5nZXJQb2xhcihuKTtpZighMT09PXRoaXMucGxhY2VPbldhbGwmJih0aGlzLmdvYWxZYXcrPWUpLGkuY2FuU2NhbGUpe2NvbnN0IGU9dC90aGlzLmZpcnN0UmF0aW87dGhpcy5nb2FsU2NhbGU9ZTwxLjMmJmU+Ljc2OTIzMDc2OTIzMDc2OTI/MTplfX1lbHNlIGlmKDIhPT1uLmxlbmd0aClpZih0aGlzLmlzUm90YXRpbmcpe2NvbnN0IHQ9MS41KnRoaXMuaW5wdXRTb3VyY2UuZ2FtZXBhZC5heGVzWzBdO3RoaXMuZ29hbFlhdys9dC10aGlzLmxhc3RBbmdsZSx0aGlzLmxhc3RBbmdsZT10fWVsc2UgdGhpcy5pc1RyYW5zbGF0aW5nJiZuLmZvckVhY2goKHQ9PntpZih0LmlucHV0U291cmNlIT09dGhpcy5pbnB1dFNvdXJjZSlyZXR1cm47bGV0IGU9bnVsbDtpZih0LnJlc3VsdHMubGVuZ3RoPjAmJihlPXRoaXMuZ2V0SGl0UG9pbnQodC5yZXN1bHRzWzBdKSksbnVsbD09ZSYmKGU9dGhpcy5nZXRUb3VjaExvY2F0aW9uKCkpLG51bGwhPWUpe2lmKHRoaXMuZ29hbFBvc2l0aW9uLnN1Yih0aGlzLmxhc3REcmFnUG9zaXRpb24pLCExPT09dGhpcy5wbGFjZU9uV2FsbCl7Y29uc3QgdD1lLnktdGhpcy5sYXN0RHJhZ1Bvc2l0aW9uLnk7aWYodDwwKXt0aGlzLnBsYWNlbWVudEJveC5vZmZzZXRIZWlnaHQ9dC9yLHRoaXMucHJlc2VudGVkU2NlbmUuc2V0U2hhZG93U2NhbGVBbmRPZmZzZXQocix0KTtjb25zdCBuPSR1LmNvcHkoaS5nZXRDYW1lcmEoKS5wb3NpdGlvbikscz0tdC8obi55LWUueSk7bi5tdWx0aXBseVNjYWxhcihzKSxlLm11bHRpcGx5U2NhbGFyKDEtcykuYWRkKG4pfX10aGlzLmdvYWxQb3NpdGlvbi5hZGQoZSksdGhpcy5sYXN0RHJhZ1Bvc2l0aW9uLmNvcHkoZSl9fSkpO2Vsc2V7dGhpcy5pc1RyYW5zbGF0aW5nPSExLHRoaXMuaXNSb3RhdGluZz0hMSx0aGlzLmlzVHdvRmluZ2VyaW5nPSEwO2NvbnN0e3NlcGFyYXRpb246dH09dGhpcy5maW5nZXJQb2xhcihuKTt0aGlzLmZpcnN0UmF0aW89dC9yfX1tb3ZlU2NlbmUodCl7Y29uc3QgZT10aGlzLnByZXNlbnRlZFNjZW5lLHtwb3NpdGlvbjpuLHlhdzppLGlkZWFsQ2FtZXJhRGlzdGFuY2U6cn09ZSxzPXRoaXMuZ29hbFBvc2l0aW9uLGE9ZS5zY2FsZS54LG89dGhpcy5wbGFjZW1lbnRCb3g7aWYoIXMuZXF1YWxzKG4pfHx0aGlzLmdvYWxTY2FsZSE9PWEpe2xldHt4OmkseTpsLHo6Y309bjtpPXRoaXMueERhbXBlci51cGRhdGUoaSxzLngsdCxyKSxsPXRoaXMueURhbXBlci51cGRhdGUobCxzLnksdCxyKSxjPXRoaXMuekRhbXBlci51cGRhdGUoYyxzLnosdCxyKSxuLnNldChpLGwsYyk7Y29uc3QgaD10aGlzLnNjYWxlRGFtcGVyLnVwZGF0ZShhLHRoaXMuZ29hbFNjYWxlLHQsMSk7aWYoZS5zY2FsZS5zZXQoaCxoLGgpLCF0aGlzLmlzVHJhbnNsYXRpbmcpe2NvbnN0IHQ9cy55LWw7dGhpcy5wbGFjZW1lbnRDb21wbGV0ZSYmITE9PT10aGlzLnBsYWNlT25XYWxsPyhvLm9mZnNldEhlaWdodD10L2gsZS5zZXRTaGFkb3dTY2FsZUFuZE9mZnNldChoLHQpKTowPT09dCYmKHRoaXMucGxhY2VtZW50Q29tcGxldGU9ITAsby5zaG93PSExLGUuc2V0U2hhZG93SW50ZW5zaXR5KC4zKSl9fW8udXBkYXRlT3BhY2l0eSh0KSxlLnVwZGF0ZVRhcmdldCh0KSxlLnlhdz10aGlzLnlhd0RhbXBlci51cGRhdGUoaSx0aGlzLmdvYWxZYXcsdCxNYXRoLlBJKX1vbldlYlhSRnJhbWUodCxlKXt0aGlzLmZyYW1lPWUsKyt0aGlzLmZyYW1lcztjb25zdCBuPXRoaXMudGhyZWVSZW5kZXJlci54ci5nZXRSZWZlcmVuY2VTcGFjZSgpLGk9ZS5nZXRWaWV3ZXJQb3NlKG4pO251bGw9PWkmJiEwPT09dGhpcy50cmFja2luZyYmdGhpcy5mcmFtZXM+MzAmJih0aGlzLnRyYWNraW5nPSExLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTpcInRyYWNraW5nXCIsc3RhdHVzOkp1fSkpO2NvbnN0IHI9dGhpcy5wcmVzZW50ZWRTY2VuZTtpZihudWxsPT1pfHxudWxsPT1yfHwhci5lbGVtZW50W19wXSgpKXJldHVybiB2b2lkIHRoaXMudGhyZWVSZW5kZXJlci5jbGVhcigpOyExPT09dGhpcy50cmFja2luZyYmKHRoaXMudHJhY2tpbmc9ITAsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwidHJhY2tpbmdcIixzdGF0dXM6WnV9KSk7bGV0IHM9ITA7Zm9yKGNvbnN0IG4gb2YgaS52aWV3cyl7aWYodGhpcy51cGRhdGVWaWV3KG4pLHMpe3RoaXMubW92ZVRvRmxvb3IoZSksdGhpcy5wcm9jZXNzSW5wdXQoZSk7Y29uc3Qgbj10LXRoaXMubGFzdFRpY2s7dGhpcy5tb3ZlU2NlbmUobiksdGhpcy5yZW5kZXJlci5wcmVSZW5kZXIocix0LG4pLHRoaXMubGFzdFRpY2s9dH1jb25zdCBpPXRoaXMudGhyZWVSZW5kZXJlci5nZXRDb250ZXh0KCk7aS5kZXB0aE1hc2soITEpLGkuY2xlYXIoaS5ERVBUSF9CVUZGRVJfQklUKSxpLmRlcHRoTWFzayghMCksdGhpcy50aHJlZVJlbmRlcmVyLnJlbmRlcihyLHIuZ2V0Q2FtZXJhKCkpLHM9ITF9fX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jbGFzcyBuZHtjb25zdHJ1Y3Rvcih0KXt0LnRocmVlUmVuZGVyZXIuZGVidWc9e2NoZWNrU2hhZGVyRXJyb3JzOiEwfSxQcm9taXNlLnJlc29sdmUoKS50aGVuKCgoKT0+e3NlbGYuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJtb2RlbC12aWV3ZXItcmVuZGVyZXItZGVidWdcIix7ZGV0YWlsOntyZW5kZXJlcjp0LFRIUkVFOntTaGFkZXJNYXRlcmlhbDpZbixUZXh0dXJlOk50LE1lc2g6Vm4sU2NlbmU6WXMsUGxhbmVCdWZmZXJHZW9tZXRyeTpjaSxPcnRob2dyYXBoaWNDYW1lcmE6eGksV2ViR0xSZW5kZXJUYXJnZXQ6VXR9fX0pKX0pKX1hZGRTY2VuZSh0KXtzZWxmLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwibW9kZWwtdmlld2VyLXNjZW5lLWFkZGVkLWRlYnVnXCIse2RldGFpbDp7c2NlbmU6dH19KSl9cmVtb3ZlU2NlbmUodCl7c2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIm1vZGVsLXZpZXdlci1zY2VuZS1yZW1vdmVkLWRlYnVnXCIse2RldGFpbDp7c2NlbmU6dH19KSl9fWZ1bmN0aW9uIGlkKHQpe2NvbnN0IGU9bmV3IE1hcCxuPW5ldyBNYXAsaT10LmNsb25lKCk7cmV0dXJuIHJkKHQsaSwoZnVuY3Rpb24odCxpKXtlLnNldChpLHQpLG4uc2V0KHQsaSl9KSksaS50cmF2ZXJzZSgoZnVuY3Rpb24odCl7aWYoIXQuaXNTa2lubmVkTWVzaClyZXR1cm47Y29uc3QgaT10LHI9ZS5nZXQodCkscz1yLnNrZWxldG9uLmJvbmVzO2kuc2tlbGV0b249ci5za2VsZXRvbi5jbG9uZSgpLGkuYmluZE1hdHJpeC5jb3B5KHIuYmluZE1hdHJpeCksaS5za2VsZXRvbi5ib25lcz1zLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG4uZ2V0KHQpfSkpLGkuYmluZChpLnNrZWxldG9uLGkuYmluZE1hdHJpeCl9KSksaX1mdW5jdGlvbiByZCh0LGUsbil7bih0LGUpO2ZvcihsZXQgaT0wO2k8dC5jaGlsZHJlbi5sZW5ndGg7aSsrKXJkKHQuY2hpbGRyZW5baV0sZS5jaGlsZHJlbltpXSxuKX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jb25zdCBzZD1TeW1ib2woXCJwcmVwYXJlZFwiKSxhZD1TeW1ib2woXCJwcmVwYXJlXCIpLG9kPVN5bWJvbChcInByZXBhcmVkR0xURlwiKSxsZD1TeW1ib2woXCJjbG9uZVwiKTtjbGFzcyBjZHtjb25zdHJ1Y3Rvcih0KXt0aGlzW29kXT10fXN0YXRpYyBwcmVwYXJlKHQpe2lmKG51bGw9PXQuc2NlbmUpdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIHNjZW5lXCIpO2lmKHRbc2RdKXJldHVybiB0O2NvbnN0IGU9dGhpc1thZF0odCk7cmV0dXJuIGVbc2RdPSEwLGV9c3RhdGljW2FkXSh0KXtjb25zdHtzY2VuZTplfT10LG49W2VdO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse3NjZW5lOmUsc2NlbmVzOm59KX1nZXQgcGFyc2VyKCl7cmV0dXJuIHRoaXNbb2RdLnBhcnNlcn1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW29kXS5hbmltYXRpb25zfWdldCBzY2VuZSgpe3JldHVybiB0aGlzW29kXS5zY2VuZX1nZXQgc2NlbmVzKCl7cmV0dXJuIHRoaXNbb2RdLnNjZW5lc31nZXQgY2FtZXJhcygpe3JldHVybiB0aGlzW29kXS5jYW1lcmFzfWdldCBhc3NldCgpe3JldHVybiB0aGlzW29kXS5hc3NldH1nZXQgdXNlckRhdGEoKXtyZXR1cm4gdGhpc1tvZF0udXNlckRhdGF9Y2xvbmUoKXtyZXR1cm4gbmV3KDAsdGhpcy5jb25zdHJ1Y3RvcikodGhpc1tsZF0oKSl9ZGlzcG9zZSgpe3RoaXMuc2NlbmVzLmZvckVhY2goKHQ9Pnt0LnRyYXZlcnNlKCh0PT57aWYoIXQuaXNNZXNoKXJldHVybjtjb25zdCBlPXQ7KEFycmF5LmlzQXJyYXkoZS5tYXRlcmlhbCk/ZS5tYXRlcmlhbDpbZS5tYXRlcmlhbF0pLmZvckVhY2goKHQ9Pntmb3IoY29uc3QgZSBpbiB0KXtjb25zdCBuPXRbZV07biBpbnN0YW5jZW9mIE50JiZuLmRpc3Bvc2UoKX10LmRpc3Bvc2UoKX0pKSxlLmdlb21ldHJ5LmRpc3Bvc2UoKX0pKX0pKX1bbGRdKCl7Y29uc3QgdD10aGlzW29kXSxlPWlkKHRoaXMuc2NlbmUpO2hkKGUsdGhpcy5zY2VuZSk7Y29uc3Qgbj1bZV0saT10LnVzZXJEYXRhP09iamVjdC5hc3NpZ24oe30sdC51c2VyRGF0YSk6e307cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7c2NlbmU6ZSxzY2VuZXM6bix1c2VyRGF0YTppfSl9fWNvbnN0IGhkPSh0LGUpPT57dWQodCxlLCgodCxlKT0+e3ZvaWQgMCE9PWUudXNlckRhdGEudmFyaWFudE1hdGVyaWFscyYmKHQudXNlckRhdGEudmFyaWFudE1hdGVyaWFscz1uZXcgTWFwKGUudXNlckRhdGEudmFyaWFudE1hdGVyaWFscykpLHZvaWQgMCE9PWUudXNlckRhdGEub3JpZ2luYWxNYXRlcmlhbCYmKHQudXNlckRhdGEub3JpZ2luYWxNYXRlcmlhbD1lLnVzZXJEYXRhLm9yaWdpbmFsTWF0ZXJpYWwpfSkpfSx1ZD0odCxlLG4pPT57bih0LGUpO2ZvcihsZXQgaT0wO2k8dC5jaGlsZHJlbi5sZW5ndGg7aSsrKXVkKHQuY2hpbGRyZW5baV0sZS5jaGlsZHJlbltpXSxuKX0sZGQ9U3ltYm9sKFwidGhyZWVHTFRGXCIpLHBkPVN5bWJvbChcImdsdGZcIiksbWQ9U3ltYm9sKFwiZ2x0ZkVsZW1lbnRNYXBcIiksZmQ9U3ltYm9sKFwidGhyZWVPYmplY3RNYXBcIiksZ2Q9U3ltYm9sKFwicGFyYWxsZWxUcmF2ZXJzZVRocmVlU2NlbmVcIiksdmQ9U3ltYm9sKFwiY29ycmVsYXRlT3JpZ2luYWxUaHJlZUdMVEZcIikseWQ9U3ltYm9sKFwiY29ycmVsYXRlQ2xvbmVUaHJlZUdMVEZcIik7Y2xhc3MgeGR7Y29uc3RydWN0b3IodCxlLG4saSl7dGhpc1tkZF09dCx0aGlzW3BkXT1lLHRoaXNbbWRdPWksdGhpc1tmZF09bn1zdGF0aWMgZnJvbSh0LGUpe3JldHVybiBudWxsIT1lP3RoaXNbeWRdKHQsZSk6dGhpc1t2ZF0odCl9c3RhdGljW3ZkXSh0KXtjb25zdCBlPXQucGFyc2VyLmpzb24sbj10LnBhcnNlci5hc3NvY2lhdGlvbnMsaT1uZXcgTWFwLHI9e25hbWU6XCJEZWZhdWx0XCJ9LHM9e3R5cGU6XCJtYXRlcmlhbHNcIixpbmRleDotMX07Zm9yKGNvbnN0IHQgb2Ygbi5rZXlzKCkpdCBpbnN0YW5jZW9mIGVuJiZudWxsPT1uLmdldCh0KSYmKHMuaW5kZXg8MCYmKG51bGw9PWUubWF0ZXJpYWxzJiYoZS5tYXRlcmlhbHM9W10pLHMuaW5kZXg9ZS5tYXRlcmlhbHMubGVuZ3RoLGUubWF0ZXJpYWxzLnB1c2gocikpLHQubmFtZT1yLm5hbWUsbi5zZXQodCx7bWF0ZXJpYWxzOnMuaW5kZXh9KSk7Zm9yKGNvbnN0W3Qscl1vZiBuKXtpZihyKXtjb25zdCBlPXQ7ZS51c2VyRGF0YT1lLnVzZXJEYXRhfHx7fSxlLnVzZXJEYXRhLmFzc29jaWF0aW9ucz1yfWZvcihjb25zdCBuIGluIHIpaWYobnVsbCE9biYmXCJwcmltaXRpdmVzXCIhPT1uKXtjb25zdCBzPW4sYT0oZVtzXXx8W10pW3Jbc11dO2lmKG51bGw9PWEpY29udGludWU7bGV0IG89aS5nZXQoYSk7bnVsbD09byYmKG89bmV3IFNldCxpLnNldChhLG8pKSxvLmFkZCh0KX19cmV0dXJuIG5ldyB4ZCh0LGUsbixpKX1zdGF0aWNbeWRdKHQsZSl7Y29uc3Qgbj1lLnRocmVlR0xURixpPWUuZ2x0ZixyPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaSkpLHM9bmV3IE1hcCxhPW5ldyBNYXA7Zm9yKGxldCBpPTA7aTxuLnNjZW5lcy5sZW5ndGg7aSsrKXRoaXNbZ2RdKG4uc2NlbmVzW2ldLHQuc2NlbmVzW2ldLCgodCxuKT0+e2NvbnN0IGk9ZS50aHJlZU9iamVjdE1hcC5nZXQodCk7aWYobnVsbCE9aSlmb3IoY29uc3QgdCBpbiBpKWlmKG51bGwhPXQmJlwicHJpbWl0aXZlc1wiIT09dCl7Y29uc3QgZT10LG89aVtlXSxsPXJbZV1bb10sYz1zLmdldChuKXx8e307Y1tlXT1vLHMuc2V0KG4sYyk7Y29uc3QgaD1hLmdldChsKXx8bmV3IFNldDtoLmFkZChuKSxhLnNldChsLGgpfX0pKTtyZXR1cm4gbmV3IHhkKHQscixzLGEpfXN0YXRpY1tnZF0odCxlLG4pe2NvbnN0IGk9KHQsZSk9PntpZihuKHQsZSksdC5pc09iamVjdDNEKXtpZih0LmlzTWVzaClpZihBcnJheS5pc0FycmF5KHQubWF0ZXJpYWwpKWZvcihsZXQgbj0wO248dC5tYXRlcmlhbC5sZW5ndGg7KytuKWkodC5tYXRlcmlhbFtuXSxlLm1hdGVyaWFsW25dKTtlbHNlIGkodC5tYXRlcmlhbCxlLm1hdGVyaWFsKTtmb3IobGV0IG49MDtuPHQuY2hpbGRyZW4ubGVuZ3RoOysrbilpKHQuY2hpbGRyZW5bbl0sZS5jaGlsZHJlbltuXSl9fTtpKHQsZSl9Z2V0IHRocmVlR0xURigpe3JldHVybiB0aGlzW2RkXX1nZXQgZ2x0Zigpe3JldHVybiB0aGlzW3BkXX1nZXQgZ2x0ZkVsZW1lbnRNYXAoKXtyZXR1cm4gdGhpc1ttZF19Z2V0IHRocmVlT2JqZWN0TWFwKCl7cmV0dXJuIHRoaXNbZmRdfX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jb25zdCBiZD1TeW1ib2woXCJjbG9uZUFuZFBhdGNoTWF0ZXJpYWxcIiksd2Q9U3ltYm9sKFwiY29ycmVsYXRlZFNjZW5lR3JhcGhcIik7Y2xhc3MgX2QgZXh0ZW5kcyBjZHtzdGF0aWNbYWRdKHQpe2NvbnN0IGU9c3VwZXJbYWRdKHQpO251bGw9PWVbd2RdJiYoZVt3ZF09eGQuZnJvbShlKSk7Y29uc3R7c2NlbmU6bn09ZSxpPW5ldyBsZSh2b2lkIDAsMS8wKTtyZXR1cm4gbi50cmF2ZXJzZSgodD0+e3QucmVuZGVyT3JkZXI9MWUzLHQuZnJ1c3R1bUN1bGxlZD0hMSx0Lm5hbWV8fCh0Lm5hbWU9dC51dWlkKTtjb25zdCBlPXQ7ZS5pc01lc2gmJihlLmNhc3RTaGFkb3c9ITAsZS5pc1NraW5uZWRNZXNoJiYoZS5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZT1pLGUuZ2VvbWV0cnkuYm91bmRpbmdCb3g9bnVsbCkpfSkpLGV9Z2V0IGNvcnJlbGF0ZWRTY2VuZUdyYXBoKCl7cmV0dXJuIHRoaXNbb2RdW3dkXX1bbGRdKCl7Y29uc3QgdD1zdXBlcltsZF0oKSxlPW5ldyBNYXA7cmV0dXJuIHQuc2NlbmUudHJhdmVyc2UoKHQ9PntpZih0LmlzTWVzaCl7Y29uc3Qgbj10O0FycmF5LmlzQXJyYXkobi5tYXRlcmlhbCk/bi5tYXRlcmlhbD1uLm1hdGVyaWFsLm1hcCgodD0+dGhpc1tiZF0odCxlKSkpOm51bGwhPW4ubWF0ZXJpYWwmJihuLm1hdGVyaWFsPXRoaXNbYmRdKG4ubWF0ZXJpYWwsZSkpfX0pKSx0W3dkXT14ZC5mcm9tKHQsdGhpcy5jb3JyZWxhdGVkU2NlbmVHcmFwaCksdH1bYmRdKHQsZSl7aWYoZS5oYXModC51dWlkKSlyZXR1cm4gZS5nZXQodC51dWlkKTtjb25zdCBuPXQuY2xvbmUoKTtudWxsIT10Lm1hcCYmKG4ubWFwPXQubWFwLmNsb25lKCksbi5tYXAubmVlZHNVcGRhdGU9ITApLG51bGwhPXQubm9ybWFsTWFwJiYobi5ub3JtYWxNYXA9dC5ub3JtYWxNYXAuY2xvbmUoKSxuLm5vcm1hbE1hcC5uZWVkc1VwZGF0ZT0hMCksbnVsbCE9dC5lbWlzc2l2ZU1hcCYmKG4uZW1pc3NpdmVNYXA9dC5lbWlzc2l2ZU1hcC5jbG9uZSgpLG4uZW1pc3NpdmVNYXAubmVlZHNVcGRhdGU9ITApO2xldCBpPW51bGw7aWYobnVsbCE9dC5yb3VnaG5lc3NNYXAmJihpPXQucm91Z2huZXNzTWFwLmNsb25lKCkpLG51bGwhPWkpe2kubmVlZHNVcGRhdGU9ITAsbi5yb3VnaG5lc3NNYXA9aTtjb25zdHt0aHJlZVJlbmRlcmVyOnQscm91Z2huZXNzTWlwbWFwcGVyOmV9PUNkLnNpbmdsZXRvbix7ZW5hYmxlZDpyfT10LnhyO3QueHIuZW5hYmxlZD0hMTtjb25zdHtpbWFnZTpzfT1uLnJvdWdobmVzc01hcDtlLmdlbmVyYXRlTWlwbWFwcyhuKSxuLnJvdWdobmVzc01hcC5pbWFnZT1zLHQueHIuZW5hYmxlZD1yfXJldHVybiB0LnJvdWdobmVzc01hcD09PXQubWV0YWxuZXNzTWFwP24ubWV0YWxuZXNzTWFwPWk6bnVsbCE9dC5tZXRhbG5lc3NNYXAmJihuLm1ldGFsbmVzc01hcD10Lm1ldGFsbmVzc01hcC5jbG9uZSgpLG4ubWV0YWxuZXNzTWFwLm5lZWRzVXBkYXRlPSEwKSx0LnJvdWdobmVzc01hcD09PXQuYW9NYXA/bi5hb01hcD1pOm51bGwhPXQuYW9NYXAmJihuLmFvTWFwPXQuYW9NYXAuY2xvbmUoKSxuLmFvTWFwLm5lZWRzVXBkYXRlPSEwKSxuLnNoYWRvd1NpZGU9MCxlLnNldCh0LnV1aWQsbiksbn19XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNZCBleHRlbmRzIFlze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBvc2l0aW9uLnk9LTMuNTtjb25zdCB0PW5ldyBXbjt0LmRlbGV0ZUF0dHJpYnV0ZShcInV2XCIpO2NvbnN0IGU9bmV3IFpvKHttZXRhbG5lc3M6MCxzaWRlOjF9KSxuPW5ldyBabyh7bWV0YWxuZXNzOjB9KSxpPW5ldyBJbCgxNjc3NzIxNSw1MDAsMjgsMik7aS5wb3NpdGlvbi5zZXQoLjQxOCwxNi4xOTksLjMpLHRoaXMuYWRkKGkpO2NvbnN0IHI9bmV3IFZuKHQsZSk7ci5wb3NpdGlvbi5zZXQoLS43NTcsMTMuMjE5LC43MTcpLHIuc2NhbGUuc2V0KDMxLjcxMywyOC4zMDUsMjguNTkxKSx0aGlzLmFkZChyKTtjb25zdCBzPW5ldyBWbih0LG4pO3MucG9zaXRpb24uc2V0KC0xMC45MDYsMi4wMDksMS44NDYpLHMucm90YXRpb24uc2V0KDAsLS4xOTUsMCkscy5zY2FsZS5zZXQoMi4zMjgsNy45MDUsNC42NTEpLHRoaXMuYWRkKHMpO2NvbnN0IGE9bmV3IFZuKHQsbik7YS5wb3NpdGlvbi5zZXQoLTUuNjA3LC0uNzU0LC0uNzU4KSxhLnJvdGF0aW9uLnNldCgwLC45OTQsMCksYS5zY2FsZS5zZXQoMS45NywxLjUzNCwzLjk1NSksdGhpcy5hZGQoYSk7Y29uc3Qgbz1uZXcgVm4odCxuKTtvLnBvc2l0aW9uLnNldCg2LjE2NywuODU3LDcuODAzKSxvLnJvdGF0aW9uLnNldCgwLC41NjEsMCksby5zY2FsZS5zZXQoMy45MjcsNi4yODUsMy42ODcpLHRoaXMuYWRkKG8pO2NvbnN0IGw9bmV3IFZuKHQsbik7bC5wb3NpdGlvbi5zZXQoLTIuMDE3LC4wMTgsNi4xMjQpLGwucm90YXRpb24uc2V0KDAsLjMzMywwKSxsLnNjYWxlLnNldCgyLjAwMiw0LjU2NiwyLjA2NCksdGhpcy5hZGQobCk7Y29uc3QgYz1uZXcgVm4odCxuKTtjLnBvc2l0aW9uLnNldCgyLjI5MSwtLjc1NiwtMi42MjEpLGMucm90YXRpb24uc2V0KDAsLS4yODYsMCksYy5zY2FsZS5zZXQoMS41NDYsMS41NTIsMS40OTYpLHRoaXMuYWRkKGMpO2NvbnN0IGg9bmV3IFZuKHQsbik7aC5wb3NpdGlvbi5zZXQoLTIuMTkzLC0uMzY5LC01LjU0NyksaC5yb3RhdGlvbi5zZXQoMCwuNTE2LDApLGguc2NhbGUuc2V0KDMuODc1LDMuNDg3LDIuOTg2KSx0aGlzLmFkZChoKTtjb25zdCB1PW5ldyBWbih0LHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoNTApKTt1LnBvc2l0aW9uLnNldCgtMTYuMTE2LDE0LjM3LDguMjA4KSx1LnNjYWxlLnNldCguMSwyLjQyOCwyLjczOSksdGhpcy5hZGQodSk7Y29uc3QgZD1uZXcgVm4odCx0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDUwKSk7ZC5wb3NpdGlvbi5zZXQoLTE2LjEwOSwxOC4wMjEsLTguMjA3KSxkLnNjYWxlLnNldCguMSwyLjQyNSwyLjc1MSksdGhpcy5hZGQoZCk7Y29uc3QgcD1uZXcgVm4odCx0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDE3KSk7cC5wb3NpdGlvbi5zZXQoMTQuOTA0LDEyLjE5OCwtMS44MzIpLHAuc2NhbGUuc2V0KC4xNSw0LjI2NSw2LjMzMSksdGhpcy5hZGQocCk7Y29uc3QgbT1uZXcgVm4odCx0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDQzKSk7bS5wb3NpdGlvbi5zZXQoLS40NjIsOC44OSwxNC41MiksbS5zY2FsZS5zZXQoNC4zOCw1LjQ0MSwuMDg4KSx0aGlzLmFkZChtKTtjb25zdCBmPW5ldyBWbih0LHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoMjApKTtmLnBvc2l0aW9uLnNldCgzLjIzNSwxMS40ODYsLTEyLjU0MSksZi5zY2FsZS5zZXQoMi41LDIsLjEpLHRoaXMuYWRkKGYpO2NvbnN0IGc9bmV3IFZuKHQsdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCgxMDApKTtnLnBvc2l0aW9uLnNldCgwLDIwLDApLGcuc2NhbGUuc2V0KDEsLjEsMSksdGhpcy5hZGQoZyl9Y3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwodCl7Y29uc3QgZT1uZXcgaG47cmV0dXJuIGUuY29sb3Iuc2V0U2NhbGFyKHQpLGV9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL2NsYXNzIFNkIGV4dGVuZHMgWXN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucG9zaXRpb24ueT0tMy41O2NvbnN0IHQ9bmV3IFduO3QuZGVsZXRlQXR0cmlidXRlKFwidXZcIik7Y29uc3QgZT1uZXcgWm8oe21ldGFsbmVzczowLHNpZGU6MX0pLG49bmV3IFpvKHttZXRhbG5lc3M6MH0pLGk9bmV3IElsKDE2Nzc3MjE1LDQwMCwyOCwyKTtpLnBvc2l0aW9uLnNldCguNSwxNCwuNSksdGhpcy5hZGQoaSk7Y29uc3Qgcj1uZXcgVm4odCxlKTtyLnBvc2l0aW9uLnNldCgwLDEzLjIsMCksci5zY2FsZS5zZXQoMzEuNSwyOC41LDMxLjUpLHRoaXMuYWRkKHIpO2NvbnN0IHM9bmV3IFZuKHQsbik7cy5wb3NpdGlvbi5zZXQoLTEwLjkwNiwtMSwxLjg0Nikscy5yb3RhdGlvbi5zZXQoMCwtLjE5NSwwKSxzLnNjYWxlLnNldCgyLjMyOCw3LjkwNSw0LjY1MSksdGhpcy5hZGQocyk7Y29uc3QgYT1uZXcgVm4odCxuKTthLnBvc2l0aW9uLnNldCgtNS42MDcsLS43NTQsLS43NTgpLGEucm90YXRpb24uc2V0KDAsLjk5NCwwKSxhLnNjYWxlLnNldCgxLjk3LDEuNTM0LDMuOTU1KSx0aGlzLmFkZChhKTtjb25zdCBvPW5ldyBWbih0LG4pO28ucG9zaXRpb24uc2V0KDYuMTY3LC0uMTYsNy44MDMpLG8ucm90YXRpb24uc2V0KDAsLjU2MSwwKSxvLnNjYWxlLnNldCgzLjkyNyw2LjI4NSwzLjY4NyksdGhpcy5hZGQobyk7Y29uc3QgbD1uZXcgVm4odCxuKTtsLnBvc2l0aW9uLnNldCgtMi4wMTcsLjAxOCw2LjEyNCksbC5yb3RhdGlvbi5zZXQoMCwuMzMzLDApLGwuc2NhbGUuc2V0KDIuMDAyLDQuNTY2LDIuMDY0KSx0aGlzLmFkZChsKTtjb25zdCBjPW5ldyBWbih0LG4pO2MucG9zaXRpb24uc2V0KDIuMjkxLC0uNzU2LC0yLjYyMSksYy5yb3RhdGlvbi5zZXQoMCwtLjI4NiwwKSxjLnNjYWxlLnNldCgxLjU0NiwxLjU1MiwxLjQ5NiksdGhpcy5hZGQoYyk7Y29uc3QgaD1uZXcgVm4odCxuKTtoLnBvc2l0aW9uLnNldCgtMi4xOTMsLS4zNjksLTUuNTQ3KSxoLnJvdGF0aW9uLnNldCgwLC41MTYsMCksaC5zY2FsZS5zZXQoMy44NzUsMy40ODcsMi45ODYpLHRoaXMuYWRkKGgpO2NvbnN0IHU9bmV3IFZuKHQsdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCg4MCkpO3UucG9zaXRpb24uc2V0KC0xNCwxMCw4KSx1LnNjYWxlLnNldCguMSwyLjUsMi41KSx0aGlzLmFkZCh1KTtjb25zdCBkPW5ldyBWbih0LHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoODApKTtkLnBvc2l0aW9uLnNldCgtMTQsMTQsLTQpLGQuc2NhbGUuc2V0KC4xLDIuNSwyLjUpLHRoaXMuYWRkKGQpO2NvbnN0IHA9bmV3IFZuKHQsdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCgyMykpO3AucG9zaXRpb24uc2V0KDE0LDEyLDApLHAuc2NhbGUuc2V0KC4xLDUsNSksdGhpcy5hZGQocCk7Y29uc3QgbT1uZXcgVm4odCx0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDE2KSk7bS5wb3NpdGlvbi5zZXQoMCw5LDE0KSxtLnNjYWxlLnNldCg1LDUsLjEpLHRoaXMuYWRkKG0pO2NvbnN0IGY9bmV3IFZuKHQsdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCg4MCkpO2YucG9zaXRpb24uc2V0KDcsOCwtMTQpLGYuc2NhbGUuc2V0KDIuNSwyLjUsLjEpLHRoaXMuYWRkKGYpO2NvbnN0IGc9bmV3IFZuKHQsdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCg4MCkpO2cucG9zaXRpb24uc2V0KC03LDE2LC0xNCksZy5zY2FsZS5zZXQoMi41LDIuNSwuMSksdGhpcy5hZGQoZyk7Y29uc3Qgdj1uZXcgVm4odCx0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDEpKTt2LnBvc2l0aW9uLnNldCgwLDIwLDApLHYuc2NhbGUuc2V0KC4xLC4xLC4xKSx0aGlzLmFkZCh2KX1jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCh0KXtjb25zdCBlPW5ldyBobjtyZXR1cm4gZS5jb2xvci5zZXRTY2FsYXIodCksZX19XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovY29uc3QgVGQ9L1xcLmhkcihcXC5qcyk/JC8sRWQ9bmV3IGJsLEFkPW5ldyBjbGFzcyBleHRlbmRzIHhse2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMudHlwZT0xMDE2fXBhcnNlKHQpe2NvbnN0IGU9ZnVuY3Rpb24odCxlKXtzd2l0Y2godCl7Y2FzZSAxOmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIFJlYWQgRXJyb3I6IFwiKyhlfHxcIlwiKSk7YnJlYWs7Y2FzZSAyOmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIFdyaXRlIEVycm9yOiBcIisoZXx8XCJcIikpO2JyZWFrO2Nhc2UgMzpjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlciBCYWQgRmlsZSBGb3JtYXQ6IFwiKyhlfHxcIlwiKSk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogRXJyb3I6IFwiKyhlfHxcIlwiKSl9cmV0dXJuLTF9LG49ZnVuY3Rpb24odCxlLG4pe2U9ZXx8MTAyNDtsZXQgaT10LnBvcyxyPS0xLHM9MCxhPVwiXCIsbz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQxNkFycmF5KHQuc3ViYXJyYXkoaSxpKzEyOCkpKTtmb3IoOzA+KHI9by5pbmRleE9mKFwiXFxuXCIpKSYmczxlJiZpPHQuYnl0ZUxlbmd0aDspYSs9byxzKz1vLmxlbmd0aCxpKz0xMjgsbys9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50MTZBcnJheSh0LnN1YmFycmF5KGksaSsxMjgpKSk7cmV0dXJuLTE8ciYmKCExIT09biYmKHQucG9zKz1zK3IrMSksYStvLnNsaWNlKDAscikpfSxpPWZ1bmN0aW9uKHQsZSxuLGkpe2NvbnN0IHI9dFtlKzNdLHM9TWF0aC5wb3coMixyLTEyOCkvMjU1O25baSswXT10W2UrMF0qcyxuW2krMV09dFtlKzFdKnMsbltpKzJdPXRbZSsyXSpzfSxyPWZ1bmN0aW9uKHQsZSxuLGkpe2NvbnN0IHI9dFtlKzNdLHM9TWF0aC5wb3coMixyLTEyOCkvMjU1O25baSswXT1jYy50b0hhbGZGbG9hdChNYXRoLm1pbih0W2UrMF0qcyw2NTUwNCkpLG5baSsxXT1jYy50b0hhbGZGbG9hdChNYXRoLm1pbih0W2UrMV0qcyw2NTUwNCkpLG5baSsyXT1jYy50b0hhbGZGbG9hdChNYXRoLm1pbih0W2UrMl0qcyw2NTUwNCkpfSxzPW5ldyBVaW50OEFycmF5KHQpO3MucG9zPTA7Y29uc3QgYT1mdW5jdGlvbih0KXtjb25zdCBpPS9eXFxzKkdBTU1BXFxzKj1cXHMqKFxcZCsoXFwuXFxkKyk/KVxccyokLyxyPS9eXFxzKkVYUE9TVVJFXFxzKj1cXHMqKFxcZCsoXFwuXFxkKyk/KVxccyokLyxzPS9eXFxzKkZPUk1BVD0oXFxTKylcXHMqJC8sYT0vXlxccypcXC1ZXFxzKyhcXGQrKVxccytcXCtYXFxzKyhcXGQrKVxccyokLyxvPXt2YWxpZDowLHN0cmluZzpcIlwiLGNvbW1lbnRzOlwiXCIscHJvZ3JhbXR5cGU6XCJSR0JFXCIsZm9ybWF0OlwiXCIsZ2FtbWE6MSxleHBvc3VyZToxLHdpZHRoOjAsaGVpZ2h0OjB9O2xldCBsLGM7aWYodC5wb3M+PXQuYnl0ZUxlbmd0aHx8IShsPW4odCkpKXJldHVybiBlKDEsXCJubyBoZWFkZXIgZm91bmRcIik7aWYoIShjPWwubWF0Y2goL14jXFw/KFxcUyspLykpKXJldHVybiBlKDMsXCJiYWQgaW5pdGlhbCB0b2tlblwiKTtmb3Ioby52YWxpZHw9MSxvLnByb2dyYW10eXBlPWNbMV0sby5zdHJpbmcrPWwrXCJcXG5cIjtsPW4odCksITEhPT1sOylpZihvLnN0cmluZys9bCtcIlxcblwiLFwiI1wiIT09bC5jaGFyQXQoMCkpe2lmKChjPWwubWF0Y2goaSkpJiYoby5nYW1tYT1wYXJzZUZsb2F0KGNbMV0sMTApKSwoYz1sLm1hdGNoKHIpKSYmKG8uZXhwb3N1cmU9cGFyc2VGbG9hdChjWzFdLDEwKSksKGM9bC5tYXRjaChzKSkmJihvLnZhbGlkfD0yLG8uZm9ybWF0PWNbMV0pLChjPWwubWF0Y2goYSkpJiYoby52YWxpZHw9NCxvLmhlaWdodD1wYXJzZUludChjWzFdLDEwKSxvLndpZHRoPXBhcnNlSW50KGNbMl0sMTApKSwyJm8udmFsaWQmJjQmby52YWxpZClicmVha31lbHNlIG8uY29tbWVudHMrPWwrXCJcXG5cIjtyZXR1cm4gMiZvLnZhbGlkPzQmby52YWxpZD9vOmUoMyxcIm1pc3NpbmcgaW1hZ2Ugc2l6ZSBzcGVjaWZpZXJcIik6ZSgzLFwibWlzc2luZyBmb3JtYXQgc3BlY2lmaWVyXCIpfShzKTtpZigtMSE9PWEpe2NvbnN0IHQ9YS53aWR0aCxuPWEuaGVpZ2h0LG89ZnVuY3Rpb24odCxuLGkpe2NvbnN0IHI9bjtpZihyPDh8fHI+MzI3Njd8fDIhPT10WzBdfHwyIT09dFsxXXx8MTI4JnRbMl0pcmV0dXJuIG5ldyBVaW50OEFycmF5KHQpO2lmKHIhPT0odFsyXTw8OHx0WzNdKSlyZXR1cm4gZSgzLFwid3Jvbmcgc2NhbmxpbmUgd2lkdGhcIik7Y29uc3Qgcz1uZXcgVWludDhBcnJheSg0Km4qaSk7aWYoIXMubGVuZ3RoKXJldHVybiBlKDQsXCJ1bmFibGUgdG8gYWxsb2NhdGUgYnVmZmVyIHNwYWNlXCIpO2xldCBhPTAsbz0wO2NvbnN0IGw9NCpyLGM9bmV3IFVpbnQ4QXJyYXkoNCksaD1uZXcgVWludDhBcnJheShsKTtsZXQgdT1pO2Zvcig7dT4wJiZvPHQuYnl0ZUxlbmd0aDspe2lmKG8rND50LmJ5dGVMZW5ndGgpcmV0dXJuIGUoMSk7aWYoY1swXT10W28rK10sY1sxXT10W28rK10sY1syXT10W28rK10sY1szXT10W28rK10sMiE9Y1swXXx8MiE9Y1sxXXx8KGNbMl08PDh8Y1szXSkhPXIpcmV0dXJuIGUoMyxcImJhZCByZ2JlIHNjYW5saW5lIGZvcm1hdFwiKTtsZXQgbixpPTA7Zm9yKDtpPGwmJm88dC5ieXRlTGVuZ3RoOyl7bj10W28rK107Y29uc3Qgcj1uPjEyODtpZihyJiYobi09MTI4KSwwPT09bnx8aStuPmwpcmV0dXJuIGUoMyxcImJhZCBzY2FubGluZSBkYXRhXCIpO2lmKHIpe2NvbnN0IGU9dFtvKytdO2ZvcihsZXQgdD0wO3Q8bjt0KyspaFtpKytdPWV9ZWxzZSBoLnNldCh0LnN1YmFycmF5KG8sbytuKSxpKSxpKz1uLG8rPW59Y29uc3QgZD1yO2ZvcihsZXQgdD0wO3Q8ZDt0Kyspe2xldCBlPTA7c1thXT1oW3QrZV0sZSs9cixzW2ErMV09aFt0K2VdLGUrPXIsc1thKzJdPWhbdCtlXSxlKz1yLHNbYSszXT1oW3QrZV0sYSs9NH11LS19cmV0dXJuIHN9KHMuc3ViYXJyYXkocy5wb3MpLHQsbik7aWYoLTEhPT1vKXtsZXQgZSxzLGwsYztzd2l0Y2godGhpcy50eXBlKXtjYXNlIDEwMDk6ZT1vLHM9MTAyMyxsPTEwMDk7YnJlYWs7Y2FzZSAxMDE1OmM9by5sZW5ndGgvNDtjb25zdCB0PW5ldyBGbG9hdDMyQXJyYXkoMypjKTtmb3IobGV0IGU9MDtlPGM7ZSsrKWkobyw0KmUsdCwzKmUpO2U9dCxzPTEwMjIsbD0xMDE1O2JyZWFrO2Nhc2UgMTAxNjpjPW8ubGVuZ3RoLzQ7Y29uc3Qgbj1uZXcgVWludDE2QXJyYXkoMypjKTtmb3IobGV0IHQ9MDt0PGM7dCsrKXIobyw0KnQsbiwzKnQpO2U9bixzPTEwMjIsbD0xMDE2O2JyZWFrO2RlZmF1bHQ6Y29uc29sZS5lcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IHVuc3VwcG9ydGVkIHR5cGU6IFwiLHRoaXMudHlwZSl9cmV0dXJue3dpZHRoOnQsaGVpZ2h0Om4sZGF0YTplLGhlYWRlcjphLnN0cmluZyxnYW1tYTphLmdhbW1hLGV4cG9zdXJlOmEuZXhwb3N1cmUsZm9ybWF0OnMsdHlwZTpsfX19cmV0dXJuIG51bGx9c2V0RGF0YVR5cGUodCl7cmV0dXJuIHRoaXMudHlwZT10LHRoaXN9bG9hZCh0LGUsbixpKXtyZXR1cm4gc3VwZXIubG9hZCh0LChmdW5jdGlvbih0LG4pe3N3aXRjaCh0LnR5cGUpe2Nhc2UgMTAwOTp0LmVuY29kaW5nPTMwMDIsdC5taW5GaWx0ZXI9MTAwMyx0Lm1hZ0ZpbHRlcj0xMDAzLHQuZ2VuZXJhdGVNaXBtYXBzPSExLHQuZmxpcFk9ITA7YnJlYWs7Y2FzZSAxMDE1OmNhc2UgMTAxNjp0LmVuY29kaW5nPTNlMyx0Lm1pbkZpbHRlcj0xMDA2LHQubWFnRmlsdGVyPTEwMDYsdC5nZW5lcmF0ZU1pcG1hcHM9ITEsdC5mbGlwWT0hMH1lJiZlKHQsbil9KSxuLGkpfX07QWQuc2V0RGF0YVR5cGUoMTAxNik7Y2xhc3MgTGQgZXh0ZW5kcyBwdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMudGhyZWVSZW5kZXJlcj10LHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXA9bnVsbCx0aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwQWx0PW51bGwsdGhpcy5za3lib3hDYWNoZT1uZXcgTWFwLHRoaXMuYmx1ck1hdGVyaWFsPW51bGwsdGhpcy5ibHVyU2NlbmU9bnVsbH1hc3luYyBsb2FkKHQsZT0oKCk9Pnt9KSl7dHJ5e2NvbnN0IG49VGQudGVzdCh0KSxpPW4/QWQ6RWQscj1hd2FpdCBuZXcgUHJvbWlzZSgoKG4scik9PmkubG9hZCh0LG4sKHQ9PntlKHQubG9hZGVkL3QudG90YWwqLjkpfSkscikpKTtyZXR1cm4gZSgxKSxyLm5hbWU9dCxyLm1hcHBpbmc9MzAzLG58fChyLmVuY29kaW5nPTMwMDcpLHJ9ZmluYWxseXtlJiZlKDEpfX1hc3luYyBnZW5lcmF0ZUVudmlyb25tZW50TWFwQW5kU2t5Ym94KHQ9bnVsbCxlPW51bGwsbj17fSl7Y29uc3R7cHJvZ3Jlc3NUcmFja2VyOml9PW4scj1udWxsIT1pP2kuYmVnaW5BY3Rpdml0eSgpOigpPT57fSxzPVwibmV1dHJhbFwiPT09ZTshMD09PXMmJihlPW51bGwpO2NvbnN0IGE9cWgoZSk7dHJ5e2xldCBlLG49UHJvbWlzZS5yZXNvbHZlKG51bGwpO3QmJihuPXRoaXMubG9hZEVxdWlyZWN0RnJvbVVybCh0LGkpKSxlPWE/dGhpcy5sb2FkRXF1aXJlY3RGcm9tVXJsKGEsaSk6dD90aGlzLmxvYWRFcXVpcmVjdEZyb21VcmwodCxpKTohMD09PXM/dGhpcy5sb2FkR2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQoKTp0aGlzLmxvYWRHZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCgpO2xldFtvLGxdPWF3YWl0IFByb21pc2UuYWxsKFtlLG5dKTtpZihudWxsPT1vKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGVudmlyb25tZW50IG1hcC5cIik7cmV0dXJue2Vudmlyb25tZW50TWFwOm8sc2t5Ym94Omx9fWZpbmFsbHl7cigxKX19YXN5bmMgbG9hZEVxdWlyZWN0RnJvbVVybCh0LGUpe2lmKCF0aGlzLnNreWJveENhY2hlLmhhcyh0KSl7Y29uc3Qgbj1lP2UuYmVnaW5BY3Rpdml0eSgpOigpPT57fSxpPXRoaXMubG9hZCh0LG4pO3RoaXMuc2t5Ym94Q2FjaGUuc2V0KHQsaSl9cmV0dXJuIHRoaXMuc2t5Ym94Q2FjaGUuZ2V0KHQpfWFzeW5jIEdlbmVyYXRlRW52aXJvbm1lbnRNYXAodCxlKXthd2FpdCBRaCgpO2NvbnN0IG49dGhpcy50aHJlZVJlbmRlcmVyLGk9bmV3IFFuKDI1Nix7Z2VuZXJhdGVNaXBtYXBzOiExLHR5cGU6MTAxNixmb3JtYXQ6MTAyMyxlbmNvZGluZzozZTMsZGVwdGhCdWZmZXI6ITB9KSxyPW5ldyAkbiguMSwxMDAsaSkscz1yLnJlbmRlclRhcmdldC50ZXh0dXJlO3MubmFtZT1lLHMuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPSExLHMuaW1hZ2VzPVsxLDEsMSwxLDEsMV0sdC5zY2FsZS5zZXRDb21wb25lbnQoMCwtMSk7Y29uc3QgYT1uLm91dHB1dEVuY29kaW5nLG89bi50b25lTWFwcGluZztyZXR1cm4gbi50b25lTWFwcGluZz0wLG4ub3V0cHV0RW5jb2Rpbmc9M2UzLHIudXBkYXRlKG4sdCksYXdhaXQgdGhpcy5ibHVyQ3ViZW1hcChpLC4wNCksbi50b25lTWFwcGluZz1vLG4ub3V0cHV0RW5jb2Rpbmc9YSxzfWFzeW5jIGxvYWRHZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCgpe3JldHVybiBudWxsPT10aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwJiYodGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcD10aGlzLkdlbmVyYXRlRW52aXJvbm1lbnRNYXAobmV3IE1kLFwiZGVmYXVsdFwiKSksdGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcH1hc3luYyBsb2FkR2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQoKXtyZXR1cm4gbnVsbD09dGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcEFsdCYmKHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQ9dGhpcy5HZW5lcmF0ZUVudmlyb25tZW50TWFwKG5ldyBTZCxcIm5ldXRyYWxcIikpLHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHR9YXN5bmMgYmx1ckN1YmVtYXAodCxlKXtpZihudWxsPT10aGlzLmJsdXJNYXRlcmlhbCl7dGhpcy5ibHVyTWF0ZXJpYWw9dGhpcy5nZXRCbHVyU2hhZGVyKDIwKTtjb25zdCB0PW5ldyBXbixlPW5ldyBWbih0LHRoaXMuYmx1ck1hdGVyaWFsKTt0aGlzLmJsdXJTY2VuZT1uZXcgWXMsdGhpcy5ibHVyU2NlbmUuYWRkKGUpfWNvbnN0IG49dC5jbG9uZSgpO3RoaXMuaGFsZmJsdXIodCxuLGUsXCJsYXRpdHVkaW5hbFwiKSx0aGlzLmhhbGZibHVyKG4sdCxlLFwibG9uZ2l0dWRpbmFsXCIpfWFzeW5jIGhhbGZibHVyKHQsZSxuLGkpe2NvbnN0IHI9dC53aWR0aCxzPWlzRmluaXRlKG4pP01hdGguUEkvKDIqcik6MipNYXRoLlBJLzM5LGE9bi9zLG89aXNGaW5pdGUobik/MStNYXRoLmZsb29yKDMqYSk6MjA7bz4yMCYmY29uc29sZS53YXJuKGBzaWdtYVJhZGlhbnMsICR7bn0sIGlzIHRvbyBsYXJnZSBhbmQgd2lsbCBjbGlwLCBhcyBpdCByZXF1ZXN0ZWQgJHtvfSBzYW1wbGVzIHdoZW4gdGhlIG1heGltdW0gaXMgc2V0IHRvIDIwYCk7Y29uc3QgbD1bXTtsZXQgYz0wO2ZvcihsZXQgdD0wO3Q8MjA7Kyt0KXtjb25zdCBlPXQvYSxuPU1hdGguZXhwKC1lKmUvMik7bC5wdXNoKG4pLDA9PXQ/Yys9bjp0PG8mJihjKz0yKm4pfWZvcihsZXQgdD0wO3Q8bC5sZW5ndGg7dCsrKWxbdF09bFt0XS9jO2NvbnN0IGg9dGhpcy5ibHVyTWF0ZXJpYWwudW5pZm9ybXM7aC5lbnZNYXAudmFsdWU9dC50ZXh0dXJlLGguc2FtcGxlcy52YWx1ZT1vLGgud2VpZ2h0cy52YWx1ZT1sLGgubGF0aXR1ZGluYWwudmFsdWU9XCJsYXRpdHVkaW5hbFwiPT09aSxoLmRUaGV0YS52YWx1ZT1zO25ldyAkbiguMSwxMDAsZSkudXBkYXRlKHRoaXMudGhyZWVSZW5kZXJlcix0aGlzLmJsdXJTY2VuZSl9Z2V0Qmx1clNoYWRlcih0KXtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkodCksbj1uZXcgQnQoMCwxLDApO3JldHVybiBuZXcgWW4oe25hbWU6XCJTcGhlcmljYWxHYXVzc2lhbkJsdXJcIixkZWZpbmVzOntuOnR9LHVuaWZvcm1zOntlbnZNYXA6e3ZhbHVlOm51bGx9LHNhbXBsZXM6e3ZhbHVlOjF9LHdlaWdodHM6e3ZhbHVlOmV9LGxhdGl0dWRpbmFsOnt2YWx1ZTohMX0sZFRoZXRhOnt2YWx1ZTowfSxwb2xlQXhpczp7dmFsdWU6bn19LHZlcnRleFNoYWRlcjpcIlxcbiAgICAgIFxcbiAgICAgIHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xcbiAgXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgXFxuICAgICAgICB2T3V0cHV0RGlyZWN0aW9uID0gdmVjMyggcG9zaXRpb24gKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG4gIFxcbiAgICAgIH1cXG4gICAgXCIsZnJhZ21lbnRTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xcbiAgXFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG4gICAgICAgIHVuaWZvcm0gaW50IHNhbXBsZXM7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHdlaWdodHNbIG4gXTtcXG4gICAgICAgIHVuaWZvcm0gYm9vbCBsYXRpdHVkaW5hbDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgZFRoZXRhO1xcbiAgICAgICAgdW5pZm9ybSB2ZWMzIHBvbGVBeGlzO1xcbiAgXFxuICAgICAgICB2ZWMzIGdldFNhbXBsZSggZmxvYXQgdGhldGEsIHZlYzMgYXhpcyApIHtcXG4gIFxcbiAgICAgICAgICBmbG9hdCBjb3NUaGV0YSA9IGNvcyggdGhldGEgKTtcXG4gICAgICAgICAgLy8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uXFxuICAgICAgICAgIHZlYzMgc2FtcGxlRGlyZWN0aW9uID0gdk91dHB1dERpcmVjdGlvbiAqIGNvc1RoZXRhXFxuICAgICAgICAgICAgKyBjcm9zcyggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogc2luKCB0aGV0YSApXFxuICAgICAgICAgICAgKyBheGlzICogZG90KCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiAoIDEuMCAtIGNvc1RoZXRhICk7XFxuICBcXG4gICAgICAgICAgcmV0dXJuIHZlYzMoIHRleHR1cmVDdWJlKCBlbnZNYXAsIHNhbXBsZURpcmVjdGlvbiApICk7XFxuICBcXG4gICAgICAgIH1cXG4gIFxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgXFxuICAgICAgICAgIHZlYzMgYXhpcyA9IGxhdGl0dWRpbmFsID8gcG9sZUF4aXMgOiBjcm9zcyggcG9sZUF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKTtcXG4gIFxcbiAgICAgICAgICBpZiAoIGFsbCggZXF1YWwoIGF4aXMsIHZlYzMoIDAuMCApICkgKSApIHtcXG4gIFxcbiAgICAgICAgICAgIGF4aXMgPSB2ZWMzKCB2T3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgLSB2T3V0cHV0RGlyZWN0aW9uLnggKTtcXG4gIFxcbiAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgYXhpcyA9IG5vcm1hbGl6ZSggYXhpcyApO1xcbiAgXFxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcbiAgICAgICAgICBnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIDAgXSAqIGdldFNhbXBsZSggMC4wLCBheGlzICk7XFxuICBcXG4gICAgICAgICAgZm9yICggaW50IGkgPSAxOyBpIDwgbjsgaSsrICkge1xcbiAgXFxuICAgICAgICAgICAgaWYgKCBpID49IHNhbXBsZXMgKSB7XFxuICBcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgXFxuICAgICAgICAgICAgfVxcbiAgXFxuICAgICAgICAgICAgZmxvYXQgdGhldGEgPSBkVGhldGEgKiBmbG9hdCggaSApO1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCAtMS4wICogdGhldGEsIGF4aXMgKTtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggdGhldGEsIGF4aXMgKTtcXG4gIFxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgXCIsYmxlbmRpbmc6MCxkZXB0aFRlc3Q6ITEsZGVwdGhXcml0ZTohMSxzaWRlOjF9KX1hc3luYyBkaXNwb3NlKCl7Zm9yKGNvbnN0Wyx0XW9mIHRoaXMuc2t5Ym94Q2FjaGUpeyhhd2FpdCB0KS5kaXNwb3NlKCl9bnVsbCE9dGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCYmKChhd2FpdCB0aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwKS5kaXNwb3NlKCksdGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcD1udWxsKSxudWxsIT10aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwQWx0JiYoKGF3YWl0IHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQpLmRpc3Bvc2UoKSx0aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwQWx0PW51bGwpLG51bGwhPXRoaXMuYmx1ck1hdGVyaWFsJiZ0aGlzLmJsdXJNYXRlcmlhbC5kaXNwb3NlKCl9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL2NvbnN0IFJkPVsxLC43OSwuNjIsLjUsLjQsLjMxLC4yNV07Y2xhc3MgQ2QgZXh0ZW5kcyBwdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMubG9hZGVyPW5ldyBraChfZCksdGhpcy53aWR0aD0wLHRoaXMuaGVpZ2h0PTAsdGhpcy5kcHI9MSx0aGlzLmRlYnVnZ2VyPW51bGwsdGhpcy5zY2VuZXM9bmV3IFNldCx0aGlzLm11bHRpcGxlU2NlbmVzVmlzaWJsZT0hMSx0aGlzLnNjYWxlU3RlcD0wLHRoaXMubGFzdFN0ZXA9Myx0aGlzLmF2Z0ZyYW1lRHVyYXRpb249MjIsdGhpcy5vbldlYkdMQ29udGV4dExvc3Q9dD0+e3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTpcImNvbnRleHRsb3N0XCIsc291cmNlRXZlbnQ6dH0pfSx0aGlzLm9uV2ViR0xDb250ZXh0UmVzdG9yZWQ9KCk9Pnt2YXIgdDtudWxsPT09KHQ9dGhpcy50ZXh0dXJlVXRpbHMpfHx2b2lkIDA9PT10fHx0LmRpc3Bvc2UoKSx0aGlzLnRleHR1cmVVdGlscz1uZXcgTGQodGhpcy50aHJlZVJlbmRlcmVyKSx0aGlzLnJvdWdobmVzc01pcG1hcHBlcj1uZXcgSXUodGhpcy50aHJlZVJlbmRlcmVyKTtmb3IoY29uc3QgdCBvZiB0aGlzLnNjZW5lcyl0LmVsZW1lbnRbT3VdKCk7dGhpcy50aHJlZVJlbmRlcmVyLnNoYWRvd01hcC5uZWVkc1VwZGF0ZT0hMH0sdGhpcy5kcHI9JGgoKSx0aGlzLmNhbnZhczNEPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksdGhpcy5jYW52YXMzRC5pZD1cIndlYmdsLWNhbnZhc1wiO3RyeXt0aGlzLnRocmVlUmVuZGVyZXI9bmV3IFhzKHtjYW52YXM6dGhpcy5jYW52YXMzRCxhbHBoYTohMCxhbnRpYWxpYXM6ITAscG93ZXJQcmVmZXJlbmNlOnQucG93ZXJQcmVmZXJlbmNlLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMH0pLHRoaXMudGhyZWVSZW5kZXJlci5hdXRvQ2xlYXI9ITAsdGhpcy50aHJlZVJlbmRlcmVyLm91dHB1dEVuY29kaW5nPTMwMDcsdGhpcy50aHJlZVJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzPSEwLHRoaXMudGhyZWVSZW5kZXJlci5zZXRQaXhlbFJhdGlvKDEpLHRoaXMudGhyZWVSZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZD0hMCx0aGlzLnRocmVlUmVuZGVyZXIuc2hhZG93TWFwLnR5cGU9Mix0aGlzLnRocmVlUmVuZGVyZXIuc2hhZG93TWFwLmF1dG9VcGRhdGU9ITEsdGhpcy5kZWJ1Z2dlcj10LmRlYnVnP25ldyBuZCh0aGlzKTpudWxsLHRoaXMudGhyZWVSZW5kZXJlci5kZWJ1Zz17Y2hlY2tTaGFkZXJFcnJvcnM6ISF0aGlzLmRlYnVnZ2VyfSx0aGlzLnRocmVlUmVuZGVyZXIudG9uZU1hcHBpbmc9NH1jYXRjaCh0KXtjb25zb2xlLndhcm4odCl9dGhpcy5hclJlbmRlcmVyPW5ldyBlZCh0aGlzKSx0aGlzLnRleHR1cmVVdGlscz10aGlzLmNhblJlbmRlcj9uZXcgTGQodGhpcy50aHJlZVJlbmRlcmVyKTpudWxsLHRoaXMucm91Z2huZXNzTWlwbWFwcGVyPW5ldyBJdSh0aGlzLnRocmVlUmVuZGVyZXIpLGtoLmluaXRpYWxpemVLVFgyTG9hZGVyKHRoaXMudGhyZWVSZW5kZXJlciksdGhpcy5jYW52YXMzRC5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLHRoaXMub25XZWJHTENvbnRleHRMb3N0KSx0aGlzLmNhbnZhczNELmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLHRoaXMub25XZWJHTENvbnRleHRSZXN0b3JlZCksdGhpcy51cGRhdGVSZW5kZXJlclNpemUoKSx0aGlzLmxhc3RUaWNrPXBlcmZvcm1hbmNlLm5vdygpLHRoaXMuYXZnRnJhbWVEdXJhdGlvbj0wfXN0YXRpYyBnZXQgc2luZ2xldG9uKCl7cmV0dXJuIHRoaXMuX3NpbmdsZXRvbn1zdGF0aWMgcmVzZXRTaW5nbGV0b24oKXtjb25zdCB0PXRoaXMuX3NpbmdsZXRvbi5kaXNwb3NlKCk7Zm9yKGNvbnN0IGUgb2YgdCllLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7dGhpcy5fc2luZ2xldG9uPW5ldyBDZCh7cG93ZXJQcmVmZXJlbmNlOihzZWxmLk1vZGVsVmlld2VyRWxlbWVudHx8e30pLnBvd2VyUHJlZmVyZW5jZXx8XCJoaWdoLXBlcmZvcm1hbmNlXCIsZGVidWc6S2goKX0pO2Zvcihjb25zdCBlIG9mIHQpZS5jb25uZWN0ZWRDYWxsYmFjaygpfWdldCBjYW5SZW5kZXIoKXtyZXR1cm4gbnVsbCE9dGhpcy50aHJlZVJlbmRlcmVyfWdldCBzY2FsZUZhY3Rvcigpe3JldHVybiBSZFt0aGlzLnNjYWxlU3RlcF19c2V0IG1pblNjYWxlKHQpe2xldCBlPTE7Zm9yKDtlPFJkLmxlbmd0aCYmIShSZFtlXTx0KTspKytlO3RoaXMubGFzdFN0ZXA9ZS0xfXVwZGF0ZVJlbmRlcmVyU2l6ZSgpe2NvbnN0IHQ9JGgoKTtpZih0IT09dGhpcy5kcHIpZm9yKGNvbnN0IHQgb2YgdGhpcy5zY2VuZXMpe2NvbnN0e2VsZW1lbnQ6ZX09dDtlW2VwXShlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKX1sZXQgZT0wLG49MDtmb3IoY29uc3QgdCBvZiB0aGlzLnNjZW5lcyllPU1hdGgubWF4KGUsdC53aWR0aCksbj1NYXRoLm1heChuLHQuaGVpZ2h0KTtpZihlPT09dGhpcy53aWR0aCYmbj09PXRoaXMuaGVpZ2h0JiZ0PT09dGhpcy5kcHIpcmV0dXJuO3RoaXMud2lkdGg9ZSx0aGlzLmhlaWdodD1uLHRoaXMuZHByPXQsdGhpcy5jYW5SZW5kZXImJnRoaXMudGhyZWVSZW5kZXJlci5zZXRTaXplKGUqdCxuKnQsITEpO2NvbnN0IGk9dGhpcy5zY2FsZUZhY3RvcixyPWUvaSxzPW4vaTt0aGlzLmNhbnZhczNELnN0eWxlLndpZHRoPWAke3J9cHhgLHRoaXMuY2FudmFzM0Quc3R5bGUuaGVpZ2h0PWAke3N9cHhgO2Zvcihjb25zdCBpIG9mIHRoaXMuc2NlbmVzKXtjb25zdHtjYW52YXM6YX09aTthLndpZHRoPU1hdGgucm91bmQoZSp0KSxhLmhlaWdodD1NYXRoLnJvdW5kKG4qdCksYS5zdHlsZS53aWR0aD1gJHtyfXB4YCxhLnN0eWxlLmhlaWdodD1gJHtzfXB4YCxpLnF1ZXVlUmVuZGVyKCl9fXVwZGF0ZVJlbmRlcmVyU2NhbGUoKXtjb25zdCB0PXRoaXMuc2NhbGVTdGVwO2lmKHRoaXMuYXZnRnJhbWVEdXJhdGlvbj4yNj8rK3RoaXMuc2NhbGVTdGVwOnRoaXMuYXZnRnJhbWVEdXJhdGlvbjwxOCYmdGhpcy5zY2FsZVN0ZXA+MCYmLS10aGlzLnNjYWxlU3RlcCx0aGlzLnNjYWxlU3RlcD1NYXRoLm1pbih0aGlzLnNjYWxlU3RlcCx0aGlzLmxhc3RTdGVwKSx0PT10aGlzLnNjYWxlU3RlcClyZXR1cm47Y29uc3QgZT10aGlzLnNjYWxlRmFjdG9yO3RoaXMuYXZnRnJhbWVEdXJhdGlvbj0yMjtjb25zdCBuPXRoaXMud2lkdGgvZSxpPXRoaXMuaGVpZ2h0L2U7dGhpcy5jYW52YXMzRC5zdHlsZS53aWR0aD1gJHtufXB4YCx0aGlzLmNhbnZhczNELnN0eWxlLmhlaWdodD1gJHtpfXB4YDtmb3IoY29uc3QgdCBvZiB0aGlzLnNjZW5lcyl7Y29uc3R7c3R5bGU6ZX09dC5jYW52YXM7ZS53aWR0aD1gJHtufXB4YCxlLmhlaWdodD1gJHtpfXB4YCx0LnF1ZXVlUmVuZGVyKCl9fXJlZ2lzdGVyU2NlbmUodCl7dGhpcy5zY2VuZXMuYWRkKHQpO2NvbnN0e2NhbnZhczplfT10LG49dGhpcy5zY2FsZUZhY3RvcjtlLndpZHRoPU1hdGgucm91bmQodGhpcy53aWR0aCp0aGlzLmRwciksZS5oZWlnaHQ9TWF0aC5yb3VuZCh0aGlzLmhlaWdodCp0aGlzLmRwciksZS5zdHlsZS53aWR0aD10aGlzLndpZHRoL24rXCJweFwiLGUuc3R5bGUuaGVpZ2h0PXRoaXMuaGVpZ2h0L24rXCJweFwiLHRoaXMubXVsdGlwbGVTY2VuZXNWaXNpYmxlJiZlLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpLHQucXVldWVSZW5kZXIoKSx0aGlzLmNhblJlbmRlciYmdGhpcy5zY2VuZXMuc2l6ZT4wJiZ0aGlzLnRocmVlUmVuZGVyZXIuc2V0QW5pbWF0aW9uTG9vcCgoKHQsZSk9PnRoaXMucmVuZGVyKHQsZSkpKSxudWxsIT10aGlzLmRlYnVnZ2VyJiZ0aGlzLmRlYnVnZ2VyLmFkZFNjZW5lKHQpfXVucmVnaXN0ZXJTY2VuZSh0KXt0aGlzLnNjZW5lcy5kZWxldGUodCksdGhpcy5jYW5SZW5kZXImJjA9PT10aGlzLnNjZW5lcy5zaXplJiZ0aGlzLnRocmVlUmVuZGVyZXIuc2V0QW5pbWF0aW9uTG9vcChudWxsKSxudWxsIT10aGlzLmRlYnVnZ2VyJiZ0aGlzLmRlYnVnZ2VyLnJlbW92ZVNjZW5lKHQpfWRpc3BsYXlDYW52YXModCl7cmV0dXJuIHRoaXMubXVsdGlwbGVTY2VuZXNWaXNpYmxlP3QuZWxlbWVudFt1cF06dGhpcy5jYW52YXMzRH1zZWxlY3RDYW52YXMoKXtsZXQgdD0wLGU9bnVsbDtmb3IoY29uc3QgbiBvZiB0aGlzLnNjZW5lcyl7Y29uc3R7ZWxlbWVudDppfT1uO2kubW9kZWxJc1Zpc2libGUmJm51bGw9PW4uZXh0ZXJuYWxSZW5kZXJlciYmKCsrdCxlPW4uY2FudmFzKX1pZihudWxsPT1lKXJldHVybjtjb25zdCBuPXQ+MSx7Y2FudmFzM0Q6aX09dGhpcztpZihuIT09dGhpcy5tdWx0aXBsZVNjZW5lc1Zpc2libGV8fCFuJiZpLnBhcmVudEVsZW1lbnQhPT1lLnBhcmVudEVsZW1lbnQpe3RoaXMubXVsdGlwbGVTY2VuZXNWaXNpYmxlPW4sbiYmaS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtmb3IoY29uc3QgdCBvZiB0aGlzLnNjZW5lcyl7aWYobnVsbCE9dC5leHRlcm5hbFJlbmRlcmVyKWNvbnRpbnVlO2NvbnN0IHI9dC5lbGVtZW50W3VwXTtuPyhyLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpLHQucXVldWVSZW5kZXIoKSk6dC5jYW52YXM9PT1lJiYodC5jYW52YXMucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChpKSxpLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpLHIuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIiksdC5xdWV1ZVJlbmRlcigpKX19fW9yZGVyZWRTY2VuZXMoKXtjb25zdCB0PVtdO2Zvcihjb25zdCBlIG9mWyExLCEwXSlmb3IoY29uc3QgbiBvZiB0aGlzLnNjZW5lcyluLmVsZW1lbnQubW9kZWxJc1Zpc2libGU9PT1lJiZ0LnB1c2gobik7cmV0dXJuIHR9Z2V0IGlzUHJlc2VudGluZygpe3JldHVybiB0aGlzLmFyUmVuZGVyZXIuaXNQcmVzZW50aW5nfXByZVJlbmRlcih0LGUsbil7Y29uc3R7ZWxlbWVudDppLGV4cG9zdXJlOnJ9PXQ7aVttcF0oZSxuKTtjb25zdCBzPVwibnVtYmVyXCI9PXR5cGVvZiByJiYhc2VsZi5pc05hTihyKTt0aGlzLnRocmVlUmVuZGVyZXIudG9uZU1hcHBpbmdFeHBvc3VyZT1zP3I6MSx0LmlzU2hhZG93RGlydHkoKSYmKHRoaXMudGhyZWVSZW5kZXJlci5zaGFkb3dNYXAubmVlZHNVcGRhdGU9ITApfXJlbmRlcih0LGUpe2lmKG51bGwhPWUpcmV0dXJuIHZvaWQgdGhpcy5hclJlbmRlcmVyLm9uV2ViWFJGcmFtZSh0LGUpO2NvbnN0IG49dC10aGlzLmxhc3RUaWNrO2lmKHRoaXMubGFzdFRpY2s9dCwhdGhpcy5jYW5SZW5kZXJ8fHRoaXMuaXNQcmVzZW50aW5nKXJldHVybjt0aGlzLmF2Z0ZyYW1lRHVyYXRpb24rPUpoKC4yKihuLXRoaXMuYXZnRnJhbWVEdXJhdGlvbiksLTIsMiksdGhpcy5zZWxlY3RDYW52YXMoKSx0aGlzLnVwZGF0ZVJlbmRlcmVyU2l6ZSgpLHRoaXMudXBkYXRlUmVuZGVyZXJTY2FsZSgpO2NvbnN0e2RwcjppLHNjYWxlRmFjdG9yOnJ9PXRoaXM7Zm9yKGNvbnN0IGUgb2YgdGhpcy5vcmRlcmVkU2NlbmVzKCkpe2NvbnN0e2VsZW1lbnQ6c309ZTtpZighcy5tb2RlbElzVmlzaWJsZSYmZS5yZW5kZXJDb3VudD4wKWNvbnRpbnVlO2lmKHRoaXMucHJlUmVuZGVyKGUsdCxuKSwhZS5zaG91bGRSZW5kZXIoKSljb250aW51ZTtpZihudWxsIT1lLmV4dGVybmFsUmVuZGVyZXIpe2NvbnN0IHQ9ZS5nZXRDYW1lcmEoKTt0LnVwZGF0ZU1hdHJpeCgpO2NvbnN0e21hdHJpeDpuLHByb2plY3Rpb25NYXRyaXg6aX09dCxyPW4uZWxlbWVudHMuc2xpY2UoKSxzPWUuZ2V0VGFyZ2V0KCk7clsxMl0rPXMueCxyWzEzXSs9cy55LHJbMTRdKz1zLnosZS5leHRlcm5hbFJlbmRlcmVyLnJlbmRlcih7dmlld01hdHJpeDpyLHByb2plY3Rpb25NYXRyaXg6aS5lbGVtZW50c30pO2NvbnRpbnVlfWlmKCFzLm1vZGVsSXNWaXNpYmxlJiYhdGhpcy5tdWx0aXBsZVNjZW5lc1Zpc2libGUpZm9yKGNvbnN0IHQgb2YgdGhpcy5zY2VuZXMpdC5lbGVtZW50Lm1vZGVsSXNWaXNpYmxlJiZ0LnF1ZXVlUmVuZGVyKCk7Y29uc3QgYT1NYXRoLm1pbihNYXRoLmNlaWwoZS53aWR0aCpyKmkpLHRoaXMuY2FudmFzM0Qud2lkdGgpLG89TWF0aC5taW4oTWF0aC5jZWlsKGUuaGVpZ2h0KnIqaSksdGhpcy5jYW52YXMzRC5oZWlnaHQpO2lmKHRoaXMudGhyZWVSZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCksdGhpcy50aHJlZVJlbmRlcmVyLnNldFZpZXdwb3J0KDAsTWF0aC5mbG9vcih0aGlzLmhlaWdodCppKS1vLGEsbyksdGhpcy50aHJlZVJlbmRlcmVyLnJlbmRlcihlLGUuY2FtZXJhKSx0aGlzLm11bHRpcGxlU2NlbmVzVmlzaWJsZSl7bnVsbD09ZS5jb250ZXh0JiZlLmNyZWF0ZUNvbnRleHQoKTtjb25zdCB0PWUuY29udGV4dDt0LmNsZWFyUmVjdCgwLDAsYSxvKSx0LmRyYXdJbWFnZSh0aGlzLmNhbnZhczNELDAsMCxhLG8sMCwwLGEsbyl9ZS5oYXNSZW5kZXJlZCgpLHMubG9hZGVkJiYrK2UucmVuZGVyQ291bnR9fWRpc3Bvc2UoKXtudWxsIT10aGlzLnRleHR1cmVVdGlscyYmdGhpcy50ZXh0dXJlVXRpbHMuZGlzcG9zZSgpLG51bGwhPXRoaXMucm91Z2huZXNzTWlwbWFwcGVyJiZ0aGlzLnJvdWdobmVzc01pcG1hcHBlci5kaXNwb3NlKCksbnVsbCE9dGhpcy50aHJlZVJlbmRlcmVyJiZ0aGlzLnRocmVlUmVuZGVyZXIuZGlzcG9zZSgpLHRoaXMudGV4dHVyZVV0aWxzPW51bGwsdGhpcy50aHJlZVJlbmRlcmVyPW51bGw7Y29uc3QgdD1bXTtmb3IoY29uc3QgZSBvZiB0aGlzLnNjZW5lcyl0LnB1c2goZS5lbGVtZW50KTtyZXR1cm4gdGhpcy5jYW52YXMzRC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLHRoaXMub25XZWJHTENvbnRleHRMb3N0KSx0aGlzLmNhbnZhczNELnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLHRoaXMub25XZWJHTENvbnRleHRSZXN0b3JlZCksdH19Q2QuX3NpbmdsZXRvbj1uZXcgQ2Qoe3Bvd2VyUHJlZmVyZW5jZTooc2VsZi5Nb2RlbFZpZXdlckVsZW1lbnR8fHt9KS5wb3dlclByZWZlcmVuY2V8fFwiaGlnaC1wZXJmb3JtYW5jZVwiLGRlYnVnOktoKCl9KTtcbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBQZCxJZDtjb25zdCBEZD1TeW1ib2woXCJvbmdvaW5nQWN0aXZpdGllc1wiKSxOZD1TeW1ib2woXCJhbm5vdW5jZVRvdGFsUHJvZ3Jlc3NcIiksRmQ9U3ltYm9sKFwiZXZlbnREZWxlZ2F0ZVwiKTtjbGFzcyBPZHtjb25zdHJ1Y3Rvcigpe3RoaXNbUGRdPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSx0aGlzLmFkZEV2ZW50TGlzdGVuZXI9KC4uLnQpPT50aGlzW0ZkXS5hZGRFdmVudExpc3RlbmVyKC4uLnQpLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcj0oLi4udCk9PnRoaXNbRmRdLnJlbW92ZUV2ZW50TGlzdGVuZXIoLi4udCksdGhpcy5kaXNwYXRjaEV2ZW50PSguLi50KT0+dGhpc1tGZF0uZGlzcGF0Y2hFdmVudCguLi50KSx0aGlzW0lkXT1uZXcgU2V0fWdldCBvbmdvaW5nQWN0aXZpdHlDb3VudCgpe3JldHVybiB0aGlzW0RkXS5zaXplfWJlZ2luQWN0aXZpdHkoKXtjb25zdCB0PXtwcm9ncmVzczowfTtyZXR1cm4gdGhpc1tEZF0uYWRkKHQpLDE9PT10aGlzLm9uZ29pbmdBY3Rpdml0eUNvdW50JiZ0aGlzW05kXSgpLGU9PntsZXQgbjtyZXR1cm4gbj1NYXRoLm1heChKaChlLDAsMSksdC5wcm9ncmVzcyksbiE9PXQucHJvZ3Jlc3MmJih0LnByb2dyZXNzPW4sdGhpc1tOZF0oKSksdC5wcm9ncmVzc319WyhQZD1GZCxJZD1EZCxOZCldKCl7bGV0IHQ9MCxlPTAsbj0wO2Zvcihjb25zdCBpIG9mIHRoaXNbRGRdKXtjb25zdHtwcm9ncmVzczpyfT1pO3QrPXIqKC41L01hdGgucG93KDIsZSsrKSksMT09PXImJm4rK31uPT09dGhpcy5vbmdvaW5nQWN0aXZpdHlDb3VudCYmKHQ9MSx0aGlzW0RkXS5jbGVhcigpKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicHJvZ3Jlc3NcIix7ZGV0YWlsOnt0b3RhbFByb2dyZXNzOnR9fSkpfX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi92YXIgVWQsa2QsemQsQmQsSGQsVmQsR2QsV2QsamQscWQsWGQ9ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByLHM9YXJndW1lbnRzLmxlbmd0aCxhPXM8Mz9lOm51bGw9PT1pP2k9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pOmksbz10Lmxlbmd0aC0xO28+PTA7by0tKShyPXRbb10pJiYoYT0oczwzP3IoYSk6cz4zP3IoZSxuLGEpOnIoZSxuKSl8fGEpO3JldHVybiBzPjMmJmEmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4sYSksYX07Y29uc3QgWWQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxaZD1TeW1ib2woXCJmYWxsYmFja1Jlc2l6ZUhhbmRsZXJcIiksSmQ9U3ltYm9sKFwiZGVmYXVsdEFyaWFMYWJlbFwiKSwkZD1TeW1ib2woXCJyZXNpemVPYnNlcnZlclwiKSxLZD1TeW1ib2woXCJjbGVhck1vZGVsVGltZW91dFwiKSxRZD1TeW1ib2woXCJvbkNvbnRleHRMb3N0XCIpLHRwPVN5bWJvbChcImxvYWRlZFwiKSxlcD1TeW1ib2woXCJ1cGRhdGVTaXplXCIpLG5wPVN5bWJvbChcImludGVyc2VjdGlvbk9ic2VydmVyXCIpLGlwPVN5bWJvbChcImlzRWxlbWVudEluVmlld3BvcnRcIikscnA9U3ltYm9sKFwiYW5ub3VuY2VNb2RlbFZpc2liaWxpdHlcIiksc3A9U3ltYm9sKFwiYXJpYUxhYmVsXCIpLGFwPVN5bWJvbChcImxvYWRlZFRpbWVcIiksb3A9U3ltYm9sKFwidXBkYXRlU291cmNlXCIpLGxwPVN5bWJvbChcIm1hcmtMb2FkZWRcIiksY3A9U3ltYm9sKFwiY29udGFpbmVyXCIpLGhwPVN5bWJvbChcImlucHV0XCIpLHVwPVN5bWJvbChcImNhbnZhc1wiKSxkcD1TeW1ib2woXCJzY2VuZVwiKSxwcD1TeW1ib2woXCJuZWVkc1JlbmRlclwiKSxtcD1TeW1ib2woXCJ0aWNrXCIpLGZwPVN5bWJvbChcIm9uTW9kZWxMb2FkXCIpLGdwPVN5bWJvbChcIm9uUmVzaXplXCIpLHZwPVN5bWJvbChcInJlbmRlcmVyXCIpLHlwPVN5bWJvbChcInByb2dyZXNzVHJhY2tlclwiKSx4cD1TeW1ib2woXCJnZXRMb2FkZWRcIiksYnA9U3ltYm9sKFwiZ2V0TW9kZWxJc1Zpc2libGVcIiksd3A9U3ltYm9sKFwic2hvdWxkQXR0ZW1wdFByZWxvYWRcIiksX3A9U3ltYm9sKFwic2NlbmVJc1JlYWR5XCIpLE1wPVN5bWJvbChcImhhc1RyYW5zaXRpb25lZFwiKSxTcD10PT4oe3g6dC54LHk6dC55LHo6dC56LHRvU3RyaW5nKCl7cmV0dXJuYCR7dGhpcy54fW0gJHt0aGlzLnl9bSAke3RoaXMuen1tYH19KTtjbGFzcyBUcCBleHRlbmRzIFh7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuYWx0PW51bGwsdGhpcy5zcmM9bnVsbCx0aGlzW1VkXT0hMSx0aGlzW2tkXT0hMSx0aGlzW3pkXT0wLHRoaXNbQmRdPW51bGwsdGhpc1tIZF09WmgoKCgpPT57Y29uc3QgdD10aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RoaXNbZXBdKHQpfSksNTApLHRoaXNbVmRdPVpoKCh0PT57Y29uc3QgZT10aGlzLm1vZGVsSXNWaXNpYmxlO2UhPT10JiZ0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwibW9kZWwtdmlzaWJpbGl0eVwiLHtkZXRhaWw6e3Zpc2libGU6ZX19KSl9KSwwKSx0aGlzW0dkXT1udWxsLHRoaXNbV2RdPW51bGwsdGhpc1tqZF09bmV3IE9kLHRoaXNbcWRdPXQ9Pnt0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiZXJyb3JcIix7ZGV0YWlsOnt0eXBlOlwid2ViZ2xjb250ZXh0bG9zdFwiLHNvdXJjZUVycm9yOnQuc291cmNlRXZlbnR9fSkpfSx0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIn0pO2NvbnN0IHQ9dGhpcy5zaGFkb3dSb290O2xldCBlLG47aWYoKHQ9PntGKGR0LHQpfSkodCksdGhpc1tjcF09dC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRhaW5lclwiKSx0aGlzW2hwXT10LnF1ZXJ5U2VsZWN0b3IoXCIudXNlcklucHV0XCIpLHRoaXNbdXBdPXQucXVlcnlTZWxlY3RvcihcImNhbnZhc1wiKSx0aGlzW0pkXT10aGlzW2hwXS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpLHRoaXMuaXNDb25uZWN0ZWQpe2NvbnN0IHQ9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtlPXQud2lkdGgsbj10LmhlaWdodH1lbHNlIGU9MzAwLG49MTUwO3RoaXNbZHBdPW5ldyBFdSh7Y2FudmFzOnRoaXNbdXBdLGVsZW1lbnQ6dGhpcyx3aWR0aDplLGhlaWdodDpufSksdGhpc1tkcF0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vZGVsLWxvYWRcIiwoYXN5bmMgdD0+e3RoaXNbbHBdKCksdGhpc1tmcF0oKSxhd2FpdCBRaCgpLHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJsb2FkXCIse2RldGFpbDp7dXJsOnQudXJsfX0pKX0pKSxQcm9taXNlLnJlc29sdmUoKS50aGVuKCgoKT0+e3RoaXNbZXBdKHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpfSkpLGl0JiYodGhpc1skZF09bmV3IFJlc2l6ZU9ic2VydmVyKCh0PT57aWYoIXRoaXNbdnBdLmlzUHJlc2VudGluZylmb3IobGV0IGUgb2YgdCllLnRhcmdldD09PXRoaXMmJnRoaXNbZXBdKGUuY29udGVudFJlY3QpfSkpKSxydD90aGlzW25wXT1uZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKHQ9Pntmb3IobGV0IGUgb2YgdClpZihlLnRhcmdldD09PXRoaXMpe2NvbnN0IHQ9dGhpcy5tb2RlbElzVmlzaWJsZTt0aGlzW2lwXT1lLmlzSW50ZXJzZWN0aW5nLHRoaXNbcnBdKHQpLHRoaXNbaXBdJiYhdGhpc1tfcF0oKSYmdGhpc1tvcF0oKX19KSx7cm9vdDpudWxsLHJvb3RNYXJnaW46XCIwcHhcIix0aHJlc2hvbGQ6MH0pOnRoaXNbaXBdPSEwfXN0YXRpYyBnZXQgaXMoKXtyZXR1cm5cIm1vZGVsLXZpZXdlclwifXN0YXRpYyBzZXQgbW9kZWxDYWNoZVNpemUodCl7a2hbT2hdLmV2aWN0aW9uVGhyZXNob2xkPXR9c3RhdGljIGdldCBtb2RlbENhY2hlU2l6ZSgpe3JldHVybiBraFtPaF0uZXZpY3Rpb25UaHJlc2hvbGR9c3RhdGljIHNldCBtaW5pbXVtUmVuZGVyU2NhbGUodCl7dD4xJiZjb25zb2xlLndhcm4oXCI8bW9kZWwtdmlld2VyPiBtaW5pbXVtUmVuZGVyU2NhbGUgaGFzIGJlZW4gY2xhbXBlZCB0byBhIG1heGltdW0gdmFsdWUgb2YgMS5cIiksdDw9MCYmY29uc29sZS53YXJuKFwiPG1vZGVsLXZpZXdlcj4gbWluaW11bVJlbmRlclNjYWxlIGhhcyBiZWVuIGNsYW1wZWQgdG8gYSBtaW5pbXVtIHZhbHVlIG9mIDAuMjUuXCIpLENkLnNpbmdsZXRvbi5taW5TY2FsZT10fXN0YXRpYyBnZXQgbWluaW11bVJlbmRlclNjYWxlKCl7cmV0dXJuIENkLnNpbmdsZXRvbi5taW5TY2FsZX1nZXQgbG9hZGVkKCl7cmV0dXJuIHRoaXNbeHBdKCl9Z2V0WyhVZD1pcCxrZD10cCx6ZD1hcCxCZD1LZCxIZD1aZCxWZD1ycCxHZD0kZCxXZD1ucCxqZD15cCx2cCldKCl7cmV0dXJuIENkLnNpbmdsZXRvbn1nZXQgbW9kZWxJc1Zpc2libGUoKXtyZXR1cm4gdGhpc1ticF0oKX1jb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmNvbm5lY3RlZENhbGxiYWNrJiZzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpLGl0P3RoaXNbJGRdLm9ic2VydmUodGhpcyk6c2VsZi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpc1taZF0pLHJ0JiZ0aGlzW25wXS5vYnNlcnZlKHRoaXMpO2NvbnN0IHQ9dGhpc1t2cF07dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dGxvc3RcIix0aGlzW1FkXSksdC5yZWdpc3RlclNjZW5lKHRoaXNbZHBdKSxudWxsIT10aGlzW0tkXSYmKHNlbGYuY2xlYXJUaW1lb3V0KHRoaXNbS2RdKSx0aGlzW0tkXT1udWxsLHRoaXMucmVxdWVzdFVwZGF0ZShcInNyY1wiLG51bGwpKX1kaXNjb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrJiZzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpLGl0P3RoaXNbJGRdLnVub2JzZXJ2ZSh0aGlzKTpzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzW1pkXSkscnQmJnRoaXNbbnBdLnVub2JzZXJ2ZSh0aGlzKTtjb25zdCB0PXRoaXNbdnBdO3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRsb3N0XCIsdGhpc1tRZF0pLHQudW5yZWdpc3RlclNjZW5lKHRoaXNbZHBdKSx0aGlzW0tkXT1zZWxmLnNldFRpbWVvdXQoKCgpPT57dGhpc1tkcF0ucmVzZXQoKX0pLDFlMyl9dXBkYXRlZCh0KXtpZihzdXBlci51cGRhdGVkKHQpLHQuaGFzKFwic3JjXCIpJiYobnVsbD09dGhpcy5zcmM/KHRoaXNbdHBdPSExLHRoaXNbYXBdPTAsdGhpc1tkcF0ucmVzZXQoKSk6dGhpcy5zcmMhPT10aGlzW2RwXS51cmwmJih0aGlzW3RwXT0hMSx0aGlzW2FwXT0wLHRoaXNbb3BdKCkpKSx0LmhhcyhcImFsdFwiKSl7Y29uc3QgdD1udWxsPT10aGlzLmFsdD90aGlzW0pkXTp0aGlzLmFsdDt0aGlzW2hwXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsdCl9fXRvRGF0YVVSTCh0LGUpe3JldHVybiB0aGlzW3ZwXS5kaXNwbGF5Q2FudmFzKHRoaXNbZHBdKS50b0RhdGFVUkwodCxlKX1hc3luYyB0b0Jsb2IodCl7Y29uc3QgZT10P3QubWltZVR5cGU6dm9pZCAwLG49dD90LnF1YWxpdHlBcmd1bWVudDp2b2lkIDAsaT10P3QuaWRlYWxBc3BlY3Q6dm9pZCAwLHt3aWR0aDpyLGhlaWdodDpzLGZpZWxkT2ZWaWV3QXNwZWN0OmEsYXNwZWN0Om99PXRoaXNbZHBdLHtkcHI6bCxzY2FsZUZhY3RvcjpjfT10aGlzW3ZwXTtsZXQgaD1yKmMqbCx1PXMqYypsLGQ9MCxwPTA7aWYoITA9PT1pKWlmKGE+byl7Y29uc3QgdD11O3U9TWF0aC5yb3VuZChoL2EpLHA9KHQtdSkvMn1lbHNle2NvbnN0IHQ9aDtoPU1hdGgucm91bmQodSphKSxkPSh0LWgpLzJ9WWQud2lkdGg9aCxZZC5oZWlnaHQ9dTt0cnl7cmV0dXJuIG5ldyBQcm9taXNlKChhc3luYyh0LGkpPT4oWWQuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZSh0aGlzW3ZwXS5kaXNwbGF5Q2FudmFzKHRoaXNbZHBdKSxkLHAsaCx1LDAsMCxoLHUpLCFZZC5tc1RvQmxvYnx8ZSYmXCJpbWFnZS9wbmdcIiE9PWU/WWQudG9CbG9iP3ZvaWQgWWQudG9CbG9iKChlPT57aWYoIWUpcmV0dXJuIGkobmV3IEVycm9yKFwiVW5hYmxlIHRvIHJldHJpZXZlIGNhbnZhcyBibG9iXCIpKTt0KGUpfSksZSxuKTp0KGF3YWl0KGFzeW5jIHQ9Pm5ldyBQcm9taXNlKCgoZSxuKT0+e2NvbnN0IGk9dC5tYXRjaCgvZGF0YTooLiopOy8pO2lmKCFpKXJldHVybiBuKG5ldyBFcnJvcihgJHt0fSBpcyBub3QgYSB2YWxpZCBkYXRhIFVybGApKTtjb25zdCByPWlbMV0scz10LnJlcGxhY2UoL2RhdGE6aW1hZ2VcXC9cXHcrO2Jhc2U2NCwvLFwiXCIpLGE9YXRvYihzKSxvPVtdO2ZvcihsZXQgdD0wO3Q8YS5sZW5ndGg7dCs9NTEyKXtjb25zdCBlPWEuc2xpY2UodCx0KzUxMiksbj1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKW5bdF09ZS5jaGFyQ29kZUF0KHQpO2NvbnN0IGk9bmV3IFVpbnQ4QXJyYXkobik7by5wdXNoKGkpfWUobmV3IEJsb2Iobyx7dHlwZTpyfSkpfSkpKShZZC50b0RhdGFVUkwoZSxuKSkpOnQoWWQubXNUb0Jsb2IoKSkpKSl9ZmluYWxseXt0aGlzW2VwXSh7d2lkdGg6cixoZWlnaHQ6c30pfX1yZWdpc3RlclJlbmRlcmVyKHQpe3RoaXNbZHBdLmV4dGVybmFsUmVuZGVyZXI9dH11bnJlZ2lzdGVyUmVuZGVyZXIoKXt0aGlzW2RwXS5leHRlcm5hbFJlbmRlcmVyPW51bGx9Z2V0W3NwXSgpe3JldHVybiBudWxsPT10aGlzLmFsdHx8XCJudWxsXCI9PT10aGlzLmFsdD90aGlzW0pkXTp0aGlzLmFsdH1beHBdKCl7cmV0dXJuIHRoaXNbdHBdfVticF0oKXtyZXR1cm4gdGhpcy5sb2FkZWQmJnRoaXNbaXBdfVtNcF0oKXtyZXR1cm4gdGhpcy5tb2RlbElzVmlzaWJsZX1bd3BdKCl7cmV0dXJuISF0aGlzLnNyYyYmdGhpc1tpcF19W19wXSgpe3JldHVybiB0aGlzW3RwXX1bZXBdKHt3aWR0aDp0LGhlaWdodDplfSl7dGhpc1tjcF0uc3R5bGUud2lkdGg9YCR7dH1weGAsdGhpc1tjcF0uc3R5bGUuaGVpZ2h0PWAke2V9cHhgLHRoaXNbZ3BdKHt3aWR0aDpwYXJzZUZsb2F0KHQpLGhlaWdodDpwYXJzZUZsb2F0KGUpfSl9W21wXSh0LGUpe31bbHBdKCl7dGhpc1t0cF18fCh0aGlzW3RwXT0hMCx0aGlzW2FwXT1wZXJmb3JtYW5jZS5ub3coKSl9W3BwXSgpe3RoaXNbZHBdLnF1ZXVlUmVuZGVyKCl9W2ZwXSgpe31bZ3BdKHQpe3RoaXNbZHBdLnNldFNpemUodC53aWR0aCx0LmhlaWdodCl9YXN5bmNbKHFkPVFkLG9wKV0oKXtpZih0aGlzLmxvYWRlZHx8IXRoaXNbd3BdKCkpcmV0dXJuO2NvbnN0IHQ9dGhpc1t5cF0uYmVnaW5BY3Rpdml0eSgpLGU9dGhpcy5zcmM7dHJ5e2F3YWl0IHRoaXNbZHBdLnNldFNvdXJjZShlLChlPT50KC44KmUpKSk7Y29uc3Qgbj17dXJsOmV9O3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJwcmVsb2FkXCIse2RldGFpbDpufSkpfWNhdGNoKHQpe3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJlcnJvclwiLHtkZXRhaWw6dH0pKX1maW5hbGx5e3QoLjkpLHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCk9PntyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT57dCgxKX0pKX0pKX19fVhkKFtaKHt0eXBlOlN0cmluZ30pXSxUcC5wcm90b3R5cGUsXCJhbHRcIix2b2lkIDApLFhkKFtaKHt0eXBlOlN0cmluZ30pXSxUcC5wcm90b3R5cGUsXCJzcmNcIix2b2lkIDApO1xuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEVwPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcixzPWFyZ3VtZW50cy5sZW5ndGgsYT1zPDM/ZTpudWxsPT09aT9pPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTppLG89dC5sZW5ndGgtMTtvPj0wO28tLSkocj10W29dKSYmKGE9KHM8Mz9yKGEpOnM+Mz9yKGUsbixhKTpyKGUsbikpfHxhKTtyZXR1cm4gcz4zJiZhJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLGEpLGF9O2NvbnN0IEFwPVN5bWJvbChcImNoYW5nZUFuaW1hdGlvblwiKSxMcD1TeW1ib2woXCJwYXVzZWRcIiksUnA9U3ltYm9sKFwiaG90c3BvdE1hcFwiKSxDcD1TeW1ib2woXCJtdXRhdGlvbkNhbGxiYWNrXCIpLFBwPVN5bWJvbChcIm9ic2VydmVyXCIpLElwPVN5bWJvbChcImFkZEhvdHNwb3RcIiksRHA9U3ltYm9sKFwicmVtb3ZlSG90c3BvdFwiKSxOcD1uZXcgdmUsRnA9bmV3IEx0O1xuLyohXG5mZmxhdGUgLSBmYXN0IEphdmFTY3JpcHQgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvblxuPGh0dHBzOi8vMTAxYXJyb3d6LmdpdGh1Yi5pby9mZmxhdGU+XG5MaWNlbnNlZCB1bmRlciBNSVQuIGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbnZlcnNpb24gMC42LjlcbiovXG52YXIgT3A9ZnVuY3Rpb24odCl7cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3RdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSl9O3RyeXtVUkwucmV2b2tlT2JqZWN0VVJMKE9wKFwiXCIpKX1jYXRjaCh0KXtPcD1mdW5jdGlvbih0KXtyZXR1cm5cImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdDtjaGFyc2V0PVVURi04LFwiK2VuY29kZVVSSSh0KX19dmFyIFVwPVVpbnQ4QXJyYXksa3A9VWludDE2QXJyYXksenA9VWludDMyQXJyYXksQnA9bmV3IFVwKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxIcD1uZXcgVXAoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTMsMCwwXSksVnA9bmV3IFVwKFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksR3A9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGtwKDMxKSxpPTA7aTwzMTsrK2kpbltpXT1lKz0xPDx0W2ktMV07dmFyIHI9bmV3IHpwKG5bMzBdKTtmb3IoaT0xO2k8MzA7KytpKWZvcih2YXIgcz1uW2ldO3M8bltpKzFdOysrcylyW3NdPXMtbltpXTw8NXxpO3JldHVybltuLHJdfSxXcD1HcChCcCwyKSxqcD1XcFswXSxxcD1XcFsxXTtqcFsyOF09MjU4LHFwWzI1OF09Mjg7Zm9yKHZhciBYcD1HcChIcCwwKVsxXSxZcD1uZXcga3AoMzI3NjgpLFpwPTA7WnA8MzI3Njg7KytacCl7dmFyIEpwPSg0MzY5MCZacCk+Pj4xfCgyMTg0NSZacCk8PDE7SnA9KDYxNjgwJihKcD0oNTI0MjgmSnApPj4+MnwoMTMxMDcmSnApPDwyKSk+Pj40fCgzODU1JkpwKTw8NCxZcFtacF09KCg2NTI4MCZKcCk+Pj44fCgyNTUmSnApPDw4KT4+PjF9dmFyICRwPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dC5sZW5ndGgscj0wLHM9bmV3IGtwKGUpO3I8aTsrK3IpKytzW3Rbcl0tMV07dmFyIGEsbz1uZXcga3AoZSk7Zm9yKHI9MDtyPGU7KytyKW9bcl09b1tyLTFdK3Nbci0xXTw8MTtpZihuKXthPW5ldyBrcCgxPDxlKTt2YXIgbD0xNS1lO2ZvcihyPTA7cjxpOysrcilpZih0W3JdKWZvcih2YXIgYz1yPDw0fHRbcl0saD1lLXRbcl0sdT1vW3Rbcl0tMV0rKzw8aCxkPXV8KDE8PGgpLTE7dTw9ZDsrK3UpYVtZcFt1XT4+PmxdPWN9ZWxzZSBmb3IoYT1uZXcga3AoaSkscj0wO3I8aTsrK3IpdFtyXSYmKGFbcl09WXBbb1t0W3JdLTFdKytdPj4+MTUtdFtyXSk7cmV0dXJuIGF9LEtwPW5ldyBVcCgyODgpO2ZvcihacD0wO1pwPDE0NDsrK1pwKUtwW1pwXT04O2ZvcihacD0xNDQ7WnA8MjU2OysrWnApS3BbWnBdPTk7Zm9yKFpwPTI1NjtacDwyODA7KytacClLcFtacF09Nztmb3IoWnA9MjgwO1pwPDI4ODsrK1pwKUtwW1pwXT04O3ZhciBRcD1uZXcgVXAoMzIpO2ZvcihacD0wO1pwPDMyOysrWnApUXBbWnBdPTU7dmFyIHRtPSRwKEtwLDksMCksZW09JHAoUXAsNSwwKSxubT1mdW5jdGlvbih0KXtyZXR1cm4odC84fDApKyg3JnQmJjEpfSxpbT1mdW5jdGlvbih0LGUsbil7KG51bGw9PWV8fGU8MCkmJihlPTApLChudWxsPT1ufHxuPnQubGVuZ3RoKSYmKG49dC5sZW5ndGgpO3ZhciBpPW5ldyh0IGluc3RhbmNlb2Yga3A/a3A6dCBpbnN0YW5jZW9mIHpwP3pwOlVwKShuLWUpO3JldHVybiBpLnNldCh0LnN1YmFycmF5KGUsbikpLGl9LHJtPWZ1bmN0aW9uKHQsZSxuKXtuPDw9NyZlO3ZhciBpPWUvOHwwO3RbaV18PW4sdFtpKzFdfD1uPj4+OH0sc209ZnVuY3Rpb24odCxlLG4pe248PD03JmU7dmFyIGk9ZS84fDA7dFtpXXw9bix0W2krMV18PW4+Pj44LHRbaSsyXXw9bj4+PjE2fSxhbT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bXSxpPTA7aTx0Lmxlbmd0aDsrK2kpdFtpXSYmbi5wdXNoKHtzOmksZjp0W2ldfSk7dmFyIHI9bi5sZW5ndGgscz1uLnNsaWNlKCk7aWYoIXIpcmV0dXJuW3BtLDBdO2lmKDE9PXIpe3ZhciBhPW5ldyBVcChuWzBdLnMrMSk7cmV0dXJuIGFbblswXS5zXT0xLFthLDFdfW4uc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5mLWUuZn0pKSxuLnB1c2goe3M6LTEsZjoyNTAwMX0pO3ZhciBvPW5bMF0sbD1uWzFdLGM9MCxoPTEsdT0yO2ZvcihuWzBdPXtzOi0xLGY6by5mK2wuZixsOm8scjpsfTtoIT1yLTE7KW89bltuW2NdLmY8blt1XS5mP2MrKzp1KytdLGw9bltjIT1oJiZuW2NdLmY8blt1XS5mP2MrKzp1KytdLG5baCsrXT17czotMSxmOm8uZitsLmYsbDpvLHI6bH07dmFyIGQ9c1swXS5zO2ZvcihpPTE7aTxyOysraSlzW2ldLnM+ZCYmKGQ9c1tpXS5zKTt2YXIgcD1uZXcga3AoZCsxKSxtPW9tKG5baC0xXSxwLDApO2lmKG0+ZSl7aT0wO3ZhciBmPTAsZz1tLWUsdj0xPDxnO2ZvcihzLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHBbZS5zXS1wW3Quc118fHQuZi1lLmZ9KSk7aTxyOysraSl7dmFyIHk9c1tpXS5zO2lmKCEocFt5XT5lKSlicmVhaztmKz12LSgxPDxtLXBbeV0pLHBbeV09ZX1mb3IoZj4+Pj1nO2Y+MDspe3ZhciB4PXNbaV0ucztwW3hdPGU/Zi09MTw8ZS1wW3hdKystMTorK2l9Zm9yKDtpPj0wJiZmOy0taSl7dmFyIGI9c1tpXS5zO3BbYl09PWUmJigtLXBbYl0sKytmKX1tPWV9cmV0dXJuW25ldyBVcChwKSxtXX0sb209ZnVuY3Rpb24odCxlLG4pe3JldHVybi0xPT10LnM/TWF0aC5tYXgob20odC5sLGUsbisxKSxvbSh0LnIsZSxuKzEpKTplW3Quc109bn0sbG09ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoO2UmJiF0Wy0tZV07KTtmb3IodmFyIG49bmV3IGtwKCsrZSksaT0wLHI9dFswXSxzPTEsYT1mdW5jdGlvbih0KXtuW2krK109dH0sbz0xO288PWU7KytvKWlmKHRbb109PXImJm8hPWUpKytzO2Vsc2V7aWYoIXImJnM+Mil7Zm9yKDtzPjEzODtzLT0xMzgpYSgzMjc1NCk7cz4yJiYoYShzPjEwP3MtMTE8PDV8Mjg2OTA6cy0zPDw1fDEyMzA1KSxzPTApfWVsc2UgaWYocz4zKXtmb3IoYShyKSwtLXM7cz42O3MtPTYpYSg4MzA0KTtzPjImJihhKHMtMzw8NXw4MjA4KSxzPTApfWZvcig7cy0tOylhKHIpO3M9MSxyPXRbb119cmV0dXJuW24uc3ViYXJyYXkoMCxpKSxlXX0sY209ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPTA7aTxlLmxlbmd0aDsrK2kpbis9dFtpXSplW2ldO3JldHVybiBufSxobT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bi5sZW5ndGgscj1ubShlKzIpO3Rbcl09MjU1JmksdFtyKzFdPWk+Pj44LHRbcisyXT0yNTVedFtyXSx0W3IrM109MjU1XnRbcisxXTtmb3IodmFyIHM9MDtzPGk7KytzKXRbcitzKzRdPW5bc107cmV0dXJuIDgqKHIrNCtpKX0sdW09ZnVuY3Rpb24odCxlLG4saSxyLHMsYSxvLGwsYyxoKXtybShlLGgrKyxuKSwrK3JbMjU2XTtmb3IodmFyIHU9YW0ociwxNSksZD11WzBdLHA9dVsxXSxtPWFtKHMsMTUpLGY9bVswXSxnPW1bMV0sdj1sbShkKSx5PXZbMF0seD12WzFdLGI9bG0oZiksdz1iWzBdLF89YlsxXSxNPW5ldyBrcCgxOSksUz0wO1M8eS5sZW5ndGg7KytTKU1bMzEmeVtTXV0rKztmb3IoUz0wO1M8dy5sZW5ndGg7KytTKU1bMzEmd1tTXV0rKztmb3IodmFyIFQ9YW0oTSw3KSxFPVRbMF0sQT1UWzFdLEw9MTk7TD40JiYhRVtWcFtMLTFdXTstLUwpO3ZhciBSLEMsUCxJLEQ9Yys1PDwzLE49Y20ocixLcCkrY20ocyxRcCkrYSxGPWNtKHIsZCkrY20ocyxmKSthKzE0KzMqTCtjbShNLEUpKygyKk1bMTZdKzMqTVsxN10rNypNWzE4XSk7aWYoRDw9TiYmRDw9RilyZXR1cm4gaG0oZSxoLHQuc3ViYXJyYXkobCxsK2MpKTtpZihybShlLGgsMSsoRjxOKSksaCs9MixGPE4pe1I9JHAoZCxwLDApLEM9ZCxQPSRwKGYsZywwKSxJPWY7dmFyIE89JHAoRSxBLDApO3JtKGUsaCx4LTI1Nykscm0oZSxoKzUsXy0xKSxybShlLGgrMTAsTC00KSxoKz0xNDtmb3IoUz0wO1M8TDsrK1Mpcm0oZSxoKzMqUyxFW1ZwW1NdXSk7aCs9MypMO2Zvcih2YXIgVT1beSx3XSxrPTA7azwyOysrayl7dmFyIHo9VVtrXTtmb3IoUz0wO1M8ei5sZW5ndGg7KytTKXt2YXIgQj0zMSZ6W1NdO3JtKGUsaCxPW0JdKSxoKz1FW0JdLEI+MTUmJihybShlLGgseltTXT4+PjUmMTI3KSxoKz16W1NdPj4+MTIpfX19ZWxzZSBSPXRtLEM9S3AsUD1lbSxJPVFwO2ZvcihTPTA7UzxvOysrUylpZihpW1NdPjI1NSl7Qj1pW1NdPj4+MTgmMzE7c20oZSxoLFJbQisyNTddKSxoKz1DW0IrMjU3XSxCPjcmJihybShlLGgsaVtTXT4+PjIzJjMxKSxoKz1CcFtCXSk7dmFyIEg9MzEmaVtTXTtzbShlLGgsUFtIXSksaCs9SVtIXSxIPjMmJihzbShlLGgsaVtTXT4+PjUmODE5MSksaCs9SHBbSF0pfWVsc2Ugc20oZSxoLFJbaVtTXV0pLGgrPUNbaVtTXV07cmV0dXJuIHNtKGUsaCxSWzI1Nl0pLGgrQ1syNTZdfSxkbT1uZXcgenAoWzY1NTQwLDEzMTA4MCwxMzEwODgsMTMxMTA0LDI2MjE3NiwxMDQ4NzA0LDEwNDg4MzIsMjExNDU2MCwyMTE3NjMyXSkscG09bmV3IFVwKDApLG1tPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyB6cCgyNTYpLGU9MDtlPDI1NjsrK2Upe2Zvcih2YXIgbj1lLGk9OTstLWk7KW49KDEmbiYmMzk4ODI5MjM4NClebj4+PjE7dFtlXT1ufXJldHVybiB0fSgpLGZtPWZ1bmN0aW9uKCl7dmFyIHQ9LTE7cmV0dXJue3A6ZnVuY3Rpb24oZSl7Zm9yKHZhciBuPXQsaT0wO2k8ZS5sZW5ndGg7KytpKW49bW1bMjU1Jm5eZVtpXV1ebj4+Pjg7dD1ufSxkOmZ1bmN0aW9uKCl7cmV0dXJufnR9fX0sZ209ZnVuY3Rpb24odCxlLG4saSxyKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4saSxyLHMpe3ZhciBhPXQubGVuZ3RoLG89bmV3IFVwKGkrYSs1KigxK01hdGguY2VpbChhLzdlMykpK3IpLGw9by5zdWJhcnJheShpLG8ubGVuZ3RoLXIpLGM9MDtpZighZXx8YTw4KWZvcih2YXIgaD0wO2g8PWE7aCs9NjU1MzUpe3ZhciB1PWgrNjU1MzU7dTxhP2M9aG0obCxjLHQuc3ViYXJyYXkoaCx1KSk6KGxbaF09cyxjPWhtKGwsYyx0LnN1YmFycmF5KGgsYSkpKX1lbHNle2Zvcih2YXIgZD1kbVtlLTFdLHA9ZD4+PjEzLG09ODE5MSZkLGY9KDE8PG4pLTEsZz1uZXcga3AoMzI3NjgpLHY9bmV3IGtwKGYrMSkseT1NYXRoLmNlaWwobi8zKSx4PTIqeSxiPWZ1bmN0aW9uKGUpe3JldHVybih0W2VdXnRbZSsxXTw8eV50W2UrMl08PHgpJmZ9LHc9bmV3IHpwKDI1ZTMpLF89bmV3IGtwKDI4OCksTT1uZXcga3AoMzIpLFM9MCxUPTAsRT0oaD0wLDApLEE9MCxMPTA7aDxhOysraCl7dmFyIFI9YihoKSxDPTMyNzY3JmgsUD12W1JdO2lmKGdbQ109UCx2W1JdPUMsQTw9aCl7dmFyIEk9YS1oO2lmKChTPjdlM3x8RT4yNDU3NikmJkk+NDIzKXtjPXVtKHQsbCwwLHcsXyxNLFQsRSxMLGgtTCxjKSxFPVM9VD0wLEw9aDtmb3IodmFyIEQ9MDtEPDI4NjsrK0QpX1tEXT0wO2ZvcihEPTA7RDwzMDsrK0QpTVtEXT0wfXZhciBOPTIsRj0wLE89bSxVPUMtUCYzMjc2NztpZihJPjImJlI9PWIoaC1VKSlmb3IodmFyIGs9TWF0aC5taW4ocCxJKS0xLHo9TWF0aC5taW4oMzI3NjcsaCksQj1NYXRoLm1pbigyNTgsSSk7VTw9eiYmLS1PJiZDIT1QOyl7aWYodFtoK05dPT10W2grTi1VXSl7Zm9yKHZhciBIPTA7SDxCJiZ0W2grSF09PXRbaCtILVVdOysrSCk7aWYoSD5OKXtpZihOPUgsRj1VLEg+aylicmVhazt2YXIgVj1NYXRoLm1pbihVLEgtMiksRz0wO2ZvcihEPTA7RDxWOysrRCl7dmFyIFc9aC1VK0QrMzI3NjgmMzI3Njcsaj1XLWdbV10rMzI3NjgmMzI3Njc7aj5HJiYoRz1qLFA9Vyl9fX1VKz0oQz1QKS0oUD1nW0NdKSszMjc2OCYzMjc2N31pZihGKXt3W0UrK109MjY4NDM1NDU2fHFwW05dPDwxOHxYcFtGXTt2YXIgcT0zMSZxcFtOXSxYPTMxJlhwW0ZdO1QrPUJwW3FdK0hwW1hdLCsrX1syNTcrcV0sKytNW1hdLEE9aCtOLCsrU31lbHNlIHdbRSsrXT10W2hdLCsrX1t0W2hdXX19Yz11bSh0LGwscyx3LF8sTSxULEUsTCxoLUwsYyksIXMmJjcmYyYmKGM9aG0obCxjKzEscG0pKX1yZXR1cm4gaW0obywwLGkrbm0oYykrcil9KHQsbnVsbD09ZS5sZXZlbD82OmUubGV2ZWwsbnVsbD09ZS5tZW0/TWF0aC5jZWlsKDEuNSpNYXRoLm1heCg4LE1hdGgubWluKDEzLE1hdGgubG9nKHQubGVuZ3RoKSkpKToxMitlLm1lbSxuLGksIXIpfSx2bT1mdW5jdGlvbih0LGUpe3ZhciBuPXt9O2Zvcih2YXIgaSBpbiB0KW5baV09dFtpXTtmb3IodmFyIGkgaW4gZSluW2ldPWVbaV07cmV0dXJuIG59LHltPWZ1bmN0aW9uKHQsZSxuKXtmb3IoO247KytlKXRbZV09bixuPj4+PTh9O2Z1bmN0aW9uIHhtKHQsZSl7cmV0dXJuIGdtKHQsZXx8e30sMCwwKX12YXIgYm09ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByIGluIHQpe3ZhciBzPXRbcl0sYT1lK3I7cyBpbnN0YW5jZW9mIFVwP25bYV09W3MsaV06QXJyYXkuaXNBcnJheShzKT9uW2FdPVtzWzBdLHZtKGksc1sxXSldOmJtKHMsYStcIi9cIixuLGkpfX0sd209XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHRFbmNvZGVyJiZuZXcgVGV4dEVuY29kZXIsX209XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXI7dHJ5e19tLmRlY29kZShwbSx7c3RyZWFtOiEwfSksMX1jYXRjaCh0KXt9ZnVuY3Rpb24gTW0odCxlKXtpZihlKXtmb3IodmFyIG49bmV3IFVwKHQubGVuZ3RoKSxpPTA7aTx0Lmxlbmd0aDsrK2kpbltpXT10LmNoYXJDb2RlQXQoaSk7cmV0dXJuIG59aWYod20pcmV0dXJuIHdtLmVuY29kZSh0KTt2YXIgcj10Lmxlbmd0aCxzPW5ldyBVcCh0Lmxlbmd0aCsodC5sZW5ndGg+PjEpKSxhPTAsbz1mdW5jdGlvbih0KXtzW2ErK109dH07Zm9yKGk9MDtpPHI7KytpKXtpZihhKzU+cy5sZW5ndGgpe3ZhciBsPW5ldyBVcChhKzgrKHItaTw8MSkpO2wuc2V0KHMpLHM9bH12YXIgYz10LmNoYXJDb2RlQXQoaSk7YzwxMjh8fGU/byhjKTpjPDIwNDg/KG8oMTkyfGM+PjYpLG8oMTI4fDYzJmMpKTpjPjU1Mjk1JiZjPDU3MzQ0PyhvKDI0MHwoYz02NTUzNisoMTA0NzU1MiZjKXwxMDIzJnQuY2hhckNvZGVBdCgrK2kpKT4+MTgpLG8oMTI4fGM+PjEyJjYzKSxvKDEyOHxjPj42JjYzKSxvKDEyOHw2MyZjKSk6KG8oMjI0fGM+PjEyKSxvKDEyOHxjPj42JjYzKSxvKDEyOHw2MyZjKSl9cmV0dXJuIGltKHMsMCxhKX12YXIgU209ZnVuY3Rpb24odCl7dmFyIGU9MDtpZih0KWZvcih2YXIgbiBpbiB0KXt2YXIgaT10W25dLmxlbmd0aDtpZihpPjY1NTM1KXRocm93XCJleHRyYSBmaWVsZCB0b28gbG9uZ1wiO2UrPWkrNH1yZXR1cm4gZX0sVG09ZnVuY3Rpb24odCxlLG4saSxyLHMsYSxvKXt2YXIgbD1pLmxlbmd0aCxjPW4uZXh0cmEsaD1vJiZvLmxlbmd0aCx1PVNtKGMpO3ltKHQsZSxudWxsIT1hPzMzNjM5MjQ4OjY3MzI0NzUyKSxlKz00LG51bGwhPWEmJih0W2UrK109MjAsdFtlKytdPW4ub3MpLHRbZV09MjAsZSs9Mix0W2UrK109bi5mbGFnPDwxfChudWxsPT1zJiY4KSx0W2UrK109ciYmOCx0W2UrK109MjU1Jm4uY29tcHJlc3Npb24sdFtlKytdPW4uY29tcHJlc3Npb24+Pjg7dmFyIGQ9bmV3IERhdGUobnVsbD09bi5tdGltZT9EYXRlLm5vdygpOm4ubXRpbWUpLHA9ZC5nZXRGdWxsWWVhcigpLTE5ODA7aWYocDwwfHxwPjExOSl0aHJvd1wiZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5XCI7aWYoeW0odCxlLHA8PDI1fGQuZ2V0TW9udGgoKSsxPDwyMXxkLmdldERhdGUoKTw8MTZ8ZC5nZXRIb3VycygpPDwxMXxkLmdldE1pbnV0ZXMoKTw8NXxkLmdldFNlY29uZHMoKT4+PjEpLGUrPTQsbnVsbCE9cyYmKHltKHQsZSxuLmNyYykseW0odCxlKzQscykseW0odCxlKzgsbi5zaXplKSkseW0odCxlKzEyLGwpLHltKHQsZSsxNCx1KSxlKz0xNixudWxsIT1hJiYoeW0odCxlLGgpLHltKHQsZSs2LG4uYXR0cnMpLHltKHQsZSsxMCxhKSxlKz0xNCksdC5zZXQoaSxlKSxlKz1sLHUpZm9yKHZhciBtIGluIGMpe3ZhciBmPWNbbV0sZz1mLmxlbmd0aDt5bSh0LGUsK20pLHltKHQsZSsyLGcpLHQuc2V0KGYsZSs0KSxlKz00K2d9cmV0dXJuIGgmJih0LnNldChvLGUpLGUrPWgpLGV9O2Z1bmN0aW9uIEVtKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9LGk9W107Ym0odCxcIlwiLG4sZSk7dmFyIHI9MCxzPTA7Zm9yKHZhciBhIGluIG4pe3ZhciBvPW5bYV0sbD1vWzBdLGM9b1sxXSxoPTA9PWMubGV2ZWw/MDo4LHU9KE09TW0oYSkpLmxlbmd0aCxkPWMuY29tbWVudCxwPWQmJk1tKGQpLG09cCYmcC5sZW5ndGgsZj1TbShjLmV4dHJhKTtpZih1PjY1NTM1KXRocm93XCJmaWxlbmFtZSB0b28gbG9uZ1wiO3ZhciBnPWg/eG0obCxjKTpsLHY9Zy5sZW5ndGgseT1mbSgpO3kucChsKSxpLnB1c2godm0oYyx7c2l6ZTpsLmxlbmd0aCxjcmM6eS5kKCksYzpnLGY6TSxtOnAsdTp1IT1hLmxlbmd0aHx8cCYmZC5sZW5ndGghPW0sbzpyLGNvbXByZXNzaW9uOmh9KSkscis9MzArdStmK3Yscys9NzYrMioodStmKSsobXx8MCkrdn1mb3IodmFyIHg9bmV3IFVwKHMrMjIpLGI9cix3PXMtcixfPTA7XzxpLmxlbmd0aDsrK18pe3ZhciBNPWlbX107VG0oeCxNLm8sTSxNLmYsTS51LE0uYy5sZW5ndGgpO3ZhciBTPTMwK00uZi5sZW5ndGgrU20oTS5leHRyYSk7eC5zZXQoTS5jLE0ubytTKSxUbSh4LHIsTSxNLmYsTS51LE0uYy5sZW5ndGgsTS5vLE0ubSkscis9MTYrUysoTS5tP00ubS5sZW5ndGg6MCl9cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLGkscil7eW0odCxlLDEwMTAxMDI1NikseW0odCxlKzgsbikseW0odCxlKzEwLG4pLHltKHQsZSsxMixpKSx5bSh0LGUrMTYscil9KHgscixpLmxlbmd0aCx3LGIpLHh9Y2xhc3MgQW17YXN5bmMgcGFyc2UodCl7Y29uc3QgZT17fTtlW1wibW9kZWwudXNkYVwiXT1udWxsO2xldCBuPVJtKCk7Y29uc3QgaT17fSxyPXt9O3QudHJhdmVyc2VWaXNpYmxlKCh0PT57aWYodC5pc01lc2gmJnQubWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCl7Y29uc3Qgcj10Lmdlb21ldHJ5LHM9dC5tYXRlcmlhbCxhPVwiZ2VvbWV0cmllcy9HZW9tZXRyeV9cIityLmlkK1wiLnVzZFwiO2lmKCEoYSBpbiBlKSl7Y29uc3QgdD1mdW5jdGlvbih0KXtyZXR1cm5gXFxuZGVmIFwiR2VvbWV0cnlcIlxcbntcXG4gICR7ZnVuY3Rpb24odCl7Y29uc3QgZT1cIkdlb21ldHJ5XCIsbj10LmF0dHJpYnV0ZXMsaT1uLnBvc2l0aW9uLmNvdW50O3JldHVybmBcXG4gICAgZGVmIE1lc2ggXCIke2V9XCJcXG4gICAge1xcbiAgICAgICAgaW50W10gZmFjZVZlcnRleENvdW50cyA9IFske2Z1bmN0aW9uKHQpe2NvbnN0IGU9bnVsbCE9PXQuaW5kZXg/dC5pbmRleC5hcnJheS5sZW5ndGg6dC5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O3JldHVybiBBcnJheShlLzMpLmZpbGwoMykuam9pbihcIiwgXCIpfSh0KX1dXFxuICAgICAgICBpbnRbXSBmYWNlVmVydGV4SW5kaWNlcyA9IFske2Z1bmN0aW9uKHQpe2lmKG51bGwhPT10LmluZGV4KXJldHVybiB0LmluZGV4LmFycmF5LmpvaW4oXCIsIFwiKTtjb25zdCBlPVtdLG49dC5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O2ZvcihsZXQgdD0wO3Q8bjt0KyspZS5wdXNoKHQpO3JldHVybiBlLmpvaW4oXCIsIFwiKX0odCl9XVxcbiAgICAgICAgbm9ybWFsM2ZbXSBub3JtYWxzID0gWyR7UG0obi5ub3JtYWwsaSl9XSAoXFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFwidmVydGV4XCJcXG4gICAgICAgIClcXG4gICAgICAgIHBvaW50M2ZbXSBwb2ludHMgPSBbJHtQbShuLnBvc2l0aW9uLGkpfV1cXG4gICAgICAgIGZsb2F0MltdIHByaW12YXJzOnN0ID0gWyR7ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT10KXJldHVybiBjb25zb2xlLndhcm4oXCJVU0RaRXhwb3J0ZXI6IFVWcyBtaXNzaW5nLlwiKSxBcnJheShlKS5maWxsKFwiKDAsIDApXCIpLmpvaW4oXCIsIFwiKTtjb25zdCBuPVtdLGk9dC5hcnJheTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoO3QrPTIpbi5wdXNoKGAoJHtpW3QrMF0udG9QcmVjaXNpb24oNyl9LCAkezEtaVt0KzFdLnRvUHJlY2lzaW9uKDcpfSlgKTtyZXR1cm4gbi5qb2luKFwiLCBcIil9KG4udXYsaSl9XSAoXFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFwidmVydGV4XCJcXG4gICAgICAgIClcXG4gICAgICAgIHVuaWZvcm0gdG9rZW4gc3ViZGl2aXNpb25TY2hlbWUgPSBcIm5vbmVcIlxcbiAgICB9XFxuYH0odCl9XFxufVxcbmB9KHIpO2VbYV09ZnVuY3Rpb24odCl7bGV0IGU9Um0oKTtyZXR1cm4gZSs9dCxNbShlKX0odCl9cy51dWlkIGluIGl8fChpW3MudXVpZF09cyksbis9ZnVuY3Rpb24odCxlLG4pe2NvbnN0IGk9XCJPYmplY3RfXCIrdC5pZCxyPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5lbGVtZW50cztyZXR1cm5gKCAke0NtKGUsMCl9LCAke0NtKGUsNCl9LCAke0NtKGUsOCl9LCAke0NtKGUsMTIpfSApYH0odC5tYXRyaXhXb3JsZCk7dC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpPDAmJmNvbnNvbGUud2FybihcIlRIUkVFLlVTRFpFeHBvcnRlcjogVVNEWiBkb2VzIG5vdCBzdXBwb3J0IG5lZ2F0aXZlIHNjYWxlc1wiLHQpO3JldHVybmBkZWYgWGZvcm0gXCIke2l9XCIgKFxcbiAgICBwcmVwZW5kIHJlZmVyZW5jZXMgPSBALi9nZW9tZXRyaWVzL0dlb21ldHJ5XyR7ZS5pZH0udXNkQDwvR2VvbWV0cnk+XFxuKVxcbntcXG4gICAgbWF0cml4NGQgeGZvcm1PcDp0cmFuc2Zvcm0gPSAke3J9XFxuICAgIHVuaWZvcm0gdG9rZW5bXSB4Zm9ybU9wT3JkZXIgPSBbXCJ4Zm9ybU9wOnRyYW5zZm9ybVwiXVxcblxcbiAgICByZWwgbWF0ZXJpYWw6YmluZGluZyA9IDwvTWF0ZXJpYWxzL01hdGVyaWFsXyR7bi5pZH0+XFxufVxcblxcbmB9KHQscixzKX19KSksbis9ZnVuY3Rpb24odCxlKXtjb25zdCBuPVtdO2Zvcihjb25zdCBpIGluIHQpe2NvbnN0IHI9dFtpXTtuLnB1c2goSW0ocixlKSl9cmV0dXJuYGRlZiBcIk1hdGVyaWFsc1wiXFxue1xcbiR7bi5qb2luKFwiXCIpfVxcbn1cXG5cXG5gfShpLHIpLGVbXCJtb2RlbC51c2RhXCJdPU1tKG4pLG49bnVsbDtmb3IoY29uc3QgdCBpbiByKXtjb25zdCBuPXJbdF0saT10LnNwbGl0KFwiX1wiKVsxXSxzPTEwMjM9PT1uLmZvcm1hdCxhPUxtKG4uaW1hZ2UsaSksbz1hd2FpdCBuZXcgUHJvbWlzZSgodD0+YS50b0Jsb2IodCxzP1wiaW1hZ2UvcG5nXCI6XCJpbWFnZS9qcGVnXCIsMSkpKTtlW2B0ZXh0dXJlcy9UZXh0dXJlXyR7dH0uJHtzP1wicG5nXCI6XCJqcGdcIn1gXT1uZXcgVWludDhBcnJheShhd2FpdCBvLmFycmF5QnVmZmVyKCkpfWxldCBzPTA7Zm9yKGNvbnN0IHQgaW4gZSl7Y29uc3Qgbj1lW3RdO3MrPTM0K3QubGVuZ3RoO2NvbnN0IGk9NjMmcztpZig0IT09aSl7Y29uc3Qgcj1uZXcgVWludDhBcnJheSg2NC1pKTtlW3RdPVtuLHtleHRyYTp7MTIzNDU6cn19XX1zPW4ubGVuZ3RofXJldHVybiBFbShlLHtsZXZlbDowfSl9fWZ1bmN0aW9uIExtKHQsZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQmJnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50fHxcInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQmJnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIE9mZnNjcmVlbkNhbnZhcyYmdCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhc3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEltYWdlQml0bWFwJiZ0IGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApe2NvbnN0IG49MTAyNC9NYXRoLm1heCh0LndpZHRoLHQuaGVpZ2h0KSxpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7aS53aWR0aD10LndpZHRoKk1hdGgubWluKDEsbiksaS5oZWlnaHQ9dC5oZWlnaHQqTWF0aC5taW4oMSxuKTtjb25zdCByPWkuZ2V0Q29udGV4dChcIjJkXCIpO2lmKHIuZHJhd0ltYWdlKHQsMCwwLGkud2lkdGgsaS5oZWlnaHQpLHZvaWQgMCE9PWUpe2NvbnN0IHQ9cGFyc2VJbnQoZSwxNiksbj0odD4+MTYmMjU1KS8yNTUscz0odD4+OCYyNTUpLzI1NSxhPSgyNTUmdCkvMjU1LG89ci5nZXRJbWFnZURhdGEoMCwwLGkud2lkdGgsaS5oZWlnaHQpLGw9by5kYXRhO2ZvcihsZXQgdD0wO3Q8bC5sZW5ndGg7dCs9NClsW3QrMF09bFt0KzBdKm4sbFt0KzFdPWxbdCsxXSpzLGxbdCsyXT1sW3QrMl0qYTtyLnB1dEltYWdlRGF0YShvLDAsMCl9cmV0dXJuIGl9fWZ1bmN0aW9uIFJtKCl7cmV0dXJuJyN1c2RhIDEuMFxcbihcXG4gICAgY3VzdG9tTGF5ZXJEYXRhID0ge1xcbiAgICAgICAgc3RyaW5nIGNyZWF0b3IgPSBcIlRocmVlLmpzIFVTRFpFeHBvcnRlclwiXFxuICAgIH1cXG4gICAgbWV0ZXJzUGVyVW5pdCA9IDFcXG4gICAgdXBBeGlzID0gXCJZXCJcXG4pXFxuXFxuJ31mdW5jdGlvbiBDbSh0LGUpe3JldHVybmAoJHt0W2UrMF19LCAke3RbZSsxXX0sICR7dFtlKzJdfSwgJHt0W2UrM119KWB9ZnVuY3Rpb24gUG0odCxlKXtpZih2b2lkIDA9PT10KXJldHVybiBjb25zb2xlLndhcm4oXCJVU0RaRXhwb3J0ZXI6IE5vcm1hbHMgbWlzc2luZy5cIiksQXJyYXkoZSkuZmlsbChcIigwLCAwLCAwKVwiKS5qb2luKFwiLCBcIik7Y29uc3Qgbj1bXSxpPXQuYXJyYXk7Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kz0zKW4ucHVzaChgKCR7aVt0KzBdLnRvUHJlY2lzaW9uKDcpfSwgJHtpW3QrMV0udG9QcmVjaXNpb24oNyl9LCAke2lbdCsyXS50b1ByZWNpc2lvbig3KX0pYCk7cmV0dXJuIG4uam9pbihcIiwgXCIpfWZ1bmN0aW9uIEltKHQsZSl7Y29uc3Qgbj1cIiAgICAgICAgICAgIFwiLGk9W10scj1bXTtmdW5jdGlvbiBzKG4saSxyKXtjb25zdCBzPW4uaWQrKHI/XCJfXCIrci5nZXRIZXhTdHJpbmcoKTpcIlwiKSxhPTEwMjM9PT1uLmZvcm1hdDtyZXR1cm4gZVtzXT1uLGBcXG4gICAgICAgIGRlZiBTaGFkZXIgXCJUcmFuc2Zvcm0yZF8ke2l9XCIgKFxcbiAgICAgICAgICAgIHNkck1ldGFkYXRhID0ge1xcbiAgICAgICAgICAgICAgICBzdHJpbmcgcm9sZSA9IFwibWF0aFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgKVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIHVuaWZvcm0gdG9rZW4gaW5mbzppZCA9IFwiVXNkVHJhbnNmb3JtMmRcIlxcbiAgICAgICAgICAgIGZsb2F0MiBpbnB1dHM6aW4uY29ubmVjdCA9IDwvTWF0ZXJpYWxzL01hdGVyaWFsXyR7dC5pZH0vdXZSZWFkZXJfc3Qub3V0cHV0czpyZXN1bHQ+XFxuICAgICAgICAgICAgZmxvYXQyIGlucHV0czpzY2FsZSA9ICR7Tm0obi5yZXBlYXQpfVxcbiAgICAgICAgICAgIGZsb2F0MiBpbnB1dHM6dHJhbnNsYXRpb24gPSAke05tKG4ub2Zmc2V0KX1cXG4gICAgICAgICAgICBmbG9hdDIgb3V0cHV0czpyZXN1bHRcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRlZiBTaGFkZXIgXCJUZXh0dXJlXyR7bi5pZH1fJHtpfVwiXFxuICAgICAgICB7XFxuICAgICAgICAgICAgdW5pZm9ybSB0b2tlbiBpbmZvOmlkID0gXCJVc2RVVlRleHR1cmVcIlxcbiAgICAgICAgICAgIGFzc2V0IGlucHV0czpmaWxlID0gQHRleHR1cmVzL1RleHR1cmVfJHtzfS4ke2E/XCJwbmdcIjpcImpwZ1wifUBcXG4gICAgICAgICAgICBmbG9hdDIgaW5wdXRzOnN0LmNvbm5lY3QgPSA8L01hdGVyaWFscy9NYXRlcmlhbF8ke3QuaWR9L1RyYW5zZm9ybTJkXyR7aX0ub3V0cHV0czpyZXN1bHQ+XFxuICAgICAgICAgICAgdG9rZW4gaW5wdXRzOndyYXBTID0gXCJyZXBlYXRcIlxcbiAgICAgICAgICAgIHRva2VuIGlucHV0czp3cmFwVCA9IFwicmVwZWF0XCJcXG4gICAgICAgICAgICBmbG9hdCBvdXRwdXRzOnJcXG4gICAgICAgICAgICBmbG9hdCBvdXRwdXRzOmdcXG4gICAgICAgICAgICBmbG9hdCBvdXRwdXRzOmJcXG4gICAgICAgICAgICBmbG9hdDMgb3V0cHV0czpyZ2JcXG4gICAgICAgIH1gfXJldHVybiBudWxsIT09dC5tYXA/KGkucHVzaChgJHtufWNvbG9yM2YgaW5wdXRzOmRpZmZ1c2VDb2xvci5jb25uZWN0ID0gPC9NYXRlcmlhbHMvTWF0ZXJpYWxfJHt0LmlkfS9UZXh0dXJlXyR7dC5tYXAuaWR9X2RpZmZ1c2Uub3V0cHV0czpyZ2I+YCksci5wdXNoKHModC5tYXAsXCJkaWZmdXNlXCIsdC5jb2xvcikpKTppLnB1c2goYCR7bn1jb2xvcjNmIGlucHV0czpkaWZmdXNlQ29sb3IgPSAke0RtKHQuY29sb3IpfWApLG51bGwhPT10LmVtaXNzaXZlTWFwPyhpLnB1c2goYCR7bn1jb2xvcjNmIGlucHV0czplbWlzc2l2ZUNvbG9yLmNvbm5lY3QgPSA8L01hdGVyaWFscy9NYXRlcmlhbF8ke3QuaWR9L1RleHR1cmVfJHt0LmVtaXNzaXZlTWFwLmlkfV9lbWlzc2l2ZS5vdXRwdXRzOnJnYj5gKSxyLnB1c2gocyh0LmVtaXNzaXZlTWFwLFwiZW1pc3NpdmVcIikpKTp0LmVtaXNzaXZlLmdldEhleCgpPjAmJmkucHVzaChgJHtufWNvbG9yM2YgaW5wdXRzOmVtaXNzaXZlQ29sb3IgPSAke0RtKHQuZW1pc3NpdmUpfWApLG51bGwhPT10Lm5vcm1hbE1hcCYmKGkucHVzaChgJHtufW5vcm1hbDNmIGlucHV0czpub3JtYWwuY29ubmVjdCA9IDwvTWF0ZXJpYWxzL01hdGVyaWFsXyR7dC5pZH0vVGV4dHVyZV8ke3Qubm9ybWFsTWFwLmlkfV9ub3JtYWwub3V0cHV0czpyZ2I+YCksci5wdXNoKHModC5ub3JtYWxNYXAsXCJub3JtYWxcIikpKSxudWxsIT09dC5hb01hcCYmKGkucHVzaChgJHtufWZsb2F0IGlucHV0czpvY2NsdXNpb24uY29ubmVjdCA9IDwvTWF0ZXJpYWxzL01hdGVyaWFsXyR7dC5pZH0vVGV4dHVyZV8ke3QuYW9NYXAuaWR9X29jY2x1c2lvbi5vdXRwdXRzOnI+YCksci5wdXNoKHModC5hb01hcCxcIm9jY2x1c2lvblwiKSkpLG51bGwhPT10LnJvdWdobmVzc01hcCYmMT09PXQucm91Z2huZXNzPyhpLnB1c2goYCR7bn1mbG9hdCBpbnB1dHM6cm91Z2huZXNzLmNvbm5lY3QgPSA8L01hdGVyaWFscy9NYXRlcmlhbF8ke3QuaWR9L1RleHR1cmVfJHt0LnJvdWdobmVzc01hcC5pZH1fcm91Z2huZXNzLm91dHB1dHM6Zz5gKSxyLnB1c2gocyh0LnJvdWdobmVzc01hcCxcInJvdWdobmVzc1wiKSkpOmkucHVzaChgJHtufWZsb2F0IGlucHV0czpyb3VnaG5lc3MgPSAke3Qucm91Z2huZXNzfWApLG51bGwhPT10Lm1ldGFsbmVzc01hcCYmMT09PXQubWV0YWxuZXNzPyhpLnB1c2goYCR7bn1mbG9hdCBpbnB1dHM6bWV0YWxsaWMuY29ubmVjdCA9IDwvTWF0ZXJpYWxzL01hdGVyaWFsXyR7dC5pZH0vVGV4dHVyZV8ke3QubWV0YWxuZXNzTWFwLmlkfV9tZXRhbGxpYy5vdXRwdXRzOmI+YCksci5wdXNoKHModC5tZXRhbG5lc3NNYXAsXCJtZXRhbGxpY1wiKSkpOmkucHVzaChgJHtufWZsb2F0IGlucHV0czptZXRhbGxpYyA9ICR7dC5tZXRhbG5lc3N9YCksbnVsbCE9PXQuYWxwaGFNYXA/KGkucHVzaChgJHtufWZsb2F0IGlucHV0czpvcGFjaXR5LmNvbm5lY3QgPSA8L01hdGVyaWFscy9NYXRlcmlhbF8ke3QuaWR9L1RleHR1cmVfJHt0LmFscGhhTWFwLmlkfV9vcGFjaXR5Lm91dHB1dHM6cj5gKSxpLnB1c2goYCR7bn1mbG9hdCBpbnB1dHM6b3BhY2l0eVRocmVzaG9sZCA9IDAuMDAwMWApLHIucHVzaChzKHQuYWxwaGFNYXAsXCJvcGFjaXR5XCIpKSk6aS5wdXNoKGAke259ZmxvYXQgaW5wdXRzOm9wYWNpdHkgPSAke3Qub3BhY2l0eX1gKSx0LmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwmJihpLnB1c2goYCR7bn1mbG9hdCBpbnB1dHM6Y2xlYXJjb2F0ID0gJHt0LmNsZWFyY29hdH1gKSxpLnB1c2goYCR7bn1mbG9hdCBpbnB1dHM6Y2xlYXJjb2F0Um91Z2huZXNzID0gJHt0LmNsZWFyY29hdFJvdWdobmVzc31gKSxpLnB1c2goYCR7bn1mbG9hdCBpbnB1dHM6aW9yID0gJHt0Lmlvcn1gKSksYFxcbiAgICBkZWYgTWF0ZXJpYWwgXCJNYXRlcmlhbF8ke3QuaWR9XCJcXG4gICAge1xcbiAgICAgICAgZGVmIFNoYWRlciBcIlByZXZpZXdTdXJmYWNlXCJcXG4gICAgICAgIHtcXG4gICAgICAgICAgICB1bmlmb3JtIHRva2VuIGluZm86aWQgPSBcIlVzZFByZXZpZXdTdXJmYWNlXCJcXG4ke2kuam9pbihcIlxcblwiKX1cXG4gICAgICAgICAgICBpbnQgaW5wdXRzOnVzZVNwZWN1bGFyV29ya2Zsb3cgPSAwXFxuICAgICAgICAgICAgdG9rZW4gb3V0cHV0czpzdXJmYWNlXFxuICAgICAgICB9XFxuXFxuICAgICAgICB0b2tlbiBvdXRwdXRzOnN1cmZhY2UuY29ubmVjdCA9IDwvTWF0ZXJpYWxzL01hdGVyaWFsXyR7dC5pZH0vUHJldmlld1N1cmZhY2Uub3V0cHV0czpzdXJmYWNlPlxcbiAgICAgICAgdG9rZW4gaW5wdXRzOmZyYW1lOnN0UHJpbXZhck5hbWUgPSBcInN0XCJcXG5cXG4gICAgICAgIGRlZiBTaGFkZXIgXCJ1dlJlYWRlcl9zdFwiXFxuICAgICAgICB7XFxuICAgICAgICAgICAgdW5pZm9ybSB0b2tlbiBpbmZvOmlkID0gXCJVc2RQcmltdmFyUmVhZGVyX2Zsb2F0MlwiXFxuICAgICAgICAgICAgdG9rZW4gaW5wdXRzOnZhcm5hbWUuY29ubmVjdCA9IDwvTWF0ZXJpYWxzL01hdGVyaWFsXyR7dC5pZH0uaW5wdXRzOmZyYW1lOnN0UHJpbXZhck5hbWU+XFxuICAgICAgICAgICAgZmxvYXQyIGlucHV0czpmYWxsYmFjayA9ICgwLjAsIDAuMClcXG4gICAgICAgICAgICBmbG9hdDIgb3V0cHV0czpyZXN1bHRcXG4gICAgICAgIH1cXG5cXG4ke3Iuam9pbihcIlxcblwiKX1cXG5cXG4gICAgfVxcbmB9ZnVuY3Rpb24gRG0odCl7cmV0dXJuYCgke3Qucn0sICR7dC5nfSwgJHt0LmJ9KWB9ZnVuY3Rpb24gTm0odCl7cmV0dXJuYCgke3QueH0sICR7dC55fSlgfVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEZtPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcixzPWFyZ3VtZW50cy5sZW5ndGgsYT1zPDM/ZTpudWxsPT09aT9pPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTppLG89dC5sZW5ndGgtMTtvPj0wO28tLSkocj10W29dKSYmKGE9KHM8Mz9yKGEpOnM+Mz9yKGUsbixhKTpyKGUsbikpfHxhKTtyZXR1cm4gcz4zJiZhJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLGEpLGF9O2xldCBPbT0hMSxVbT0hMTtjb25zdCBrbT0oem09W1wicXVpY2stbG9va1wiLFwic2NlbmUtdmlld2VyXCIsXCJ3ZWJ4clwiLFwibm9uZVwiXSx0PT57dHJ5e2NvbnN0IGU9bnUodCksbj0oZS5sZW5ndGg/ZVswXS50ZXJtczpbXSkuZmlsdGVyKCh0PT50JiZcImlkZW50XCI9PT10LnR5cGUpKS5tYXAoKHQ9PnQudmFsdWUpKS5maWx0ZXIoKHQ9PnptLmluZGV4T2YodCk+LTEpKSxpPW5ldyBTZXQ7Zm9yKGNvbnN0IHQgb2YgbilpLmFkZCh0KTtyZXR1cm4gaX1jYXRjaCh0KXt9cmV0dXJuIG5ldyBTZXR9KTt2YXIgem07Y29uc3QgQm09XCJxdWljay1sb29rXCIsSG09XCJzY2VuZS12aWV3ZXJcIixWbT1cIndlYnhyXCIsR209XCJub25lXCIsV209U3ltYm9sKFwiYXJCdXR0b25Db250YWluZXJcIiksam09U3ltYm9sKFwiZW50ZXJBUldpdGhXZWJYUlwiKSxxbT1TeW1ib2woXCJvcGVuU2NlbmVWaWV3ZXJcIiksWG09U3ltYm9sKFwib3BlbklPU0FSUXVpY2tMb29rXCIpLFltPVN5bWJvbChcImNhbkFjdGl2YXRlQVJcIiksWm09U3ltYm9sKFwiYXJNb2RlXCIpLEptPVN5bWJvbChcImFyTW9kZXNcIiksJG09U3ltYm9sKFwiYXJBbmNob3JcIiksS209U3ltYm9sKFwicHJlbG9hZFwiKSxRbT1TeW1ib2woXCJvbkFSQnV0dG9uQ29udGFpbmVyQ2xpY2tcIiksdGY9U3ltYm9sKFwib25BUlN0YXR1c1wiKSxlZj1TeW1ib2woXCJvbkFSVHJhY2tpbmdcIiksbmY9U3ltYm9sKFwib25BUlRhcFwiKSxyZj1TeW1ib2woXCJzZWxlY3RBUk1vZGVcIiksc2Y9U3ltYm9sKFwidHJpZ2dlckxvYWRcIik7XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgYWYsb2YsbGY7Y29uc3QgY2Y9U3ltYm9sKFwiZXZhbHVhdGVcIiksaGY9U3ltYm9sKFwibGFzdFZhbHVlXCIpO2NsYXNzIHVme2NvbnN0cnVjdG9yKCl7dGhpc1thZl09bnVsbH1zdGF0aWMgZXZhbHVhdGFibGVGb3IodCxlPWh1KXtpZih0IGluc3RhbmNlb2YgdWYpcmV0dXJuIHQ7aWYoXCJudW1iZXJcIj09PXQudHlwZSlyZXR1cm5cIiVcIj09PXQudW5pdD9uZXcgbWYodCxlKTp0O3N3aXRjaCh0Lm5hbWUudmFsdWUpe2Nhc2VcImNhbGNcIjpyZXR1cm4gbmV3IHhmKHQsZSk7Y2FzZVwiZW52XCI6cmV0dXJuIG5ldyBnZih0KX1yZXR1cm4gaHV9c3RhdGljIGV2YWx1YXRlKHQpe3JldHVybiB0IGluc3RhbmNlb2YgdWY/dC5ldmFsdWF0ZSgpOnR9c3RhdGljIGlzQ29uc3RhbnQodCl7cmV0dXJuISh0IGluc3RhbmNlb2YgdWYpfHx0LmlzQ29uc3RhbnR9c3RhdGljIGFwcGx5SW50cmluc2ljcyh0LGUpe2NvbnN0e2Jhc2lzOm4sa2V5d29yZHM6aX09ZSx7YXV0bzpyfT1pO3JldHVybiBuLm1hcCgoKGUsbik9Pntjb25zdCBzPW51bGw9PXJbbl0/ZTpyW25dO2xldCBhPXRbbl0/dFtuXTpzO2lmKFwiaWRlbnRcIj09PWEudHlwZSl7Y29uc3QgdD1hLnZhbHVlO3QgaW4gaSYmKGE9aVt0XVtuXSl9cmV0dXJuIG51bGwhPWEmJlwiaWRlbnRcIiE9PWEudHlwZXx8KGE9cyksXCIlXCI9PT1hLnVuaXQ/ZXUoYS5udW1iZXIvMTAwKmUubnVtYmVyLGUudW5pdCk6KGE9cHUoYSxlKSxhLnVuaXQhPT1lLnVuaXQ/ZTphKX0pKX1nZXQgaXNDb25zdGFudCgpe3JldHVybiExfWV2YWx1YXRlKCl7cmV0dXJuIHRoaXMuaXNDb25zdGFudCYmbnVsbCE9dGhpc1toZl18fCh0aGlzW2hmXT10aGlzW2NmXSgpKSx0aGlzW2hmXX19YWY9aGY7Y29uc3QgZGY9U3ltYm9sKFwicGVyY2VudGFnZVwiKSxwZj1TeW1ib2woXCJiYXNpc1wiKTtjbGFzcyBtZiBleHRlbmRzIHVme2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIoKSx0aGlzW2RmXT10LHRoaXNbcGZdPWV9Z2V0IGlzQ29uc3RhbnQoKXtyZXR1cm4hMH1bY2ZdKCl7cmV0dXJuIGV1KHRoaXNbZGZdLm51bWJlci8xMDAqdGhpc1twZl0ubnVtYmVyLHRoaXNbcGZdLnVuaXQpfX1jb25zdCBmZj1TeW1ib2woXCJpZGVudE5vZGVcIik7Y2xhc3MgZ2YgZXh0ZW5kcyB1Zntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXNbb2ZdPW51bGw7Y29uc3QgZT10LmFyZ3VtZW50cy5sZW5ndGg/dC5hcmd1bWVudHNbMF0udGVybXNbMF06bnVsbDtudWxsIT1lJiZcImlkZW50XCI9PT1lLnR5cGUmJih0aGlzW2ZmXT1lKX1nZXQgaXNDb25zdGFudCgpe3JldHVybiExfVsob2Y9ZmYsY2YpXSgpe2lmKG51bGwhPXRoaXNbZmZdJiZcIndpbmRvdy1zY3JvbGwteVwiPT09dGhpc1tmZl0udmFsdWUpe3JldHVybnt0eXBlOlwibnVtYmVyXCIsbnVtYmVyOndpbmRvdy5wYWdlWU9mZnNldC8oTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpLXdpbmRvdy5pbm5lckhlaWdodCl8fDAsdW5pdDpudWxsfX1yZXR1cm4gaHV9fWNvbnN0IHZmPS9bXFwqXFwvXS8seWY9U3ltYm9sKFwiZXZhbHV0b3JcIik7Y2xhc3MgeGYgZXh0ZW5kcyB1Zntjb25zdHJ1Y3Rvcih0LGU9aHUpe2lmKHN1cGVyKCksdGhpc1tsZl09bnVsbCwxIT09dC5hcmd1bWVudHMubGVuZ3RoKXJldHVybjtjb25zdCBuPXQuYXJndW1lbnRzWzBdLnRlcm1zLnNsaWNlKCksaT1bXTtmb3IoO24ubGVuZ3RoOyl7Y29uc3QgdD1uLnNoaWZ0KCk7aWYoaS5sZW5ndGg+MCl7Y29uc3Qgbj1pW2kubGVuZ3RoLTFdO2lmKFwib3BlcmF0b3JcIj09PW4udHlwZSYmdmYudGVzdChuLnZhbHVlKSl7Y29uc3Qgbj1pLnBvcCgpLHI9aS5wb3AoKTtpZihudWxsPT1yKXJldHVybjtpLnB1c2gobmV3IE1mKG4sdWYuZXZhbHVhdGFibGVGb3IocixlKSx1Zi5ldmFsdWF0YWJsZUZvcih0LGUpKSk7Y29udGludWV9fWkucHVzaChcIm9wZXJhdG9yXCI9PT10LnR5cGU/dDp1Zi5ldmFsdWF0YWJsZUZvcih0LGUpKX1mb3IoO2kubGVuZ3RoPjI7KXtjb25zdFt0LG4scl09aS5zcGxpY2UoMCwzKTtpZihcIm9wZXJhdG9yXCIhPT1uLnR5cGUpcmV0dXJuO2kudW5zaGlmdChuZXcgTWYobix1Zi5ldmFsdWF0YWJsZUZvcih0LGUpLHVmLmV2YWx1YXRhYmxlRm9yKHIsZSkpKX0xPT09aS5sZW5ndGgmJih0aGlzW3lmXT1pWzBdKX1nZXQgaXNDb25zdGFudCgpe3JldHVybiBudWxsPT10aGlzW3lmXXx8dWYuaXNDb25zdGFudCh0aGlzW3lmXSl9WyhsZj15ZixjZildKCl7cmV0dXJuIG51bGwhPXRoaXNbeWZdP3VmLmV2YWx1YXRlKHRoaXNbeWZdKTpodX19Y29uc3QgYmY9U3ltYm9sKFwib3BlcmF0b3JcIiksd2Y9U3ltYm9sKFwibGVmdFwiKSxfZj1TeW1ib2woXCJyaWdodFwiKTtjbGFzcyBNZiBleHRlbmRzIHVme2NvbnN0cnVjdG9yKHQsZSxuKXtzdXBlcigpLHRoaXNbYmZdPXQsdGhpc1t3Zl09ZSx0aGlzW19mXT1ufWdldCBpc0NvbnN0YW50KCl7cmV0dXJuIHVmLmlzQ29uc3RhbnQodGhpc1t3Zl0pJiZ1Zi5pc0NvbnN0YW50KHRoaXNbX2ZdKX1bY2ZdKCl7Y29uc3QgdD1wdSh1Zi5ldmFsdWF0ZSh0aGlzW3dmXSkpLGU9cHUodWYuZXZhbHVhdGUodGhpc1tfZl0pKSx7bnVtYmVyOm4sdW5pdDppfT10LHtudW1iZXI6cix1bml0OnN9PWU7aWYobnVsbCE9cyYmbnVsbCE9aSYmcyE9aSlyZXR1cm4gaHU7Y29uc3QgYT1pfHxzO2xldCBvO3N3aXRjaCh0aGlzW2JmXS52YWx1ZSl7Y2FzZVwiK1wiOm89bityO2JyZWFrO2Nhc2VcIi1cIjpvPW4tcjticmVhaztjYXNlXCIvXCI6bz1uL3I7YnJlYWs7Y2FzZVwiKlwiOm89bipyO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIGh1fXJldHVybnt0eXBlOlwibnVtYmVyXCIsbnVtYmVyOm8sdW5pdDphfX19Y29uc3QgU2Y9U3ltYm9sKFwiZXZhbHVhdGFibGVzXCIpLFRmPVN5bWJvbChcImludHJpbnNpY3NcIik7Y2xhc3MgRWYgZXh0ZW5kcyB1Zntjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpc1tUZl09ZTtjb25zdCBuPXRbMF0saT1udWxsIT1uP24udGVybXM6W107dGhpc1tTZl09ZS5iYXNpcy5tYXAoKCh0LGUpPT57Y29uc3Qgbj1pW2VdO3JldHVybiBudWxsPT1uP3t0eXBlOlwiaWRlbnRcIix2YWx1ZTpcImF1dG9cIn06XCJpZGVudFwiPT09bi50eXBlP246dWYuZXZhbHVhdGFibGVGb3Iobix0KX0pKX1nZXQgaXNDb25zdGFudCgpe2Zvcihjb25zdCB0IG9mIHRoaXNbU2ZdKWlmKCF1Zi5pc0NvbnN0YW50KHQpKXJldHVybiExO3JldHVybiEwfVtjZl0oKXtjb25zdCB0PXRoaXNbU2ZdLm1hcCgodD0+dWYuZXZhbHVhdGUodCkpKTtyZXR1cm4gdWYuYXBwbHlJbnRyaW5zaWNzKHQsdGhpc1tUZl0pLm1hcCgodD0+dC5udW1iZXIpKX19XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovdmFyIEFmLExmLFJmLENmO2NvbnN0IFBmPVN5bWJvbChcImluc3RhbmNlc1wiKSxJZj1TeW1ib2woXCJhY3RpdmF0ZUxpc3RlbmVyXCIpLERmPVN5bWJvbChcImRlYWN0aXZhdGVMaXN0ZW5lclwiKSxOZj1TeW1ib2woXCJub3RpZnlJbnN0YW5jZXNcIiksRmY9U3ltYm9sKFwibm90aWZ5XCIpLE9mPVN5bWJvbChcImNhbGxiYWNrXCIpO2NsYXNzIFVme2NvbnN0cnVjdG9yKHQpe3RoaXNbT2ZdPXR9c3RhdGljW05mXSgpe2Zvcihjb25zdCB0IG9mIFVmW1BmXSl0W0ZmXSgpfXN0YXRpY1soQWY9UGYsSWYpXSgpe3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpc1tOZl0se3Bhc3NpdmU6ITB9KX1zdGF0aWNbRGZdKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzW05mXSl9b2JzZXJ2ZSgpezA9PT1VZltQZl0uc2l6ZSYmVWZbSWZdKCksVWZbUGZdLmFkZCh0aGlzKX1kaXNjb25uZWN0KCl7VWZbUGZdLmRlbGV0ZSh0aGlzKSwwPT09VWZbUGZdLnNpemUmJlVmW0RmXSgpfVtGZl0oKXt0aGlzW09mXSgpfX1VZltBZl09bmV3IFNldDtjb25zdCBrZj1TeW1ib2woXCJjb21wdXRlU3R5bGVDYWxsYmFja1wiKSx6Zj1TeW1ib2woXCJhc3RXYWxrZXJcIiksQmY9U3ltYm9sKFwiZGVwZW5kZW5jaWVzXCIpLEhmPVN5bWJvbChcIm9uU2Nyb2xsXCIpO2NsYXNzIFZme2NvbnN0cnVjdG9yKHQpe3RoaXNbTGZdPXt9LHRoaXNbUmZdPW5ldyBjdShbXCJmdW5jdGlvblwiXSksdGhpc1tDZl09KCk9Pnt0aGlzW2tmXSh7cmVsYXRlZFN0YXRlOlwid2luZG93LXNjcm9sbFwifSl9LHRoaXNba2ZdPXR9b2JzZXJ2ZUVmZmVjdHNGb3IodCl7Y29uc3QgZT17fSxuPXRoaXNbQmZdO3RoaXNbemZdLndhbGsodCwodD0+e2NvbnN0e25hbWU6aX09dCxyPXQuYXJndW1lbnRzWzBdLnRlcm1zWzBdO2lmKFwiZW52XCI9PT1pLnZhbHVlJiZudWxsIT1yJiZcImlkZW50XCI9PT1yLnR5cGUmJlwid2luZG93LXNjcm9sbC15XCI9PT1yLnZhbHVlKWlmKG51bGw9PWVbXCJ3aW5kb3ctc2Nyb2xsXCJdKXtjb25zdCB0PVwid2luZG93LXNjcm9sbFwiaW4gbj9uW1wid2luZG93LXNjcm9sbFwiXTpuZXcgVWYodGhpc1tIZl0pO3Qub2JzZXJ2ZSgpLGRlbGV0ZSBuW1wid2luZG93LXNjcm9sbFwiXSxlW1wid2luZG93LXNjcm9sbFwiXT10fX0pKTtmb3IoY29uc3QgdCBpbiBuKXtuW3RdLmRpc2Nvbm5lY3QoKX10aGlzW0JmXT1lfWRpc3Bvc2UoKXtmb3IoY29uc3QgdCBpbiB0aGlzW0JmXSl7dGhpc1tCZl1bdF0uZGlzY29ubmVjdCgpfX19TGY9QmYsUmY9emYsQ2Y9SGY7XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBHZj10PT57Y29uc3QgZT10Lm9ic2VydmVFZmZlY3RzfHwhMSxuPXQuaW50cmluc2ljcyBpbnN0YW5jZW9mIEZ1bmN0aW9uP3QuaW50cmluc2ljczooKT0+dC5pbnRyaW5zaWNzO3JldHVybihpLHIpPT57Y29uc3Qgcz1pLnVwZGF0ZWQsYT1pLmNvbm5lY3RlZENhbGxiYWNrLG89aS5kaXNjb25uZWN0ZWRDYWxsYmFjayxsPVN5bWJvbChgJHtyfVN0eWxlRWZmZWN0b3JgKSxjPVN5bWJvbChgJHtyfVN0eWxlRXZhbHVhdG9yYCksaD1TeW1ib2woYCR7cn1VcGRhdGVFdmFsdWF0b3JgKSx1PVN5bWJvbChgJHtyfUV2YWx1YXRlQW5kU3luY2ApO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGkse1tsXTp7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0sW2NdOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSxbaF06e3ZhbHVlOmZ1bmN0aW9uKCl7Y29uc3QgdD1udSh0aGlzW3JdKTt0aGlzW2NdPW5ldyBFZih0LG4odGhpcykpLG51bGw9PXRoaXNbbF0mJmUmJih0aGlzW2xdPW5ldyBWZigoKCk9PnRoaXNbdV0oKSkpKSxudWxsIT10aGlzW2xdJiZ0aGlzW2xdLm9ic2VydmVFZmZlY3RzRm9yKHQpfX0sW3VdOnt2YWx1ZTpmdW5jdGlvbigpe2lmKG51bGw9PXRoaXNbY10pcmV0dXJuO2NvbnN0IGU9dGhpc1tjXS5ldmFsdWF0ZSgpO3RoaXNbdC51cGRhdGVIYW5kbGVyXShlKX19LHVwZGF0ZWQ6e3ZhbHVlOmZ1bmN0aW9uKHQpe3QuaGFzKHIpJiYodGhpc1toXSgpLHRoaXNbdV0oKSkscy5jYWxsKHRoaXMsdCl9fSxjb25uZWN0ZWRDYWxsYmFjazp7dmFsdWU6ZnVuY3Rpb24oKXthLmNhbGwodGhpcyksdGhpcy5yZXF1ZXN0VXBkYXRlKHIsdGhpc1tyXSl9fSxkaXNjb25uZWN0ZWRDYWxsYmFjazp7dmFsdWU6ZnVuY3Rpb24oKXtvLmNhbGwodGhpcyksbnVsbCE9dGhpc1tsXSYmKHRoaXNbbF0uZGlzcG9zZSgpLHRoaXNbbF09bnVsbCl9fX0pfX0sV2Y9T2JqZWN0LmZyZWV6ZSh7bWluaW11bVJhZGl1czowLG1heGltdW1SYWRpdXM6MS8wLG1pbmltdW1Qb2xhckFuZ2xlOk1hdGguUEkvOCxtYXhpbXVtUG9sYXJBbmdsZTpNYXRoLlBJLU1hdGguUEkvOCxtaW5pbXVtQXppbXV0aGFsQW5nbGU6LTEvMCxtYXhpbXVtQXppbXV0aGFsQW5nbGU6MS8wLG1pbmltdW1GaWVsZE9mVmlldzoxMCxtYXhpbXVtRmllbGRPZlZpZXc6NDUsaW50ZXJhY3Rpb25Qb2xpY3k6XCJhbHdheXMtYWxsb3dcIix0b3VjaEFjdGlvbjpcInBhbi15XCJ9KSxqZj1NYXRoLlBJLzgscWY9MzMsWGY9MzQsWWY9MzcsWmY9MzgsSmY9MzksJGY9NDAsS2Y9XCJ1c2VyLWludGVyYWN0aW9uXCIsUWY9XCJub25lXCI7XG4vKiBAbGljZW5zZVxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jbGFzcyB0ZyBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIoKSx0aGlzLmNhbWVyYT10LHRoaXMuZWxlbWVudD1lLHRoaXMuc2Vuc2l0aXZpdHk9MSx0aGlzLl9pbnRlcmFjdGlvbkVuYWJsZWQ9ITEsdGhpcy5fZGlzYWJsZVpvb209ITEsdGhpcy5pc1VzZXJDaGFuZ2U9ITEsdGhpcy5pc1VzZXJQb2ludGluZz0hMSx0aGlzLnNwaGVyaWNhbD1uZXcgbmMsdGhpcy5nb2FsU3BoZXJpY2FsPW5ldyBuYyx0aGlzLnRoZXRhRGFtcGVyPW5ldyB0dSx0aGlzLnBoaURhbXBlcj1uZXcgdHUsdGhpcy5yYWRpdXNEYW1wZXI9bmV3IHR1LHRoaXMubG9nRm92PU1hdGgubG9nKFdmLm1heGltdW1GaWVsZE9mVmlldyksdGhpcy5nb2FsTG9nRm92PXRoaXMubG9nRm92LHRoaXMuZm92RGFtcGVyPW5ldyB0dSx0aGlzLnRvdWNoTW9kZT1udWxsLHRoaXMubGFzdFBvaW50ZXJQb3NpdGlvbj17Y2xpZW50WDowLGNsaWVudFk6MH0sdGhpcy50b3VjaERlY2lkZWQ9ITEsdGhpcy5vbk1vdXNlTW92ZT10PT57dGhpcy5oYW5kbGVTaW5nbGVQb2ludGVyTW92ZSh0KSx0LmNhbmNlbGFibGUmJnQucHJldmVudERlZmF1bHQoKX0sdGhpcy5vblRvdWNoTW92ZT10PT57bnVsbCE9PXRoaXMudG91Y2hNb2RlJiYodGhpcy50b3VjaE1vZGUodCksbnVsbCE9PXRoaXMudG91Y2hNb2RlJiZ0LmNhbmNlbGFibGUmJnQucHJldmVudERlZmF1bHQoKSl9LHRoaXMudG91Y2hNb2RlWm9vbT10PT57Y29uc3R7dGFyZ2V0VG91Y2hlczplfT10O2lmKHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoPjEmJmUubGVuZ3RoPjEpe2NvbnN0IHQ9LjA0Kih0aGlzLnR3b1RvdWNoRGlzdGFuY2UodGhpcy5sYXN0VG91Y2hlc1swXSx0aGlzLmxhc3RUb3VjaGVzWzFdKS10aGlzLnR3b1RvdWNoRGlzdGFuY2UoZVswXSxlWzFdKSkvMTA7dGhpcy51c2VyQWRqdXN0T3JiaXQoMCwwLHQpLHRoaXMubGFzdFRvdWNoZXM9ZX19LHRoaXMudG91Y2hNb2RlUm90YXRlPXQ9Pntjb25zdHt0YXJnZXRUb3VjaGVzOmV9PXQse3RvdWNoQWN0aW9uOm59PXRoaXMuX29wdGlvbnM7aWYoIXRoaXMudG91Y2hEZWNpZGVkJiZcIm5vbmVcIiE9PW4pe3RoaXMudG91Y2hEZWNpZGVkPSEwO2NvbnN0e2NsaWVudFg6dCxjbGllbnRZOml9PWVbMF0scj1NYXRoLmFicyh0LXRoaXMubGFzdFBvaW50ZXJQb3NpdGlvbi5jbGllbnRYKSxzPU1hdGguYWJzKGktdGhpcy5sYXN0UG9pbnRlclBvc2l0aW9uLmNsaWVudFkpO2lmKFwicGFuLXlcIj09PW4mJnM+cnx8XCJwYW4teFwiPT09biYmcj5zKXJldHVybiB2b2lkKHRoaXMudG91Y2hNb2RlPW51bGwpfXRoaXMuaGFuZGxlU2luZ2xlUG9pbnRlck1vdmUoZVswXSksdGhpcy5sYXN0VG91Y2hlcz1lfSx0aGlzLm9uTW91c2VEb3duPXQ9Pnt0aGlzLm9uUG9pbnRlckRvd24oKCgpPT57c2VsZi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5vbk1vdXNlTW92ZSksc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMub25Nb3VzZVVwLHtvbmNlOiEwfSksdGhpcy5oYW5kbGVTaW5nbGVQb2ludGVyRG93bih0KX0pKX0sdGhpcy5vblRvdWNoU3RhcnQ9dD0+e3RoaXMub25Qb2ludGVyRG93bigoKCk9Pntjb25zdHt0YXJnZXRUb3VjaGVzOmUsY2hhbmdlZFRvdWNoZXM6bix0b3VjaGVzOml9PXQ7ZS5sZW5ndGg9PT1uLmxlbmd0aCYmKHRoaXMudG91Y2hNb2RlPW51bGwsdGhpcy50b3VjaERlY2lkZWQ9ITEpLGUubGVuZ3RoPT09aS5sZW5ndGgmJnRoaXMub25Ub3VjaENoYW5nZSh0KX0pKX0sdGhpcy5vbk1vdXNlVXA9dD0+e3NlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMub25Nb3VzZU1vdmUpLHRoaXMub25Qb2ludGVyVXAoKX0sdGhpcy5vblRvdWNoRW5kPXQ9Pnt0LnRhcmdldFRvdWNoZXMubGVuZ3RoPjAmJm51bGwhPT10aGlzLnRvdWNoTW9kZSYmdGhpcy5vblRvdWNoQ2hhbmdlKHQpLHRoaXMub25Qb2ludGVyVXAoKX0sdGhpcy5vbldoZWVsPXQ9PntpZighdGhpcy5jYW5JbnRlcmFjdClyZXR1cm47Y29uc3QgZT10LmRlbHRhWSooMT09dC5kZWx0YU1vZGU/MTg6MSkqLjA0LzMwO3RoaXMudXNlckFkanVzdE9yYml0KDAsMCxlKSx0LmNhbmNlbGFibGUmJnQucHJldmVudERlZmF1bHQoKX0sdGhpcy5vbktleURvd249dD0+e2xldCBlPSExO3N3aXRjaCh0LmtleUNvZGUpe2Nhc2UgcWY6ZT0hMCx0aGlzLnVzZXJBZGp1c3RPcmJpdCgwLDAsLjA0KTticmVhaztjYXNlIFhmOmU9ITAsdGhpcy51c2VyQWRqdXN0T3JiaXQoMCwwLC0uMDQpO2JyZWFrO2Nhc2UgWmY6ZT0hMCx0aGlzLnVzZXJBZGp1c3RPcmJpdCgwLC1qZiwwKTticmVhaztjYXNlICRmOmU9ITAsdGhpcy51c2VyQWRqdXN0T3JiaXQoMCxqZiwwKTticmVhaztjYXNlIFlmOmU9ITAsdGhpcy51c2VyQWRqdXN0T3JiaXQoLWpmLDAsMCk7YnJlYWs7Y2FzZSBKZjplPSEwLHRoaXMudXNlckFkanVzdE9yYml0KGpmLDAsMCl9ZSYmdC5jYW5jZWxhYmxlJiZ0LnByZXZlbnREZWZhdWx0KCl9LHRoaXMuX29wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxXZiksdGhpcy5zZXRPcmJpdCgwLE1hdGguUEkvMiwxKSx0aGlzLnNldEZpZWxkT2ZWaWV3KDEwMCksdGhpcy5qdW1wVG9Hb2FsKCl9Z2V0IGludGVyYWN0aW9uRW5hYmxlZCgpe3JldHVybiB0aGlzLl9pbnRlcmFjdGlvbkVuYWJsZWR9ZW5hYmxlSW50ZXJhY3Rpb24oKXtpZighMT09PXRoaXMuX2ludGVyYWN0aW9uRW5hYmxlZCl7Y29uc3R7ZWxlbWVudDp0fT10aGlzO3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMub25Nb3VzZURvd24pLHRoaXMuX2Rpc2FibGVab29tfHx0LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHRoaXMub25XaGVlbCksdC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMub25LZXlEb3duKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5vblRvdWNoU3RhcnQse3Bhc3NpdmU6ITB9KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLm9uVG91Y2hNb3ZlLHtwYXNzaXZlOiExfSksdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm9uVG91Y2hFbmQpLHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3I9XCJncmFiXCIsdGhpcy5faW50ZXJhY3Rpb25FbmFibGVkPSEwLHRoaXMudXBkYXRlVG91Y2hBY3Rpb25TdHlsZSgpfX1kaXNhYmxlSW50ZXJhY3Rpb24oKXtpZighMD09PXRoaXMuX2ludGVyYWN0aW9uRW5hYmxlZCl7Y29uc3R7ZWxlbWVudDp0fT10aGlzO3NlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMub25Nb3VzZU1vdmUpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMub25Nb3VzZURvd24pLHRoaXMuX2Rpc2FibGVab29tfHx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHRoaXMub25XaGVlbCksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMub25LZXlEb3duKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5vblRvdWNoU3RhcnQpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMub25Ub3VjaE1vdmUpLHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLm9uTW91c2VVcCksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm9uVG91Y2hFbmQpLHQuc3R5bGUuY3Vyc29yPVwiXCIsdGhpcy50b3VjaE1vZGU9bnVsbCx0aGlzLl9pbnRlcmFjdGlvbkVuYWJsZWQ9ITEsdGhpcy51cGRhdGVUb3VjaEFjdGlvblN0eWxlKCl9fWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXMuX29wdGlvbnN9c2V0IGRpc2FibGVab29tKHQpe3RoaXMuX2Rpc2FibGVab29tIT10JiYodGhpcy5fZGlzYWJsZVpvb209dCwhMD09PXQ/dGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHRoaXMub25XaGVlbCk6dGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHRoaXMub25XaGVlbCksdGhpcy51cGRhdGVUb3VjaEFjdGlvblN0eWxlKCkpfWdldENhbWVyYVNwaGVyaWNhbCh0PW5ldyBuYyl7cmV0dXJuIHQuY29weSh0aGlzLnNwaGVyaWNhbCl9Z2V0RmllbGRPZlZpZXcoKXtyZXR1cm4gdGhpcy5jYW1lcmEuZm92fWFwcGx5T3B0aW9ucyh0KXtPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsdCksdGhpcy5zZXRPcmJpdCgpLHRoaXMuc2V0RmllbGRPZlZpZXcoTWF0aC5leHAodGhpcy5nb2FsTG9nRm92KSl9dXBkYXRlTmVhckZhcih0LGUpe3RoaXMuY2FtZXJhLm5lYXI9TWF0aC5tYXgodCxlLzFlMyksdGhpcy5jYW1lcmEuZmFyPWUsdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfXVwZGF0ZUFzcGVjdCh0KXt0aGlzLmNhbWVyYS5hc3BlY3Q9dCx0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9c2V0T3JiaXQodD10aGlzLmdvYWxTcGhlcmljYWwudGhldGEsZT10aGlzLmdvYWxTcGhlcmljYWwucGhpLG49dGhpcy5nb2FsU3BoZXJpY2FsLnJhZGl1cyl7Y29uc3R7bWluaW11bUF6aW11dGhhbEFuZ2xlOmksbWF4aW11bUF6aW11dGhhbEFuZ2xlOnIsbWluaW11bVBvbGFyQW5nbGU6cyxtYXhpbXVtUG9sYXJBbmdsZTphLG1pbmltdW1SYWRpdXM6byxtYXhpbXVtUmFkaXVzOmx9PXRoaXMuX29wdGlvbnMse3RoZXRhOmMscGhpOmgscmFkaXVzOnV9PXRoaXMuZ29hbFNwaGVyaWNhbCxkPUpoKHQsaSxyKTtpc0Zpbml0ZShpKXx8aXNGaW5pdGUocil8fCh0aGlzLnNwaGVyaWNhbC50aGV0YT10aGlzLndyYXBBbmdsZSh0aGlzLnNwaGVyaWNhbC50aGV0YS1kKStkKTtjb25zdCBwPUpoKGUscyxhKSxtPUpoKG4sbyxsKTtyZXR1cm4oZCE9PWN8fHAhPT1ofHxtIT09dSkmJih0aGlzLmdvYWxTcGhlcmljYWwudGhldGE9ZCx0aGlzLmdvYWxTcGhlcmljYWwucGhpPXAsdGhpcy5nb2FsU3BoZXJpY2FsLnJhZGl1cz1tLHRoaXMuZ29hbFNwaGVyaWNhbC5tYWtlU2FmZSgpLHRoaXMuaXNVc2VyQ2hhbmdlPSExLCEwKX1zZXRSYWRpdXModCl7dGhpcy5nb2FsU3BoZXJpY2FsLnJhZGl1cz10LHRoaXMuc2V0T3JiaXQoKX1zZXRGaWVsZE9mVmlldyh0KXtjb25zdHttaW5pbXVtRmllbGRPZlZpZXc6ZSxtYXhpbXVtRmllbGRPZlZpZXc6bn09dGhpcy5fb3B0aW9uczt0PUpoKHQsZSxuKSx0aGlzLmdvYWxMb2dGb3Y9TWF0aC5sb2codCl9c2V0RGFtcGVyRGVjYXlUaW1lKHQpe3RoaXMudGhldGFEYW1wZXIuc2V0RGVjYXlUaW1lKHQpLHRoaXMucGhpRGFtcGVyLnNldERlY2F5VGltZSh0KSx0aGlzLnJhZGl1c0RhbXBlci5zZXREZWNheVRpbWUodCksdGhpcy5mb3ZEYW1wZXIuc2V0RGVjYXlUaW1lKHQpfWFkanVzdE9yYml0KHQsZSxuKXtjb25zdHt0aGV0YTppLHBoaTpyLHJhZGl1czpzfT10aGlzLmdvYWxTcGhlcmljYWwse21pbmltdW1SYWRpdXM6YSxtYXhpbXVtUmFkaXVzOm8sbWluaW11bUZpZWxkT2ZWaWV3OmwsbWF4aW11bUZpZWxkT2ZWaWV3OmN9PXRoaXMuX29wdGlvbnMsaD10aGlzLnNwaGVyaWNhbC50aGV0YS1pLHU9TWF0aC5QSS0uMDAxLGQ9aS1KaCh0LC11LWgsdS1oKSxwPXItZSxtPTA9PT1uPzA6KChuPjA/bzphKS1zKS8oTWF0aC5sb2cobj4wP2M6bCktdGhpcy5nb2FsTG9nRm92KSxmPXMrbipNYXRoLm1pbihpc0Zpbml0ZShtKT9tOjEvMCxvLWEpO2lmKHRoaXMuc2V0T3JiaXQoZCxwLGYpLDAhPT1uKXtjb25zdCB0PXRoaXMuZ29hbExvZ0ZvdituO3RoaXMuc2V0RmllbGRPZlZpZXcoTWF0aC5leHAodCkpfX1qdW1wVG9Hb2FsKCl7dGhpcy51cGRhdGUoMCwxZTQpfXVwZGF0ZSh0LGUpe2lmKHRoaXMuaXNTdGF0aW9uYXJ5KCkpcmV0dXJuO2NvbnN0e21heGltdW1Qb2xhckFuZ2xlOm4sbWF4aW11bVJhZGl1czppfT10aGlzLl9vcHRpb25zLHI9dGhpcy5zcGhlcmljYWwudGhldGEtdGhpcy5nb2FsU3BoZXJpY2FsLnRoZXRhO01hdGguYWJzKHIpPk1hdGguUEkmJiFpc0Zpbml0ZSh0aGlzLl9vcHRpb25zLm1pbmltdW1BemltdXRoYWxBbmdsZSkmJiFpc0Zpbml0ZSh0aGlzLl9vcHRpb25zLm1heGltdW1BemltdXRoYWxBbmdsZSkmJih0aGlzLnNwaGVyaWNhbC50aGV0YS09MipNYXRoLnNpZ24ocikqTWF0aC5QSSksdGhpcy5zcGhlcmljYWwudGhldGE9dGhpcy50aGV0YURhbXBlci51cGRhdGUodGhpcy5zcGhlcmljYWwudGhldGEsdGhpcy5nb2FsU3BoZXJpY2FsLnRoZXRhLGUsTWF0aC5QSSksdGhpcy5zcGhlcmljYWwucGhpPXRoaXMucGhpRGFtcGVyLnVwZGF0ZSh0aGlzLnNwaGVyaWNhbC5waGksdGhpcy5nb2FsU3BoZXJpY2FsLnBoaSxlLG4pLHRoaXMuc3BoZXJpY2FsLnJhZGl1cz10aGlzLnJhZGl1c0RhbXBlci51cGRhdGUodGhpcy5zcGhlcmljYWwucmFkaXVzLHRoaXMuZ29hbFNwaGVyaWNhbC5yYWRpdXMsZSxpKSx0aGlzLmxvZ0Zvdj10aGlzLmZvdkRhbXBlci51cGRhdGUodGhpcy5sb2dGb3YsdGhpcy5nb2FsTG9nRm92LGUsMSksdGhpcy5tb3ZlQ2FtZXJhKCl9dXBkYXRlVG91Y2hBY3Rpb25TdHlsZSgpe2NvbnN0e3N0eWxlOnR9PXRoaXMuZWxlbWVudDtpZih0aGlzLl9pbnRlcmFjdGlvbkVuYWJsZWQpe2NvbnN0e3RvdWNoQWN0aW9uOmV9PXRoaXMuX29wdGlvbnM7dGhpcy5fZGlzYWJsZVpvb20mJlwibm9uZVwiIT09ZT90LnRvdWNoQWN0aW9uPVwibWFuaXB1bGF0aW9uXCI6dC50b3VjaEFjdGlvbj1lfWVsc2UgdC50b3VjaEFjdGlvbj1cIlwifWlzU3RhdGlvbmFyeSgpe3JldHVybiB0aGlzLmdvYWxTcGhlcmljYWwudGhldGE9PT10aGlzLnNwaGVyaWNhbC50aGV0YSYmdGhpcy5nb2FsU3BoZXJpY2FsLnBoaT09PXRoaXMuc3BoZXJpY2FsLnBoaSYmdGhpcy5nb2FsU3BoZXJpY2FsLnJhZGl1cz09PXRoaXMuc3BoZXJpY2FsLnJhZGl1cyYmdGhpcy5nb2FsTG9nRm92PT09dGhpcy5sb2dGb3Z9bW92ZUNhbWVyYSgpe3RoaXMuc3BoZXJpY2FsLm1ha2VTYWZlKCksdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCksdGhpcy5jYW1lcmEuc2V0Um90YXRpb25Gcm9tRXVsZXIobmV3IEFlKHRoaXMuc3BoZXJpY2FsLnBoaS1NYXRoLlBJLzIsdGhpcy5zcGhlcmljYWwudGhldGEsMCxcIllYWlwiKSksdGhpcy5jYW1lcmEuZm92IT09TWF0aC5leHAodGhpcy5sb2dGb3YpJiYodGhpcy5jYW1lcmEuZm92PU1hdGguZXhwKHRoaXMubG9nRm92KSx0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkpO2NvbnN0IHQ9dGhpcy5pc1VzZXJDaGFuZ2U/S2Y6UWY7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiY2hhbmdlXCIsc291cmNlOnR9KX1nZXQgY2FuSW50ZXJhY3QoKXtpZihcImFsbG93LXdoZW4tZm9jdXNlZFwiPT10aGlzLl9vcHRpb25zLmludGVyYWN0aW9uUG9saWN5KXtyZXR1cm4gdGhpcy5lbGVtZW50LmdldFJvb3ROb2RlKCkuYWN0aXZlRWxlbWVudD09PXRoaXMuZWxlbWVudH1yZXR1cm5cImFsd2F5cy1hbGxvd1wiPT09dGhpcy5fb3B0aW9ucy5pbnRlcmFjdGlvblBvbGljeX11c2VyQWRqdXN0T3JiaXQodCxlLG4pe3RoaXMuYWRqdXN0T3JiaXQodCp0aGlzLnNlbnNpdGl2aXR5LGUqdGhpcy5zZW5zaXRpdml0eSxuKSx0aGlzLmlzVXNlckNoYW5nZT0hMCx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJjaGFuZ2VcIixzb3VyY2U6S2Z9KX13cmFwQW5nbGUodCl7Y29uc3QgZT0odCtNYXRoLlBJKS8oMipNYXRoLlBJKTtyZXR1cm4gMiooZS1NYXRoLmZsb29yKGUpKSpNYXRoLlBJLU1hdGguUEl9cGl4ZWxMZW5ndGhUb1NwaGVyaWNhbEFuZ2xlKHQpe3JldHVybiAyKk1hdGguUEkqdC90aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0fXR3b1RvdWNoRGlzdGFuY2UodCxlKXtjb25zdHtjbGllbnRYOm4sY2xpZW50WTppfT10LHtjbGllbnRYOnIsY2xpZW50WTpzfT1lLGE9ci1uLG89cy1pO3JldHVybiBNYXRoLnNxcnQoYSphK28qbyl9aGFuZGxlU2luZ2xlUG9pbnRlck1vdmUodCl7Y29uc3R7Y2xpZW50WDplLGNsaWVudFk6bn09dCxpPXRoaXMucGl4ZWxMZW5ndGhUb1NwaGVyaWNhbEFuZ2xlKGUtdGhpcy5sYXN0UG9pbnRlclBvc2l0aW9uLmNsaWVudFgpLHI9dGhpcy5waXhlbExlbmd0aFRvU3BoZXJpY2FsQW5nbGUobi10aGlzLmxhc3RQb2ludGVyUG9zaXRpb24uY2xpZW50WSk7dGhpcy5sYXN0UG9pbnRlclBvc2l0aW9uLmNsaWVudFg9ZSx0aGlzLmxhc3RQb2ludGVyUG9zaXRpb24uY2xpZW50WT1uLCExPT09dGhpcy5pc1VzZXJQb2ludGluZyYmKHRoaXMuaXNVc2VyUG9pbnRpbmc9ITAsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwicG9pbnRlci1jaGFuZ2Utc3RhcnRcIixwb2ludGVyOk9iamVjdC5hc3NpZ24oe30sdCl9KSksdGhpcy51c2VyQWRqdXN0T3JiaXQoaSxyLDApfW9uUG9pbnRlckRvd24odCl7dGhpcy5jYW5JbnRlcmFjdCYmKHRoaXMuaXNVc2VyUG9pbnRpbmc9ITEsdCgpKX1vblRvdWNoQ2hhbmdlKHQpe2NvbnN0e3RhcmdldFRvdWNoZXM6ZX09dDtpZigyPT09ZS5sZW5ndGgpdGhpcy50b3VjaE1vZGU9dGhpcy5fZGlzYWJsZVpvb218fHRoaXMudG91Y2hEZWNpZGVkJiZudWxsPT09dGhpcy50b3VjaE1vZGU/bnVsbDp0aGlzLnRvdWNoTW9kZVpvb20sdGhpcy50b3VjaERlY2lkZWQ9ITA7ZWxzZSB0aGlzLnRvdWNoTW9kZT10aGlzLnRvdWNoTW9kZVJvdGF0ZSx0aGlzLmhhbmRsZVNpbmdsZVBvaW50ZXJEb3duKGVbMF0pO3RoaXMubGFzdFRvdWNoZXM9ZX1oYW5kbGVTaW5nbGVQb2ludGVyRG93bih0KXt0aGlzLmxhc3RQb2ludGVyUG9zaXRpb24uY2xpZW50WD10LmNsaWVudFgsdGhpcy5sYXN0UG9pbnRlclBvc2l0aW9uLmNsaWVudFk9dC5jbGllbnRZLHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3I9XCJncmFiYmluZ1wifW9uUG9pbnRlclVwKCl7dGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvcj1cImdyYWJcIix0aGlzLmlzVXNlclBvaW50aW5nJiZ0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJwb2ludGVyLWNoYW5nZS1lbmRcIixwb2ludGVyOk9iamVjdC5hc3NpZ24oe30sdGhpcy5sYXN0UG9pbnRlclBvc2l0aW9uKX0pfX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jb25zdCBlZz10PT50PC41PzIqdCp0Oig0LTIqdCkqdC0xLG5nPSh0LGUsbj1lZyk9Pmk9PnQrKGUtdCkqbihpKSxpZz0odCxlKT0+e2NvbnN0IG49W10saT1bXTtsZXQgcj10O2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtjb25zdCBzPWVbdF0se3ZhbHVlOmEsZnJhbWVzOm99PXMsbD1zLmVhc2V8fGVnLGM9bmcocixhLGwpO24ucHVzaChjKSxpLnB1c2gobykscj1hfXJldHVybigodCxlKT0+e2NvbnN0IG49ZS5yZWR1Y2UoKCh0LGUpPT50K2UpLDApLGk9ZS5tYXAoKHQ9PnQvbikpO3JldHVybiBlPT57bGV0IG49MCxyPTEvMCxzPSgpPT4wO2ZvcihsZXQgYT0wO2E8aS5sZW5ndGgmJihyPWlbYV0scz10W2FdLCEoZTw9bityKSk7KythKW4rPXI7cmV0dXJuIHMoKGUtbikvcil9fSkobixpKX07XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgcmc9ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByLHM9YXJndW1lbnRzLmxlbmd0aCxhPXM8Mz9lOm51bGw9PT1pP2k9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pOmksbz10Lmxlbmd0aC0xO28+PTA7by0tKShyPXRbb10pJiYoYT0oczwzP3IoYSk6cz4zP3IoZSxuLGEpOnIoZSxuKSl8fGEpO3JldHVybiBzPjMmJmEmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4sYSksYX07Y29uc3Qgc2c9aWcoMCxbe2ZyYW1lczo1LHZhbHVlOi0xfSx7ZnJhbWVzOjEsdmFsdWU6LTF9LHtmcmFtZXM6OCx2YWx1ZToxfSx7ZnJhbWVzOjEsdmFsdWU6MX0se2ZyYW1lczo1LHZhbHVlOjB9LHtmcmFtZXM6MTgsdmFsdWU6MH1dKSxhZz1pZygwLFt7ZnJhbWVzOjEsdmFsdWU6MX0se2ZyYW1lczo1LHZhbHVlOjF9LHtmcmFtZXM6MSx2YWx1ZTowfSx7ZnJhbWVzOjYsdmFsdWU6MH1dKSxvZz0xLjEqeXUsbGc9W1wiZnJvbnRcIixcInJpZ2h0XCIsXCJiYWNrXCIsXCJsZWZ0XCJdLGNnPVtcInVwcGVyLVwiLFwiXCIsXCJsb3dlci1cIl0saGc9XCJhdXRvXCIsdWc9XCJ3aGVuLWZvY3VzZWRcIixkZz1cIndpZ2dsZVwiLHBnPVwiYWx3YXlzLWFsbG93XCIsbWc9XCJwYW4teVwiLGZnPXQ9Pih7YmFzaXM6W2V1KHRbSGddKk1hdGguUEkvMTgwLFwicmFkXCIpXSxrZXl3b3Jkczp7YXV0bzpbbnVsbF19fSksZ2c9e2Jhc2lzOlt1dShldSgyNSxcImRlZ1wiKSldLGtleXdvcmRzOnthdXRvOltudWxsXX19LHZnPXQ9Pntjb25zdCBlPXRbZHBdO3JldHVybntiYXNpczpbdXUoZXUoNDUsXCJkZWdcIikpXSxrZXl3b3Jkczp7YXV0bzpbZXUoZS5mcmFtZWRGaWVsZE9mVmlldyxcImRlZ1wiKV19fX0seWc9KCgpPT57Y29uc3QgdD1udShcIjBkZWcgNzVkZWcgMTA1JVwiKVswXS50ZXJtcyxlPXB1KHRbMF0pLG49cHUodFsxXSk7cmV0dXJuIHQ9Pntjb25zdCBpPXRbZHBdLmlkZWFsQ2FtZXJhRGlzdGFuY2U7cmV0dXJue2Jhc2lzOltlLG4sZXUoaSxcIm1cIildLGtleXdvcmRzOnthdXRvOltudWxsLG51bGwsZXUoMTA1LFwiJVwiKV19fX19KSgpLHhnPXQ9Pntjb25zdCBlPW9nKnRbZHBdLmlkZWFsQ2FtZXJhRGlzdGFuY2U7cmV0dXJue2Jhc2lzOltldSgtMS8wLFwicmFkXCIpLGV1KE1hdGguUEkvOCxcInJhZFwiKSxldShlLFwibVwiKV0sa2V5d29yZHM6e2F1dG86W251bGwsbnVsbCxudWxsXX19fSxiZz10PT57Y29uc3QgZT15Zyh0KSxuPW5ldyBFZihbXSxlKS5ldmFsdWF0ZSgpWzJdO3JldHVybntiYXNpczpbZXUoMS8wLFwicmFkXCIpLGV1KE1hdGguUEktTWF0aC5QSS84LFwicmFkXCIpLGV1KG4sXCJtXCIpXSxrZXl3b3Jkczp7YXV0bzpbbnVsbCxudWxsLG51bGxdfX19LHdnPXQ9Pntjb25zdCBlPXRbZHBdLmJvdW5kaW5nQm94LmdldENlbnRlcihuZXcgQnQpO3JldHVybntiYXNpczpbZXUoZS54LFwibVwiKSxldShlLnksXCJtXCIpLGV1KGUueixcIm1cIildLGtleXdvcmRzOnthdXRvOltudWxsLG51bGwsbnVsbF19fX0sX2c9TWF0aC5QSS8yLE1nPU1hdGguUEkvMyxTZz1fZy8yLFRnPTIqTWF0aC5QSSxFZz1TeW1ib2woXCJjb250cm9sc1wiKSxBZz1TeW1ib2woXCJwcm9tcHRFbGVtZW50XCIpLExnPVN5bWJvbChcInByb21wdEFuaW1hdGVkQ29udGFpbmVyXCIpLFJnPVN5bWJvbChcImRlZmVySW50ZXJhY3Rpb25Qcm9tcHRcIiksQ2c9U3ltYm9sKFwidXBkYXRlQXJpYVwiKSxQZz1TeW1ib2woXCJ1cGRhdGVDYW1lcmFGb3JSYWRpdXNcIiksSWc9U3ltYm9sKFwib25CbHVyXCIpLERnPVN5bWJvbChcIm9uRm9jdXNcIiksTmc9U3ltYm9sKFwib25DaGFuZ2VcIiksRmc9U3ltYm9sKFwib25Qb2ludGVyQ2hhbmdlXCIpLE9nPVN5bWJvbChcIndhaXRpbmdUb1Byb21wdFVzZXJcIiksVWc9U3ltYm9sKFwidXNlckhhc0ludGVyYWN0ZWRcIiksa2c9U3ltYm9sKFwicHJvbXB0RWxlbWVudFZpc2libGVUaW1lXCIpLHpnPVN5bWJvbChcImxhc3RQcm9tcHRPZmZzZXRcIiksQmc9U3ltYm9sKFwiZm9jdXNlZFRpbWVcIiksSGc9U3ltYm9sKFwiem9vbUFkanVzdGVkRmllbGRPZlZpZXdcIiksVmc9U3ltYm9sKFwibGFzdFNwaGVyaWNhbFwiKSxHZz1TeW1ib2woXCJqdW1wQ2FtZXJhXCIpLFdnPVN5bWJvbChcImluaXRpYWxpemVkXCIpLGpnPVN5bWJvbChcIm1haW50YWluVGhldGFQaGlcIikscWc9U3ltYm9sKFwic3luY0NhbWVyYU9yYml0XCIpLFhnPVN5bWJvbChcInN5bmNGaWVsZE9mVmlld1wiKSxZZz1TeW1ib2woXCJzeW5jQ2FtZXJhVGFyZ2V0XCIpLFpnPVN5bWJvbChcInN5bmNNaW5DYW1lcmFPcmJpdFwiKSxKZz1TeW1ib2woXCJzeW5jTWF4Q2FtZXJhT3JiaXRcIiksJGc9U3ltYm9sKFwic3luY01pbkZpZWxkT2ZWaWV3XCIpLEtnPVN5bWJvbChcInN5bmNNYXhGaWVsZE9mVmlld1wiKTtcbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBRZyx0djtjb25zdCBldj1TeW1ib2woXCJtb2RlbFZpZXdlclN0YXR1c0luc3RhbmNlXCIpLG52PVN5bWJvbChcInVwZGF0ZVN0YXR1c1wiKTtRZz1ldix0dj1udjtcbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBpdj1mdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHIscz1hcmd1bWVudHMubGVuZ3RoLGE9czwzP2U6bnVsbD09PWk/aT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik6aSxvPXQubGVuZ3RoLTE7bz49MDtvLS0pKHI9dFtvXSkmJihhPShzPDM/cihhKTpzPjM/cihlLG4sYSk6cihlLG4pKXx8YSk7cmV0dXJuIHM+MyYmYSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbixhKSxhfTtjb25zdCBydj1cImF1dG9cIixzdj1cIm1hbnVhbFwiLGF2PVwiYXV0b1wiLG92PVwiZWFnZXJcIixsdj1cImludGVyYWN0aW9uXCIsY3Y9bmV3IGNsYXNzIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXNbUWddPW51bGwsdGhpcy5yZWdpc3RlcmVkSW5zdGFuY2VTdGF0dXNlcz1uZXcgTWFwLHRoaXMubG9hZGluZ1Byb21pc2VzPVtdLHRoaXMuc3RhdHVzRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSx0aGlzLnN0YXR1c1VwZGF0ZUluUHJvZ3Jlc3M9ITEsdGhpc1t0dl09WmgoKCgpPT50aGlzLnVwZGF0ZVN0YXR1cygpKSwxMDApO2NvbnN0e3N0YXR1c0VsZW1lbnQ6dH09dGhpcyx7c3R5bGU6ZX09dDt0LnNldEF0dHJpYnV0ZShcInJvbGVcIixcInN0YXR1c1wiKSx0LmNsYXNzTGlzdC5hZGQoXCJzY3JlZW4tcmVhZGVyLW9ubHlcIiksZS50b3A9ZS5sZWZ0PVwiMFwiLGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIn1yZWdpc3Rlckluc3RhbmNlKHQpe2lmKHRoaXMucmVnaXN0ZXJlZEluc3RhbmNlU3RhdHVzZXMuaGFzKHQpKXJldHVybjtsZXQgZT0oKT0+e307Y29uc3Qgbj0hMT09PXQubG9hZGVkJiYhIXQuc3JjLGk9bmV3IFByb21pc2UoKGk9PntpZighbilyZXR1cm4gdm9pZCBpKCk7Y29uc3Qgcj0oKT0+e2koKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsciksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixyKX07dC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLHIpLHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsciksZT1yfSkpO3RoaXMucmVnaXN0ZXJlZEluc3RhbmNlU3RhdHVzZXMuc2V0KHQse29uVW5yZWdpc3RlcmVkOmV9KSx0aGlzLmxvYWRpbmdQcm9taXNlcy5wdXNoKGkpLG51bGw9PXRoaXMubW9kZWxWaWV3ZXJTdGF0dXNJbnN0YW5jZSYmKHRoaXMubW9kZWxWaWV3ZXJTdGF0dXNJbnN0YW5jZT10KX11bnJlZ2lzdGVySW5zdGFuY2UodCl7aWYoIXRoaXMucmVnaXN0ZXJlZEluc3RhbmNlU3RhdHVzZXMuaGFzKHQpKXJldHVybjtjb25zdCBlPXRoaXMucmVnaXN0ZXJlZEluc3RhbmNlU3RhdHVzZXMsbj1lLmdldCh0KTtlLmRlbGV0ZSh0KSxuLm9uVW5yZWdpc3RlcmVkKCksdGhpcy5tb2RlbFZpZXdlclN0YXR1c0luc3RhbmNlPT09dCYmKHRoaXMubW9kZWxWaWV3ZXJTdGF0dXNJbnN0YW5jZT1lLnNpemU+MD8odD0+e2lmKG51bGwhPXQua2V5cylyZXR1cm4gdC5rZXlzKCkubmV4dCgpLnZhbHVlfHxudWxsO2xldCBlPW51bGw7dHJ5e3QuZm9yRWFjaCgoKHQsbixpKT0+e3Rocm93IGU9bixuZXcgRXJyb3J9KSl9Y2F0Y2godCl7fXJldHVybiBlfSkoZSk6bnVsbCl9Z2V0IG1vZGVsVmlld2VyU3RhdHVzSW5zdGFuY2UoKXtyZXR1cm4gdGhpc1tldl19c2V0IG1vZGVsVmlld2VyU3RhdHVzSW5zdGFuY2UodCl7aWYodGhpc1tldl09PT10KXJldHVybjtjb25zdHtzdGF0dXNFbGVtZW50OmV9PXRoaXM7bnVsbCE9dCYmbnVsbCE9dC5zaGFkb3dSb290P3Quc2hhZG93Um9vdC5hcHBlbmRDaGlsZChlKTpudWxsIT1lLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSx0aGlzW2V2XT10LHRoaXNbbnZdKCl9YXN5bmMgdXBkYXRlU3RhdHVzKCl7aWYoIXRoaXMuc3RhdHVzVXBkYXRlSW5Qcm9ncmVzcyYmMCE9PXRoaXMubG9hZGluZ1Byb21pc2VzLmxlbmd0aCl7Zm9yKHRoaXMuc3RhdHVzRWxlbWVudC50ZXh0Q29udGVudD1cIlRoaXMgcGFnZSBpbmNsdWRlcyBvbmUgb3IgbW9yZSAzRCBtb2RlbHMgdGhhdCBhcmUgbG9hZGluZ1wiLHRoaXMuc3RhdHVzVXBkYXRlSW5Qcm9ncmVzcz0hMCx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJpbml0aWFsLXN0YXR1cy1hbm5vdW5jZWRcIn0pO3RoaXMubG9hZGluZ1Byb21pc2VzLmxlbmd0aDspe2NvbnN0e2xvYWRpbmdQcm9taXNlczp0fT10aGlzO3RoaXMubG9hZGluZ1Byb21pc2VzPVtdLGF3YWl0IFByb21pc2UuYWxsKHQpfXRoaXMuc3RhdHVzRWxlbWVudC50ZXh0Q29udGVudD1cIkFsbCAzRCBtb2RlbHMgaW4gdGhlIHBhZ2UgaGF2ZSBsb2FkZWRcIix0aGlzLnN0YXR1c1VwZGF0ZUluUHJvZ3Jlc3M9ITEsdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZmluaXNoZWQtbG9hZGluZy1hbm5vdW5jZWRcIn0pfX19LGh2PVN5bWJvbChcImRlZmF1bHRQcm9ncmVzc0JhckVsZW1lbnRcIiksdXY9U3ltYm9sKFwiZGVmYXVsdFByb2dyZXNzTWFza0VsZW1lbnRcIiksZHY9U3ltYm9sKFwicG9zdGVyQ29udGFpbmVyRWxlbWVudFwiKSxwdj1TeW1ib2woXCJkZWZhdWx0UG9zdGVyRWxlbWVudFwiKSxtdj1TeW1ib2woXCJwb3N0ZXJEaXNtaXNzYWxTb3VyY2VcIiksZnY9U3ltYm9sKFwiaGlkZVBvc3RlclwiKSxndj1TeW1ib2woXCJtb2RlbElzUmV2ZWFsZWRcIiksdnY9U3ltYm9sKFwidXBkYXRlUHJvZ3Jlc3NCYXJcIikseXY9U3ltYm9sKFwibGFzdFJlcG9ydGVkUHJvZ3Jlc3NcIikseHY9U3ltYm9sKFwidHJhbnNpdGlvbmVkXCIpLGJ2PVN5bWJvbChcIm9uVHJhbnNpdGlvbkVuZFwiKSx3dj1TeW1ib2woXCJhcmlhTGFiZWxDYWxsVG9BY3Rpb25cIiksX3Y9U3ltYm9sKFwib25DbGlja1wiKSxNdj1TeW1ib2woXCJvbktleWRvd25cIiksU3Y9U3ltYm9sKFwib25Qcm9ncmVzc1wiKTtjbGFzcyBUdntjb25zdHJ1Y3Rvcigpe3RoaXMucGx1Z2luQ2FsbGJhY2tzPVtdLHRoaXMucmVnaXN0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUXYodCl9KSksdGhpcy5yZWdpc3RlcigoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB0eSh0KX0pKSx0aGlzLnJlZ2lzdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGV5KHQpfSkpLHRoaXMucmVnaXN0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbnkodCl9KSksdGhpcy5yZWdpc3RlcigoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBpeSh0KX0pKX1yZWdpc3Rlcih0KXtyZXR1cm4tMT09PXRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YodCkmJnRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2godCksdGhpc311bnJlZ2lzdGVyKHQpe3JldHVybi0xIT09dGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZih0KSYmdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YodCksMSksdGhpc31wYXJzZSh0LGUsbil7Y29uc3QgaT1uZXcgS3Yscj1bXTtmb3IobGV0IHQ9MCxlPXRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDt0PGU7dCsrKXIucHVzaCh0aGlzLnBsdWdpbkNhbGxiYWNrc1t0XShpKSk7aS5zZXRQbHVnaW5zKHIpLGkud3JpdGUodCxlLG4pfX1jb25zdCBFdj0wLEF2PTEsTHY9MixSdj0zLEN2PTQsUHY9NTEyMSxJdj01MTIzLER2PTUxMjYsTnY9NTEyNSxGdj0zNDk2MixPdj0zNDk2MyxVdj05NzI4LGt2PTk3MjksenY9OTk4NCxCdj05OTg1LEh2PTk5ODYsVnY9OTk4NyxHdj0zMzA3MSxXdj0zMzY0OCxqdj0xMDQ5Nyxxdj17fTtxdlsxMDAzXT1VdixxdlsxMDA0XT16dixxdlsxMDA1XT1IdixxdlsxMDA2XT1rdixxdlsxMDA3XT1CdixxdlsxMDA4XT1WdixxdlsxMDAxXT1HdixxdlsxZTNdPWp2LHF2WzEwMDJdPVd2O2NvbnN0IFh2PXtzY2FsZTpcInNjYWxlXCIscG9zaXRpb246XCJ0cmFuc2xhdGlvblwiLHF1YXRlcm5pb246XCJyb3RhdGlvblwiLG1vcnBoVGFyZ2V0SW5mbHVlbmNlczpcIndlaWdodHNcIn07ZnVuY3Rpb24gWXYodCxlKXtyZXR1cm4gdC5sZW5ndGg9PT1lLmxlbmd0aCYmdC5ldmVyeSgoZnVuY3Rpb24odCxuKXtyZXR1cm4gdD09PWVbbl19KSl9ZnVuY3Rpb24gWnYodCl7cmV0dXJuIDQqTWF0aC5jZWlsKHQvNCl9ZnVuY3Rpb24gSnYodCxlPTApe2NvbnN0IG49WnYodC5ieXRlTGVuZ3RoKTtpZihuIT09dC5ieXRlTGVuZ3RoKXtjb25zdCBpPW5ldyBVaW50OEFycmF5KG4pO2lmKGkuc2V0KG5ldyBVaW50OEFycmF5KHQpKSwwIT09ZSlmb3IobGV0IHI9dC5ieXRlTGVuZ3RoO3I8bjtyKyspaVtyXT1lO3JldHVybiBpLmJ1ZmZlcn1yZXR1cm4gdH1sZXQgJHY9bnVsbDtjbGFzcyBLdntjb25zdHJ1Y3Rvcigpe3RoaXMucGx1Z2lucz1bXSx0aGlzLm9wdGlvbnM9e30sdGhpcy5wZW5kaW5nPVtdLHRoaXMuYnVmZmVycz1bXSx0aGlzLmJ5dGVPZmZzZXQ9MCx0aGlzLmJ1ZmZlcnM9W10sdGhpcy5ub2RlTWFwPW5ldyBNYXAsdGhpcy5za2lucz1bXSx0aGlzLmV4dGVuc2lvbnNVc2VkPXt9LHRoaXMudWlkcz1uZXcgTWFwLHRoaXMudWlkPTAsdGhpcy5qc29uPXthc3NldDp7dmVyc2lvbjpcIjIuMFwiLGdlbmVyYXRvcjpcIlRIUkVFLkdMVEZFeHBvcnRlclwifX0sdGhpcy5jYWNoZT17bWVzaGVzOm5ldyBNYXAsYXR0cmlidXRlczpuZXcgTWFwLGF0dHJpYnV0ZXNOb3JtYWxpemVkOm5ldyBNYXAsbWF0ZXJpYWxzOm5ldyBNYXAsdGV4dHVyZXM6bmV3IE1hcCxpbWFnZXM6bmV3IE1hcH19c2V0UGx1Z2lucyh0KXt0aGlzLnBsdWdpbnM9dH13cml0ZSh0LGUsbil7dGhpcy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe30se2JpbmFyeTohMSx0cnM6ITEsb25seVZpc2libGU6ITAsdHJ1bmNhdGVEcmF3UmFuZ2U6ITAsZW1iZWRJbWFnZXM6ITAsbWF4VGV4dHVyZVNpemU6MS8wLGFuaW1hdGlvbnM6W10saW5jbHVkZUN1c3RvbUV4dGVuc2lvbnM6ITF9LG4pLHRoaXMub3B0aW9ucy5hbmltYXRpb25zLmxlbmd0aD4wJiYodGhpcy5vcHRpb25zLnRycz0hMCksdGhpcy5wcm9jZXNzSW5wdXQodCk7Y29uc3QgaT10aGlzO1Byb21pc2UuYWxsKHRoaXMucGVuZGluZykudGhlbigoZnVuY3Rpb24oKXtjb25zdCB0PWkuYnVmZmVycyxuPWkuanNvbixyPWkub3B0aW9ucyxzPWkuZXh0ZW5zaW9uc1VzZWQsYT1uZXcgQmxvYih0LHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSxvPU9iamVjdC5rZXlzKHMpO2lmKG8ubGVuZ3RoPjAmJihuLmV4dGVuc2lvbnNVc2VkPW8pLG4uYnVmZmVycyYmbi5idWZmZXJzLmxlbmd0aD4wJiYobi5idWZmZXJzWzBdLmJ5dGVMZW5ndGg9YS5zaXplKSwhMD09PXIuYmluYXJ5KXtjb25zdCB0PW5ldyB3aW5kb3cuRmlsZVJlYWRlcjt0LnJlYWRBc0FycmF5QnVmZmVyKGEpLHQub25sb2FkZW5kPWZ1bmN0aW9uKCl7Y29uc3QgaT1Kdih0LnJlc3VsdCkscj1uZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtyLnNldFVpbnQzMigwLGkuYnl0ZUxlbmd0aCwhMCksci5zZXRVaW50MzIoNCw1MTMwNTYyLCEwKTtjb25zdCBzPUp2KGZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXdpbmRvdy5UZXh0RW5jb2RlcilyZXR1cm4obmV3IFRleHRFbmNvZGVyKS5lbmNvZGUodCkuYnVmZmVyO2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKHQubGVuZ3RoKSk7Zm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKXtjb25zdCBpPXQuY2hhckNvZGVBdChuKTtlW25dPWk+MjU1PzMyOml9cmV0dXJuIGUuYnVmZmVyfShKU09OLnN0cmluZ2lmeShuKSksMzIpLGE9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7YS5zZXRVaW50MzIoMCxzLmJ5dGVMZW5ndGgsITApLGEuc2V0VWludDMyKDQsMTMxMzgyMTUxNCwhMCk7Y29uc3Qgbz1uZXcgQXJyYXlCdWZmZXIoMTIpLGw9bmV3IERhdGFWaWV3KG8pO2wuc2V0VWludDMyKDAsMTE3OTkzNzg5NSwhMCksbC5zZXRVaW50MzIoNCwyLCEwKTtjb25zdCBjPTEyK2EuYnl0ZUxlbmd0aCtzLmJ5dGVMZW5ndGgrci5ieXRlTGVuZ3RoK2kuYnl0ZUxlbmd0aDtsLnNldFVpbnQzMig4LGMsITApO2NvbnN0IGg9bmV3IEJsb2IoW28sYSxzLHIsaV0se3R5cGU6XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pLHU9bmV3IHdpbmRvdy5GaWxlUmVhZGVyO3UucmVhZEFzQXJyYXlCdWZmZXIoaCksdS5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXtlKHUucmVzdWx0KX19fWVsc2UgaWYobi5idWZmZXJzJiZuLmJ1ZmZlcnMubGVuZ3RoPjApe2NvbnN0IHQ9bmV3IHdpbmRvdy5GaWxlUmVhZGVyO3QucmVhZEFzRGF0YVVSTChhKSx0Lm9ubG9hZGVuZD1mdW5jdGlvbigpe2NvbnN0IGk9dC5yZXN1bHQ7bi5idWZmZXJzWzBdLnVyaT1pLGUobil9fWVsc2UgZShuKX0pKX1zZXJpYWxpemVVc2VyRGF0YSh0LGUpe2lmKDA9PT1PYmplY3Qua2V5cyh0LnVzZXJEYXRhKS5sZW5ndGgpcmV0dXJuO2NvbnN0IG49dGhpcy5vcHRpb25zLGk9dGhpcy5leHRlbnNpb25zVXNlZDt0cnl7Y29uc3Qgcj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQudXNlckRhdGEpKTtpZihuLmluY2x1ZGVDdXN0b21FeHRlbnNpb25zJiZyLmdsdGZFeHRlbnNpb25zKXt2b2lkIDA9PT1lLmV4dGVuc2lvbnMmJihlLmV4dGVuc2lvbnM9e30pO2Zvcihjb25zdCB0IGluIHIuZ2x0ZkV4dGVuc2lvbnMpZS5leHRlbnNpb25zW3RdPXIuZ2x0ZkV4dGVuc2lvbnNbdF0saVt0XT0hMDtkZWxldGUgci5nbHRmRXh0ZW5zaW9uc31PYmplY3Qua2V5cyhyKS5sZW5ndGg+MCYmKGUuZXh0cmFzPXIpfWNhdGNoKGUpe2NvbnNvbGUud2FybihcIlRIUkVFLkdMVEZFeHBvcnRlcjogdXNlckRhdGEgb2YgJ1wiK3QubmFtZStcIicgd29uJ3QgYmUgc2VyaWFsaXplZCBiZWNhdXNlIG9mIEpTT04uc3RyaW5naWZ5IGVycm9yIC0gXCIrZS5tZXNzYWdlKX19Z2V0VUlEKHQpe3JldHVybiB0aGlzLnVpZHMuaGFzKHQpfHx0aGlzLnVpZHMuc2V0KHQsdGhpcy51aWQrKyksdGhpcy51aWRzLmdldCh0KX1pc05vcm1hbGl6ZWROb3JtYWxBdHRyaWJ1dGUodCl7aWYodGhpcy5jYWNoZS5hdHRyaWJ1dGVzTm9ybWFsaXplZC5oYXModCkpcmV0dXJuITE7Y29uc3QgZT1uZXcgQnQ7Zm9yKGxldCBuPTAsaT10LmNvdW50O248aTtuKyspaWYoTWF0aC5hYnMoZS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsbikubGVuZ3RoKCktMSk+NWUtNClyZXR1cm4hMTtyZXR1cm4hMH1jcmVhdGVOb3JtYWxpemVkTm9ybWFsQXR0cmlidXRlKHQpe2NvbnN0IGU9dGhpcy5jYWNoZTtpZihlLmF0dHJpYnV0ZXNOb3JtYWxpemVkLmhhcyh0KSlyZXR1cm4gZS5hdHRyaWJ1dGVzTm9ybWFsaXplZC5nZXQodCk7Y29uc3Qgbj10LmNsb25lKCksaT1uZXcgQnQ7Zm9yKGxldCB0PTAsZT1uLmNvdW50O3Q8ZTt0KyspaS5mcm9tQnVmZmVyQXR0cmlidXRlKG4sdCksMD09PWkueCYmMD09PWkueSYmMD09PWkuej9pLnNldFgoMSk6aS5ub3JtYWxpemUoKSxuLnNldFhZWih0LGkueCxpLnksaS56KTtyZXR1cm4gZS5hdHRyaWJ1dGVzTm9ybWFsaXplZC5zZXQodCxuKSxufWFwcGx5VGV4dHVyZVRyYW5zZm9ybSh0LGUpe2xldCBuPSExO2NvbnN0IGk9e307MD09PWUub2Zmc2V0LngmJjA9PT1lLm9mZnNldC55fHwoaS5vZmZzZXQ9ZS5vZmZzZXQudG9BcnJheSgpLG49ITApLDAhPT1lLnJvdGF0aW9uJiYoaS5yb3RhdGlvbj1lLnJvdGF0aW9uLG49ITApLDE9PT1lLnJlcGVhdC54JiYxPT09ZS5yZXBlYXQueXx8KGkuc2NhbGU9ZS5yZXBlYXQudG9BcnJheSgpLG49ITApLG4mJih0LmV4dGVuc2lvbnM9dC5leHRlbnNpb25zfHx7fSx0LmV4dGVuc2lvbnMuS0hSX3RleHR1cmVfdHJhbnNmb3JtPWksdGhpcy5leHRlbnNpb25zVXNlZC5LSFJfdGV4dHVyZV90cmFuc2Zvcm09ITApfXByb2Nlc3NCdWZmZXIodCl7Y29uc3QgZT10aGlzLmpzb24sbj10aGlzLmJ1ZmZlcnM7cmV0dXJuIGUuYnVmZmVyc3x8KGUuYnVmZmVycz1be2J5dGVMZW5ndGg6MH1dKSxuLnB1c2godCksMH1wcm9jZXNzQnVmZmVyVmlldyh0LGUsbixpLHIpe2NvbnN0IHM9dGhpcy5qc29uO2xldCBhO3MuYnVmZmVyVmlld3N8fChzLmJ1ZmZlclZpZXdzPVtdKSxhPWU9PT1Qdj8xOmU9PT1Jdj8yOjQ7Y29uc3Qgbz1adihpKnQuaXRlbVNpemUqYSksbD1uZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKG8pKTtsZXQgYz0wO2ZvcihsZXQgcj1uO3I8bitpO3IrKylmb3IobGV0IG49MDtuPHQuaXRlbVNpemU7bisrKXtsZXQgaTt0Lml0ZW1TaXplPjQ/aT10LmFycmF5W3IqdC5pdGVtU2l6ZStuXTowPT09bj9pPXQuZ2V0WChyKToxPT09bj9pPXQuZ2V0WShyKToyPT09bj9pPXQuZ2V0WihyKTozPT09biYmKGk9dC5nZXRXKHIpKSxlPT09RHY/bC5zZXRGbG9hdDMyKGMsaSwhMCk6ZT09PU52P2wuc2V0VWludDMyKGMsaSwhMCk6ZT09PUl2P2wuc2V0VWludDE2KGMsaSwhMCk6ZT09PVB2JiZsLnNldFVpbnQ4KGMsaSksYys9YX1jb25zdCBoPXtidWZmZXI6dGhpcy5wcm9jZXNzQnVmZmVyKGwuYnVmZmVyKSxieXRlT2Zmc2V0OnRoaXMuYnl0ZU9mZnNldCxieXRlTGVuZ3RoOm99O3ZvaWQgMCE9PXImJihoLnRhcmdldD1yKSxyPT09RnYmJihoLmJ5dGVTdHJpZGU9dC5pdGVtU2l6ZSphKSx0aGlzLmJ5dGVPZmZzZXQrPW8scy5idWZmZXJWaWV3cy5wdXNoKGgpO3JldHVybntpZDpzLmJ1ZmZlclZpZXdzLmxlbmd0aC0xLGJ5dGVMZW5ndGg6MH19cHJvY2Vzc0J1ZmZlclZpZXdJbWFnZSh0KXtjb25zdCBlPXRoaXMsbj1lLmpzb247cmV0dXJuIG4uYnVmZmVyVmlld3N8fChuLmJ1ZmZlclZpZXdzPVtdKSxuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSl7Y29uc3Qgcj1uZXcgd2luZG93LkZpbGVSZWFkZXI7ci5yZWFkQXNBcnJheUJ1ZmZlcih0KSxyLm9ubG9hZGVuZD1mdW5jdGlvbigpe2NvbnN0IHQ9SnYoci5yZXN1bHQpLHM9e2J1ZmZlcjplLnByb2Nlc3NCdWZmZXIodCksYnl0ZU9mZnNldDplLmJ5dGVPZmZzZXQsYnl0ZUxlbmd0aDp0LmJ5dGVMZW5ndGh9O2UuYnl0ZU9mZnNldCs9dC5ieXRlTGVuZ3RoLGkobi5idWZmZXJWaWV3cy5wdXNoKHMpLTEpfX0pKX1wcm9jZXNzQWNjZXNzb3IodCxlLG4saSl7Y29uc3Qgcj10aGlzLm9wdGlvbnMscz10aGlzLmpzb247bGV0IGE7aWYodC5hcnJheS5jb25zdHJ1Y3Rvcj09PUZsb2F0MzJBcnJheSlhPUR2O2Vsc2UgaWYodC5hcnJheS5jb25zdHJ1Y3Rvcj09PVVpbnQzMkFycmF5KWE9TnY7ZWxzZSBpZih0LmFycmF5LmNvbnN0cnVjdG9yPT09VWludDE2QXJyYXkpYT1JdjtlbHNle2lmKHQuYXJyYXkuY29uc3RydWN0b3IhPT1VaW50OEFycmF5KXRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZFeHBvcnRlcjogVW5zdXBwb3J0ZWQgYnVmZmVyQXR0cmlidXRlIGNvbXBvbmVudCB0eXBlLlwiKTthPVB2fWlmKHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PWkmJihpPXQuY291bnQpLHIudHJ1bmNhdGVEcmF3UmFuZ2UmJnZvaWQgMCE9PWUmJm51bGw9PT1lLmluZGV4KXtjb25zdCByPW4raSxzPWUuZHJhd1JhbmdlLmNvdW50PT09MS8wP3QuY291bnQ6ZS5kcmF3UmFuZ2Uuc3RhcnQrZS5kcmF3UmFuZ2UuY291bnQ7bj1NYXRoLm1heChuLGUuZHJhd1JhbmdlLnN0YXJ0KSwoaT1NYXRoLm1pbihyLHMpLW4pPDAmJihpPTApfWlmKDA9PT1pKXJldHVybiBudWxsO2NvbnN0IG89ZnVuY3Rpb24odCxlLG4pe2NvbnN0IGk9e21pbjpuZXcgQXJyYXkodC5pdGVtU2l6ZSkuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpLG1heDpuZXcgQXJyYXkodC5pdGVtU2l6ZSkuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpfTtmb3IobGV0IHI9ZTtyPGUrbjtyKyspZm9yKGxldCBlPTA7ZTx0Lml0ZW1TaXplO2UrKyl7bGV0IG47dC5pdGVtU2l6ZT40P249dC5hcnJheVtyKnQuaXRlbVNpemUrZV06MD09PWU/bj10LmdldFgocik6MT09PWU/bj10LmdldFkocik6Mj09PWU/bj10LmdldFoocik6Mz09PWUmJihuPXQuZ2V0VyhyKSksaS5taW5bZV09TWF0aC5taW4oaS5taW5bZV0sbiksaS5tYXhbZV09TWF0aC5tYXgoaS5tYXhbZV0sbil9cmV0dXJuIGl9KHQsbixpKTtsZXQgbDt2b2lkIDAhPT1lJiYobD10PT09ZS5pbmRleD9PdjpGdik7Y29uc3QgYz10aGlzLnByb2Nlc3NCdWZmZXJWaWV3KHQsYSxuLGksbCksaD17YnVmZmVyVmlldzpjLmlkLGJ5dGVPZmZzZXQ6Yy5ieXRlT2Zmc2V0LGNvbXBvbmVudFR5cGU6YSxjb3VudDppLG1heDpvLm1heCxtaW46by5taW4sdHlwZTp7MTpcIlNDQUxBUlwiLDI6XCJWRUMyXCIsMzpcIlZFQzNcIiw0OlwiVkVDNFwiLDE2OlwiTUFUNFwifVt0Lml0ZW1TaXplXX07cmV0dXJuITA9PT10Lm5vcm1hbGl6ZWQmJihoLm5vcm1hbGl6ZWQ9ITApLHMuYWNjZXNzb3JzfHwocy5hY2Nlc3NvcnM9W10pLHMuYWNjZXNzb3JzLnB1c2goaCktMX1wcm9jZXNzSW1hZ2UodCxlLG4pe2NvbnN0IGk9dGhpcyxyPWkuY2FjaGUscz1pLmpzb24sYT1pLm9wdGlvbnMsbz1pLnBlbmRpbmc7ci5pbWFnZXMuaGFzKHQpfHxyLmltYWdlcy5zZXQodCx7fSk7Y29uc3QgbD1yLmltYWdlcy5nZXQodCksYz0xMDIzPT09ZT9cImltYWdlL3BuZ1wiOlwiaW1hZ2UvanBlZ1wiLGg9YytcIjpmbGlwWS9cIituLnRvU3RyaW5nKCk7aWYodm9pZCAwIT09bFtoXSlyZXR1cm4gbFtoXTtzLmltYWdlc3x8KHMuaW1hZ2VzPVtdKTtjb25zdCB1PXttaW1lVHlwZTpjfTtpZihhLmVtYmVkSW1hZ2VzKXtjb25zdCByPSR2PSR2fHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Iud2lkdGg9TWF0aC5taW4odC53aWR0aCxhLm1heFRleHR1cmVTaXplKSxyLmhlaWdodD1NYXRoLm1pbih0LmhlaWdodCxhLm1heFRleHR1cmVTaXplKTtjb25zdCBzPXIuZ2V0Q29udGV4dChcIjJkXCIpO2lmKCEwPT09biYmKHMudHJhbnNsYXRlKDAsci5oZWlnaHQpLHMuc2NhbGUoMSwtMSkpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50JiZ0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50JiZ0IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBPZmZzY3JlZW5DYW52YXMmJnQgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXN8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBJbWFnZUJpdG1hcCYmdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXMuZHJhd0ltYWdlKHQsMCwwLHIud2lkdGgsci5oZWlnaHQpO2Vsc2V7MTAyMyE9PWUmJjEwMjIhPT1lJiZjb25zb2xlLmVycm9yKFwiR0xURkV4cG9ydGVyOiBPbmx5IFJHQiBhbmQgUkdCQSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQuXCIpLCh0LndpZHRoPmEubWF4VGV4dHVyZVNpemV8fHQuaGVpZ2h0PmEubWF4VGV4dHVyZVNpemUpJiZjb25zb2xlLndhcm4oXCJHTFRGRXhwb3J0ZXI6IEltYWdlIHNpemUgaXMgYmlnZ2VyIHRoYW4gbWF4VGV4dHVyZVNpemVcIix0KTtjb25zdCBuPW5ldyBVaW50OENsYW1wZWRBcnJheSh0LmhlaWdodCp0LndpZHRoKjQpO2lmKDEwMjM9PT1lKWZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSs9NCluW2UrMF09dC5kYXRhW2UrMF0sbltlKzFdPXQuZGF0YVtlKzFdLG5bZSsyXT10LmRhdGFbZSsyXSxuW2UrM109dC5kYXRhW2UrM107ZWxzZSBmb3IobGV0IGU9MCxpPTA7ZTxuLmxlbmd0aDtlKz00LGkrPTMpbltlKzBdPXQuZGF0YVtpKzBdLG5bZSsxXT10LmRhdGFbaSsxXSxuW2UrMl09dC5kYXRhW2krMl0sbltlKzNdPTI1NTtzLnB1dEltYWdlRGF0YShuZXcgSW1hZ2VEYXRhKG4sdC53aWR0aCx0LmhlaWdodCksMCwwKX0hMD09PWEuYmluYXJ5P28ucHVzaChuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7ci50b0Jsb2IoKGZ1bmN0aW9uKGUpe2kucHJvY2Vzc0J1ZmZlclZpZXdJbWFnZShlKS50aGVuKChmdW5jdGlvbihlKXt1LmJ1ZmZlclZpZXc9ZSx0KCl9KSl9KSxjKX0pKSk6dS51cmk9ci50b0RhdGFVUkwoYyl9ZWxzZSB1LnVyaT10LnNyYztjb25zdCBkPXMuaW1hZ2VzLnB1c2godSktMTtyZXR1cm4gbFtoXT1kLGR9cHJvY2Vzc1NhbXBsZXIodCl7Y29uc3QgZT10aGlzLmpzb247ZS5zYW1wbGVyc3x8KGUuc2FtcGxlcnM9W10pO2NvbnN0IG49e21hZ0ZpbHRlcjpxdlt0Lm1hZ0ZpbHRlcl0sbWluRmlsdGVyOnF2W3QubWluRmlsdGVyXSx3cmFwUzpxdlt0LndyYXBTXSx3cmFwVDpxdlt0LndyYXBUXX07cmV0dXJuIGUuc2FtcGxlcnMucHVzaChuKS0xfXByb2Nlc3NUZXh0dXJlKHQpe2NvbnN0IGU9dGhpcy5jYWNoZSxuPXRoaXMuanNvbjtpZihlLnRleHR1cmVzLmhhcyh0KSlyZXR1cm4gZS50ZXh0dXJlcy5nZXQodCk7bi50ZXh0dXJlc3x8KG4udGV4dHVyZXM9W10pO2NvbnN0IGk9e3NhbXBsZXI6dGhpcy5wcm9jZXNzU2FtcGxlcih0KSxzb3VyY2U6dGhpcy5wcm9jZXNzSW1hZ2UodC5pbWFnZSx0LmZvcm1hdCx0LmZsaXBZKX07dC5uYW1lJiYoaS5uYW1lPXQubmFtZSksdGhpcy5faW52b2tlQWxsKChmdW5jdGlvbihlKXtlLndyaXRlVGV4dHVyZSYmZS53cml0ZVRleHR1cmUodCxpKX0pKTtjb25zdCByPW4udGV4dHVyZXMucHVzaChpKS0xO3JldHVybiBlLnRleHR1cmVzLnNldCh0LHIpLHJ9cHJvY2Vzc01hdGVyaWFsKHQpe2NvbnN0IGU9dGhpcy5jYWNoZSxuPXRoaXMuanNvbjtpZihlLm1hdGVyaWFscy5oYXModCkpcmV0dXJuIGUubWF0ZXJpYWxzLmdldCh0KTtpZih0LmlzU2hhZGVyTWF0ZXJpYWwpcmV0dXJuIGNvbnNvbGUud2FybihcIkdMVEZFeHBvcnRlcjogVEhSRUUuU2hhZGVyTWF0ZXJpYWwgbm90IHN1cHBvcnRlZC5cIiksbnVsbDtuLm1hdGVyaWFsc3x8KG4ubWF0ZXJpYWxzPVtdKTtjb25zdCBpPXtwYnJNZXRhbGxpY1JvdWdobmVzczp7fX07ITAhPT10LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwmJiEwIT09dC5pc01lc2hCYXNpY01hdGVyaWFsJiZjb25zb2xlLndhcm4oXCJHTFRGRXhwb3J0ZXI6IFVzZSBNZXNoU3RhbmRhcmRNYXRlcmlhbCBvciBNZXNoQmFzaWNNYXRlcmlhbCBmb3IgYmVzdCByZXN1bHRzLlwiKTtjb25zdCByPXQuY29sb3IudG9BcnJheSgpLmNvbmNhdChbdC5vcGFjaXR5XSk7aWYoWXYocixbMSwxLDEsMV0pfHwoaS5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I9ciksdC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsPyhpLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yPXQubWV0YWxuZXNzLGkucGJyTWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yPXQucm91Z2huZXNzKTooaS5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3Rvcj0uNSxpLnBick1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3Rvcj0uNSksdC5tZXRhbG5lc3NNYXB8fHQucm91Z2huZXNzTWFwKWlmKHQubWV0YWxuZXNzTWFwPT09dC5yb3VnaG5lc3NNYXApe2NvbnN0IGU9e2luZGV4OnRoaXMucHJvY2Vzc1RleHR1cmUodC5tZXRhbG5lc3NNYXApfTt0aGlzLmFwcGx5VGV4dHVyZVRyYW5zZm9ybShlLHQubWV0YWxuZXNzTWFwKSxpLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT1lfWVsc2UgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkV4cG9ydGVyOiBJZ25vcmluZyBtZXRhbG5lc3NNYXAgYW5kIHJvdWdobmVzc01hcCBiZWNhdXNlIHRoZXkgYXJlIG5vdCB0aGUgc2FtZSBUZXh0dXJlLlwiKTtpZih0Lm1hcCl7Y29uc3QgZT17aW5kZXg6dGhpcy5wcm9jZXNzVGV4dHVyZSh0Lm1hcCl9O3RoaXMuYXBwbHlUZXh0dXJlVHJhbnNmb3JtKGUsdC5tYXApLGkucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZT1lfWlmKHQuZW1pc3NpdmUpe2NvbnN0IGU9dC5lbWlzc2l2ZS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHQuZW1pc3NpdmVJbnRlbnNpdHkpLG49TWF0aC5tYXgoZS5yLGUuZyxlLmIpO2lmKG4+MSYmKGUubXVsdGlwbHlTY2FsYXIoMS9uKSxjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGRXhwb3J0ZXI6IFNvbWUgZW1pc3NpdmUgY29tcG9uZW50cyBleGNlZWQgMTsgZW1pc3NpdmUgaGFzIGJlZW4gbGltaXRlZFwiKSksbj4wJiYoaS5lbWlzc2l2ZUZhY3Rvcj1lLnRvQXJyYXkoKSksdC5lbWlzc2l2ZU1hcCl7Y29uc3QgZT17aW5kZXg6dGhpcy5wcm9jZXNzVGV4dHVyZSh0LmVtaXNzaXZlTWFwKX07dGhpcy5hcHBseVRleHR1cmVUcmFuc2Zvcm0oZSx0LmVtaXNzaXZlTWFwKSxpLmVtaXNzaXZlVGV4dHVyZT1lfX1pZih0Lm5vcm1hbE1hcCl7Y29uc3QgZT17aW5kZXg6dGhpcy5wcm9jZXNzVGV4dHVyZSh0Lm5vcm1hbE1hcCl9O3Qubm9ybWFsU2NhbGUmJjEhPT10Lm5vcm1hbFNjYWxlLngmJihlLnNjYWxlPXQubm9ybWFsU2NhbGUueCksdGhpcy5hcHBseVRleHR1cmVUcmFuc2Zvcm0oZSx0Lm5vcm1hbE1hcCksaS5ub3JtYWxUZXh0dXJlPWV9aWYodC5hb01hcCl7Y29uc3QgZT17aW5kZXg6dGhpcy5wcm9jZXNzVGV4dHVyZSh0LmFvTWFwKSx0ZXhDb29yZDoxfTsxIT09dC5hb01hcEludGVuc2l0eSYmKGUuc3RyZW5ndGg9dC5hb01hcEludGVuc2l0eSksdGhpcy5hcHBseVRleHR1cmVUcmFuc2Zvcm0oZSx0LmFvTWFwKSxpLm9jY2x1c2lvblRleHR1cmU9ZX10LnRyYW5zcGFyZW50P2kuYWxwaGFNb2RlPVwiQkxFTkRcIjp0LmFscGhhVGVzdD4wJiYoaS5hbHBoYU1vZGU9XCJNQVNLXCIsaS5hbHBoYUN1dG9mZj10LmFscGhhVGVzdCksMj09PXQuc2lkZSYmKGkuZG91YmxlU2lkZWQ9ITApLFwiXCIhPT10Lm5hbWUmJihpLm5hbWU9dC5uYW1lKSx0aGlzLnNlcmlhbGl6ZVVzZXJEYXRhKHQsaSksdGhpcy5faW52b2tlQWxsKChmdW5jdGlvbihlKXtlLndyaXRlTWF0ZXJpYWwmJmUud3JpdGVNYXRlcmlhbCh0LGkpfSkpO2NvbnN0IHM9bi5tYXRlcmlhbHMucHVzaChpKS0xO3JldHVybiBlLm1hdGVyaWFscy5zZXQodCxzKSxzfXByb2Nlc3NNZXNoKHQpe2NvbnN0IGU9dGhpcy5jYWNoZSxuPXRoaXMuanNvbixpPVt0Lmdlb21ldHJ5LnV1aWRdO2lmKEFycmF5LmlzQXJyYXkodC5tYXRlcmlhbCkpZm9yKGxldCBlPTAsbj10Lm1hdGVyaWFsLmxlbmd0aDtlPG47ZSsrKWkucHVzaCh0Lm1hdGVyaWFsW2VdLnV1aWQpO2Vsc2UgaS5wdXNoKHQubWF0ZXJpYWwudXVpZCk7Y29uc3Qgcj1pLmpvaW4oXCI6XCIpO2lmKGUubWVzaGVzLmhhcyhyKSlyZXR1cm4gZS5tZXNoZXMuZ2V0KHIpO2NvbnN0IHM9dC5nZW9tZXRyeTtsZXQgYTtpZihhPXQuaXNMaW5lU2VnbWVudHM/QXY6dC5pc0xpbmVMb29wP0x2OnQuaXNMaW5lP1J2OnQuaXNQb2ludHM/RXY6dC5tYXRlcmlhbC53aXJlZnJhbWU/QXY6Q3YsITAhPT1zLmlzQnVmZmVyR2VvbWV0cnkpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkV4cG9ydGVyOiBHZW9tZXRyeSBpcyBub3Qgb2YgdHlwZSBUSFJFRS5CdWZmZXJHZW9tZXRyeS5cIik7Y29uc3Qgbz17fSxsPXt9LGM9W10saD1bXSx1PXt1djpcIlRFWENPT1JEXzBcIix1djI6XCJURVhDT09SRF8xXCIsY29sb3I6XCJDT0xPUl8wXCIsc2tpbldlaWdodDpcIldFSUdIVFNfMFwiLHNraW5JbmRleDpcIkpPSU5UU18wXCJ9LGQ9cy5nZXRBdHRyaWJ1dGUoXCJub3JtYWxcIik7dm9pZCAwPT09ZHx8dGhpcy5pc05vcm1hbGl6ZWROb3JtYWxBdHRyaWJ1dGUoZCl8fChjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGRXhwb3J0ZXI6IENyZWF0aW5nIG5vcm1hbGl6ZWQgbm9ybWFsIGF0dHJpYnV0ZSBmcm9tIHRoZSBub24tbm9ybWFsaXplZCBvbmUuXCIpLHMuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsdGhpcy5jcmVhdGVOb3JtYWxpemVkTm9ybWFsQXR0cmlidXRlKGQpKSk7bGV0IHA9bnVsbDtmb3IobGV0IHQgaW4gcy5hdHRyaWJ1dGVzKXtpZihcIm1vcnBoXCI9PT10LnN1YnN0cigwLDUpKWNvbnRpbnVlO2NvbnN0IG49cy5hdHRyaWJ1dGVzW3RdO3Q9dVt0XXx8dC50b1VwcGVyQ2FzZSgpO2lmKC9eKFBPU0lUSU9OfE5PUk1BTHxUQU5HRU5UfFRFWENPT1JEX1xcZCt8Q09MT1JfXFxkK3xKT0lOVFNfXFxkK3xXRUlHSFRTX1xcZCspJC8udGVzdCh0KXx8KHQ9XCJfXCIrdCksZS5hdHRyaWJ1dGVzLmhhcyh0aGlzLmdldFVJRChuKSkpe2xbdF09ZS5hdHRyaWJ1dGVzLmdldCh0aGlzLmdldFVJRChuKSk7Y29udGludWV9cD1udWxsO2NvbnN0IGk9bi5hcnJheTtcIkpPSU5UU18wXCIhPT10fHxpIGluc3RhbmNlb2YgVWludDE2QXJyYXl8fGkgaW5zdGFuY2VvZiBVaW50OEFycmF5fHwoY29uc29sZS53YXJuKCdHTFRGRXhwb3J0ZXI6IEF0dHJpYnV0ZSBcInNraW5JbmRleFwiIGNvbnZlcnRlZCB0byB0eXBlIFVOU0lHTkVEX1NIT1JULicpLHA9bmV3IHBuKG5ldyBVaW50MTZBcnJheShpKSxuLml0ZW1TaXplLG4ubm9ybWFsaXplZCkpO2NvbnN0IHI9dGhpcy5wcm9jZXNzQWNjZXNzb3IocHx8bixzKTtudWxsIT09ciYmKGxbdF09cixlLmF0dHJpYnV0ZXMuc2V0KHRoaXMuZ2V0VUlEKG4pLHIpKX1pZih2b2lkIDAhPT1kJiZzLnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLGQpLDA9PT1PYmplY3Qua2V5cyhsKS5sZW5ndGgpcmV0dXJuIG51bGw7aWYodm9pZCAwIT09dC5tb3JwaFRhcmdldEluZmx1ZW5jZXMmJnQubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aD4wKXtjb25zdCBuPVtdLGk9W10scj17fTtpZih2b2lkIDAhPT10Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeSlmb3IoY29uc3QgZSBpbiB0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeSlyW3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5W2VdXT1lO2ZvcihsZXQgYT0wO2E8dC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoOysrYSl7Y29uc3Qgbz17fTtsZXQgbD0hMTtmb3IoY29uc3QgdCBpbiBzLm1vcnBoQXR0cmlidXRlcyl7aWYoXCJwb3NpdGlvblwiIT09dCYmXCJub3JtYWxcIiE9PXQpe2x8fChjb25zb2xlLndhcm4oXCJHTFRGRXhwb3J0ZXI6IE9ubHkgUE9TSVRJT04gYW5kIE5PUk1BTCBtb3JwaCBhcmUgc3VwcG9ydGVkLlwiKSxsPSEwKTtjb250aW51ZX1jb25zdCBuPXMubW9ycGhBdHRyaWJ1dGVzW3RdW2FdLGk9dC50b1VwcGVyQ2FzZSgpLHI9cy5hdHRyaWJ1dGVzW3RdO2lmKGUuYXR0cmlidXRlcy5oYXModGhpcy5nZXRVSUQobikpKXtvW2ldPWUuYXR0cmlidXRlcy5nZXQodGhpcy5nZXRVSUQobikpO2NvbnRpbnVlfWNvbnN0IGM9bi5jbG9uZSgpO2lmKCFzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKWZvcihsZXQgdD0wLGU9bi5jb3VudDt0PGU7dCsrKWMuc2V0WFlaKHQsbi5nZXRYKHQpLXIuZ2V0WCh0KSxuLmdldFkodCktci5nZXRZKHQpLG4uZ2V0Wih0KS1yLmdldFoodCkpO29baV09dGhpcy5wcm9jZXNzQWNjZXNzb3IoYyxzKSxlLmF0dHJpYnV0ZXMuc2V0KHRoaXMuZ2V0VUlEKHIpLG9baV0pfWgucHVzaChvKSxuLnB1c2godC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbYV0pLHZvaWQgMCE9PXQubW9ycGhUYXJnZXREaWN0aW9uYXJ5JiZpLnB1c2goclthXSl9by53ZWlnaHRzPW4saS5sZW5ndGg+MCYmKG8uZXh0cmFzPXt9LG8uZXh0cmFzLnRhcmdldE5hbWVzPWkpfWNvbnN0IG09QXJyYXkuaXNBcnJheSh0Lm1hdGVyaWFsKTtpZihtJiYwPT09cy5ncm91cHMubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IGY9bT90Lm1hdGVyaWFsOlt0Lm1hdGVyaWFsXSxnPW0/cy5ncm91cHM6W3ttYXRlcmlhbEluZGV4OjAsc3RhcnQ6dm9pZCAwLGNvdW50OnZvaWQgMH1dO2ZvcihsZXQgdD0wLG49Zy5sZW5ndGg7dDxuO3QrKyl7Y29uc3Qgbj17bW9kZTphLGF0dHJpYnV0ZXM6bH07aWYodGhpcy5zZXJpYWxpemVVc2VyRGF0YShzLG4pLGgubGVuZ3RoPjAmJihuLnRhcmdldHM9aCksbnVsbCE9PXMuaW5kZXgpe2xldCBpPXRoaXMuZ2V0VUlEKHMuaW5kZXgpO3ZvaWQgMD09PWdbdF0uc3RhcnQmJnZvaWQgMD09PWdbdF0uY291bnR8fChpKz1cIjpcIitnW3RdLnN0YXJ0K1wiOlwiK2dbdF0uY291bnQpLGUuYXR0cmlidXRlcy5oYXMoaSk/bi5pbmRpY2VzPWUuYXR0cmlidXRlcy5nZXQoaSk6KG4uaW5kaWNlcz10aGlzLnByb2Nlc3NBY2Nlc3NvcihzLmluZGV4LHMsZ1t0XS5zdGFydCxnW3RdLmNvdW50KSxlLmF0dHJpYnV0ZXMuc2V0KGksbi5pbmRpY2VzKSksbnVsbD09PW4uaW5kaWNlcyYmZGVsZXRlIG4uaW5kaWNlc31jb25zdCBpPXRoaXMucHJvY2Vzc01hdGVyaWFsKGZbZ1t0XS5tYXRlcmlhbEluZGV4XSk7bnVsbCE9PWkmJihuLm1hdGVyaWFsPWkpLGMucHVzaChuKX1vLnByaW1pdGl2ZXM9YyxuLm1lc2hlc3x8KG4ubWVzaGVzPVtdKSx0aGlzLl9pbnZva2VBbGwoKGZ1bmN0aW9uKGUpe2Uud3JpdGVNZXNoJiZlLndyaXRlTWVzaCh0LG8pfSkpO2NvbnN0IHY9bi5tZXNoZXMucHVzaChvKS0xO3JldHVybiBlLm1lc2hlcy5zZXQocix2KSx2fXByb2Nlc3NDYW1lcmEodCl7Y29uc3QgZT10aGlzLmpzb247ZS5jYW1lcmFzfHwoZS5jYW1lcmFzPVtdKTtjb25zdCBuPXQuaXNPcnRob2dyYXBoaWNDYW1lcmEsaT17dHlwZTpuP1wib3J0aG9ncmFwaGljXCI6XCJwZXJzcGVjdGl2ZVwifTtyZXR1cm4gbj9pLm9ydGhvZ3JhcGhpYz17eG1hZzoyKnQucmlnaHQseW1hZzoyKnQudG9wLHpmYXI6dC5mYXI8PTA/LjAwMTp0LmZhcix6bmVhcjp0Lm5lYXI8MD8wOnQubmVhcn06aS5wZXJzcGVjdGl2ZT17YXNwZWN0UmF0aW86dC5hc3BlY3QseWZvdjpFdC5kZWdUb1JhZCh0LmZvdiksemZhcjp0LmZhcjw9MD8uMDAxOnQuZmFyLHpuZWFyOnQubmVhcjwwPzA6dC5uZWFyfSxcIlwiIT09dC5uYW1lJiYoaS5uYW1lPXQudHlwZSksZS5jYW1lcmFzLnB1c2goaSktMX1wcm9jZXNzQW5pbWF0aW9uKHQsZSl7Y29uc3Qgbj10aGlzLmpzb24saT10aGlzLm5vZGVNYXA7bi5hbmltYXRpb25zfHwobi5hbmltYXRpb25zPVtdKTtjb25zdCByPSh0PVR2LlV0aWxzLm1lcmdlTW9ycGhUYXJnZXRUcmFja3ModC5jbG9uZSgpLGUpKS50cmFja3Mscz1bXSxhPVtdO2ZvcihsZXQgdD0wO3Q8ci5sZW5ndGg7Kyt0KXtjb25zdCBuPXJbdF0sbz0kbC5wYXJzZVRyYWNrTmFtZShuLm5hbWUpO2xldCBsPSRsLmZpbmROb2RlKGUsby5ub2RlTmFtZSk7Y29uc3QgYz1YdltvLnByb3BlcnR5TmFtZV07aWYoXCJib25lc1wiPT09by5vYmplY3ROYW1lJiYobD0hMD09PWwuaXNTa2lubmVkTWVzaD9sLnNrZWxldG9uLmdldEJvbmVCeU5hbWUoby5vYmplY3RJbmRleCk6dm9pZCAwKSwhbHx8IWMpcmV0dXJuIGNvbnNvbGUud2FybignVEhSRUUuR0xURkV4cG9ydGVyOiBDb3VsZCBub3QgZXhwb3J0IGFuaW1hdGlvbiB0cmFjayBcIiVzXCIuJyxuLm5hbWUpLG51bGw7Y29uc3QgaD0xO2xldCB1LGQ9bi52YWx1ZXMubGVuZ3RoL24udGltZXMubGVuZ3RoO2M9PT1Ydi5tb3JwaFRhcmdldEluZmx1ZW5jZXMmJihkLz1sLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGgpLCEwPT09bi5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZT8odT1cIkNVQklDU1BMSU5FXCIsZC89Myk6dT0yMzAwPT09bi5nZXRJbnRlcnBvbGF0aW9uKCk/XCJTVEVQXCI6XCJMSU5FQVJcIixhLnB1c2goe2lucHV0OnRoaXMucHJvY2Vzc0FjY2Vzc29yKG5ldyBwbihuLnRpbWVzLGgpKSxvdXRwdXQ6dGhpcy5wcm9jZXNzQWNjZXNzb3IobmV3IHBuKG4udmFsdWVzLGQpKSxpbnRlcnBvbGF0aW9uOnV9KSxzLnB1c2goe3NhbXBsZXI6YS5sZW5ndGgtMSx0YXJnZXQ6e25vZGU6aS5nZXQobCkscGF0aDpjfX0pfXJldHVybiBuLmFuaW1hdGlvbnMucHVzaCh7bmFtZTp0Lm5hbWV8fFwiY2xpcF9cIituLmFuaW1hdGlvbnMubGVuZ3RoLHNhbXBsZXJzOmEsY2hhbm5lbHM6c30pLG4uYW5pbWF0aW9ucy5sZW5ndGgtMX1wcm9jZXNzU2tpbih0KXtjb25zdCBlPXRoaXMuanNvbixuPXRoaXMubm9kZU1hcCxpPWUubm9kZXNbbi5nZXQodCldLHI9dC5za2VsZXRvbjtpZih2b2lkIDA9PT1yKXJldHVybiBudWxsO2NvbnN0IHM9dC5za2VsZXRvbi5ib25lc1swXTtpZih2b2lkIDA9PT1zKXJldHVybiBudWxsO2NvbnN0IGE9W10sbz1uZXcgRmxvYXQzMkFycmF5KDE2KnIuYm9uZXMubGVuZ3RoKSxsPW5ldyB2ZTtmb3IobGV0IGU9MDtlPHIuYm9uZXMubGVuZ3RoOysrZSlhLnB1c2gobi5nZXQoci5ib25lc1tlXSkpLGwuY29weShyLmJvbmVJbnZlcnNlc1tlXSksbC5tdWx0aXBseSh0LmJpbmRNYXRyaXgpLnRvQXJyYXkobywxNiplKTt2b2lkIDA9PT1lLnNraW5zJiYoZS5za2lucz1bXSksZS5za2lucy5wdXNoKHtpbnZlcnNlQmluZE1hdHJpY2VzOnRoaXMucHJvY2Vzc0FjY2Vzc29yKG5ldyBwbihvLDE2KSksam9pbnRzOmEsc2tlbGV0b246bi5nZXQocyl9KTtyZXR1cm4gaS5za2luPWUuc2tpbnMubGVuZ3RoLTF9cHJvY2Vzc05vZGUodCl7Y29uc3QgZT10aGlzLmpzb24sbj10aGlzLm9wdGlvbnMsaT10aGlzLm5vZGVNYXA7ZS5ub2Rlc3x8KGUubm9kZXM9W10pO2NvbnN0IHI9e307aWYobi50cnMpe2NvbnN0IGU9dC5xdWF0ZXJuaW9uLnRvQXJyYXkoKSxuPXQucG9zaXRpb24udG9BcnJheSgpLGk9dC5zY2FsZS50b0FycmF5KCk7WXYoZSxbMCwwLDAsMV0pfHwoci5yb3RhdGlvbj1lKSxZdihuLFswLDAsMF0pfHwoci50cmFuc2xhdGlvbj1uKSxZdihpLFsxLDEsMV0pfHwoci5zY2FsZT1pKX1lbHNlIHQubWF0cml4QXV0b1VwZGF0ZSYmdC51cGRhdGVNYXRyaXgoKSwhMT09PVl2KHQubWF0cml4LmVsZW1lbnRzLFsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSkmJihyLm1hdHJpeD10Lm1hdHJpeC5lbGVtZW50cyk7aWYoXCJcIiE9PXQubmFtZSYmKHIubmFtZT1TdHJpbmcodC5uYW1lKSksdGhpcy5zZXJpYWxpemVVc2VyRGF0YSh0LHIpLHQuaXNNZXNofHx0LmlzTGluZXx8dC5pc1BvaW50cyl7Y29uc3QgZT10aGlzLnByb2Nlc3NNZXNoKHQpO251bGwhPT1lJiYoci5tZXNoPWUpfWVsc2UgdC5pc0NhbWVyYSYmKHIuY2FtZXJhPXRoaXMucHJvY2Vzc0NhbWVyYSh0KSk7aWYodC5pc1NraW5uZWRNZXNoJiZ0aGlzLnNraW5zLnB1c2godCksdC5jaGlsZHJlbi5sZW5ndGg+MCl7Y29uc3QgZT1bXTtmb3IobGV0IGk9MCxyPXQuY2hpbGRyZW4ubGVuZ3RoO2k8cjtpKyspe2NvbnN0IHI9dC5jaGlsZHJlbltpXTtpZihyLnZpc2libGV8fCExPT09bi5vbmx5VmlzaWJsZSl7Y29uc3QgdD10aGlzLnByb2Nlc3NOb2RlKHIpO251bGwhPT10JiZlLnB1c2godCl9fWUubGVuZ3RoPjAmJihyLmNoaWxkcmVuPWUpfXRoaXMuX2ludm9rZUFsbCgoZnVuY3Rpb24oZSl7ZS53cml0ZU5vZGUmJmUud3JpdGVOb2RlKHQscil9KSk7Y29uc3Qgcz1lLm5vZGVzLnB1c2gociktMTtyZXR1cm4gaS5zZXQodCxzKSxzfXByb2Nlc3NTY2VuZSh0KXtjb25zdCBlPXRoaXMuanNvbixuPXRoaXMub3B0aW9ucztlLnNjZW5lc3x8KGUuc2NlbmVzPVtdLGUuc2NlbmU9MCk7Y29uc3QgaT17fTtcIlwiIT09dC5uYW1lJiYoaS5uYW1lPXQubmFtZSksZS5zY2VuZXMucHVzaChpKTtjb25zdCByPVtdO2ZvcihsZXQgZT0wLGk9dC5jaGlsZHJlbi5sZW5ndGg7ZTxpO2UrKyl7Y29uc3QgaT10LmNoaWxkcmVuW2VdO2lmKGkudmlzaWJsZXx8ITE9PT1uLm9ubHlWaXNpYmxlKXtjb25zdCB0PXRoaXMucHJvY2Vzc05vZGUoaSk7bnVsbCE9PXQmJnIucHVzaCh0KX19ci5sZW5ndGg+MCYmKGkubm9kZXM9ciksdGhpcy5zZXJpYWxpemVVc2VyRGF0YSh0LGkpfXByb2Nlc3NPYmplY3RzKHQpe2NvbnN0IGU9bmV3IFlzO2UubmFtZT1cIkF1eFNjZW5lXCI7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5jaGlsZHJlbi5wdXNoKHRbbl0pO3RoaXMucHJvY2Vzc1NjZW5lKGUpfXByb2Nlc3NJbnB1dCh0KXtjb25zdCBlPXRoaXMub3B0aW9uczt0PXQgaW5zdGFuY2VvZiBBcnJheT90Olt0XSx0aGlzLl9pbnZva2VBbGwoKGZ1bmN0aW9uKGUpe2UuYmVmb3JlUGFyc2UmJmUuYmVmb3JlUGFyc2UodCl9KSk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdaW5zdGFuY2VvZiBZcz90aGlzLnByb2Nlc3NTY2VuZSh0W2VdKTpuLnB1c2godFtlXSk7bi5sZW5ndGg+MCYmdGhpcy5wcm9jZXNzT2JqZWN0cyhuKTtmb3IobGV0IHQ9MDt0PHRoaXMuc2tpbnMubGVuZ3RoOysrdCl0aGlzLnByb2Nlc3NTa2luKHRoaXMuc2tpbnNbdF0pO2ZvcihsZXQgbj0wO248ZS5hbmltYXRpb25zLmxlbmd0aDsrK24pdGhpcy5wcm9jZXNzQW5pbWF0aW9uKGUuYW5pbWF0aW9uc1tuXSx0WzBdKTt0aGlzLl9pbnZva2VBbGwoKGZ1bmN0aW9uKGUpe2UuYWZ0ZXJQYXJzZSYmZS5hZnRlclBhcnNlKHQpfSkpfV9pbnZva2VBbGwodCl7Zm9yKGxldCBlPTAsbj10aGlzLnBsdWdpbnMubGVuZ3RoO2U8bjtlKyspdCh0aGlzLnBsdWdpbnNbZV0pfX1jbGFzcyBRdntjb25zdHJ1Y3Rvcih0KXt0aGlzLndyaXRlcj10LHRoaXMubmFtZT1cIktIUl9saWdodHNfcHVuY3R1YWxcIn13cml0ZU5vZGUodCxlKXtpZighdC5pc0xpZ2h0KXJldHVybjtpZighdC5pc0RpcmVjdGlvbmFsTGlnaHQmJiF0LmlzUG9pbnRMaWdodCYmIXQuaXNTcG90TGlnaHQpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkV4cG9ydGVyOiBPbmx5IGRpcmVjdGlvbmFsLCBwb2ludCwgYW5kIHNwb3QgbGlnaHRzIGFyZSBzdXBwb3J0ZWQuXCIsdCk7Y29uc3Qgbj10aGlzLndyaXRlcixpPW4uanNvbixyPW4uZXh0ZW5zaW9uc1VzZWQscz17fTt0Lm5hbWUmJihzLm5hbWU9dC5uYW1lKSxzLmNvbG9yPXQuY29sb3IudG9BcnJheSgpLHMuaW50ZW5zaXR5PXQuaW50ZW5zaXR5LHQuaXNEaXJlY3Rpb25hbExpZ2h0P3MudHlwZT1cImRpcmVjdGlvbmFsXCI6dC5pc1BvaW50TGlnaHQ/KHMudHlwZT1cInBvaW50XCIsdC5kaXN0YW5jZT4wJiYocy5yYW5nZT10LmRpc3RhbmNlKSk6dC5pc1Nwb3RMaWdodCYmKHMudHlwZT1cInNwb3RcIix0LmRpc3RhbmNlPjAmJihzLnJhbmdlPXQuZGlzdGFuY2UpLHMuc3BvdD17fSxzLnNwb3QuaW5uZXJDb25lQW5nbGU9KHQucGVudW1icmEtMSkqdC5hbmdsZSotMSxzLnNwb3Qub3V0ZXJDb25lQW5nbGU9dC5hbmdsZSksdm9pZCAwIT09dC5kZWNheSYmMiE9PXQuZGVjYXkmJmNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZFeHBvcnRlcjogTGlnaHQgZGVjYXkgbWF5IGJlIGxvc3QuIGdsVEYgaXMgcGh5c2ljYWxseS1iYXNlZCwgYW5kIGV4cGVjdHMgbGlnaHQuZGVjYXk9Mi5cIiksIXQudGFyZ2V0fHx0LnRhcmdldC5wYXJlbnQ9PT10JiYwPT09dC50YXJnZXQucG9zaXRpb24ueCYmMD09PXQudGFyZ2V0LnBvc2l0aW9uLnkmJi0xPT09dC50YXJnZXQucG9zaXRpb24uenx8Y29uc29sZS53YXJuKFwiVEhSRUUuR0xURkV4cG9ydGVyOiBMaWdodCBkaXJlY3Rpb24gbWF5IGJlIGxvc3QuIEZvciBiZXN0IHJlc3VsdHMsIG1ha2UgbGlnaHQudGFyZ2V0IGEgY2hpbGQgb2YgdGhlIGxpZ2h0IHdpdGggcG9zaXRpb24gMCwwLC0xLlwiKSxyW3RoaXMubmFtZV18fChpLmV4dGVuc2lvbnM9aS5leHRlbnNpb25zfHx7fSxpLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT17bGlnaHRzOltdfSxyW3RoaXMubmFtZV09ITApO2NvbnN0IGE9aS5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHRzO2EucHVzaChzKSxlLmV4dGVuc2lvbnM9ZS5leHRlbnNpb25zfHx7fSxlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT17bGlnaHQ6YS5sZW5ndGgtMX19fWNsYXNzIHR5e2NvbnN0cnVjdG9yKHQpe3RoaXMud3JpdGVyPXQsdGhpcy5uYW1lPVwiS0hSX21hdGVyaWFsc191bmxpdFwifXdyaXRlTWF0ZXJpYWwodCxlKXtpZighdC5pc01lc2hCYXNpY01hdGVyaWFsKXJldHVybjtjb25zdCBuPXRoaXMud3JpdGVyLmV4dGVuc2lvbnNVc2VkO2UuZXh0ZW5zaW9ucz1lLmV4dGVuc2lvbnN8fHt9LGUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdPXt9LG5bdGhpcy5uYW1lXT0hMCxlLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yPTAsZS5wYnJNZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3I9Ljl9fWNsYXNzIGV5e2NvbnN0cnVjdG9yKHQpe3RoaXMud3JpdGVyPXQsdGhpcy5uYW1lPVwiS0hSX21hdGVyaWFsc19wYnJTcGVjdWxhckdsb3NzaW5lc3NcIn13cml0ZU1hdGVyaWFsKHQsZSl7aWYoIXQuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwpcmV0dXJuO2NvbnN0IG49dGhpcy53cml0ZXIsaT1uLmV4dGVuc2lvbnNVc2VkLHI9e307ZS5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3ImJihyLmRpZmZ1c2VGYWN0b3I9ZS5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IpO2NvbnN0IHM9WzEsMSwxXTtpZih0LnNwZWN1bGFyLnRvQXJyYXkocywwKSxyLnNwZWN1bGFyRmFjdG9yPXMsci5nbG9zc2luZXNzRmFjdG9yPXQuZ2xvc3NpbmVzcyxlLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUmJihyLmRpZmZ1c2VUZXh0dXJlPWUucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSksdC5zcGVjdWxhck1hcCl7Y29uc3QgZT17aW5kZXg6bi5wcm9jZXNzVGV4dHVyZSh0LnNwZWN1bGFyTWFwKX07bi5hcHBseVRleHR1cmVUcmFuc2Zvcm0oZSx0LnNwZWN1bGFyTWFwKSxyLnNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmU9ZX1lLmV4dGVuc2lvbnM9ZS5leHRlbnNpb25zfHx7fSxlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT1yLGlbdGhpcy5uYW1lXT0hMH19Y2xhc3Mgbnl7Y29uc3RydWN0b3IodCl7dGhpcy53cml0ZXI9dCx0aGlzLm5hbWU9XCJLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblwifXdyaXRlTWF0ZXJpYWwodCxlKXtpZighdC5pc01lc2hQaHlzaWNhbE1hdGVyaWFsfHwwPT09dC50cmFuc21pc3Npb24pcmV0dXJuO2NvbnN0IG49dGhpcy53cml0ZXIsaT1uLmV4dGVuc2lvbnNVc2VkLHI9e307aWYoci50cmFuc21pc3Npb25GYWN0b3I9dC50cmFuc21pc3Npb24sdC50cmFuc21pc3Npb25NYXApe2NvbnN0IGU9e2luZGV4Om4ucHJvY2Vzc1RleHR1cmUodC50cmFuc21pc3Npb25NYXApfTtuLmFwcGx5VGV4dHVyZVRyYW5zZm9ybShlLHQudHJhbnNtaXNzaW9uTWFwKSxyLnRyYW5zbWlzc2lvblRleHR1cmU9ZX1lLmV4dGVuc2lvbnM9ZS5leHRlbnNpb25zfHx7fSxlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXT1yLGlbdGhpcy5uYW1lXT0hMH19Y2xhc3MgaXl7Y29uc3RydWN0b3IodCl7dGhpcy53cml0ZXI9dCx0aGlzLm5hbWU9XCJLSFJfbWF0ZXJpYWxzX3ZvbHVtZVwifXdyaXRlTWF0ZXJpYWwodCxlKXtpZighdC5pc01lc2hQaHlzaWNhbE1hdGVyaWFsfHwwPT09dC50aGlja25lc3MpcmV0dXJuO2NvbnN0IG49dGhpcy53cml0ZXIsaT1uLmV4dGVuc2lvbnNVc2VkLHI9e307aWYoci50aGlja25lc3NGYWN0b3I9dC50aGlja25lc3MsdC50aGlja25lc3NNYXApe2NvbnN0IGU9e2luZGV4Om4ucHJvY2Vzc1RleHR1cmUodC50aGlja25lc3NNYXApfTtuLmFwcGx5VGV4dHVyZVRyYW5zZm9ybShlLHQudGhpY2tuZXNzTWFwKSxyLnRoaWNrbmVzc1RleHR1cmU9ZX1yLmF0dGVudWF0aW9uRGlzdGFuY2U9dC5hdHRlbnVhdGlvbkRpc3RhbmNlLHIuYXR0ZW51YXRpb25Db2xvcj10LmF0dGVudWF0aW9uVGludC50b0FycmF5KCksZS5leHRlbnNpb25zPWUuZXh0ZW5zaW9uc3x8e30sZS5leHRlbnNpb25zW3RoaXMubmFtZV09cixpW3RoaXMubmFtZV09ITB9fVR2LlV0aWxzPXtpbnNlcnRLZXlmcmFtZTpmdW5jdGlvbih0LGUpe2NvbnN0IG49LjAwMSxpPXQuZ2V0VmFsdWVTaXplKCkscj1uZXcgdC5UaW1lQnVmZmVyVHlwZSh0LnRpbWVzLmxlbmd0aCsxKSxzPW5ldyB0LlZhbHVlQnVmZmVyVHlwZSh0LnZhbHVlcy5sZW5ndGgraSksYT10LmNyZWF0ZUludGVycG9sYW50KG5ldyB0LlZhbHVlQnVmZmVyVHlwZShpKSk7bGV0IG87aWYoMD09PXQudGltZXMubGVuZ3RoKXtyWzBdPWU7Zm9yKGxldCB0PTA7dDxpO3QrKylzW3RdPTA7bz0wfWVsc2UgaWYoZTx0LnRpbWVzWzBdKXtpZihNYXRoLmFicyh0LnRpbWVzWzBdLWUpPG4pcmV0dXJuIDA7clswXT1lLHIuc2V0KHQudGltZXMsMSkscy5zZXQoYS5ldmFsdWF0ZShlKSwwKSxzLnNldCh0LnZhbHVlcyxpKSxvPTB9ZWxzZSBpZihlPnQudGltZXNbdC50aW1lcy5sZW5ndGgtMV0pe2lmKE1hdGguYWJzKHQudGltZXNbdC50aW1lcy5sZW5ndGgtMV0tZSk8bilyZXR1cm4gdC50aW1lcy5sZW5ndGgtMTtyW3IubGVuZ3RoLTFdPWUsci5zZXQodC50aW1lcywwKSxzLnNldCh0LnZhbHVlcywwKSxzLnNldChhLmV2YWx1YXRlKGUpLHQudmFsdWVzLmxlbmd0aCksbz1yLmxlbmd0aC0xfWVsc2UgZm9yKGxldCBsPTA7bDx0LnRpbWVzLmxlbmd0aDtsKyspe2lmKE1hdGguYWJzKHQudGltZXNbbF0tZSk8bilyZXR1cm4gbDtpZih0LnRpbWVzW2xdPGUmJnQudGltZXNbbCsxXT5lKXtyLnNldCh0LnRpbWVzLnNsaWNlKDAsbCsxKSwwKSxyW2wrMV09ZSxyLnNldCh0LnRpbWVzLnNsaWNlKGwrMSksbCsyKSxzLnNldCh0LnZhbHVlcy5zbGljZSgwLChsKzEpKmkpLDApLHMuc2V0KGEuZXZhbHVhdGUoZSksKGwrMSkqaSkscy5zZXQodC52YWx1ZXMuc2xpY2UoKGwrMSkqaSksKGwrMikqaSksbz1sKzE7YnJlYWt9fXJldHVybiB0LnRpbWVzPXIsdC52YWx1ZXM9cyxvfSxtZXJnZU1vcnBoVGFyZ2V0VHJhY2tzOmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1bXSxpPXt9LHI9dC50cmFja3M7Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDsrK3Qpe2xldCBzPXJbdF07Y29uc3QgYT0kbC5wYXJzZVRyYWNrTmFtZShzLm5hbWUpLG89JGwuZmluZE5vZGUoZSxhLm5vZGVOYW1lKTtpZihcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiIT09YS5wcm9wZXJ0eU5hbWV8fHZvaWQgMD09PWEucHJvcGVydHlJbmRleCl7bi5wdXNoKHMpO2NvbnRpbnVlfWlmKHMuY3JlYXRlSW50ZXJwb2xhbnQhPT1zLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlJiZzLmNyZWF0ZUludGVycG9sYW50IT09cy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIpe2lmKHMuY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkV4cG9ydGVyOiBDYW5ub3QgbWVyZ2UgdHJhY2tzIHdpdGggZ2xURiBDVUJJQ1NQTElORSBpbnRlcnBvbGF0aW9uLlwiKTtjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGRXhwb3J0ZXI6IE1vcnBoIHRhcmdldCBpbnRlcnBvbGF0aW9uIG1vZGUgbm90IHlldCBzdXBwb3J0ZWQuIFVzaW5nIExJTkVBUiBpbnN0ZWFkLlwiKSxzPXMuY2xvbmUoKSxzLnNldEludGVycG9sYXRpb24oMjMwMSl9Y29uc3QgbD1vLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGgsYz1vLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVthLnByb3BlcnR5SW5kZXhdO2lmKHZvaWQgMD09PWMpdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkV4cG9ydGVyOiBNb3JwaCB0YXJnZXQgbmFtZSBub3QgZm91bmQ6IFwiK2EucHJvcGVydHlJbmRleCk7bGV0IGg7aWYodm9pZCAwPT09aVtvLnV1aWRdKXtoPXMuY2xvbmUoKTtjb25zdCB0PW5ldyBoLlZhbHVlQnVmZmVyVHlwZShsKmgudGltZXMubGVuZ3RoKTtmb3IobGV0IGU9MDtlPGgudGltZXMubGVuZ3RoO2UrKyl0W2UqbCtjXT1oLnZhbHVlc1tlXTtoLm5hbWU9KGEubm9kZU5hbWV8fFwiXCIpK1wiLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiLGgudmFsdWVzPXQsaVtvLnV1aWRdPWgsbi5wdXNoKGgpO2NvbnRpbnVlfWNvbnN0IHU9cy5jcmVhdGVJbnRlcnBvbGFudChuZXcgcy5WYWx1ZUJ1ZmZlclR5cGUoMSkpO2g9aVtvLnV1aWRdO2ZvcihsZXQgdD0wO3Q8aC50aW1lcy5sZW5ndGg7dCsrKWgudmFsdWVzW3QqbCtjXT11LmV2YWx1YXRlKGgudGltZXNbdF0pO2ZvcihsZXQgdD0wO3Q8cy50aW1lcy5sZW5ndGg7dCsrKXtjb25zdCBlPXRoaXMuaW5zZXJ0S2V5ZnJhbWUoaCxzLnRpbWVzW3RdKTtoLnZhbHVlc1tlKmwrY109cy52YWx1ZXNbdF19fXJldHVybiB0LnRyYWNrcz1uLHR9fTtcbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHJ5PXQ9PnZvaWQgMCE9PXQubWF0ZXJpYWwmJnQudXNlckRhdGEmJnQudXNlckRhdGEudmFyaWFudE1hdGVyaWFscyYmISFBcnJheS5mcm9tKHQudXNlckRhdGEudmFyaWFudE1hdGVyaWFscy52YWx1ZXMoKSkuZmlsdGVyKCh0PT5zeSh0Lm1hdGVyaWFsKSkpLHN5PXQ9PnQmJnQuaXNNYXRlcmlhbCYmIUFycmF5LmlzQXJyYXkodCk7Y2xhc3MgYXl7Y29uc3RydWN0b3IodCl7dGhpcy53cml0ZXI9dCx0aGlzLm5hbWU9XCJLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzXCIsdGhpcy52YXJpYW50TmFtZXM9W119YmVmb3JlUGFyc2UodCl7Y29uc3QgZT1uZXcgU2V0O2Zvcihjb25zdCBuIG9mIHQpbi50cmF2ZXJzZSgodD0+e2lmKCFyeSh0KSlyZXR1cm47Y29uc3Qgbj10LnVzZXJEYXRhLnZhcmlhbnRNYXRlcmlhbHM7Zm9yKGNvbnN0IHQgb2Ygbi5rZXlzKCkpe2NvbnN0IGk9bi5nZXQodCk7c3koaS5tYXRlcmlhbCkmJmUuYWRkKHQpfX0pKTtlLmZvckVhY2goKHQ9PnRoaXMudmFyaWFudE5hbWVzLnB1c2godCkpKX13cml0ZU1lc2godCxlKXtpZighcnkodCkpcmV0dXJuO2NvbnN0IG49dC51c2VyRGF0YSxpPW4udmFyaWFudE1hdGVyaWFscyxyPW5ldyBNYXA7Zm9yKGNvbnN0IHQgb2YgaS5rZXlzKCkpe2NvbnN0IGU9aS5nZXQodCkubWF0ZXJpYWw7aWYoIXN5KGUpKWNvbnRpbnVlO2NvbnN0IG49dGhpcy52YXJpYW50TmFtZXMuaW5kZXhPZih0KSxzPXRoaXMud3JpdGVyLnByb2Nlc3NNYXRlcmlhbChlKTtyLmhhcyhzKXx8ci5zZXQocyx7bWF0ZXJpYWw6cyx2YXJpYW50czpbXX0pLHIuZ2V0KHMpLnZhcmlhbnRzLnB1c2gobil9Y29uc3Qgcz1BcnJheS5mcm9tKHIudmFsdWVzKCkpLm1hcCgodD0+dC52YXJpYW50cy5zb3J0KCgodCxlKT0+dC1lKSkmJnQpKS5zb3J0KCgodCxlKT0+dC5tYXRlcmlhbC1lLm1hdGVyaWFsKSk7aWYoMD09PXMubGVuZ3RoKXJldHVybjtjb25zdCBhPXN5KG4ub3JpZ2luYWxNYXRlcmlhbCk/dGhpcy53cml0ZXIucHJvY2Vzc01hdGVyaWFsKG4ub3JpZ2luYWxNYXRlcmlhbCk6LTE7Zm9yKGNvbnN0IHQgb2YgZS5wcmltaXRpdmVzKWE+PTAmJih0Lm1hdGVyaWFsPWEpLHQuZXh0ZW5zaW9ucz10LmV4dGVuc2lvbnN8fHt9LHQuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdPXttYXBwaW5nczpzfX1hZnRlclBhcnNlKCl7aWYoMD09PXRoaXMudmFyaWFudE5hbWVzLmxlbmd0aClyZXR1cm47Y29uc3QgdD10aGlzLndyaXRlci5qc29uO3QuZXh0ZW5zaW9ucz10LmV4dGVuc2lvbnN8fHt9O2NvbnN0IGU9dGhpcy52YXJpYW50TmFtZXMubWFwKCh0PT4oe25hbWU6dH0pKSk7dC5leHRlbnNpb25zW3RoaXMubmFtZV09e3ZhcmlhbnRzOmV9LHRoaXMud3JpdGVyLmV4dGVuc2lvbnNVc2VkW3RoaXMubmFtZV09ITB9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL2NvbnN0IG95PVN5bWJvbChcImNvcnJlbGF0ZWRPYmplY3RzXCIpLGx5PVN5bWJvbChcInNvdXJjZU9iamVjdFwiKSxjeT1TeW1ib2woXCJvblVwZGF0ZVwiKTtjbGFzcyBoeXtjb25zdHJ1Y3Rvcih0LGUsbj1udWxsKXt0aGlzW2N5XT10LHRoaXNbbHldPWUsdGhpc1tveV09bn19XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovY29uc3QgdXk9bmV3IHZsLGR5PW5ldyBobixweT1uZXcgY2koMiwyKSxteT1TeW1ib2woXCJ0aHJlZVRleHR1cmVcIik7Y2xhc3MgZnkgZXh0ZW5kcyBoeXtnZXRbbXldKCl7dmFyIHQ7cmV0dXJuIGNvbnNvbGUuYXNzZXJ0KG51bGwhPXRoaXNbb3ldJiZ0aGlzW295XS5zaXplPjAsXCJJbWFnZSBjb3JyZWxhdGVkIG9iamVjdCBpcyB1bmRlZmluZWRcIiksbnVsbD09PSh0PXRoaXNbb3ldKXx8dm9pZCAwPT09dD92b2lkIDA6dC52YWx1ZXMoKS5uZXh0KCkudmFsdWV9Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKHQsbj1udWxsIT1uP246e25hbWU6XCJhZGhvY19pbWFnZVwiLHVyaTplJiZlLmltYWdlP2UuaW1hZ2Uuc3JjOlwiYWRob2NfaW1hZ2VcIn0sbmV3IFNldChlP1tlXTpbXSkpfWdldCBuYW1lKCl7cmV0dXJuIHRoaXNbbHldLm5hbWV8fFwiXCJ9Z2V0IHVyaSgpe3JldHVybiB0aGlzW2x5XS51cml9Z2V0IGJ1ZmZlclZpZXcoKXtyZXR1cm4gdGhpc1tseV0uYnVmZmVyVmlld31nZXQgdHlwZSgpe3JldHVybiBudWxsIT10aGlzLnVyaT9cImV4dGVybmFsXCI6XCJlbWJlZGRlZFwifWFzeW5jIHNldFVSSSh0KXt0aGlzW2x5XS51cmk9dDtjb25zdCBlPWF3YWl0IG5ldyBQcm9taXNlKCgoZSxuKT0+e3V5LmxvYWQodCxlLHZvaWQgMCxuKX0pKSxuPXRoaXNbbXldO24uaW1hZ2U9ZSxuLm5lZWRzVXBkYXRlPSEwLHRoaXNbY3ldKCl9YXN5bmMgY3JlYXRlVGh1bWJuYWlsKHQsZSl7Y29uc3Qgbj1uZXcgWXM7ZHkubWFwPXRoaXNbbXldO2NvbnN0IGk9bmV3IFZuKHB5LGR5KTtuLmFkZChpKTtjb25zdCByPW5ldyB4aSgtMSwxLDEsLTEsMCwxKSx7dGhyZWVSZW5kZXJlcjpzfT1DZC5zaW5nbGV0b24sYT1uZXcgVXQodCxlKTtzLnNldFJlbmRlclRhcmdldChhKSxzLnJlbmRlcihuLHIpLHMuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO2NvbnN0IG89bmV3IFVpbnQ4QXJyYXkodCplKjQpO3MucmVhZFJlbmRlclRhcmdldFBpeGVscyhhLDAsMCx0LGUsbyksWWQud2lkdGg9dCxZZC5oZWlnaHQ9ZTtjb25zdCBsPVlkLmdldENvbnRleHQoXCIyZFwiKSxjPWwuY3JlYXRlSW1hZ2VEYXRhKHQsZSk7cmV0dXJuIGMuZGF0YS5zZXQobyksbC5wdXRJbWFnZURhdGEoYywwLDApLG5ldyBQcm9taXNlKChhc3luYyh0LGUpPT57WWQudG9CbG9iKChuPT57aWYoIW4pcmV0dXJuIGUoXCJGYWlsZWQgdG8gY2FwdHVyZSB0aHVtYm5haWwuXCIpO3QoVVJMLmNyZWF0ZU9iamVjdFVSTChuKSl9KSxcImltYWdlL3BuZ1wiKX0pKX19dmFyIGd5LHZ5OyFmdW5jdGlvbih0KXt0W3QuTmVhcmVzdD05NzI4XT1cIk5lYXJlc3RcIix0W3QuTGluZWFyPTk3MjldPVwiTGluZWFyXCIsdFt0Lk5lYXJlc3RNaXBtYXBOZWFyZXN0PTk5ODRdPVwiTmVhcmVzdE1pcG1hcE5lYXJlc3RcIix0W3QuTGluZWFyTWlwbWFwTmVhcmVzdD05OTg1XT1cIkxpbmVhck1pcG1hcE5lYXJlc3RcIix0W3QuTmVhcmVzdE1pcG1hcExpbmVhcj05OTg2XT1cIk5lYXJlc3RNaXBtYXBMaW5lYXJcIix0W3QuTGluZWFyTWlwbWFwTGluZWFyPTk5ODddPVwiTGluZWFyTWlwbWFwTGluZWFyXCJ9KGd5fHwoZ3k9e30pKSxmdW5jdGlvbih0KXt0W3QuQ2xhbXBUb0VkZ2U9MzMwNzFdPVwiQ2xhbXBUb0VkZ2VcIix0W3QuTWlycm9yZWRSZXBlYXQ9MzM2NDhdPVwiTWlycm9yZWRSZXBlYXRcIix0W3QuUmVwZWF0PTEwNDk3XT1cIlJlcGVhdFwifSh2eXx8KHZ5PXt9KSk7XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCB5eT0oKCk9Pntjb25zdCB0PVtneS5OZWFyZXN0LGd5LkxpbmVhcixneS5OZWFyZXN0TWlwbWFwTmVhcmVzdCxneS5MaW5lYXJNaXBtYXBMaW5lYXIsZ3kuTmVhcmVzdE1pcG1hcExpbmVhcixneS5MaW5lYXJNaXBtYXBMaW5lYXJdO3JldHVybiBlPT50LmluZGV4T2YoZSk+LTF9KSgpLHh5PSgoKT0+e2NvbnN0IHQ9W2d5Lk5lYXJlc3QsZ3kuTGluZWFyXTtyZXR1cm4gZT0+dC5pbmRleE9mKGUpPi0xfSkoKSxieT0oKCk9Pntjb25zdCB0PVt2eS5DbGFtcFRvRWRnZSx2eS5NaXJyb3JlZFJlcGVhdCx2eS5SZXBlYXRdO3JldHVybiBlPT50LmluZGV4T2YoZSk+LTF9KSgpLHd5PVN5bWJvbChcInRocmVlVGV4dHVyZXNcIiksX3k9U3ltYm9sKFwic2V0UHJvcGVydHlcIiksTXk9U3ltYm9sKFwic291cmNlU2FtcGxlclwiKTtjbGFzcyBTeSBleHRlbmRzIGh5e2dldFt3eV0oKXtyZXR1cm4gY29uc29sZS5hc3NlcnQobnVsbCE9dGhpc1tveV0mJnRoaXNbb3ldLnNpemU+MCxcIlNhbXBsZXIgY29ycmVsYXRlZCBvYmplY3QgaXMgdW5kZWZpbmVkXCIpLHRoaXNbb3ldfWdldFtNeV0oKXtyZXR1cm4gY29uc29sZS5hc3NlcnQobnVsbCE9dGhpc1tseV0sXCJTYW1wbGVyIHNvdXJjZSBpcyB1bmRlZmluZWRcIiksdGhpc1tseV19Y29uc3RydWN0b3IodCxlLG4pe251bGw9PShuPW51bGwhPW4/bjp7fSkubWluRmlsdGVyJiYobi5taW5GaWx0ZXI9ZT9lLm1pbkZpbHRlcjpneS5MaW5lYXJNaXBtYXBMaW5lYXIpLG51bGw9PW4ubWFnRmlsdGVyJiYobi5tYWdGaWx0ZXI9ZT9lLm1hZ0ZpbHRlcjpneS5MaW5lYXIpLG51bGw9PW4ud3JhcFMmJihuLndyYXBTPWU/ZS53cmFwUzp2eS5SZXBlYXQpLG51bGw9PW4ud3JhcFQmJihuLndyYXBUPWU/ZS53cmFwVDp2eS5SZXBlYXQpLHN1cGVyKHQsbixuZXcgU2V0KGU/W2VdOltdKSl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tseV0ubmFtZXx8XCJcIn1nZXQgbWluRmlsdGVyKCl7cmV0dXJuIHRoaXNbTXldLm1pbkZpbHRlcn1nZXQgbWFnRmlsdGVyKCl7cmV0dXJuIHRoaXNbTXldLm1hZ0ZpbHRlcn1nZXQgd3JhcFMoKXtyZXR1cm4gdGhpc1tNeV0ud3JhcFN9Z2V0IHdyYXBUKCl7cmV0dXJuIHRoaXNbTXldLndyYXBUfXNldE1pbkZpbHRlcih0KXt0aGlzW195XShcIm1pbkZpbHRlclwiLHQpfXNldE1hZ0ZpbHRlcih0KXt0aGlzW195XShcIm1hZ0ZpbHRlclwiLHQpfXNldFdyYXBTKHQpe3RoaXNbX3ldKFwid3JhcFNcIix0KX1zZXRXcmFwVCh0KXt0aGlzW195XShcIndyYXBUXCIsdCl9W195XSh0LGUpe2NvbnN0IG49dGhpc1tNeV07aWYobnVsbCE9bil7aWYoKCh0LGUpPT57c3dpdGNoKHQpe2Nhc2VcIm1pbkZpbHRlclwiOnJldHVybiB5eShlKTtjYXNlXCJtYWdGaWx0ZXJcIjpyZXR1cm4geHkoZSk7Y2FzZVwid3JhcFNcIjpjYXNlXCJ3cmFwVFwiOnJldHVybiBieShlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbmZpZ3VyZSBwcm9wZXJ0eSBcIiR7dH1cIiBvbiBTYW1wbGVyYCl9fSkodCxlKSl7blt0XT1lO2Zvcihjb25zdCBuIG9mIHRoaXNbd3ldKW5bdF09ZSxuLm5lZWRzVXBkYXRlPSEwfXRoaXNbY3ldKCl9fX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9jb25zdCBUeT1TeW1ib2woXCJpbWFnZVwiKSxFeT1TeW1ib2woXCJzYW1wbGVyXCIpO2NsYXNzIEF5IGV4dGVuZHMgaHl7Y29uc3RydWN0b3IodCxlLG49bnVsbCxpPW51bGwscj1udWxsKXtzdXBlcih0LG58fHt9LG5ldyBTZXQoZT9bZV06W10pKSx0aGlzW0V5XT1uZXcgU3kodCxlLGkpLHRoaXNbVHldPW5ldyBmeSh0LGUscil9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tseV0ubmFtZXx8XCJcIn1nZXQgc2FtcGxlcigpe3JldHVybiB0aGlzW0V5XX1nZXQgc291cmNlKCl7cmV0dXJuIHRoaXNbVHldfX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi92YXIgTHk7Y29uc3QgUnk9U3ltYm9sKFwidGV4dHVyZVwiKSxDeT1TeW1ib2woXCJtYXRlcmlhbHNcIiksUHk9U3ltYm9sKFwidXNhZ2VcIik7dmFyIEl5OyFmdW5jdGlvbih0KXt0W3QuQmFzZT0wXT1cIkJhc2VcIix0W3QuTWV0YWxsaWNSb3VnaG5lc3M9MV09XCJNZXRhbGxpY1JvdWdobmVzc1wiLHRbdC5Ob3JtYWw9Ml09XCJOb3JtYWxcIix0W3QuT2NjbHVzaW9uPTNdPVwiT2NjbHVzaW9uXCIsdFt0LkVtaXNzaXZlPTRdPVwiRW1pc3NpdmVcIn0oSXl8fChJeT17fSkpO2NsYXNzIER5e2NvbnN0cnVjdG9yKHQsZSxuLGkscixzKXtpZih0aGlzW0x5XT1udWxsLHMpe2NvbnN0IGU9ci50ZXh0dXJlcz9yLnRleHR1cmVzW3MuaW5kZXhdOm51bGwsaT1lJiZyLnNhbXBsZXJzP3Iuc2FtcGxlcnNbZS5zYW1wbGVyXTpudWxsLGE9ZSYmci5pbWFnZXM/ci5pbWFnZXNbZS5zb3VyY2VdOm51bGw7dGhpc1tSeV09bmV3IEF5KHQsbixlLGksYSl9dGhpcy5vblVwZGF0ZT10LHRoaXNbQ3ldPWksdGhpc1tQeV09ZX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW1J5XX1zZXRUZXh0dXJlKHQpe2NvbnN0IGU9bnVsbCE9dD90LnNvdXJjZVtteV06bnVsbDtsZXQgbj0zMDAxO2lmKHRoaXNbUnldPXQsdGhpc1tDeV0pZm9yKGNvbnN0IHQgb2YgdGhpc1tDeV0pe3N3aXRjaCh0aGlzW1B5XSl7Y2FzZSBJeS5CYXNlOnQubWFwPWU7YnJlYWs7Y2FzZSBJeS5NZXRhbGxpY1JvdWdobmVzczpuPTNlMyx0Lm1ldGFsbmVzc01hcD1lLHQucm91Z2huZXNzTWFwPWU7YnJlYWs7Y2FzZSBJeS5Ob3JtYWw6bj0zZTMsdC5ub3JtYWxNYXA9ZTticmVhaztjYXNlIEl5Lk9jY2x1c2lvbjpuPTNlMyx0LmFvTWFwPWU7YnJlYWs7Y2FzZSBJeS5FbWlzc2l2ZTp0LmVtaXNzaXZlTWFwPWV9dC5uZWVkc1VwZGF0ZT0hMH1lJiYoZS5lbmNvZGluZz1uKSx0aGlzLm9uVXBkYXRlKCl9fUx5PVJ5O1xuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTnk9U3ltYm9sKFwidGhyZWVNYXRlcmlhbHNcIiksRnk9U3ltYm9sKFwiYmFzZUNvbG9yVGV4dHVyZVwiKSxPeT1TeW1ib2woXCJtZXRhbGxpY1JvdWdobmVzc1RleHR1cmVcIik7Y2xhc3MgVXkgZXh0ZW5kcyBoeXtjb25zdHJ1Y3Rvcih0LGUsbixpKXtzdXBlcih0LG4saSksbnVsbD09bi5iYXNlQ29sb3JGYWN0b3ImJihuLmJhc2VDb2xvckZhY3Rvcj1bMSwxLDEsMV0pLG51bGw9PW4ucm91Z2huZXNzRmFjdG9yJiYobi5yb3VnaG5lc3NGYWN0b3I9MSksbnVsbD09bi5tZXRhbGxpY0ZhY3RvciYmKG4ubWV0YWxsaWNGYWN0b3I9MSk7Y29uc3R7YmFzZUNvbG9yVGV4dHVyZTpyLG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZTpzfT1uLHttYXA6YSxtZXRhbG5lc3NNYXA6b309aS52YWx1ZXMoKS5uZXh0KCkudmFsdWU7dGhpc1tGeV09bmV3IER5KHQsSXkuQmFzZSxhLGksZSxyfHxudWxsKSx0aGlzW095XT1uZXcgRHkodCxJeS5NZXRhbGxpY1JvdWdobmVzcyxvLGksZSxzfHxudWxsKX1nZXRbTnldKCl7cmV0dXJuIHRoaXNbb3ldfWdldCBiYXNlQ29sb3JGYWN0b3IoKXtyZXR1cm4gdGhpc1tseV0uYmFzZUNvbG9yRmFjdG9yfWdldCBtZXRhbGxpY0ZhY3Rvcigpe3JldHVybiB0aGlzW2x5XS5tZXRhbGxpY0ZhY3Rvcn1nZXQgcm91Z2huZXNzRmFjdG9yKCl7cmV0dXJuIHRoaXNbbHldLnJvdWdobmVzc0ZhY3Rvcn1nZXQgYmFzZUNvbG9yVGV4dHVyZSgpe3JldHVybiB0aGlzW0Z5XX1nZXQgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKCl7cmV0dXJuIHRoaXNbT3ldfXNldEJhc2VDb2xvckZhY3Rvcih0KXtmb3IoY29uc3QgZSBvZiB0aGlzW055XSllLmNvbG9yLmZyb21BcnJheSh0KSxlLm9wYWNpdHk9dFszXTt0aGlzW2x5XS5iYXNlQ29sb3JGYWN0b3I9dCx0aGlzW2N5XSgpfXNldE1ldGFsbGljRmFjdG9yKHQpe2Zvcihjb25zdCBlIG9mIHRoaXNbTnldKWUubWV0YWxuZXNzPXQ7dGhpc1tseV0ubWV0YWxsaWNGYWN0b3I9dCx0aGlzW2N5XSgpfXNldFJvdWdobmVzc0ZhY3Rvcih0KXtmb3IoY29uc3QgZSBvZiB0aGlzW055XSllLnJvdWdobmVzcz10O3RoaXNbbHldLnJvdWdobmVzc0ZhY3Rvcj10LHRoaXNbY3ldKCl9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL2NvbnN0IGt5PVN5bWJvbChcInBick1ldGFsbGljUm91Z2huZXNzXCIpLHp5PVN5bWJvbChcIm5vcm1hbFRleHR1cmVcIiksQnk9U3ltYm9sKFwib2NjbHVzaW9uVGV4dHVyZVwiKSxIeT1TeW1ib2woXCJlbWlzc2l2ZVRleHR1cmVcIiksVnk9U3ltYm9sKFwiYmFja2luZ1RocmVlTWF0ZXJpYWxcIiksR3k9U3ltYm9sKFwiYXBwbHlBbHBoYUN1dG9mZlwiKSxXeT1TeW1ib2woXCJsYXp5TG9hZEdMVEZJbmZvXCIpLGp5PVN5bWJvbChcImluaXRpYWxpemVcIikscXk9U3ltYm9sKFwiZ2V0TG9hZGVkTWF0ZXJpYWxcIiksWHk9U3ltYm9sKFwiZW5zdXJlTWF0ZXJpYWxJc0xvYWRlZFwiKTtjbGFzcyBZeSBleHRlbmRzIGh5e2NvbnN0cnVjdG9yKHQsZSxuLGkscil7c3VwZXIodCxuLGkpLG51bGw9PXI/dGhpc1tqeV0oZSk6dGhpc1tXeV09cn1nZXRbVnldKCl7cmV0dXJuIHRoaXNbb3ldLnZhbHVlcygpLm5leHQoKS52YWx1ZX1banldKHQpe2NvbnN0IGU9dGhpc1tjeV0sbj10aGlzW2x5XSxpPXRoaXNbb3ldO24uZXh0ZW5zaW9ucyYmbi5leHRlbnNpb25zLktIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzJiZjb25zb2xlLndhcm4oYE1hdGVyaWFsICR7bi5uYW1lfSB1c2VzIGEgZGVwcmVjYXRlZCBleHRlbnNpb25cXG4gICAgICAgICAgXCJLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1wiLCBwbGVhc2UgdXNlXFxuICAgICAgICAgIFwicGJyTWV0YWxsaWNSb3VnaG5lc3NcIiBpbnN0ZWFkLiBTcGVjdWxhciBHbG9zc2luZXNzIG1hdGVyaWFscyBhcmVcXG4gICAgICAgICAgY3VycmVudGx5IHN1cHBvcnRlZCBmb3IgcmVuZGVyaW5nLCBidXQgbm90IGZvciBvdXIgc2NlbmUtZ3JhcGggQVBJLFxcbiAgICAgICAgICBub3IgZm9yIGF1dG8tZ2VuZXJhdGlvbiBvZiBVU0RaIGZvciBRdWljayBMb29rLmApLG51bGw9PW4ucGJyTWV0YWxsaWNSb3VnaG5lc3MmJihuLnBick1ldGFsbGljUm91Z2huZXNzPXt9KSx0aGlzW2t5XT1uZXcgVXkoZSx0LG4ucGJyTWV0YWxsaWNSb3VnaG5lc3MsaSksbnVsbD09bi5lbWlzc2l2ZUZhY3RvciYmKG4uZW1pc3NpdmVGYWN0b3I9WzAsMCwwXSksbnVsbD09bi5kb3VibGVTaWRlZCYmKG4uZG91YmxlU2lkZWQ9ITEpLG51bGw9PW4uYWxwaGFNb2RlJiYobi5hbHBoYU1vZGU9XCJPUEFRVUVcIiksbnVsbD09bi5hbHBoYUN1dG9mZiYmKG4uYWxwaGFDdXRvZmY9LjUpO2NvbnN0e25vcm1hbFRleHR1cmU6cixvY2NsdXNpb25UZXh0dXJlOnMsZW1pc3NpdmVUZXh0dXJlOmF9PW4se25vcm1hbE1hcDpvLGFvTWFwOmwsZW1pc3NpdmVNYXA6Y309aS52YWx1ZXMoKS5uZXh0KCkudmFsdWU7dGhpc1t6eV09bmV3IER5KGUsSXkuTm9ybWFsLG8saSx0LHJ8fG51bGwpLHRoaXNbQnldPW5ldyBEeShlLEl5Lk9jY2x1c2lvbixsLGksdCxzfHxudWxsKSx0aGlzW0h5XT1uZXcgRHkoZSxJeS5FbWlzc2l2ZSxjLGksdCxhfHxudWxsKX1hc3luY1txeV0oKXtpZihudWxsIT10aGlzW1d5XSl7Y29uc3R7c2V0OnQsbWF0ZXJpYWw6ZX09YXdhaXQgdGhpc1tXeV0uZG9MYXp5TG9hZCgpO3JldHVybiB0aGlzW295XT10LHRoaXNbanldKHRoaXNbV3ldLmdsdGYpLHRoaXNbV3ldPXZvaWQgMCx0aGlzLmVuc3VyZUxvYWRlZD1hc3luYygpPT57fSxlfXJldHVybiB0aGlzW295XS52YWx1ZXMoKS5uZXh0KCkudmFsdWV9W1h5XSgpe2lmKG51bGwhPXRoaXNbV3ldKXRocm93IG5ldyBFcnJvcihgTWF0ZXJpYWwgXCIke3RoaXMubmFtZX1cIiBoYXMgbm90IGJlZW4gbG9hZGVkLCBjYWxsICdhd2FpdFxcbiAgICBteU1hdGVyaWFsLmVuc3VyZUxvYWRlZCgpJyBiZWZvcmUgdXNpbmcgYW4gdW5sb2FkZWQgbWF0ZXJpYWwuYCl9YXN5bmMgZW5zdXJlTG9hZGVkKCl7YXdhaXQgdGhpc1txeV0oKX1nZXQgaXNMb2FkZWQoKXtyZXR1cm4gbnVsbD09dGhpc1tXeV19Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tseV0ubmFtZXx8XCJcIn1nZXQgcGJyTWV0YWxsaWNSb3VnaG5lc3MoKXtyZXR1cm4gdGhpc1tYeV0oKSx0aGlzW2t5XX1nZXQgbm9ybWFsVGV4dHVyZSgpe3JldHVybiB0aGlzW1h5XSgpLHRoaXNbenldfWdldCBvY2NsdXNpb25UZXh0dXJlKCl7cmV0dXJuIHRoaXNbWHldKCksdGhpc1tCeV19Z2V0IGVtaXNzaXZlVGV4dHVyZSgpe3JldHVybiB0aGlzW1h5XSgpLHRoaXNbSHldfWdldCBlbWlzc2l2ZUZhY3Rvcigpe3JldHVybiB0aGlzW1h5XSgpLHRoaXNbbHldLmVtaXNzaXZlRmFjdG9yfXNldEVtaXNzaXZlRmFjdG9yKHQpe3RoaXNbWHldKCk7Zm9yKGNvbnN0IGUgb2YgdGhpc1tveV0pZS5lbWlzc2l2ZS5mcm9tQXJyYXkodCk7dGhpc1tseV0uZW1pc3NpdmVGYWN0b3I9dCx0aGlzW2N5XSgpfVtHeV0oKXt0aGlzW1h5XSgpO2NvbnN0IHQ9dGhpc1tseV07Zm9yKGNvbnN0IGUgb2YgdGhpc1tveV0pZS5hbHBoYVRlc3Q9dC5hbHBoYUN1dG9mZixlLm5lZWRzVXBkYXRlPSEwfXNldEFscGhhQ3V0b2ZmKHQpe3RoaXNbWHldKCksdGhpc1tseV0uYWxwaGFDdXRvZmY9dCx0aGlzW0d5XSgpLHRoaXNbY3ldKCl9Z2V0QWxwaGFDdXRvZmYoKXtyZXR1cm4gdGhpc1tYeV0oKSx0aGlzW2x5XS5hbHBoYUN1dG9mZn1zZXREb3VibGVTaWRlZCh0KXt0aGlzW1h5XSgpO2Zvcihjb25zdCBlIG9mIHRoaXNbb3ldKWUuc2lkZT10PzI6MCxlLm5lZWRzVXBkYXRlPSEwO3RoaXNbbHldLmRvdWJsZVNpZGVkPXQsdGhpc1tjeV0oKX1nZXREb3VibGVTaWRlZCgpe3JldHVybiB0aGlzW1h5XSgpLHRoaXNbbHldLmRvdWJsZVNpZGVkfXNldEFscGhhTW9kZSh0KXt0aGlzW1h5XSgpO2NvbnN0IGU9KHQsZSk9Pnt0LnRyYW5zcGFyZW50PWUsdC5kZXB0aFdyaXRlPSFlfTt0aGlzW2x5XS5hbHBoYU1vZGU9dDtmb3IoY29uc3QgbiBvZiB0aGlzW295XSllKG4sXCJPUEFRVUVcIiE9PXQpLHRoaXNbR3ldKCksbi5uZWVkc1VwZGF0ZT0hMDt0aGlzW2N5XSgpfWdldEFscGhhTW9kZSgpe3JldHVybiB0aGlzW1h5XSgpLHRoaXNbbHldLmFscGhhTW9kZX19dmFyIFp5LEp5O2NvbnN0ICR5PVN5bWJvbChcIm1hdGVyaWFsc1wiKSxLeT1TeW1ib2woXCJ2YXJpYW50SW5mb1wiKSxReT1TeW1ib2woXCJtZXNoXCIpLHR4PVN5bWJvbChcImNoaWxkcmVuXCIpLGV4PVN5bWJvbChcImluaXRpYWxNYXRlcmlhbElkeFwiKSxueD1TeW1ib2woXCJhY3RpdmVNYXRlcmlhbElkeFwiKTtjbGFzcyBpeHtjb25zdHJ1Y3Rvcih0KXt0aGlzLm5hbWU9XCJcIix0aGlzW1p5XT1uZXcgQXJyYXksdGhpcy5uYW1lPXR9fVp5PXR4O2NsYXNzIHJ4IGV4dGVuZHMgaXh7Y29uc3RydWN0b3IodCxlLG4pe3N1cGVyKHQubmFtZSksdGhpc1tKeV09bmV3IE1hcCx0aGlzW1F5XT10O2NvbnN0e2dsdGY6aSx0aHJlZUdMVEY6cix0aHJlZU9iamVjdE1hcDpzfT1uLGE9cy5nZXQodC5tYXRlcmlhbCk7bnVsbCE9YS5tYXRlcmlhbHM/dGhpc1tleF09dGhpc1tueF09YS5tYXRlcmlhbHM6Y29uc29sZS5lcnJvcihgUHJpbWl0aXZlICgke3QubmFtZX0pIG1pc3NpbmcgaW5pdGlhbCBtYXRlcmlhbCByZWZlcmVuY2UuYCk7Y29uc3Qgbz1zLmdldCh0KS5tZXNoZXMsbD0oaS5tZXNoZXN8fFtdKVtvXS5wcmltaXRpdmVzfHxbXTtmb3IoY29uc3QgdCBvZiBsKXtpZihudWxsIT10Lm1hdGVyaWFsKXRoaXNbJHldLnNldCh0Lm1hdGVyaWFsLGVbdC5tYXRlcmlhbF0pO2Vsc2V7Y29uc3QgdD1lLmZpbmRJbmRleCgodD0+XCJEZWZhdWx0XCI9PT10Lm5hbWUpKTt0Pj0wP3RoaXNbJHldLnNldCh0LGVbdF0pOmNvbnNvbGUud2FybihcIlByaW1pdGl2ZSBoYXMgbm8gbWF0ZXJpYWwhXCIpfWlmKHQuZXh0ZW5zaW9ucyYmdC5leHRlbnNpb25zLktIUl9tYXRlcmlhbHNfdmFyaWFudHMpe2NvbnN0IG49dC5leHRlbnNpb25zLktIUl9tYXRlcmlhbHNfdmFyaWFudHMsaT1yLnBhcnNlci5qc29uLmV4dGVuc2lvbnMuS0hSX21hdGVyaWFsc192YXJpYW50cy52YXJpYW50czt0aGlzW0t5XT1uZXcgTWFwO2Zvcihjb25zdCB0IG9mIG4ubWFwcGluZ3Mpe3RoaXNbJHldLnNldCh0Lm1hdGVyaWFsLGVbdC5tYXRlcmlhbF0pO2Zvcihjb25zdCBuIG9mIHQudmFyaWFudHMpe2NvbnN0e25hbWU6cn09aVtuXTt0aGlzW0t5XS5zZXQocix7bWF0ZXJpYWw6ZVt0Lm1hdGVyaWFsXSxpbmRleDp0Lm1hdGVyaWFsfSl9fX19fWdldCBtZXNoKCl7cmV0dXJuIHRoaXNbUXldfWFzeW5jIHNldEFjdGl2ZU1hdGVyaWFsKHQpe2NvbnN0IGU9dGhpc1skeV0uZ2V0KHQpO3JldHVybiBudWxsIT1lJiYodGhpcy5tZXNoLm1hdGVyaWFsPWF3YWl0IGVbcXldKCksdGhpc1tueF09dCksdGhpcy5tZXNoLm1hdGVyaWFsfWdldEFjdGl2ZU1hdGVyaWFsKCl7cmV0dXJuIHRoaXNbJHldLmdldCh0aGlzW254XSl9YXN5bmMgZW5hYmxlVmFyaWFudCh0KXtpZihudWxsPT10KXJldHVybiB0aGlzLnNldEFjdGl2ZU1hdGVyaWFsKHRoaXNbZXhdKTtpZihudWxsIT10aGlzW0t5XSl7Y29uc3QgZT10aGlzW0t5XS5nZXQodCk7aWYobnVsbCE9ZSlyZXR1cm4gdGhpcy5zZXRBY3RpdmVNYXRlcmlhbChlLmluZGV4KX1yZXR1cm4gbnVsbH1hc3luYyBpbnN0YW50aWF0ZVZhcmlhbnRzKCl7aWYobnVsbCE9dGhpc1tLeV0pZm9yKGNvbnN0IHQgb2YgdGhpc1tLeV0ua2V5cygpKXtpZihudWxsIT10aGlzLm1lc2gudXNlckRhdGEudmFyaWFudE1hdGVyaWFscy5nZXQodCkubWF0ZXJpYWwpY29udGludWU7Y29uc3QgZT1hd2FpdCB0aGlzLmVuYWJsZVZhcmlhbnQodCk7bnVsbCE9ZSYmKHRoaXMubWVzaC51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzLmdldCh0KS5tYXRlcmlhbD1lKX19Z2V0IHZhcmlhbnRJbmZvKCl7cmV0dXJuIHRoaXNbS3ldfX1cbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBzeCxheCxveCxseDtKeT0keTtjb25zdCBjeD1TeW1ib2woXCJtYXRlcmlhbHNcIiksaHg9U3ltYm9sKFwiaGllcmFyY2h5XCIpLHV4PVN5bWJvbChcInJvb3RzXCIpLGR4PVN5bWJvbChcInByaW1pdGl2ZXNcIikscHg9U3ltYm9sKFwicHJlcGFyZVZhcmlhbnRzRm9yRXhwb3J0XCIpLG14PVN5bWJvbChcInN3aXRjaFZhcmlhbnRcIiksZng9U3ltYm9sKFwidGhyZWVTY2VuZVwiKSxneD1TeW1ib2woXCJtYXRlcmlhbHNGcm9tUG9pbnRcIiksdng9U3ltYm9sKFwibWF0ZXJpYWxGcm9tUG9pbnRcIik7Y2xhc3MgeXh7Y29uc3RydWN0b3IodCxlLG4saSl7dGhpcy5nbHRmPXQsdGhpcy5nbHRmRWxlbWVudE1hcD1lLHRoaXMubWFwS2V5PW4sdGhpcy5kb0xhenlMb2FkPWl9fWNsYXNzIHh4e2NvbnN0cnVjdG9yKHQsZT0oKCk9Pnt9KSl7dGhpc1tzeF09bmV3IEFycmF5LHRoaXNbYXhdPW5ldyBBcnJheSx0aGlzW294XT1uZXcgQXJyYXksdGhpc1tseF09bmV3IEFycmF5O2NvbnN0e2dsdGY6bix0aHJlZUdMVEY6aSxnbHRmRWxlbWVudE1hcDpyfT10O3RoaXNbZnhdPWkuc2NlbmU7Zm9yKGNvbnN0W3Qsc11vZiBuLm1hdGVyaWFscy5lbnRyaWVzKCkpe2NvbnN0IGE9ci5nZXQocyk7aWYobnVsbCE9YSl0aGlzW2N4XS5wdXNoKG5ldyBZeShlLG4scyxhKSk7ZWxzZXtjb25zdCBzPShuLm1hdGVyaWFsc3x8W10pW3RdLG89dCxsPWFzeW5jKCk9Pntjb25zdCB0PWF3YWl0IGkucGFyc2VyLmdldERlcGVuZGVuY3koXCJtYXRlcmlhbFwiLG8pLGU9bmV3IFNldDtyZXR1cm4gci5zZXQocyxlKSxlLmFkZCh0KSx7c2V0OmUsbWF0ZXJpYWw6dH19O3RoaXNbY3hdLnB1c2gobmV3IFl5KGUsbixzLGEsbmV3IHl4KG4scixzLGwpKSl9fWNvbnN0IHM9bmV3IE1hcCxhPW5ldyBBcnJheTtmb3IoY29uc3QgdCBvZiBpLnNjZW5lLmNoaWxkcmVuKWEucHVzaCh0KTtmb3IoO2EubGVuZ3RoPjA7KXtjb25zdCBlPWEucG9wKCk7bGV0IG49bnVsbDtlIGluc3RhbmNlb2YgVm4/KG49bmV3IHJ4KGUsdGhpcy5tYXRlcmlhbHMsdCksdGhpc1tkeF0ucHVzaChuKSk6bj1uZXcgaXgoZS5uYW1lKTtjb25zdCBpPXMuZ2V0KGUpO251bGwhPWk/aVt0eF0ucHVzaChuKTp0aGlzW3V4XS5wdXNoKG4pLHRoaXNbaHhdLnB1c2gobik7Zm9yKGNvbnN0IHQgb2YgZS5jaGlsZHJlbilhLnB1c2godCkscy5zZXQoZSxuKX19Z2V0IG1hdGVyaWFscygpe3JldHVybiB0aGlzW2N4XX1nZXRNYXRlcmlhbEJ5TmFtZSh0KXtjb25zdCBlPXRoaXNbY3hdLmZpbHRlcigoZT0+ZS5uYW1lPT09dCkpO3JldHVybiBlLmxlbmd0aD4wP2VbMF06bnVsbH1bKHN4PWN4LGF4PWh4LG94PXV4LGx4PWR4LGd4KV0odCl7cmV0dXJuIHQuaW50ZXJzZWN0T2JqZWN0KHRoaXNbZnhdLCEwKS5tYXAoKHQ9Pntjb25zdCBlPXRoaXNbaHhdLmZpbmQoKGU9PntpZihlIGluc3RhbmNlb2Ygcngpe2lmKGUubWVzaD09PXQub2JqZWN0KXJldHVybiEwfXJldHVybiExfSkpO3JldHVybiBudWxsIT1lP2UuZ2V0QWN0aXZlTWF0ZXJpYWwoKTpudWxsfSkpfVt2eF0odCl7Y29uc3QgZT10aGlzW2d4XSh0KTtyZXR1cm4gZS5sZW5ndGg+MD9lWzBdOm51bGx9YXN5bmNbbXhdKHQpe2NvbnN0IGU9bmV3IEFycmF5O2Zvcihjb25zdCBuIG9mIHRoaXNbZHhdKWUucHVzaChuLmVuYWJsZVZhcmlhbnQodCkpO2F3YWl0IFByb21pc2UuYWxsKGUpfWFzeW5jW3B4XSgpe2NvbnN0IHQ9bmV3IEFycmF5O2Zvcihjb25zdCBlIG9mIHRoaXNbZHhdKXQucHVzaChlLmluc3RhbnRpYXRlVmFyaWFudHMoKSk7YXdhaXQgUHJvbWlzZS5hbGwodCl9fVxuLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL3ZhciBieD1mdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHIscz1hcmd1bWVudHMubGVuZ3RoLGE9czwzP2U6bnVsbD09PWk/aT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik6aSxvPXQubGVuZ3RoLTE7bz49MDtvLS0pKHI9dFtvXSkmJihhPShzPDM/cihhKTpzPjM/cihlLG4sYSk6cihlLG4pKXx8YSk7cmV0dXJuIHM+MyYmYSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbixhKSxhfTtjb25zdCB3eD1TeW1ib2woXCJjdXJyZW50R0xURlwiKSxfeD1TeW1ib2woXCJtb2RlbFwiKSxNeD1TeW1ib2woXCJ2YXJpYW50c1wiKSxTeD1TeW1ib2woXCJnZXRPblVwZGF0ZU1ldGhvZFwiKSxUeD1TeW1ib2woXCJ0ZXh0dXJlTG9hZGVyXCIpLEV4PVN5bWJvbChcIm9yaWdpbmFsR2x0Zkpzb25cIik7XG4vKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQXg9ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByLHM9YXJndW1lbnRzLmxlbmd0aCxhPXM8Mz9lOm51bGw9PT1pP2k9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pOmksbz10Lmxlbmd0aC0xO28+PTA7by0tKShyPXRbb10pJiYoYT0oczwzP3IoYSk6cz4zP3IoZSxuLGEpOnIoZSxuKSl8fGEpO3JldHVybiBzPjMmJmEmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4sYSksYX07Y29uc3QgTHg9TWF0aC5QSS8zMixSeD17YmFzaXM6W3V1KGV1KEx4LFwicmFkXCIpKV0sa2V5d29yZHM6e2F1dG86W251bGxdfX0sQ3g9U3ltYm9sKFwiYXV0b1JvdGF0ZVN0YXJ0VGltZVwiKSxQeD1TeW1ib2woXCJyYWRpYW5zUGVyU2Vjb25kXCIpLEl4PVN5bWJvbChcInN5bmNSb3RhdGlvblJhdGVcIiksRHg9U3ltYm9sKFwib25DYW1lcmFDaGFuZ2VcIiksTng9KHQ9Pnt2YXIgZSxuLGk7Y2xhc3MgciBleHRlbmRzIHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXNbZV09bmV3IE1hcCx0aGlzW25dPXQ9Pnt0LmZvckVhY2goKHQ9Pnt0IGluc3RhbmNlb2YgTXV0YXRpb25SZWNvcmQmJlwiY2hpbGRMaXN0XCIhPT10LnR5cGV8fCh0LmFkZGVkTm9kZXMuZm9yRWFjaCgodD0+e3RoaXNbSXBdKHQpfSkpLHQucmVtb3ZlZE5vZGVzLmZvckVhY2goKHQ9Pnt0aGlzW0RwXSh0KX0pKSx0aGlzW3BwXSgpKX0pKX0sdGhpc1tpXT1uZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzW0NwXSl9Y29ubmVjdGVkQ2FsbGJhY2soKXtzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jaGlsZHJlbi5sZW5ndGg7Kyt0KXRoaXNbSXBdKHRoaXMuY2hpbGRyZW5bdF0pO2NvbnN0e1NoYWR5RE9NOnR9PXNlbGY7bnVsbD09dD90aGlzW1BwXS5vYnNlcnZlKHRoaXMse2NoaWxkTGlzdDohMH0pOnRoaXNbUHBdPXQub2JzZXJ2ZUNoaWxkcmVuKHRoaXMsdGhpc1tDcF0pfWRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7c3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtjb25zdHtTaGFkeURPTTp0fT1zZWxmO251bGw9PXQ/dGhpc1tQcF0uZGlzY29ubmVjdCgpOnQudW5vYnNlcnZlQ2hpbGRyZW4odGhpc1tQcF0pfVsoZT1ScCxuPUNwLGk9UHAsbXApXSh0LGUpe3N1cGVyW21wXSh0LGUpO2NvbnN0IG49dGhpc1tkcF0se2Fubm90YXRpb25SZW5kZXJlcjppfT1uLHI9bi5nZXRDYW1lcmEoKTtuLnNob3VsZFJlbmRlcigpJiYobi51cGRhdGVIb3RzcG90cyhyLnBvc2l0aW9uKSxpLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheT1cIlwiLGkucmVuZGVyKG4scikpfXVwZGF0ZUhvdHNwb3QodCl7Y29uc3QgZT10aGlzW1JwXS5nZXQodC5uYW1lKTtudWxsIT1lJiYoZS51cGRhdGVQb3NpdGlvbih0LnBvc2l0aW9uKSxlLnVwZGF0ZU5vcm1hbCh0Lm5vcm1hbCksdGhpc1twcF0oKSl9cG9zaXRpb25BbmROb3JtYWxGcm9tUG9pbnQodCxlKXtjb25zdCBuPXRoaXNbZHBdLGk9bi5nZXROREModCxlKSxyPW4ucG9zaXRpb25BbmROb3JtYWxGcm9tUG9pbnQoaSk7aWYobnVsbD09cilyZXR1cm4gbnVsbDtOcC5jb3B5KG4udGFyZ2V0Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtjb25zdCBzPVNwKHIucG9zaXRpb24uYXBwbHlNYXRyaXg0KE5wKSk7RnAuZ2V0Tm9ybWFsTWF0cml4KE5wKTtyZXR1cm57cG9zaXRpb246cyxub3JtYWw6U3Aoci5ub3JtYWwuYXBwbHlOb3JtYWxNYXRyaXgoRnApKX19W0lwXSh0KXtpZighKHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCYmMD09PXQuc2xvdC5pbmRleE9mKFwiaG90c3BvdFwiKSkpcmV0dXJuO2xldCBlPXRoaXNbUnBdLmdldCh0LnNsb3QpO251bGwhPWU/ZS5pbmNyZW1lbnQoKTooZT1uZXcgbXUoe25hbWU6dC5zbG90LHBvc2l0aW9uOnQuZGF0YXNldC5wb3NpdGlvbixub3JtYWw6dC5kYXRhc2V0Lm5vcm1hbH0pLHRoaXNbUnBdLnNldCh0LnNsb3QsZSksdGhpc1tkcF0uYWRkSG90c3BvdChlKSksdGhpc1tkcF0ucXVldWVSZW5kZXIoKX1bRHBdKHQpe2lmKCEodCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlyZXR1cm47Y29uc3QgZT10aGlzW1JwXS5nZXQodC5zbG90KTtlJiYoZS5kZWNyZW1lbnQoKSYmKHRoaXNbZHBdLnJlbW92ZUhvdHNwb3QoZSksdGhpc1tScF0uZGVsZXRlKHQuc2xvdCkpLHRoaXNbZHBdLnF1ZXVlUmVuZGVyKCkpfX1yZXR1cm4gcn0pKCh0PT57dmFyIGUsbixpLHIscztjbGFzcyBhIGV4dGVuZHMgdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpc1tlXT12b2lkIDAsdGhpc1tuXT1udWxsLHRoaXNbaV09W10sdGhpc1tyXT1uZXcgYmwsdGhpc1tzXT1udWxsLHRoaXMudmFyaWFudE5hbWU9bnVsbCx0aGlzLm9yaWVudGF0aW9uPVwiMCAwIDBcIix0aGlzLnNjYWxlPVwiMSAxIDFcIn1nZXQgbW9kZWwoKXtyZXR1cm4gdGhpc1tfeF19Z2V0IGF2YWlsYWJsZVZhcmlhbnRzKCl7cmV0dXJuIHRoaXNbTXhdfWdldCBvcmlnaW5hbEdsdGZKc29uKCl7cmV0dXJuIHRoaXNbRXhdfVsoZT1feCxuPXd4LGk9TXgscj1UeCxzPUV4LFN4KV0oKXtyZXR1cm4oKT0+e3RoaXNbcHBdKCl9fWFzeW5jIGNyZWF0ZVRleHR1cmUodCxlPVwiaW1hZ2UvcG5nXCIpe2NvbnN0IG49dGhpc1t3eF0saT1hd2FpdCBuZXcgUHJvbWlzZSgoZT0+dGhpc1tUeF0ubG9hZCh0LGUpKSk7cmV0dXJuIG4mJmk/KGkuZW5jb2Rpbmc9MzAwMSxpLndyYXBTPTFlMyxpLndyYXBUPTFlMyxpLmZsaXBZPSExLFwiaW1hZ2UvanBlZ1wiPT09ZSYmKGkuZm9ybWF0PTEwMjIpLG5ldyBBeSh0aGlzW1N4XSgpLGkpKTpudWxsfWFzeW5jIHVwZGF0ZWQodCl7aWYoc3VwZXIudXBkYXRlZCh0KSx0LmhhcyhcInZhcmlhbnROYW1lXCIpKXtjb25zdCB0PXRoaXNbd3hdLHt2YXJpYW50TmFtZTplfT10aGlzO251bGwhPXQmJihhd2FpdCB0aGlzW194XVtteF0oZSksdGhpc1twcF0oKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwidmFyaWFudC1hcHBsaWVkXCIpKSl9aWYodC5oYXMoXCJvcmllbnRhdGlvblwiKXx8dC5oYXMoXCJzY2FsZVwiKSl7Y29uc3R7bW9kZWxDb250YWluZXI6dH09dGhpc1tkcF0sZT1udSh0aGlzLm9yaWVudGF0aW9uKVswXS50ZXJtcyxuPXB1KGVbMF0pLm51bWJlcixpPXB1KGVbMV0pLm51bWJlcixyPXB1KGVbMl0pLm51bWJlcjt0LnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKG5ldyBBZShpLHIsbixcIllYWlwiKSk7Y29uc3Qgcz1udSh0aGlzLnNjYWxlKVswXS50ZXJtczt0LnNjYWxlLnNldChzWzBdLm51bWJlcixzWzFdLm51bWJlcixzWzJdLm51bWJlciksdGhpc1tkcF0udXBkYXRlQm91bmRpbmdCb3goKSx0aGlzW2RwXS51cGRhdGVTaGFkb3coKSx0aGlzW3ZwXS5hclJlbmRlcmVyLm9uVXBkYXRlU2NlbmUoKSx0aGlzW3BwXSgpfX1bZnBdKCl7c3VwZXJbZnBdKCksdGhpc1tNeF09W107Y29uc3R7Y3VycmVudEdMVEY6dH09dGhpc1tkcF07aWYobnVsbCE9dCl7Y29uc3R7Y29ycmVsYXRlZFNjZW5lR3JhcGg6ZX09dDtudWxsIT1lJiZ0IT09dGhpc1t3eF0mJih0aGlzW194XT1uZXcgeHgoZSx0aGlzW1N4XSgpKSx0aGlzW0V4XT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUuZ2x0ZikpKSxcInZhcmlhbnRzXCJpbiB0LnVzZXJEYXRhJiYodGhpc1tNeF09dC51c2VyRGF0YS52YXJpYW50cy5zbGljZSgpLHRoaXMucmVxdWVzdFVwZGF0ZShcInZhcmlhbnROYW1lXCIpKX10aGlzW3d4XT10LHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJzY2VuZS1ncmFwaC1yZWFkeVwiKSl9YXN5bmMgZXhwb3J0U2NlbmUodCl7Y29uc3QgZT10aGlzW2RwXTtyZXR1cm4gbmV3IFByb21pc2UoKGFzeW5jIG49Pntjb25zdCBpPXtiaW5hcnk6ITAsb25seVZpc2libGU6ITAsbWF4VGV4dHVyZVNpemU6MS8wLGZvcmNlUG93ZXJPZlR3b1RleHR1cmVzOiExLGluY2x1ZGVDdXN0b21FeHRlbnNpb25zOiExLGVtYmVkSW1hZ2VzOiEwfTtPYmplY3QuYXNzaWduKGksdCksaS5hbmltYXRpb25zPWUuYW5pbWF0aW9ucyxpLnRydW5jYXRlRHJhd1JhbmdlPSEwO2NvbnN0IHI9ZS5zaGFkb3c7bGV0IHM9ITE7bnVsbCE9ciYmKHM9ci52aXNpYmxlLHIudmlzaWJsZT0hMSksYXdhaXQgdGhpc1tfeF1bcHhdKCk7KG5ldyBUdikucmVnaXN0ZXIoKHQ9Pm5ldyBheSh0KSkpLnBhcnNlKGUubW9kZWxDb250YWluZXIuY2hpbGRyZW5bMF0sKHQ9Pm4obmV3IEJsb2IoW2kuYmluYXJ5P3Q6SlNPTi5zdHJpbmdpZnkodCldLHt0eXBlOmkuYmluYXJ5P1wiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSkpLGkpLG51bGwhPXImJihyLnZpc2libGU9cyl9KSl9bWF0ZXJpYWxGcm9tUG9pbnQodCxlKXtjb25zdCBuPXRoaXNbZHBdLGk9bi5nZXROREModCxlKTtyZXR1cm4gbi5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShpLG4uZ2V0Q2FtZXJhKCkpLHRoaXNbX3hdW3Z4XShuLnJheWNhc3Rlcil9fXJldHVybiBieChbWih7dHlwZTpTdHJpbmcsYXR0cmlidXRlOlwidmFyaWFudC1uYW1lXCJ9KV0sYS5wcm90b3R5cGUsXCJ2YXJpYW50TmFtZVwiLHZvaWQgMCksYngoW1ooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcIm9yaWVudGF0aW9uXCJ9KV0sYS5wcm90b3R5cGUsXCJvcmllbnRhdGlvblwiLHZvaWQgMCksYngoW1ooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcInNjYWxlXCJ9KV0sYS5wcm90b3R5cGUsXCJzY2FsZVwiLHZvaWQgMCksYX0pKCh0PT57dmFyIGUsbixpO2NsYXNzIHIgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmF1dG9Sb3RhdGU9ITEsdGhpcy5hdXRvUm90YXRlRGVsYXk9M2UzLHRoaXMucm90YXRpb25QZXJTZWNvbmQ9XCJhdXRvXCIsdGhpc1tlXT1wZXJmb3JtYW5jZS5ub3coKSx0aGlzW25dPTAsdGhpc1tpXT10PT57dGhpcy5hdXRvUm90YXRlJiZcInVzZXItaW50ZXJhY3Rpb25cIj09PXQuZGV0YWlsLnNvdXJjZSYmKHRoaXNbQ3hdPXBlcmZvcm1hbmNlLm5vdygpKX19Y29ubmVjdGVkQ2FsbGJhY2soKXtzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNhbWVyYS1jaGFuZ2VcIix0aGlzW0R4XSksdGhpc1tDeF09cGVyZm9ybWFuY2Uubm93KCl9ZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbWVyYS1jaGFuZ2VcIix0aGlzW0R4XSksdGhpc1tDeF09cGVyZm9ybWFuY2Uubm93KCl9dXBkYXRlZCh0KXtzdXBlci51cGRhdGVkKHQpLHQuaGFzKFwiYXV0b1JvdGF0ZVwiKSYmKHRoaXNbQ3hdPXBlcmZvcm1hbmNlLm5vdygpKX1bKGU9Q3gsbj1QeCxJeCldKHQpe3RoaXNbUHhdPXRbMF19W21wXSh0LGUpe2lmKHN1cGVyW21wXSh0LGUpLCF0aGlzLmF1dG9Sb3RhdGV8fCF0aGlzW01wXSgpfHx0aGlzW3ZwXS5pc1ByZXNlbnRpbmcpcmV0dXJuO2NvbnN0IG49TWF0aC5taW4oZSx0LXRoaXNbQ3hdLXRoaXMuYXV0b1JvdGF0ZURlbGF5KTtuPjAmJih0aGlzW2RwXS55YXc9dGhpcy50dXJudGFibGVSb3RhdGlvbit0aGlzW1B4XSpuKi4wMDEpfWdldCB0dXJudGFibGVSb3RhdGlvbigpe3JldHVybiB0aGlzW2RwXS55YXd9cmVzZXRUdXJudGFibGVSb3RhdGlvbih0PTApe3RoaXNbZHBdLnlhdz10fX1yZXR1cm4gaT1EeCxBeChbWih7dHlwZTpCb29sZWFuLGF0dHJpYnV0ZTpcImF1dG8tcm90YXRlXCJ9KV0sci5wcm90b3R5cGUsXCJhdXRvUm90YXRlXCIsdm9pZCAwKSxBeChbWih7dHlwZTpOdW1iZXIsYXR0cmlidXRlOlwiYXV0by1yb3RhdGUtZGVsYXlcIn0pXSxyLnByb3RvdHlwZSxcImF1dG9Sb3RhdGVEZWxheVwiLHZvaWQgMCksQXgoW0dmKHtpbnRyaW5zaWNzOlJ4LHVwZGF0ZUhhbmRsZXI6SXh9KSxaKHt0eXBlOlN0cmluZyxhdHRyaWJ1dGU6XCJyb3RhdGlvbi1wZXItc2Vjb25kXCJ9KV0sci5wcm90b3R5cGUsXCJyb3RhdGlvblBlclNlY29uZFwiLHZvaWQgMCkscn0pKCh0PT57dmFyIGUsbixpO2NsYXNzIHIgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmVudmlyb25tZW50SW1hZ2U9bnVsbCx0aGlzLnNreWJveEltYWdlPW51bGwsdGhpcy5zaGFkb3dJbnRlbnNpdHk9MCx0aGlzLnNoYWRvd1NvZnRuZXNzPTEsdGhpcy5leHBvc3VyZT0xLHRoaXNbZV09bnVsbCx0aGlzW25dPW51bGwsdGhpc1tpXT10PT57dC5lbGVtZW50PT09dGhpcyYmdGhpc1tPdV0oKX19Y29ubmVjdGVkQ2FsbGJhY2soKXtzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpLHRoaXNbdnBdLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKFwicHJlbG9hZFwiLHRoaXNba3VdKX1kaXNjb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCksdGhpc1t2cF0ubG9hZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcmVsb2FkXCIsdGhpc1trdV0pfXVwZGF0ZWQodCl7c3VwZXIudXBkYXRlZCh0KSx0LmhhcyhcInNoYWRvd0ludGVuc2l0eVwiKSYmKHRoaXNbZHBdLnNldFNoYWRvd0ludGVuc2l0eSguMSp0aGlzLnNoYWRvd0ludGVuc2l0eSksdGhpc1twcF0oKSksdC5oYXMoXCJzaGFkb3dTb2Z0bmVzc1wiKSYmKHRoaXNbZHBdLnNldFNoYWRvd1NvZnRuZXNzKHRoaXMuc2hhZG93U29mdG5lc3MpLHRoaXNbcHBdKCkpLHQuaGFzKFwiZXhwb3N1cmVcIikmJih0aGlzW2RwXS5leHBvc3VyZT10aGlzLmV4cG9zdXJlLHRoaXNbcHBdKCkpLCh0LmhhcyhcImVudmlyb25tZW50SW1hZ2VcIil8fHQuaGFzKFwic2t5Ym94SW1hZ2VcIikpJiZ0aGlzW3dwXSgpJiZ0aGlzW091XSgpfVsoZT1OdSxuPVV1LGk9a3UsZnApXSgpe3N1cGVyW2ZwXSgpLG51bGwhPXRoaXNbTnVdJiZ0aGlzW0Z1XSh0aGlzW051XSl9YXN5bmNbT3VdKCl7Y29uc3R7c2t5Ym94SW1hZ2U6dCxlbnZpcm9ubWVudEltYWdlOmV9PXRoaXM7bnVsbCE9dGhpc1tVdV0mJih0aGlzW1V1XSgpLHRoaXNbVXVdPW51bGwpO2NvbnN0e3RleHR1cmVVdGlsczpufT10aGlzW3ZwXTtpZihudWxsIT1uKXRyeXtjb25zdHtlbnZpcm9ubWVudE1hcDppLHNreWJveDpyfT1hd2FpdCBuZXcgUHJvbWlzZSgoYXN5bmMoaSxyKT0+e2NvbnN0IHM9bi5nZW5lcmF0ZUVudmlyb25tZW50TWFwQW5kU2t5Ym94KHFoKHQpLGUse3Byb2dyZXNzVHJhY2tlcjp0aGlzW3lwXX0pO3RoaXNbVXVdPSgpPT5yKHMpLGkoYXdhaXQgcyl9KSk7dGhpc1tkcF0uYmFja2dyb3VuZD1udWxsIT1yP3IubmFtZT09PWkubmFtZT9pOnI6bnVsbCx0aGlzW0Z1XShpKSx0aGlzW2RwXS5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZW52bWFwLXVwZGF0ZVwifSl9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIEVycm9yKXRocm93IHRoaXNbRnVdKG51bGwpLHR9fVtGdV0odCl7dGhpc1tkcF0uZW52aXJvbm1lbnQhPT10JiYodGhpc1tOdV09dCx0aGlzW2RwXS5lbnZpcm9ubWVudD10aGlzW051XSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiZW52aXJvbm1lbnQtY2hhbmdlXCIpKSx0aGlzW3BwXSgpKX19cmV0dXJuIER1KFtaKHt0eXBlOlN0cmluZyxhdHRyaWJ1dGU6XCJlbnZpcm9ubWVudC1pbWFnZVwifSldLHIucHJvdG90eXBlLFwiZW52aXJvbm1lbnRJbWFnZVwiLHZvaWQgMCksRHUoW1ooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcInNreWJveC1pbWFnZVwifSldLHIucHJvdG90eXBlLFwic2t5Ym94SW1hZ2VcIix2b2lkIDApLER1KFtaKHt0eXBlOk51bWJlcixhdHRyaWJ1dGU6XCJzaGFkb3ctaW50ZW5zaXR5XCJ9KV0sci5wcm90b3R5cGUsXCJzaGFkb3dJbnRlbnNpdHlcIix2b2lkIDApLER1KFtaKHt0eXBlOk51bWJlcixhdHRyaWJ1dGU6XCJzaGFkb3ctc29mdG5lc3NcIn0pXSxyLnByb3RvdHlwZSxcInNoYWRvd1NvZnRuZXNzXCIsdm9pZCAwKSxEdShbWih7dHlwZTpOdW1iZXJ9KV0sci5wcm90b3R5cGUsXCJleHBvc3VyZVwiLHZvaWQgMCkscn0pKCh0PT57dmFyIGUsbixpLHIscyxhLG8sbCxjLGgsdSxkLHAsbSxmLGcsdjtjbGFzcyB5IGV4dGVuZHMgdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jYW1lcmFDb250cm9scz0hMSx0aGlzLmNhbWVyYU9yYml0PVwiMGRlZyA3NWRlZyAxMDUlXCIsdGhpcy5jYW1lcmFUYXJnZXQ9XCJhdXRvIGF1dG8gYXV0b1wiLHRoaXMuZmllbGRPZlZpZXc9XCJhdXRvXCIsdGhpcy5taW5DYW1lcmFPcmJpdD1cImF1dG9cIix0aGlzLm1heENhbWVyYU9yYml0PVwiYXV0b1wiLHRoaXMubWluRmllbGRPZlZpZXc9XCJhdXRvXCIsdGhpcy5tYXhGaWVsZE9mVmlldz1cImF1dG9cIix0aGlzLmludGVyYWN0aW9uUHJvbXB0VGhyZXNob2xkPTNlMyx0aGlzLmludGVyYWN0aW9uUHJvbXB0U3R5bGU9ZGcsdGhpcy5pbnRlcmFjdGlvblByb21wdD1oZyx0aGlzLmludGVyYWN0aW9uUG9saWN5PXBnLHRoaXMub3JiaXRTZW5zaXRpdml0eT0xLHRoaXMudG91Y2hBY3Rpb249bWcsdGhpcy5kaXNhYmxlWm9vbT0hMSx0aGlzLmludGVycG9sYXRpb25EZWNheT01MCx0aGlzLmJvdW5kcz1cImxlZ2FjeVwiLHRoaXNbZV09dGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIuaW50ZXJhY3Rpb24tcHJvbXB0XCIpLHRoaXNbbl09dGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIuaW50ZXJhY3Rpb24tcHJvbXB0ID4gLmFuaW1hdGVkLWNvbnRhaW5lclwiKSx0aGlzW2ldPTEvMCx0aGlzW3JdPTAsdGhpc1tzXT0xLzAsdGhpc1thXT0hMSx0aGlzW29dPSExLHRoaXNbbF09bmV3IHRnKHRoaXNbZHBdLmNhbWVyYSx0aGlzW2hwXSksdGhpc1tjXT0wLHRoaXNbaF09bmV3IG5jLHRoaXNbdV09ITEsdGhpc1tkXT0hMSx0aGlzW3BdPSExLHRoaXNbbV09KCk9Pntjb25zdCB0PXRoaXNbaHBdO2lzRmluaXRlKHRoaXNbQmddKXx8KHRoaXNbQmddPXBlcmZvcm1hbmNlLm5vdygpKTtjb25zdCBlPXRoaXNbc3BdO3QuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSE9PWUmJnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLGUpLHRoaXMuaW50ZXJhY3Rpb25Qcm9tcHQhPT11Z3x8dGhpc1tVZ118fCh0aGlzW09nXT0hMCl9LHRoaXNbZl09KCk9Pnt0aGlzLmludGVyYWN0aW9uUHJvbXB0PT09dWcmJih0aGlzW09nXT0hMSx0aGlzW0FnXS5jbGFzc0xpc3QucmVtb3ZlKFwidmlzaWJsZVwiKSx0aGlzW2tnXT0xLzAsdGhpc1tCZ109MS8wKX0sdGhpc1tnXT0oe3NvdXJjZTp0fSk9Pnt0aGlzW0NnXSgpLHRoaXNbcHBdKCksdD09PUtmJiYodGhpc1tVZ109ITAsdGhpc1tSZ10oKSksdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNhbWVyYS1jaGFuZ2VcIix7ZGV0YWlsOntzb3VyY2U6dH19KSl9LHRoaXNbdl09dD0+e1wicG9pbnRlci1jaGFuZ2Utc3RhcnRcIj09PXQudHlwZT90aGlzW2NwXS5jbGFzc0xpc3QuYWRkKFwicG9pbnRlci10dW1ibGluZ1wiKTp0aGlzW2NwXS5jbGFzc0xpc3QucmVtb3ZlKFwicG9pbnRlci10dW1ibGluZ1wiKX19Z2V0Q2FtZXJhT3JiaXQoKXtjb25zdHt0aGV0YTp0LHBoaTplLHJhZGl1czpufT10aGlzW1ZnXTtyZXR1cm57dGhldGE6dCxwaGk6ZSxyYWRpdXM6bix0b1N0cmluZygpe3JldHVybmAke3RoaXMudGhldGF9cmFkICR7dGhpcy5waGl9cmFkICR7dGhpcy5yYWRpdXN9bWB9fX1nZXRDYW1lcmFUYXJnZXQoKXtyZXR1cm4gU3AodGhpc1t2cF0uaXNQcmVzZW50aW5nP3RoaXNbdnBdLmFyUmVuZGVyZXIudGFyZ2V0OnRoaXNbZHBdLmdldFRhcmdldCgpKX1nZXRGaWVsZE9mVmlldygpe3JldHVybiB0aGlzW0VnXS5nZXRGaWVsZE9mVmlldygpfWdldE1pbmltdW1GaWVsZE9mVmlldygpe3JldHVybiB0aGlzW0VnXS5vcHRpb25zLm1pbmltdW1GaWVsZE9mVmlld31nZXRNYXhpbXVtRmllbGRPZlZpZXcoKXtyZXR1cm4gdGhpc1tFZ10ub3B0aW9ucy5tYXhpbXVtRmllbGRPZlZpZXd9anVtcENhbWVyYVRvR29hbCgpe3RoaXNbR2ddPSEwLHRoaXMucmVxdWVzdFVwZGF0ZShHZywhMSl9cmVzZXRJbnRlcmFjdGlvblByb21wdCgpe3RoaXNbemddPTAsdGhpc1trZ109MS8wLHRoaXNbVWddPSExLHRoaXNbT2ddPXRoaXMuaW50ZXJhY3Rpb25Qcm9tcHQ9PT1oZyYmdGhpcy5jYW1lcmFDb250cm9sc31jb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCksdGhpc1tFZ10uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLHRoaXNbTmddKSx0aGlzW0VnXS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlci1jaGFuZ2Utc3RhcnRcIix0aGlzW0ZnXSksdGhpc1tFZ10uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXItY2hhbmdlLWVuZFwiLHRoaXNbRmddKX1kaXNjb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCksdGhpc1tFZ10ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLHRoaXNbTmddKSx0aGlzW0VnXS5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlci1jaGFuZ2Utc3RhcnRcIix0aGlzW0ZnXSksdGhpc1tFZ10ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXItY2hhbmdlLWVuZFwiLHRoaXNbRmddKX11cGRhdGVkKHQpe3N1cGVyLnVwZGF0ZWQodCk7Y29uc3QgZT10aGlzW0VnXSxuPXRoaXNbaHBdO2lmKHQuaGFzKFwiY2FtZXJhQ29udHJvbHNcIikmJih0aGlzLmNhbWVyYUNvbnRyb2xzPyhlLmVuYWJsZUludGVyYWN0aW9uKCksdGhpcy5pbnRlcmFjdGlvblByb21wdD09PWhnJiYodGhpc1tPZ109ITApLG4uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpc1tEZ10pLG4uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzW0lnXSkpOihuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXNbRGddKSxuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpc1tJZ10pLGUuZGlzYWJsZUludGVyYWN0aW9uKCksdGhpc1tSZ10oKSkpLHQuaGFzKFwiZGlzYWJsZVpvb21cIikmJihlLmRpc2FibGVab29tPXRoaXMuZGlzYWJsZVpvb20pLHQuaGFzKFwiYm91bmRzXCIpJiYodGhpc1tkcF0udGlnaHRCb3VuZHM9XCJ0aWdodFwiPT09dGhpcy5ib3VuZHMpLCh0LmhhcyhcImludGVyYWN0aW9uUHJvbXB0XCIpfHx0LmhhcyhcImNhbWVyYUNvbnRyb2xzXCIpfHx0LmhhcyhcInNyY1wiKSkmJih0aGlzLmludGVyYWN0aW9uUHJvbXB0PT09aGcmJnRoaXMuY2FtZXJhQ29udHJvbHMmJiF0aGlzW1VnXT90aGlzW09nXT0hMDp0aGlzW1JnXSgpKSx0LmhhcyhcImludGVyYWN0aW9uUHJvbXB0U3R5bGVcIikmJnRoaXNbQWddLmNsYXNzTGlzdC50b2dnbGUoXCJ3aWdnbGVcIix0aGlzLmludGVyYWN0aW9uUHJvbXB0U3R5bGU9PT1kZyksdC5oYXMoXCJpbnRlcmFjdGlvblBvbGljeVwiKSl7Y29uc3QgdD10aGlzLmludGVyYWN0aW9uUG9saWN5O2UuYXBwbHlPcHRpb25zKHtpbnRlcmFjdGlvblBvbGljeTp0fSl9aWYodC5oYXMoXCJ0b3VjaEFjdGlvblwiKSl7Y29uc3QgdD10aGlzLnRvdWNoQWN0aW9uO2UuYXBwbHlPcHRpb25zKHt0b3VjaEFjdGlvbjp0fSksZS51cGRhdGVUb3VjaEFjdGlvblN0eWxlKCl9dC5oYXMoXCJvcmJpdFNlbnNpdGl2aXR5XCIpJiYoZS5zZW5zaXRpdml0eT10aGlzLm9yYml0U2Vuc2l0aXZpdHkpLHQuaGFzKFwiaW50ZXJwb2xhdGlvbkRlY2F5XCIpJiYoZS5zZXREYW1wZXJEZWNheVRpbWUodGhpcy5pbnRlcnBvbGF0aW9uRGVjYXkpLHRoaXNbZHBdLnNldFRhcmdldERhbXBlckRlY2F5VGltZSh0aGlzLmludGVycG9sYXRpb25EZWNheSkpLCEwPT09dGhpc1tHZ10mJlByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCgpPT57ZS5qdW1wVG9Hb2FsKCksdGhpc1tkcF0uanVtcFRvR29hbCgpLHRoaXNbR2ddPSExfSkpfWFzeW5jIHVwZGF0ZUZyYW1pbmcoKXtjb25zdCB0PXRoaXNbZHBdLGU9dC5mcmFtZWRGaWVsZE9mVmlldzthd2FpdCB0aGlzLnJlcXVlc3RVcGRhdGUoXCJjYW1lcmFUYXJnZXRcIiksdC51cGRhdGVGcmFtaW5nKFwidGlnaHRcIj09PXRoaXMuYm91bmRzP3QuZ2V0VGFyZ2V0KCk6dm9pZCAwKSx0LmZyYW1lTW9kZWwoKTtjb25zdCBuPXQuZnJhbWVkRmllbGRPZlZpZXcsaT10aGlzW0VnXS5nZXRGaWVsZE9mVmlldygpL2U7dGhpc1tIZ109bippLHRoaXNbamddPSEwLHRoaXMucmVxdWVzdFVwZGF0ZShcIm1heEZpZWxkT2ZWaWV3XCIpLHRoaXMucmVxdWVzdFVwZGF0ZShcImZpZWxkT2ZWaWV3XCIpLHRoaXMucmVxdWVzdFVwZGF0ZShcIm1pbkNhbWVyYU9yYml0XCIpLHRoaXMucmVxdWVzdFVwZGF0ZShcIm1heENhbWVyYU9yYml0XCIpLGF3YWl0IHRoaXMucmVxdWVzdFVwZGF0ZShcImNhbWVyYU9yYml0XCIpfVsoZT1BZyxuPUxnLGk9Qmcscj16ZyxzPWtnLGE9VWcsbz1PZyxsPUVnLGM9SGcsaD1WZyx1PUdnLGQ9V2cscD1qZyxYZyldKHQpe3RoaXNbRWddLnNldEZpZWxkT2ZWaWV3KDE4MCp0WzBdL01hdGguUEkpfVtxZ10odCl7aWYodGhpc1tqZ10pe2NvbnN0e3RoZXRhOmUscGhpOm59PXRoaXMuZ2V0Q2FtZXJhT3JiaXQoKTt0WzBdPWUsdFsxXT1uLHRoaXNbamddPSExfXRoaXNbRWddLnNldE9yYml0KHRbMF0sdFsxXSx0WzJdKX1bWmddKHQpe3RoaXNbRWddLmFwcGx5T3B0aW9ucyh7bWluaW11bUF6aW11dGhhbEFuZ2xlOnRbMF0sbWluaW11bVBvbGFyQW5nbGU6dFsxXSxtaW5pbXVtUmFkaXVzOnRbMl19KSx0aGlzLmp1bXBDYW1lcmFUb0dvYWwoKX1bSmddKHQpe3RoaXNbRWddLmFwcGx5T3B0aW9ucyh7bWF4aW11bUF6aW11dGhhbEFuZ2xlOnRbMF0sbWF4aW11bVBvbGFyQW5nbGU6dFsxXSxtYXhpbXVtUmFkaXVzOnRbMl19KSx0aGlzW1BnXSh0WzJdKSx0aGlzLmp1bXBDYW1lcmFUb0dvYWwoKX1bJGddKHQpe3RoaXNbRWddLmFwcGx5T3B0aW9ucyh7bWluaW11bUZpZWxkT2ZWaWV3OjE4MCp0WzBdL01hdGguUEl9KSx0aGlzLmp1bXBDYW1lcmFUb0dvYWwoKX1bS2ddKHQpe3RoaXNbRWddLmFwcGx5T3B0aW9ucyh7bWF4aW11bUZpZWxkT2ZWaWV3OjE4MCp0WzBdL01hdGguUEl9KSx0aGlzLmp1bXBDYW1lcmFUb0dvYWwoKX1bWWddKHQpe2NvbnN0W2UsbixpXT10O3RoaXNbZHBdLnNldFRhcmdldChlLG4saSksdGhpc1t2cF0uYXJSZW5kZXJlci51cGRhdGVUYXJnZXQoKX1bbXBdKHQsZSl7aWYoc3VwZXJbbXBdKHQsZSksdGhpc1t2cF0uaXNQcmVzZW50aW5nfHwhdGhpc1tNcF0oKSlyZXR1cm47Y29uc3Qgbj1wZXJmb3JtYW5jZS5ub3coKTtpZih0aGlzW09nXSl7Y29uc3QgdD10aGlzLmludGVyYWN0aW9uUHJvbXB0PT09aGc/dGhpc1thcF06dGhpc1tCZ107dGhpcy5sb2FkZWQmJm4+dCt0aGlzLmludGVyYWN0aW9uUHJvbXB0VGhyZXNob2xkJiYodGhpc1tocF0uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLFwiVXNlIG1vdXNlLCB0b3VjaCBvciBhcnJvdyBrZXlzIHRvIGNvbnRyb2wgdGhlIGNhbWVyYSFcIiksdGhpc1tPZ109ITEsdGhpc1trZ109bix0aGlzW0FnXS5jbGFzc0xpc3QuYWRkKFwidmlzaWJsZVwiKSl9aWYoaXNGaW5pdGUodGhpc1trZ10pJiZ0aGlzLmludGVyYWN0aW9uUHJvbXB0U3R5bGU9PT1kZyl7Y29uc3QgdD10aGlzW2RwXSxlPShuLXRoaXNba2ddKS81ZTMlMSxpPXNnKGUpLHI9YWcoZSk7aWYodGhpc1tMZ10uc3R5bGUub3BhY2l0eT1gJHtyfWAsaSE9PXRoaXNbemddKXtjb25zdCBlPWkqdC53aWR0aCouMDUsbj0oaS10aGlzW3pnXSkqTWF0aC5QSS8xNjt0aGlzW0xnXS5zdHlsZS50cmFuc2Zvcm09YHRyYW5zbGF0ZVgoJHtlfXB4KWAsdGhpc1tFZ10uYWRqdXN0T3JiaXQobiwwLDApLHRoaXNbemddPWl9fXRoaXNbRWddLnVwZGF0ZSh0LGUpLHRoaXNbZHBdLnVwZGF0ZVRhcmdldChlKX1bUmddKCl7dGhpc1tPZ109ITEsdGhpc1tBZ10uY2xhc3NMaXN0LnJlbW92ZShcInZpc2libGVcIiksdGhpc1trZ109MS8wfVtQZ10odCl7Y29uc3R7aWRlYWxDYW1lcmFEaXN0YW5jZTplfT10aGlzW2RwXSxuPTIqTWF0aC5tYXgoZSx0KTt0aGlzW0VnXS51cGRhdGVOZWFyRmFyKDAsbil9W0NnXSgpe2NvbnN0e3RoZXRhOnQscGhpOmV9PXRoaXNbVmddLHt0aGV0YTpuLHBoaTppfT10aGlzW0VnXS5nZXRDYW1lcmFTcGhlcmljYWwodGhpc1tWZ10pLHI9dGhpcy5nZXRSb290Tm9kZSgpO2lmKG51bGwhPXImJnIuYWN0aXZlRWxlbWVudD09PXRoaXMpe2NvbnN0IHI9KDQrTWF0aC5mbG9vcigodCVUZytTZykvX2cpKSU0LHM9KDQrTWF0aC5mbG9vcigobiVUZytTZykvX2cpKSU0LGE9TWF0aC5mbG9vcihlL01nKSxvPU1hdGguZmxvb3IoaS9NZyk7aWYocyE9PXJ8fG8hPT1hKXtjb25zdCB0PWBWaWV3IGZyb20gc3RhZ2UgJHtjZ1tvXX0ke2xnW3NdfWA7dGhpc1tocF0uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLHQpfX19W2dwXSh0KXtjb25zdCBlPXRoaXNbRWddLG49dGhpc1tkcF0uZnJhbWVkRmllbGRPZlZpZXc7c3VwZXJbZ3BdKHQpO2NvbnN0IGk9dGhpc1tkcF0uZnJhbWVkRmllbGRPZlZpZXcscj1lLmdldEZpZWxkT2ZWaWV3KCkvbjt0aGlzW0hnXT1pKnIsZS51cGRhdGVBc3BlY3QodGhpc1tkcF0uYXNwZWN0KSx0aGlzLnJlcXVlc3RVcGRhdGUoXCJtYXhGaWVsZE9mVmlld1wiLHRoaXMubWF4RmllbGRPZlZpZXcpLHRoaXMucmVxdWVzdFVwZGF0ZShcImZpZWxkT2ZWaWV3XCIsdGhpcy5maWVsZE9mVmlldyksdGhpcy5qdW1wQ2FtZXJhVG9Hb2FsKCl9W2ZwXSgpe3N1cGVyW2ZwXSgpO2NvbnN0e2ZyYW1lZEZpZWxkT2ZWaWV3OnR9PXRoaXNbZHBdO3RoaXNbSGddPXQsdGhpc1tXZ10/dGhpc1tqZ109ITA6dGhpc1tXZ109ITAsdGhpcy5yZXF1ZXN0VXBkYXRlKFwibWF4RmllbGRPZlZpZXdcIix0aGlzLm1heEZpZWxkT2ZWaWV3KSx0aGlzLnJlcXVlc3RVcGRhdGUoXCJmaWVsZE9mVmlld1wiLHRoaXMuZmllbGRPZlZpZXcpLHRoaXMucmVxdWVzdFVwZGF0ZShcIm1pbkNhbWVyYU9yYml0XCIsdGhpcy5taW5DYW1lcmFPcmJpdCksdGhpcy5yZXF1ZXN0VXBkYXRlKFwibWF4Q2FtZXJhT3JiaXRcIix0aGlzLm1heENhbWVyYU9yYml0KSx0aGlzLnJlcXVlc3RVcGRhdGUoXCJjYW1lcmFPcmJpdFwiLHRoaXMuY2FtZXJhT3JiaXQpLHRoaXMucmVxdWVzdFVwZGF0ZShcImNhbWVyYVRhcmdldFwiLHRoaXMuY2FtZXJhVGFyZ2V0KSx0aGlzLmp1bXBDYW1lcmFUb0dvYWwoKX19cmV0dXJuIG09RGcsZj1JZyxnPU5nLHY9RmcscmcoW1ooe3R5cGU6Qm9vbGVhbixhdHRyaWJ1dGU6XCJjYW1lcmEtY29udHJvbHNcIn0pXSx5LnByb3RvdHlwZSxcImNhbWVyYUNvbnRyb2xzXCIsdm9pZCAwKSxyZyhbR2Yoe2ludHJpbnNpY3M6eWcsb2JzZXJ2ZUVmZmVjdHM6ITAsdXBkYXRlSGFuZGxlcjpxZ30pLFooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcImNhbWVyYS1vcmJpdFwiLGhhc0NoYW5nZWQ6KCk9PiEwfSldLHkucHJvdG90eXBlLFwiY2FtZXJhT3JiaXRcIix2b2lkIDApLHJnKFtHZih7aW50cmluc2ljczp3ZyxvYnNlcnZlRWZmZWN0czohMCx1cGRhdGVIYW5kbGVyOllnfSksWih7dHlwZTpTdHJpbmcsYXR0cmlidXRlOlwiY2FtZXJhLXRhcmdldFwiLGhhc0NoYW5nZWQ6KCk9PiEwfSldLHkucHJvdG90eXBlLFwiY2FtZXJhVGFyZ2V0XCIsdm9pZCAwKSxyZyhbR2Yoe2ludHJpbnNpY3M6Zmcsb2JzZXJ2ZUVmZmVjdHM6ITAsdXBkYXRlSGFuZGxlcjpYZ30pLFooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcImZpZWxkLW9mLXZpZXdcIixoYXNDaGFuZ2VkOigpPT4hMH0pXSx5LnByb3RvdHlwZSxcImZpZWxkT2ZWaWV3XCIsdm9pZCAwKSxyZyhbR2Yoe2ludHJpbnNpY3M6eGcsdXBkYXRlSGFuZGxlcjpaZ30pLFooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcIm1pbi1jYW1lcmEtb3JiaXRcIixoYXNDaGFuZ2VkOigpPT4hMH0pXSx5LnByb3RvdHlwZSxcIm1pbkNhbWVyYU9yYml0XCIsdm9pZCAwKSxyZyhbR2Yoe2ludHJpbnNpY3M6YmcsdXBkYXRlSGFuZGxlcjpKZ30pLFooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcIm1heC1jYW1lcmEtb3JiaXRcIixoYXNDaGFuZ2VkOigpPT4hMH0pXSx5LnByb3RvdHlwZSxcIm1heENhbWVyYU9yYml0XCIsdm9pZCAwKSxyZyhbR2Yoe2ludHJpbnNpY3M6Z2csdXBkYXRlSGFuZGxlcjokZ30pLFooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcIm1pbi1maWVsZC1vZi12aWV3XCIsaGFzQ2hhbmdlZDooKT0+ITB9KV0seS5wcm90b3R5cGUsXCJtaW5GaWVsZE9mVmlld1wiLHZvaWQgMCkscmcoW0dmKHtpbnRyaW5zaWNzOnZnLHVwZGF0ZUhhbmRsZXI6S2d9KSxaKHt0eXBlOlN0cmluZyxhdHRyaWJ1dGU6XCJtYXgtZmllbGQtb2Ytdmlld1wiLGhhc0NoYW5nZWQ6KCk9PiEwfSldLHkucHJvdG90eXBlLFwibWF4RmllbGRPZlZpZXdcIix2b2lkIDApLHJnKFtaKHt0eXBlOk51bWJlcixhdHRyaWJ1dGU6XCJpbnRlcmFjdGlvbi1wcm9tcHQtdGhyZXNob2xkXCJ9KV0seS5wcm90b3R5cGUsXCJpbnRlcmFjdGlvblByb21wdFRocmVzaG9sZFwiLHZvaWQgMCkscmcoW1ooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcImludGVyYWN0aW9uLXByb21wdC1zdHlsZVwifSldLHkucHJvdG90eXBlLFwiaW50ZXJhY3Rpb25Qcm9tcHRTdHlsZVwiLHZvaWQgMCkscmcoW1ooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcImludGVyYWN0aW9uLXByb21wdFwifSldLHkucHJvdG90eXBlLFwiaW50ZXJhY3Rpb25Qcm9tcHRcIix2b2lkIDApLHJnKFtaKHt0eXBlOlN0cmluZyxhdHRyaWJ1dGU6XCJpbnRlcmFjdGlvbi1wb2xpY3lcIn0pXSx5LnByb3RvdHlwZSxcImludGVyYWN0aW9uUG9saWN5XCIsdm9pZCAwKSxyZyhbWih7dHlwZTpOdW1iZXIsYXR0cmlidXRlOlwib3JiaXQtc2Vuc2l0aXZpdHlcIn0pXSx5LnByb3RvdHlwZSxcIm9yYml0U2Vuc2l0aXZpdHlcIix2b2lkIDApLHJnKFtaKHt0eXBlOlN0cmluZyxhdHRyaWJ1dGU6XCJ0b3VjaC1hY3Rpb25cIn0pXSx5LnByb3RvdHlwZSxcInRvdWNoQWN0aW9uXCIsdm9pZCAwKSxyZyhbWih7dHlwZTpCb29sZWFuLGF0dHJpYnV0ZTpcImRpc2FibGUtem9vbVwifSldLHkucHJvdG90eXBlLFwiZGlzYWJsZVpvb21cIix2b2lkIDApLHJnKFtaKHt0eXBlOk51bWJlcixhdHRyaWJ1dGU6XCJpbnRlcnBvbGF0aW9uLWRlY2F5XCJ9KV0seS5wcm90b3R5cGUsXCJpbnRlcnBvbGF0aW9uRGVjYXlcIix2b2lkIDApLHJnKFtaKHt0eXBlOlN0cmluZyxhdHRyaWJ1dGU6XCJib3VuZHNcIn0pXSx5LnByb3RvdHlwZSxcImJvdW5kc1wiLHZvaWQgMCkseX0pKCh0PT57dmFyIGUsbixpLHIscyxhLG8sbCxjLGg7Y2xhc3MgdSBleHRlbmRzIHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuYXI9ITEsdGhpcy5hclNjYWxlPVwiYXV0b1wiLHRoaXMuYXJQbGFjZW1lbnQ9XCJmbG9vclwiLHRoaXMuYXJNb2Rlcz1cIndlYnhyIHNjZW5lLXZpZXdlclwiLHRoaXMuaW9zU3JjPW51bGwsdGhpcy54ckVudmlyb25tZW50PSExLHRoaXNbZV09ITEsdGhpc1tuXT10aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5hci1idXR0b25cIiksdGhpc1tpXT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSx0aGlzW3JdPW5ldyBTZXQsdGhpc1tzXT1HbSx0aGlzW2FdPSExLHRoaXNbb109dD0+e3QucHJldmVudERlZmF1bHQoKSx0aGlzLmFjdGl2YXRlQVIoKX0sdGhpc1tsXT0oe3N0YXR1czp0fSk9Pnt0IT09anUmJnRoaXNbdnBdLmFyUmVuZGVyZXIucHJlc2VudGVkU2NlbmUhPT10aGlzW2RwXXx8KHRoaXMuc2V0QXR0cmlidXRlKFwiYXItc3RhdHVzXCIsdCksdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImFyLXN0YXR1c1wiLHtkZXRhaWw6e3N0YXR1czp0fX0pKSx0PT09anU/dGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJhci10cmFja2luZ1wiKTp0PT09cXUmJnRoaXMuc2V0QXR0cmlidXRlKFwiYXItdHJhY2tpbmdcIixadSkpfSx0aGlzW2NdPSh7c3RhdHVzOnR9KT0+e3RoaXMuc2V0QXR0cmlidXRlKFwiYXItdHJhY2tpbmdcIix0KSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiYXItdHJhY2tpbmdcIix7ZGV0YWlsOntzdGF0dXM6dH19KSl9LHRoaXNbaF09dD0+e1wiX2FwcGxlX2FyX3F1aWNrbG9va19idXR0b25fdGFwcGVkXCI9PXQuZGF0YSYmdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInF1aWNrLWxvb2stYnV0dG9uLXRhcHBlZFwiKSl9fWdldCBjYW5BY3RpdmF0ZUFSKCl7cmV0dXJuIHRoaXNbWm1dIT09R219Y29ubmVjdGVkQ2FsbGJhY2soKXtzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpLHRoaXNbdnBdLmFyUmVuZGVyZXIuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXR1c1wiLHRoaXNbdGZdKSx0aGlzLnNldEF0dHJpYnV0ZShcImFyLXN0YXR1c1wiLGp1KSx0aGlzW3ZwXS5hclJlbmRlcmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFja2luZ1wiLHRoaXNbZWZdKSx0aGlzWyRtXS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXNbbmZdKX1kaXNjb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCksdGhpc1t2cF0uYXJSZW5kZXJlci5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhdHVzXCIsdGhpc1t0Zl0pLHRoaXNbdnBdLmFyUmVuZGVyZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYWNraW5nXCIsdGhpc1tlZl0pLHRoaXNbJG1dLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpc1tuZl0pfWFzeW5jIHVwZGF0ZSh0KXtzdXBlci51cGRhdGUodCksdC5oYXMoXCJhclNjYWxlXCIpJiYodGhpc1tkcF0uY2FuU2NhbGU9XCJmaXhlZFwiIT09dGhpcy5hclNjYWxlKSx0LmhhcyhcImFyUGxhY2VtZW50XCIpJiYodGhpc1tkcF0udXBkYXRlU2hhZG93KCksdGhpc1twcF0oKSksKHQuaGFzKFwiYXJcIil8fHQuaGFzKFwiYXJNb2Rlc1wiKXx8dC5oYXMoXCJpb3NTcmNcIikpJiYodC5oYXMoXCJhck1vZGVzXCIpJiYodGhpc1tKbV09a20odGhpcy5hck1vZGVzKSksdGhpc1tyZl0oKSl9YXN5bmMgYWN0aXZhdGVBUigpe3N3aXRjaCh0aGlzW1ptXSl7Y2FzZSBCbTp0aGlzW1htXSgpO2JyZWFrO2Nhc2UgVm06YXdhaXQgdGhpc1tqbV0oKTticmVhaztjYXNlIEhtOnRoaXNbcW1dKCk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLndhcm4oXCJObyBBUiBNb2RlIGNhbiBiZSBhY3RpdmF0ZWQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIG1pc3NpbmcgY29uZmlndXJhdGlvbiBvciBkZXZpY2UgY2FwYWJpbGl0aWVzXCIpfX1hc3luY1soZT1ZbSxuPVdtLGk9JG0scj1KbSxzPVptLGE9S20sbz1RbSxsPXRmLGM9ZWYsaD1uZixyZildKCl7aWYodGhpc1tabV09R20sdGhpcy5hcil7aWYobnVsbCE9dGhpcy5zcmMpZm9yKGNvbnN0IHQgb2YgdGhpc1tKbV0pe2lmKFwid2VieHJcIj09PXQmJnN0JiYhT20mJmF3YWl0IHRoaXNbdnBdLmFyUmVuZGVyZXIuc3VwcG9ydHNQcmVzZW50YXRpb24oKSl7dGhpc1tabV09Vm07YnJlYWt9aWYoXCJzY2VuZS12aWV3ZXJcIj09PXQmJnV0JiYhVW0pe3RoaXNbWm1dPUhtO2JyZWFrfWlmKFwicXVpY2stbG9va1wiPT09dCYmbHQpe3RoaXNbWm1dPUJtO2JyZWFrfX0hdGhpcy5jYW5BY3RpdmF0ZUFSJiZudWxsIT10aGlzLmlvc1NyYyYmbHQmJih0aGlzW1ptXT1CbSl9aWYodGhpcy5jYW5BY3RpdmF0ZUFSKXRoaXNbV21dLmNsYXNzTGlzdC5hZGQoXCJlbmFibGVkXCIpLHRoaXNbV21dLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXNbUW1dKTtlbHNlIGlmKHRoaXNbV21dLmNsYXNzTGlzdC5jb250YWlucyhcImVuYWJsZWRcIikpe3RoaXNbV21dLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXNbUW1dKSx0aGlzW1dtXS5jbGFzc0xpc3QucmVtb3ZlKFwiZW5hYmxlZFwiKTtjb25zdCB0PVl1O3RoaXMuc2V0QXR0cmlidXRlKFwiYXItc3RhdHVzXCIsdCksdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImFyLXN0YXR1c1wiLHtkZXRhaWw6e3N0YXR1czp0fX0pKX19YXN5bmNbam1dKCl7Y29uc29sZS5sb2coXCJBdHRlbXB0aW5nIHRvIHByZXNlbnQgaW4gQVIgd2l0aCBXZWJYUi4uLlwiKSxhd2FpdCB0aGlzW3NmXSgpO3RyeXt0aGlzW1dtXS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzW1FtXSk7Y29uc3R7YXJSZW5kZXJlcjp0fT10aGlzW3ZwXTt0LnBsYWNlT25XYWxsPVwid2FsbFwiPT09dGhpcy5hclBsYWNlbWVudCxhd2FpdCB0LnByZXNlbnQodGhpc1tkcF0sdGhpcy54ckVudmlyb25tZW50KX1jYXRjaCh0KXtjb25zb2xlLndhcm4oXCJFcnJvciB3aGlsZSB0cnlpbmcgdG8gcHJlc2VudCBpbiBBUiB3aXRoIFdlYlhSXCIpLGNvbnNvbGUuZXJyb3IodCksYXdhaXQgdGhpc1t2cF0uYXJSZW5kZXJlci5zdG9wUHJlc2VudGluZygpLE9tPSEwLGNvbnNvbGUud2FybihcIkZhbGxpbmcgYmFjayB0byBuZXh0IGFyLW1vZGVcIiksYXdhaXQgdGhpc1tyZl0oKSx0aGlzLmFjdGl2YXRlQVIoKX1maW5hbGx5e3RoaXNbcmZdKCl9fWFzeW5jW3NmXSgpe3RoaXMubG9hZGVkfHwodGhpc1tLbV09ITAsdGhpc1tvcF0oKSxhd2FpdCgodCxlLG49bnVsbCk9Pm5ldyBQcm9taXNlKChpPT57dC5hZGRFdmVudExpc3RlbmVyKGUsKGZ1bmN0aW9uIHIocyl7biYmIW4ocyl8fChpKHMpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHIpKX0pKX0pKSlcbi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8odGhpcyxcImxvYWRcIiksdGhpc1tLbV09ITEpfVt3cF0oKXtyZXR1cm4gc3VwZXJbd3BdKCl8fHRoaXNbS21dfVtxbV0oKXtjb25zdCB0PXNlbGYubG9jYXRpb24udG9TdHJpbmcoKSxlPW5ldyBVUkwodCksbj1uZXcgVVJMKHRoaXMuc3JjLHQpLGk9bmV3IFVSTFNlYXJjaFBhcmFtcyhuLnNlYXJjaCk7aWYoZS5oYXNoPVwiI21vZGVsLXZpZXdlci1uby1hci1mYWxsYmFja1wiLGkuc2V0KFwibW9kZVwiLFwiYXJfcHJlZmVycmVkXCIpLGkuaGFzKFwiZGlzYWJsZV9vY2NsdXNpb25cIil8fGkuc2V0KFwiZGlzYWJsZV9vY2NsdXNpb25cIixcInRydWVcIiksXCJmaXhlZFwiPT09dGhpcy5hclNjYWxlJiZpLnNldChcInJlc2l6YWJsZVwiLFwiZmFsc2VcIiksXCJ3YWxsXCI9PT10aGlzLmFyUGxhY2VtZW50JiZpLnNldChcImVuYWJsZV92ZXJ0aWNhbF9wbGFjZW1lbnRcIixcInRydWVcIiksaS5oYXMoXCJzb3VuZFwiKSl7Y29uc3QgZT1uZXcgVVJMKGkuZ2V0KFwic291bmRcIiksdCk7aS5zZXQoXCJzb3VuZFwiLGUudG9TdHJpbmcoKSl9aWYoaS5oYXMoXCJsaW5rXCIpKXtjb25zdCBlPW5ldyBVUkwoaS5nZXQoXCJsaW5rXCIpLHQpO2kuc2V0KFwibGlua1wiLGUudG9TdHJpbmcoKSl9Y29uc3Qgcj1gaW50ZW50Oi8vYXJ2ci5nb29nbGUuY29tL3NjZW5lLXZpZXdlci8xLjA/JHtpLnRvU3RyaW5nKCkrXCImZmlsZT1cIitlbmNvZGVVUklDb21wb25lbnQobi50b1N0cmluZygpKX0jSW50ZW50O3NjaGVtZT1odHRwcztwYWNrYWdlPWNvbS5nb29nbGUuYXIuY29yZTthY3Rpb249YW5kcm9pZC5pbnRlbnQuYWN0aW9uLlZJRVc7Uy5icm93c2VyX2ZhbGxiYWNrX3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChlLnRvU3RyaW5nKCkpfTtlbmQ7YDtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsKCgpPT57XCIjbW9kZWwtdmlld2VyLW5vLWFyLWZhbGxiYWNrXCI9PT1zZWxmLmxvY2F0aW9uLmhhc2gmJihVbT0hMCxzZWxmLmhpc3RvcnkuYmFjaygpLGNvbnNvbGUud2FybihcIkVycm9yIHdoaWxlIHRyeWluZyB0byBwcmVzZW50IGluIEFSIHdpdGggU2NlbmUgVmlld2VyXCIpLGNvbnNvbGUud2FybihcIkZhbGxpbmcgYmFjayB0byBuZXh0IGFyLW1vZGVcIiksdGhpc1tyZl0oKSl9KSx7b25jZTohMH0pLHRoaXNbJG1dLnNldEF0dHJpYnV0ZShcImhyZWZcIixyKSxjb25zb2xlLmxvZyhcIkF0dGVtcHRpbmcgdG8gcHJlc2VudCBpbiBBUiB3aXRoIFNjZW5lIFZpZXdlci4uLlwiKSx0aGlzWyRtXS5jbGljaygpfWFzeW5jW1htXSgpe2NvbnN0IHQ9IXRoaXMuaW9zU3JjO3RoaXNbV21dLmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO2NvbnN0IGU9dD9hd2FpdCB0aGlzLnByZXBhcmVVU0RaKCk6dGhpcy5pb3NTcmMsbj1uZXcgVVJMKGUsc2VsZi5sb2NhdGlvbi50b1N0cmluZygpKTtcImZpeGVkXCI9PT10aGlzLmFyU2NhbGUmJihuLmhhc2gmJihuLmhhc2grPVwiJlwiKSxuLmhhc2grPVwiYWxsb3dzQ29udGVudFNjYWxpbmc9MFwiKTtjb25zdCBpPXRoaXNbJG1dO2kuc2V0QXR0cmlidXRlKFwicmVsXCIsXCJhclwiKTtjb25zdCByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7aS5hcHBlbmRDaGlsZChyKSxpLnNldEF0dHJpYnV0ZShcImhyZWZcIixuLnRvU3RyaW5nKCkpLHQmJmkuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIixcIm1vZGVsLnVzZHpcIiksY29uc29sZS5sb2coXCJBdHRlbXB0aW5nIHRvIHByZXNlbnQgaW4gQVIgd2l0aCBRdWljayBMb29rLi4uXCIpLGkuY2xpY2soKSxpLnJlbW92ZUNoaWxkKHIpLHQmJlVSTC5yZXZva2VPYmplY3RVUkwoZSksdGhpc1tXbV0uY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIil9YXN5bmMgcHJlcGFyZVVTRFooKXtjb25zdCB0PXRoaXNbeXBdLmJlZ2luQWN0aXZpdHkoKTthd2FpdCB0aGlzW3NmXSgpO2NvbnN0IGU9dGhpc1tkcF0sbj1lLnNoYWRvdztsZXQgaT0hMTtudWxsIT1uJiYoaT1uLnZpc2libGUsbi52aXNpYmxlPSExKSx0KC4yKTtjb25zdCByPW5ldyBBbSxzPWF3YWl0IHIucGFyc2UoZS5tb2RlbENvbnRhaW5lciksYT1uZXcgQmxvYihbc10se3R5cGU6XCJtb2RlbC92bmQudXNkeit6aXBcIn0pLG89VVJMLmNyZWF0ZU9iamVjdFVSTChhKTtyZXR1cm4gdCgxKSxudWxsIT1uJiYobi52aXNpYmxlPWkpLG99fXJldHVybiBGbShbWih7dHlwZTpCb29sZWFuLGF0dHJpYnV0ZTpcImFyXCJ9KV0sdS5wcm90b3R5cGUsXCJhclwiLHZvaWQgMCksRm0oW1ooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcImFyLXNjYWxlXCJ9KV0sdS5wcm90b3R5cGUsXCJhclNjYWxlXCIsdm9pZCAwKSxGbShbWih7dHlwZTpTdHJpbmcsYXR0cmlidXRlOlwiYXItcGxhY2VtZW50XCJ9KV0sdS5wcm90b3R5cGUsXCJhclBsYWNlbWVudFwiLHZvaWQgMCksRm0oW1ooe3R5cGU6U3RyaW5nLGF0dHJpYnV0ZTpcImFyLW1vZGVzXCJ9KV0sdS5wcm90b3R5cGUsXCJhck1vZGVzXCIsdm9pZCAwKSxGbShbWih7dHlwZTpTdHJpbmcsYXR0cmlidXRlOlwiaW9zLXNyY1wifSldLHUucHJvdG90eXBlLFwiaW9zU3JjXCIsdm9pZCAwKSxGbShbWih7dHlwZTpCb29sZWFuLGF0dHJpYnV0ZTpcInhyLWVudmlyb25tZW50XCJ9KV0sdS5wcm90b3R5cGUsXCJ4ckVudmlyb25tZW50XCIsdm9pZCAwKSx1fSkoKHQ9Pnt2YXIgZSxuLGkscixzLGEsbyxsLGMsaCx1LGQscCxtO2NsYXNzIGYgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKC4uLnQpe3N1cGVyKC4uLnQpLHRoaXMucG9zdGVyPW51bGwsdGhpcy5yZXZlYWw9cnYsdGhpcy5sb2FkaW5nPWF2LHRoaXMuZ2VuZXJhdGVTY2hlbWE9ITEsdGhpcy5zZWFtbGVzc1Bvc3Rlcj0hMSx0aGlzW2VdPSExLHRoaXNbbl09ITEsdGhpc1tpXT0wLHRoaXNbcl09bnVsbCx0aGlzW3NdPXRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLnNsb3QucG9zdGVyXCIpLHRoaXNbYV09dGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjZGVmYXVsdC1wb3N0ZXJcIiksdGhpc1tvXT10aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIiNkZWZhdWx0LXByb2dyZXNzLWJhciA+IC5iYXJcIiksdGhpc1tsXT10aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIiNkZWZhdWx0LXByb2dyZXNzLWJhciA+IC5tYXNrXCIpLHRoaXNbY109dGhpc1twdl0uZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSx0aGlzW2hdPSgodCxlKT0+e2xldCBuPW51bGw7Y29uc3QgaT0oLi4uaSk9PntudWxsPT1uJiYodCguLi5pKSxuPXNlbGYuc2V0VGltZW91dCgoKCk9Pm49bnVsbCksZSkpfTtyZXR1cm4gaS5mbHVzaD0oKT0+e251bGwhPW4mJihzZWxmLmNsZWFyVGltZW91dChuKSxuPW51bGwpfSxpfSkoKHQ9Pntjb25zdCBlPXRoaXNbaHZdLnBhcmVudE5vZGU7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKT0+e3RoaXNbdXZdLnN0eWxlLm9wYWNpdHk9XCJcIisuMiooMS10KSx0aGlzW2h2XS5zdHlsZS50cmFuc2Zvcm09YHNjYWxlWCgke3R9KWAsMD09PXQmJihlLnJlbW92ZUNoaWxkKHRoaXNbaHZdKSxlLmFwcGVuZENoaWxkKHRoaXNbaHZdKSksMT09PXQ/dGhpc1todl0uY2xhc3NMaXN0LmFkZChcImhpZGVcIik6dGhpc1todl0uY2xhc3NMaXN0LnJlbW92ZShcImhpZGVcIil9KSl9KSwxMDApLHRoaXNbdV09KCk9Pnt0aGlzLnJldmVhbCE9PXN2JiZ0aGlzLmRpc21pc3NQb3N0ZXIoKX0sdGhpc1tkXT10PT57aWYodGhpcy5yZXZlYWwhPT1zdilzd2l0Y2godC5rZXlDb2RlKXtjYXNlIDMyOmNhc2UgMTM6dGhpcy5kaXNtaXNzUG9zdGVyKCl9fSx0aGlzW3BdPXQ9Pntjb25zdCBlPXQuZGV0YWlsLnRvdGFsUHJvZ3Jlc3M7dGhpc1t5dl09TWF0aC5tYXgoZSx0aGlzW3l2XSksMT09PWUmJih0aGlzW3Z2XS5mbHVzaCgpLCF0aGlzW19wXSgpfHxudWxsPT10aGlzW212XSYmdGhpcy5yZXZlYWwhPT1ydnx8dGhpc1tmdl0oKSksdGhpc1t2dl0oZSksdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInByb2dyZXNzXCIse2RldGFpbDp7dG90YWxQcm9ncmVzczplfX0pKX0sdGhpc1ttXT0oKT0+e3RoaXNbeHZdPSEwO2NvbnN0IHQ9dGhpcy5nZXRSb290Tm9kZSgpO3QmJnQuYWN0aXZlRWxlbWVudD09PXRoaXMmJnRoaXNbaHBdLmZvY3VzKCk7Y29uc3QgZT10aGlzW3B2XTtlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpLGUudGFiSW5kZXg9LTEsdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInBvc3Rlci1kaXNtaXNzZWRcIikpfTtjb25zdCBmPXNlbGYuTW9kZWxWaWV3ZXJFbGVtZW50fHx7fSxnPWYuZHJhY29EZWNvZGVyTG9jYXRpb258fFwiaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vZHJhY28vdmVyc2lvbmVkL2RlY29kZXJzLzEuNC4xL1wiO2toLnNldERSQUNPRGVjb2RlckxvY2F0aW9uKGcpO2NvbnN0IHY9Zi5rdHgyVHJhbnNjb2RlckxvY2F0aW9ufHxcImh0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2Jhc2lzLXVuaXZlcnNhbC92ZXJzaW9uZWQvMjAyMS0wNC0xNS1iYTFjM2U0L1wiO2toLnNldEtUWDJUcmFuc2NvZGVyTG9jYXRpb24odiksZi5tZXNob3B0RGVjb2RlckxvY2F0aW9uJiZraC5zZXRNZXNob3B0RGVjb2RlckxvY2F0aW9uKGYubWVzaG9wdERlY29kZXJMb2NhdGlvbil9c3RhdGljIHNldCBkcmFjb0RlY29kZXJMb2NhdGlvbih0KXtraC5zZXREUkFDT0RlY29kZXJMb2NhdGlvbih0KX1zdGF0aWMgZ2V0IGRyYWNvRGVjb2RlckxvY2F0aW9uKCl7cmV0dXJuIGtoLmdldERSQUNPRGVjb2RlckxvY2F0aW9uKCl9c3RhdGljIHNldCBrdHgyVHJhbnNjb2RlckxvY2F0aW9uKHQpe2toLnNldEtUWDJUcmFuc2NvZGVyTG9jYXRpb24odCl9c3RhdGljIGdldCBrdHgyVHJhbnNjb2RlckxvY2F0aW9uKCl7cmV0dXJuIGtoLmdldEtUWDJUcmFuc2NvZGVyTG9jYXRpb24oKX1zdGF0aWMgc2V0IG1lc2hvcHREZWNvZGVyTG9jYXRpb24odCl7a2guc2V0TWVzaG9wdERlY29kZXJMb2NhdGlvbih0KX1zdGF0aWMgZ2V0IG1lc2hvcHREZWNvZGVyTG9jYXRpb24oKXtyZXR1cm4ga2guZ2V0TWVzaG9wdERlY29kZXJMb2NhdGlvbigpfXN0YXRpYyBtYXBVUkxzKHQpe0NkLnNpbmdsZXRvbi5sb2FkZXJbRmhdLm1hbmFnZXIuc2V0VVJMTW9kaWZpZXIodCl9ZGlzbWlzc1Bvc3Rlcigpe3RoaXNbX3BdKCk/dGhpc1tmdl0oKToodGhpc1ttdl09bHYsdGhpc1tvcF0oKSl9c2hvd1Bvc3Rlcigpe2NvbnN0IHQ9dGhpc1tkdl0sZT10aGlzW3B2XTtlLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpLGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksdC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtjb25zdCBuPXRoaXMubW9kZWxJc1Zpc2libGU7dGhpc1tndl09ITEsdGhpc1tycF0obiksdGhpc1t4dl09ITF9Z2V0RGltZW5zaW9ucygpe3JldHVybiBTcCh0aGlzW2RwXS5zaXplKX1jb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCksdGhpc1tkdl0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpc1tfdl0pLHRoaXNbZHZdLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpc1tNdl0pLHRoaXNbeXBdLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLHRoaXNbU3ZdKSxjdi5yZWdpc3Rlckluc3RhbmNlKHRoaXMpfWRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7c3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKSx0aGlzW2R2XS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzW192XSksdGhpc1tkdl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzW012XSksdGhpc1t5cF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsdGhpc1tTdl0pLGN2LnVucmVnaXN0ZXJJbnN0YW5jZSh0aGlzKX1hc3luYyB1cGRhdGVkKHQpe3N1cGVyLnVwZGF0ZWQodCksdC5oYXMoXCJwb3N0ZXJcIikmJm51bGwhPXRoaXMucG9zdGVyJiYodGhpc1twdl0uc3R5bGUuYmFja2dyb3VuZEltYWdlPWB1cmwoJHt0aGlzLnBvc3Rlcn0pYCksdC5oYXMoXCJhbHRcIikmJnRoaXNbcHZdLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixgJHt0aGlzW3NwXX0uICR7dGhpc1t3dl19YCksKHQuaGFzKFwicmV2ZWFsXCIpfHx0LmhhcyhcImxvYWRpbmdcIikpJiZ0aGlzW29wXSgpLHQuaGFzKFwiZ2VuZXJhdGVTY2hlbWFcIikmJighMD09PXRoaXMuZ2VuZXJhdGVTY2hlbWE/dGhpc1tkcF0udXBkYXRlU2NoZW1hKHRoaXMuc3JjKTp0aGlzW2RwXS51cGRhdGVTY2hlbWEobnVsbCkpLHQuaGFzKFwic2VhbWxlc3NQb3N0ZXJcIikmJighMD09PXRoaXMuc2VhbWxlc3NQb3N0ZXI/dGhpc1tkdl0uY2xhc3NMaXN0LmFkZChcInF1aWNrXCIpOnRoaXNbZHZdLmNsYXNzTGlzdC5yZW1vdmUoXCJxdWlja1wiKSl9WyhlPWd2LG49eHYsaT15dixyPW12LHM9ZHYsYT1wdixvPWh2LGw9dXYsYz13dixoPXZ2LHU9X3YsZD1NdixwPVN2LHdwKV0oKXtyZXR1cm4hIXRoaXMuc3JjJiYobnVsbCE9dGhpc1ttdl18fHRoaXMubG9hZGluZz09PW92fHx0aGlzLnJldmVhbD09PXJ2JiZ0aGlzW2lwXSl9W19wXSgpe2NvbnN0e3NyYzp0fT10aGlzO3JldHVybiEhdCYmc3VwZXJbX3BdKCkmJjE9PT10aGlzW3l2XX1bKG09YnYsZnYpXSgpe3RoaXNbbXZdPW51bGw7Y29uc3QgdD10aGlzW2R2XTtpZih0LmNsYXNzTGlzdC5jb250YWlucyhcInNob3dcIikpe2NvbnN0IGU9dGhpcy5tb2RlbElzVmlzaWJsZTt0aGlzW2d2XT0hMCx0aGlzW3JwXShlKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT57dC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKSwhMD09PXRoaXMuc2VhbWxlc3NQb3N0ZXI/dGhpc1tidl0oKTp0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsdGhpc1tidl0se29uY2U6ITB9KX0pKX1lbHNlIHRoaXNbeHZdPSEwfVticF0oKXtyZXR1cm4gc3VwZXJbYnBdKCkmJnRoaXNbZ3ZdfVtNcF0oKXtyZXR1cm4gc3VwZXJbTXBdKCkmJnRoaXNbeHZdfWFzeW5jW29wXSgpe3RoaXNbeXZdPTAsITA9PT10aGlzLmdlbmVyYXRlU2NoZW1hJiZ0aGlzW2RwXS51cGRhdGVTY2hlbWEodGhpcy5zcmMpLG51bGwhPXRoaXNbZHBdLmN1cnJlbnRHTFRGJiZudWxsIT10aGlzLnNyYyYmdGhpc1t3cF0oKXx8dGhpcy5zaG93UG9zdGVyKCksYXdhaXQgc3VwZXJbb3BdKCl9fXJldHVybiBpdihbWih7dHlwZTpTdHJpbmd9KV0sZi5wcm90b3R5cGUsXCJwb3N0ZXJcIix2b2lkIDApLGl2KFtaKHt0eXBlOlN0cmluZ30pXSxmLnByb3RvdHlwZSxcInJldmVhbFwiLHZvaWQgMCksaXYoW1ooe3R5cGU6U3RyaW5nfSldLGYucHJvdG90eXBlLFwibG9hZGluZ1wiLHZvaWQgMCksaXYoW1ooe3R5cGU6Qm9vbGVhbixhdHRyaWJ1dGU6XCJnZW5lcmF0ZS1zY2hlbWFcIn0pXSxmLnByb3RvdHlwZSxcImdlbmVyYXRlU2NoZW1hXCIsdm9pZCAwKSxpdihbWih7dHlwZTpCb29sZWFuLGF0dHJpYnV0ZTpcInNlYW1sZXNzLXBvc3RlclwifSldLGYucHJvdG90eXBlLFwic2VhbWxlc3NQb3N0ZXJcIix2b2lkIDApLGZ9KSgodD0+e3ZhciBlO2NsYXNzIG4gZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmF1dG9wbGF5PSExLHRoaXMuYW5pbWF0aW9uTmFtZT12b2lkIDAsdGhpcy5hbmltYXRpb25Dcm9zc2ZhZGVEdXJhdGlvbj0zMDAsdGhpc1tlXT0hMH1nZXQgYXZhaWxhYmxlQW5pbWF0aW9ucygpe3JldHVybiB0aGlzLmxvYWRlZD90aGlzW2RwXS5hbmltYXRpb25OYW1lczpbXX1nZXQgZHVyYXRpb24oKXtyZXR1cm4gdGhpc1tkcF0uZHVyYXRpb259Z2V0IHBhdXNlZCgpe3JldHVybiB0aGlzW0xwXX1nZXQgY3VycmVudFRpbWUoKXtyZXR1cm4gdGhpc1tkcF0uYW5pbWF0aW9uVGltZX1zZXQgY3VycmVudFRpbWUodCl7dGhpc1tkcF0uYW5pbWF0aW9uVGltZT10LHRoaXNbdnBdLnRocmVlUmVuZGVyZXIuc2hhZG93TWFwLm5lZWRzVXBkYXRlPSEwLHRoaXNbcHBdKCl9cGF1c2UoKXt0aGlzW0xwXXx8KHRoaXNbTHBdPSEwLHRoaXNbdnBdLnRocmVlUmVuZGVyZXIuc2hhZG93TWFwLmF1dG9VcGRhdGU9ITEsdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInBhdXNlXCIpKSl9cGxheSgpe3RoaXNbTHBdJiZ0aGlzLmF2YWlsYWJsZUFuaW1hdGlvbnMubGVuZ3RoPjAmJih0aGlzW0xwXT0hMSx0aGlzW3ZwXS50aHJlZVJlbmRlcmVyLnNoYWRvd01hcC5hdXRvVXBkYXRlPSEwLHRoaXNbZHBdLmhhc0FjdGl2ZUFuaW1hdGlvbnx8dGhpc1tBcF0oKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicGxheVwiKSkpfVsoZT1McCxmcCldKCl7c3VwZXJbZnBdKCksdGhpc1tMcF09ITAsdGhpcy5hdXRvcGxheSYmKHRoaXNbQXBdKCksdGhpcy5wbGF5KCkpfVttcF0odCxlKXtzdXBlclttcF0odCxlKSx0aGlzW0xwXXx8IXRoaXNbTXBdKCkmJiF0aGlzW3ZwXS5pc1ByZXNlbnRpbmd8fCh0aGlzW2RwXS51cGRhdGVBbmltYXRpb24oZS8xZTMpLHRoaXNbcHBdKCkpfXVwZGF0ZWQodCl7c3VwZXIudXBkYXRlZCh0KSx0LmhhcyhcImF1dG9wbGF5XCIpJiZ0aGlzLmF1dG9wbGF5JiZ0aGlzLnBsYXkoKSx0LmhhcyhcImFuaW1hdGlvbk5hbWVcIikmJnRoaXNbQXBdKCl9YXN5bmNbb3BdKCl7cmV0dXJuIHRoaXNbZHBdLnN0b3BBbmltYXRpb24oKSxzdXBlcltvcF0oKX1bQXBdKCl7dGhpc1tkcF0ucGxheUFuaW1hdGlvbih0aGlzLmFuaW1hdGlvbk5hbWUsdGhpcy5hbmltYXRpb25Dcm9zc2ZhZGVEdXJhdGlvbi8xZTMpLHRoaXNbTHBdJiYodGhpc1tkcF0udXBkYXRlQW5pbWF0aW9uKDApLHRoaXNbcHBdKCkpfX1yZXR1cm4gRXAoW1ooe3R5cGU6Qm9vbGVhbn0pXSxuLnByb3RvdHlwZSxcImF1dG9wbGF5XCIsdm9pZCAwKSxFcChbWih7dHlwZTpTdHJpbmcsYXR0cmlidXRlOlwiYW5pbWF0aW9uLW5hbWVcIn0pXSxuLnByb3RvdHlwZSxcImFuaW1hdGlvbk5hbWVcIix2b2lkIDApLEVwKFtaKHt0eXBlOk51bWJlcixhdHRyaWJ1dGU6XCJhbmltYXRpb24tY3Jvc3NmYWRlLWR1cmF0aW9uXCJ9KV0sbi5wcm90b3R5cGUsXCJhbmltYXRpb25Dcm9zc2ZhZGVEdXJhdGlvblwiLHZvaWQgMCksbn0pKCh0PT57dmFyIGU7Y29uc3Qgbj1TeW1ib2woXCJlbmRQb2x5ZmlsbENvb3JkaW5hdGlvblwiKTtyZXR1cm4gZT1uLGNsYXNzIGV4dGVuZHMgdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpc1tlXT1udWxsfWNvbm5lY3RlZENhbGxiYWNrKCl7c3VwZXIuY29ubmVjdGVkQ2FsbGJhY2smJnN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCksbnVsbD09dGhpc1tuXSYmKHRoaXNbbl09KHQ9PntpZihudWxsPT10LnNoYWRvd1Jvb3R8fHQuaGFzQXR0cmlidXRlKFwiZGF0YS1qcy1mb2N1cy12aXNpYmxlXCIpKXJldHVybigpPT57fTtpZighc2VsZi5hcHBseUZvY3VzVmlzaWJsZVBvbHlmaWxsKXtjb25zdCBlPSgpPT57c2VsZi5hcHBseUZvY3VzVmlzaWJsZVBvbHlmaWxsKHQuc2hhZG93Um9vdCl9O3JldHVybiBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1cy12aXNpYmxlLXBvbHlmaWxsLXJlYWR5XCIsZSx7b25jZTohMH0pLCgpPT57c2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXMtdmlzaWJsZS1wb2x5ZmlsbC1yZWFkeVwiLGUpfX1yZXR1cm4gc2VsZi5hcHBseUZvY3VzVmlzaWJsZVBvbHlmaWxsKHQuc2hhZG93Um9vdCksKCk9Pnt9fSkodGhpcykpfWRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7c3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2smJnN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCksbnVsbCE9dGhpc1tuXSYmKHRoaXNbbl0oKSx0aGlzW25dPW51bGwpfX19KShUcCkpKSkpKSkpKTtjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtb2RlbC12aWV3ZXJcIixOeCk7ZXhwb3J0e054IGFzIE1vZGVsVmlld2VyRWxlbWVudH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC12aWV3ZXIubWluLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
